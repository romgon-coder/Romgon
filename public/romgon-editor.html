<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Romgon Advanced Game Creator</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }

        .header h1 {
            font-size: 3em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.95;
        }

        .workflow {
            display: flex;
            background: #f5f5f5;
            border-bottom: 3px solid #ddd;
            overflow-x: auto;
        }

        .step {
            flex: 1;
            min-width: 200px;
            padding: 25px;
            text-align: center;
            cursor: pointer;
            font-weight: 600;
            font-size: 1.1em;
            transition: all 0.3s;
            border: none;
            background: none;
            position: relative;
        }

        .step:not(:last-child)::after {
            content: '‚Üí';
            position: absolute;
            right: -15px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 1.5em;
            color: #999;
        }

        .step:hover { background: #e8e8e8; }

        .step.active {
            background: white;
            color: #667eea;
            border-bottom: 4px solid #667eea;
        }

        .step.completed {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .content {
            display: none;
            padding: 40px;
            min-height: 600px;
        }

        .content.active { display: block; }

        .section {
            background: #f9f9f9;
            padding: 30px;
            border-radius: 15px;
            margin-bottom: 30px;
            border: 2px solid #e0e0e0;
        }

        .section h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.8em;
            border-bottom: 3px solid #667eea;
            padding-bottom: 15px;
        }

        .canvas-area {
            display: flex;
            gap: 40px;
            flex-wrap: wrap;
        }

        .canvas-panel {
            flex: 1;
            min-width: 350px;
        }

        canvas {
            border: 3px solid #ddd;
            border-radius: 12px;
            background: white;
            cursor: crosshair;
            display: block;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-top: 25px;
        }

        .control-group {
            background: white;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #e0e0e0;
        }

        .control-group label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: #555;
            font-size: 1.05em;
        }

        .control-group input,
        .control-group select,
        .control-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1em;
            transition: all 0.3s;
        }

        .control-group input:focus,
        .control-group select:focus,
        .control-group textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 14px 35px;
            font-size: 1.15em;
            font-weight: 600;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            margin: 8px;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }

        .btn:active { transform: translateY(-1px); }

        .btn-secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            box-shadow: 0 4px 15px rgba(240, 147, 251, 0.3);
        }

        .btn-success {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            box-shadow: 0 4px 15px rgba(79, 172, 254, 0.3);
        }

        .btn-warning {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            box-shadow: 0 4px 15px rgba(250, 112, 154, 0.3);
        }

        .btn-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 25px;
        }

        .piece-gallery {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            gap: 20px;
            margin-top: 25px;
        }

        .piece-card {
            background: white;
            border: 3px solid #e0e0e0;
            border-radius: 12px;
            padding: 20px;
            position: relative;
            transition: all 0.3s;
            cursor: pointer;
        }

        .piece-card:hover {
            border-color: #667eea;
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.2);
            transform: translateY(-5px);
        }

        .piece-card.selected {
            border-color: #667eea;
            background: #f0f4ff;
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
        }

        .piece-card h3 {
            margin-bottom: 12px;
            color: #667eea;
            font-size: 1.3em;
        }

        .piece-card .delete-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: #f5576c;
            color: white;
            border: none;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            cursor: pointer;
            font-size: 1.3em;
            transition: all 0.3s;
        }

        .piece-card .delete-btn:hover {
            background: #e74c3c;
            transform: rotate(90deg);
        }

        .piece-preview {
            width: 100%;
            height: 160px;
            margin: 15px 0;
        }

        .svg-preview {
            width: 100%;
            height: 200px;
            border: 2px solid #ddd;
            border-radius: 8px;
            background: white;
            padding: 20px;
        }

        .instructions {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 25px;
            border-left: 5px solid #2196f3;
        }

        .instructions h3 {
            margin-bottom: 12px;
            color: #1565c0;
            font-size: 1.3em;
        }

        .instructions ul {
            margin-left: 25px;
            line-height: 1.8;
        }

        .alert {
            padding: 18px 25px;
            border-radius: 10px;
            margin-bottom: 25px;
            font-weight: 500;
            font-size: 1.05em;
        }

        .alert-success {
            background: #d4edda;
            color: #155724;
            border: 2px solid #c3e6cb;
        }

        .alert-info {
            background: #d1ecf1;
            color: #0c5460;
            border: 2px solid #bee5eb;
        }

        .alert-warning {
            background: #fff3cd;
            color: #856404;
            border: 2px solid #ffeaa7;
        }

        .shape-selector {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin: 15px 0;
        }

        .shape-option {
            width: 80px;
            height: 80px;
            border: 3px solid #ddd;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            background: white;
        }

        .shape-option:hover {
            border-color: #667eea;
            transform: scale(1.1);
        }

        .shape-option.selected {
            border-color: #667eea;
            background: #f0f4ff;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .tool-bar {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .tool-btn {
            padding: 12px 25px;
            border: 2px solid #ddd;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }

        .tool-btn:hover {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .tool-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .json-viewer {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 25px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
            max-height: 600px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.5);
        }

        .checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 12px;
            margin: 12px 0;
        }

        .checkbox-wrapper input[type="checkbox"] {
            width: 22px;
            height: 22px;
            cursor: pointer;
        }

        .progress-bar {
            background: #e0e0e0;
            height: 8px;
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.5s ease;
        }

        .board-visualizer {
            display: flex;
            justify-content: center;
            margin: 30px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéÆ Romgon Advanced Game Creator</h1>
            <p>Design unlimited hexagonal strategy games with your custom pieces, rules, and boards</p>
        </div>

        <div class="workflow">
            <button class="step active" onclick="goToStep(0)">
                <div>Step 1</div>
                <small>Design Shapes</small>
            </button>
            <button class="step" onclick="goToStep(1)">
                <div>Step 2</div>
                <small>Draw SVG</small>
            </button>
            <button class="step" onclick="goToStep(2)">
                <div>Step 3</div>
                <small>Movement</small>
            </button>
            <button class="step" onclick="goToStep(3)">
                <div>Step 4</div>
                <small>Board Design</small>
            </button>
            <button class="step" onclick="goToStep(4)">
                <div>Step 5</div>
                <small>Rules & Export</small>
            </button>
        </div>

        <div class="progress-bar">
            <div class="progress-fill" id="progressFill" style="width: 20%;"></div>
        </div>

        <!-- Step 1: Design Piece Shapes -->
        <div class="content active" id="step-0">
            <div class="instructions">
                <h3>üìê Step 1: Design Your Piece Shapes</h3>
                <ul>
                    <li>Click hexagons to create your piece shape (connected hexes only)</li>
                    <li>Use straight lines - hexagonal patterns work best</li>
                    <li>Name your piece and choose a base color</li>
                    <li>Create multiple pieces for your game</li>
                </ul>
            </div>

            <div class="section">
                <h2>Hexagonal Shape Designer</h2>
                <div class="canvas-area">
                    <div class="canvas-panel">
                        <h3>Click to Draw Piece Shape</h3>
                        <canvas id="shapeCanvas" width="450" height="450"></canvas>
                        <div class="btn-group">
                            <button class="btn btn-secondary" onclick="clearShape()">Clear</button>
                            <button class="btn" onclick="centerShape()">Center</button>
                        </div>
                    </div>
                    <div class="canvas-panel">
                        <div class="controls">
                            <div class="control-group">
                                <label>Piece Name:</label>
                                <input type="text" id="pieceName" placeholder="e.g., Warrior, Tower, Dragon">
                            </div>
                            <div class="control-group">
                                <label>Base Color:</label>
                                <input type="color" id="pieceColor" value="#4a90e2">
                            </div>
                            <div class="control-group">
                                <label>Description:</label>
                                <textarea id="pieceDesc" rows="3" placeholder="Special abilities or notes..."></textarea>
                            </div>
                        </div>
                        <div class="checkbox-wrapper">
                            <input type="checkbox" id="canRotate">
                            <label>Can Rotate (orientation-dependent)</label>
                        </div>
                        <div class="checkbox-wrapper">
                            <input type="checkbox" id="canFlip">
                            <label>Can Flip (for directional mechanics)</label>
                        </div>
                        <button class="btn btn-success" onclick="savePieceShape()">Add to Collection</button>
                    </div>
                </div>
            </div>

            <div class="section">
                <h2>Your Piece Collection</h2>
                <div id="pieceGallery" class="piece-gallery">
                    <div class="alert alert-info">No pieces created yet. Design your first piece above!</div>
                </div>
            </div>

            <div class="btn-group">
                <button class="btn btn-success" onclick="goToStep(1)">Next: Draw SVG Graphics ‚Üí</button>
            </div>
        </div>

        <!-- Step 2: Draw SVG Graphics -->
        <div class="content" id="step-1">
            <div class="instructions">
                <h3>üé® Step 2: Create Visual Appearance (SVG)</h3>
                <ul>
                    <li>Select a piece from your collection</li>
                    <li>Choose from pre-made shapes or draw custom SVG</li>
                    <li>This defines how the piece looks on the board</li>
                    <li>Similar to Romgon's square, triangle, rhombus, circle, and hexagon pieces</li>
                </ul>
            </div>

            <div class="section">
                <h2>SVG Graphics Editor</h2>
                <div class="control-group">
                    <label>Select Piece to Customize:</label>
                    <select id="svgPieceSelector" onchange="loadPieceForSVG()">
                        <option value="">-- Select a piece --</option>
                    </select>
                </div>

                <div class="shape-selector" id="shapeTemplates">
                    <div class="shape-option" onclick="selectShape('square')" data-shape="square">
                        <svg width="60" height="60"><rect x="10" y="10" width="40" height="40" fill="#4a90e2" stroke="#333" stroke-width="2"/></svg>
                    </div>
                    <div class="shape-option" onclick="selectShape('triangle')" data-shape="triangle">
                        <svg width="60" height="60"><polygon points="30,10 50,50 10,50" fill="#e74c3c" stroke="#333" stroke-width="2"/></svg>
                    </div>
                    <div class="shape-option" onclick="selectShape('rhombus')" data-shape="rhombus">
                        <svg width="60" height="60"><polygon points="30,10 50,30 30,50 10,30" fill="#2ecc71" stroke="#333" stroke-width="2"/></svg>
                    </div>
                    <div class="shape-option" onclick="selectShape('circle')" data-shape="circle">
                        <svg width="60" height="60"><circle cx="30" cy="30" r="20" fill="#f39c12" stroke="#333" stroke-width="2"/></svg>
                    </div>
                    <div class="shape-option" onclick="selectShape('hexagon')" data-shape="hexagon">
                        <svg width="60" height="60"><polygon points="30,10 50,20 50,40 30,50 10,40 10,20" fill="#9b59b6" stroke="#333" stroke-width="2"/></svg>
                    </div>
                    <div class="shape-option" onclick="selectShape('star')" data-shape="star">
                        <svg width="60" height="60"><polygon points="30,10 35,25 50,25 38,35 42,50 30,40 18,50 22,35 10,25 25,25" fill="#1abc9c" stroke="#333" stroke-width="2"/></svg>
                    </div>
                    <div class="shape-option" onclick="selectShape('cross')" data-shape="cross">
                        <svg width="60" height="60"><path d="M 20,15 L 40,15 L 40,20 L 45,20 L 45,40 L 40,40 L 40,45 L 20,45 L 20,40 L 15,40 L 15,20 L 20,20 Z" fill="#e67e22" stroke="#333" stroke-width="2"/></svg>
                    </div>
                    <div class="shape-option" onclick="selectShape('custom')" data-shape="custom">
                        <svg width="60" height="60"><text x="30" y="35" font-size="14" text-anchor="middle" fill="#333">Custom</text></svg>
                    </div>
                </div>

                <div class="svg-preview" id="svgPreview">
                    <svg viewBox="0 0 100 100" id="currentSVG">
                        <text x="50" y="50" text-anchor="middle" font-size="12" fill="#999">Select a shape template above</text>
                    </svg>
                </div>

                <div class="control-group">
                    <label>Custom SVG Code (Advanced):</label>
                    <textarea id="customSVG" rows="6" placeholder='<rect class="shape-fill shape-stroke" x="15" y="15" width="70" height="70"/>'></textarea>
                </div>

                <button class="btn" onclick="applySVGToPiece()">Apply SVG to Piece</button>
            </div>

            <div class="btn-group">
                <button class="btn btn-secondary" onclick="goToStep(0)">‚Üê Back</button>
                <button class="btn btn-success" onclick="goToStep(2)">Next: Define Movement ‚Üí</button>
            </div>
        </div>

        <!-- Step 3: Define Movement Patterns -->
        <div class="content" id="step-2">
            <div class="instructions">
                <h3>‚ö° Step 3: Define Movement Patterns</h3>
                <ul>
                    <li>Select a piece and mark where it can move (green hexes)</li>
                    <li>Mark attack positions separately (red hexes) if different from movement</li>
                    <li>Click hexes again to remove them from the pattern</li>
                    <li>Use "Clear Current Type" to clear only the active pattern type</li>
                    <li>Set movement range and special abilities</li>
                    <li>Define capture rules and movement restrictions</li>
                </ul>
            </div>

            <div class="section">
                <h2>Movement Pattern Designer</h2>
                <div class="control-group">
                    <label>Select Piece:</label>
                    <select id="movePieceSelector" onchange="loadPieceForMovement()">
                        <option value="">-- Select a piece --</option>
                    </select>
                </div>

                <div class="tool-bar">
                    <button class="tool-btn active" onclick="setMoveTool('move')">‚úì Movement</button>
                    <button class="tool-btn" onclick="setMoveTool('attack')">‚öî Attack</button>
                    <button class="tool-btn" onclick="setMoveTool('special')">‚òÖ Special</button>
                    <button class="btn btn-secondary" onclick="clearCurrentMovementType()" style="margin-left: auto;">Clear Current Type</button>
                    <button class="btn btn-warning" onclick="clearAllMovement()">Clear All</button>
                </div>

                <div class="canvas-area">
                    <div class="canvas-panel">
                        <h3>Click to Mark Valid Positions</h3>
                        <canvas id="moveCanvas" width="600" height="600"></canvas>
                        <div style="margin-top: 15px; font-size: 0.9em; color: #666;">
                            <span style="color: #2ecc71;">‚ñ†</span> Movement  
                            <span style="color: #e74c3c;">‚ñ†</span> Attack  
                            <span style="color: #f39c12;">‚ñ†</span> Special
                        </div>
                    </div>
                    <div class="canvas-panel">
                        <div class="controls">
                            <div class="control-group">
                                <label>Movement Type:</label>
                                <select id="moveType">
                                    <option value="adjacent">Adjacent (6 directions)</option>
                                    <option value="forward">Forward Only</option>
                                    <option value="diagonal">Diagonal</option>
                                    <option value="knight">Knight-like Pattern</option>
                                    <option value="perimetric">Perimetric (edges)</option>
                                    <option value="custom">Custom Pattern</option>
                                </select>
                            </div>
                            <div class="control-group">
                                <label>Movement Range:</label>
                                <input type="number" id="moveRange" min="1" max="15" value="1">
                            </div>
                        </div>
                        <div class="checkbox-wrapper">
                            <input type="checkbox" id="canJump">
                            <label>Can jump over pieces</label>
                        </div>
                        <div class="checkbox-wrapper">
                            <input type="checkbox" id="canCapture">
                            <label>Can capture enemy pieces</label>
                        </div>
                        <div class="checkbox-wrapper">
                            <input type="checkbox" id="mustCapture">
                            <label>Must capture if possible</label>
                        </div>
                        <div class="control-group">
                            <label>Special Ability:</label>
                            <textarea id="specialAbility" rows="3" placeholder="e.g., Can teleport to marked positions, Double move on first turn..."></textarea>
                        </div>
                        <button class="btn" onclick="saveMovementPattern()">Save Movement Pattern</button>
                    </div>
                </div>
            </div>

            <div class="btn-group">
                <button class="btn btn-secondary" onclick="goToStep(1)">‚Üê Back</button>
                <button class="btn btn-success" onclick="goToStep(3)">Next: Design Board ‚Üí</button>
            </div>
        </div>

        <!-- Step 4: Board Design -->
        <div class="content" id="step-3">
            <div class="instructions">
                <h3>üé≤ Step 4: Design Your Game Board</h3>
                <ul>
                    <li>Set board dimensions and overall shape</li>
                    <li>Use <strong>Row Offset</strong> (-10 to +10) to shift odd columns up or down</li>
                    <li>Use <strong>Remove Hexes Per Row</strong> (0-10) to progressively remove hexes from each row, creating tapered shapes</li>
                    <li>Choose removal direction: both sides (diamond/hexagon), left, right, or alternating</li>
                    <li>Use the Delete Hex tool to manually remove individual hexagons</li>
                    <li>Define color zones (similar to Romgon's brown/orange zones)</li>
                    <li>Set starting positions for each player</li>
                </ul>
            </div>

            <div class="section">
                <h2>Board Configuration</h2>
                <div class="controls">
                    <div class="control-group">
                        <label>Board Width (columns):</label>
                        <input type="number" id="boardWidth" min="5" max="25" value="9" onchange="redrawBoard()">
                    </div>
                    <div class="control-group">
                        <label>Board Height (rows):</label>
                        <input type="number" id="boardHeight" min="5" max="25" value="11" onchange="redrawBoard()">
                    </div>
                    <div class="control-group">
                        <label>Row Offset for Odd Columns (-10 to +10):</label>
                        <input type="number" id="rowOffset" min="-10" max="10" value="0" onchange="redrawBoard()">
                        <small style="color: #666; font-size: 0.9em;">Negative = shift up, Positive = shift down</small>
                    </div>
                    <div class="control-group">
                        <label>Remove Hexes Per Row (0-10):</label>
                        <input type="number" id="removePerRow" min="0" max="10" value="0" onchange="redrawBoard()">
                        <small style="color: #666; font-size: 0.9em;">Removes hexes from sides of each row progressively</small>
                    </div>
                    <div class="control-group">
                        <label>Remove Direction:</label>
                        <select id="removeDirection" onchange="redrawBoard()">
                            <option value="both">Both Sides (Center)</option>
                            <option value="left">Left Side</option>
                            <option value="right">Right Side</option>
                            <option value="alternate">Alternating Rows</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Board Shape:</label>
                        <select id="boardShape" onchange="redrawBoard()">
                            <option value="hexagon">Hexagonal</option>
                            <option value="rectangle">Rectangular</option>
                            <option value="diamond">Diamond</option>
                            <option value="custom">Custom</option>
                        </select>
                    </div>
                </div>

                <h3 style="margin: 30px 0 15px;">Board Editor Tools</h3>
                <div class="tool-bar">
                    <button class="tool-btn active" onclick="setBoardTool('view')">üëÅ View</button>
                    <button class="tool-btn" onclick="setBoardTool('delete')">üóë Delete Hex</button>
                    <button class="tool-btn" onclick="setBoardTool('place')">üìç Place Piece</button>
                </div>

                <div class="board-visualizer">
                    <canvas id="boardCanvas" width="700" height="600"></canvas>
                </div>

                <h3 style="margin: 30px 0 15px;">Zone Colors & Special Hexes</h3>
                <div class="controls">
                    <div class="control-group">
                        <label>Zone 1 Color:</label>
                        <input type="color" id="zone1Color" value="#6d3a13">
                    </div>
                    <div class="control-group">
                        <label>Zone 2 Color:</label>
                        <input type="color" id="zone2Color" value="#f57d2d">
                    </div>
                    <div class="control-group">
                        <label>Zone 3 Color:</label>
                        <input type="color" id="zone3Color" value="#fcc49c">
                    </div>
                    <div class="control-group">
                        <label>Player 1 Start Zone:</label>
                        <select id="p1Zone">
                            <option value="bottom">Bottom</option>
                            <option value="top">Top</option>
                            <option value="left">Left</option>
                            <option value="right">Right</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Player 2 Start Zone:</label>
                        <select id="p2Zone">
                            <option value="top">Top</option>
                            <option value="bottom">Bottom</option>
                            <option value="left">Left</option>
                            <option value="right">Right</option>
                        </select>
                    </div>
                </div>

                <h3 style="margin: 30px 0 15px;">Starting Positions</h3>
                <div class="alert alert-warning">
                    Click on the board above to place pieces at their starting positions. Select a piece type and player color first.
                </div>
                <div class="controls">
                    <div class="control-group">
                        <label>Piece to Place:</label>
                        <select id="placePieceSelector">
                            <option value="">-- Select piece --</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Player:</label>
                        <select id="placePlayer">
                            <option value="white">White</option>
                            <option value="black">Black</option>
                        </select>
                    </div>
                </div>
                <button class="btn btn-secondary" onclick="clearBoardPlacements()">Clear All Placements</button>
            </div>

            <div class="btn-group">
                <button class="btn btn-secondary" onclick="goToStep(2)">‚Üê Back</button>
                <button class="btn btn-success" onclick="goToStep(4)">Next: Rules & Export ‚Üí</button>
            </div>
        </div>

        <!-- Step 5: Rules & Export -->
        <div class="content" id="step-4">
            <div class="section">
                <h2>‚öôÔ∏è Game Rules Configuration</h2>
                <div class="controls">
                    <div class="control-group">
                        <label>Game Name:</label>
                        <input type="text" id="gameName" placeholder="My Custom Hex Game">
                    </div>
                    <div class="control-group">
                        <label>Game Description:</label>
                        <textarea id="gameDesc" rows="3" placeholder="Describe your game..."></textarea>
                    </div>
                    <div class="control-group">
                        <label>Win Condition:</label>
                        <select id="winCondition">
                            <option value="rhombus_escape">Rhombus Escape (like Romgon)</option>
                            <option value="capture_all">Capture All Enemy Pieces</option>
                            <option value="capture_king">Capture Specific Piece</option>
                            <option value="reach_goal">Reach Opponent's Base</option>
                            <option value="control_zones">Control Majority of Zones</option>
                            <option value="points">Score Most Points</option>
                            <option value="custom">Custom</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Turn Time Limit (seconds):</label>
                        <input type="number" id="turnLimit" min="0" value="60" placeholder="0 = unlimited">
                    </div>
                    <div class="control-group">
                        <label>Maximum Turns:</label>
                        <input type="number" id="maxTurns" min="0" value="0" placeholder="0 = unlimited">
                    </div>
                </div>

                <h3 style="margin: 30px 0 15px;">Game Features</h3>
                <div class="checkbox-wrapper">
                    <input type="checkbox" id="enableUndo" checked>
                    <label>Enable Undo/Redo</label>
                </div>
                <div class="checkbox-wrapper">
                    <input type="checkbox" id="showHistory" checked>
                    <label>Show Move History</label>
                </div>
                <div class="checkbox-wrapper">
                    <input type="checkbox" id="enableChat" checked>
                    <label>Enable In-Game Chat</label>
                </div>
                <div class="checkbox-wrapper">
                    <input type="checkbox" id="enablePreview" checked>
                    <label>Show Move Preview (attack/move highlighting)</label>
                </div>
                <div class="checkbox-wrapper">
                    <input type="checkbox" id="allowGuests">
                    <label>Allow Guest Players</label>
                </div>

                <div class="control-group" style="margin-top: 20px;">
                    <label>Custom Rules (optional):</label>
                    <textarea id="customRules" rows="4" placeholder="Add any special rules or mechanics..."></textarea>
                </div>
            </div>

            <div class="section">
                <h2>üöÄ Export & Integration</h2>
                <div class="btn-group">
                    <button class="btn btn-success" onclick="generateFullGame()">Generate Complete Game</button>
                    <button class="btn" onclick="downloadHTML()">Download HTML File</button>
                    <button class="btn btn-warning" onclick="downloadJSON()">Download JSON Config</button>
                    <button class="btn btn-secondary" onclick="copyConfig()">Copy to Clipboard</button>
                </div>

                <div id="exportResult" style="margin-top: 30px;"></div>
            </div>

            <div class="section">
                <h2>üìã Integration Instructions</h2>
                <div class="alert alert-info">
                    <strong>To integrate this game into your Romgon platform:</strong><br><br>
                    <strong>Option 1: Standalone HTML</strong><br>
                    ‚Ä¢ Download the complete HTML file<br>
                    ‚Ä¢ Upload to your server<br>
                    ‚Ä¢ Players can access directly via URL<br><br>
                    <strong>Option 2: Database Integration</strong><br>
                    ‚Ä¢ Download the JSON configuration<br>
                    ‚Ä¢ Save to your SQL database with a unique game ID<br>
                    ‚Ä¢ Load dynamically through your game engine API<br>
                    ‚Ä¢ Players select from game variants in lobby<br><br>
                    <strong>Option 3: Platform Integration</strong><br>
                    ‚Ä¢ Use the RomgonEngine API to load the configuration<br>
                    ‚Ä¢ Integrate with your existing user system, chat, and lobby<br>
                    ‚Ä¢ Games appear in your variant selection menu
                </div>
            </div>

            <div class="btn-group">
                <button class="btn btn-secondary" onclick="goToStep(3)">‚Üê Back</button>
                <button class="btn btn-success" onclick="startNewGame()">Create Another Game</button>
            </div>
        </div>
    </div>

    <script>
        // Global game state
        const gameData = {
            pieces: [],
            currentPieceId: null,
            currentTool: 'move',
            board: {
                width: 9,
                height: 11,
                shape: 'hexagon',
                rowOffset: 0,
                removePerRow: 0,
                removeDirection: 'both',
                placements: [],
                deletedHexes: [] // Track which hexes are removed from board
            },
            currentStep: 0
        };

        // Canvas references
        let shapeCanvas, shapeCtx;
        let moveCanvas, moveCtx;
        let boardCanvas, boardCtx;

        // Hex parameters for true honeycomb/beehive pattern (based on CSS Grid honeycomb)
        const hexSize = 25;
        const hexHeight = hexSize * 2;
        const hexWidth = Math.sqrt(3) * hexSize;
        // True honeycomb: hexagons touch edges perfectly
        const horizontalGap = 0; // No gap between horizontal neighbors
        const verticalGap = hexHeight * 0.2; // 20% vertical gap for proper offset

        // Shape drawing state
        let currentShapeHexes = [];
        let currentMovement = { move: [], attack: [], special: [] };
        let selectedSVGShape = null;
        let currentBoardTool = 'view'; // Board editing tool

        // Initialize
        window.onload = function() {
            initCanvases();
            redrawBoard();
        };

        function initCanvases() {
            shapeCanvas = document.getElementById('shapeCanvas');
            shapeCtx = shapeCanvas.getContext('2d');
            moveCanvas = document.getElementById('moveCanvas');
            moveCtx = moveCanvas.getContext('2d');
            boardCanvas = document.getElementById('boardCanvas');
            boardCtx = boardCanvas.getContext('2d');

            shapeCanvas.addEventListener('click', handleShapeClick);
            moveCanvas.addEventListener('click', handleMoveClick);
            boardCanvas.addEventListener('click', handleBoardClick);

            drawHexGrid(shapeCtx, 450, 450, 7, 7);
            drawHexGrid(moveCtx, 600, 600, 11, 11); // Increased grid size for better spacing
        }

        function drawHexGrid(ctx, width, height, gridW, gridH) {
            ctx.clearRect(0, 0, width, height);
            const centerX = width / 2;
            const centerY = height / 2;
            
            // Adjusted honeycomb spacing to prevent overlap
            // Horizontal: 3/4 of hex width (edges touch)
            // Vertical: Use full proper spacing to avoid overlap
            const horizontalSpacing = hexWidth * 0.75;
            const verticalSpacing = hexHeight * 0.75; // Increased from 0.8 to prevent overlap

            for (let row = 0; row < gridH; row++) {
                for (let col = 0; col < gridW; col++) {
                    const x = centerX + (col - gridW/2) * horizontalSpacing;
                    // Odd columns offset down by half the vertical spacing
                    const y = centerY + (row - gridH/2) * verticalSpacing + (col % 2) * (verticalSpacing * 0.5);
                    drawHexagon(ctx, x, y, hexSize, '#fff', '#666', 1.5);
                }
            }
        }

        function drawHexagon(ctx, x, y, size, fill, stroke, lineWidth) {
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = Math.PI / 3 * i;
                const hx = x + size * Math.cos(angle);
                const hy = y + size * Math.sin(angle);
                if (i === 0) ctx.moveTo(hx, hy);
                else ctx.lineTo(hx, hy);
            }
            ctx.closePath();
            ctx.fillStyle = fill;
            ctx.fill();
            ctx.strokeStyle = stroke;
            ctx.lineWidth = lineWidth;
            ctx.stroke();
        }

        function handleShapeClick(e) {
            const rect = shapeCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const hex = pixelToHex(x, y, 450, 450, 7, 7);
            
            if (hex) {
                const idx = currentShapeHexes.findIndex(h => h.row === hex.row && h.col === hex.col);
                if (idx >= 0) currentShapeHexes.splice(idx, 1);
                else currentShapeHexes.push(hex);
                redrawShapeCanvas();
            }
        }

        function handleMoveClick(e) {
            if (!gameData.currentPieceId) {
                alert('Please select a piece first!');
                return;
            }
            const rect = moveCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const hex = pixelToHex(x, y, 600, 600, 11, 11); // Updated to 11x11 grid
            
            if (hex) {
                const tool = gameData.currentTool;
                const arr = currentMovement[tool];
                const idx = arr.findIndex(h => h.row === hex.row && h.col === hex.col);
                if (idx >= 0) arr.splice(idx, 1);
                else arr.push(hex);
                redrawMoveCanvas();
            }
        }

        function handleBoardClick(e) {
            const rect = boardCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const width = parseInt(document.getElementById('boardWidth').value);
            const height = parseInt(document.getElementById('boardHeight').value);
            const rowOffset = parseInt(document.getElementById('rowOffset').value);
            const removePerRow = parseInt(document.getElementById('removePerRow').value);
            const removeDirection = document.getElementById('removeDirection').value;
            const centerX = 350;
            const centerY = 300;
            const bHexSize = 20;
            
            const bHexWidth = Math.sqrt(3) * bHexSize;
            const bHexHeight = bHexSize * 2;
            const horizontalSpacing = bHexWidth * 0.75;
            const verticalSpacing = bHexHeight * 0.75;

            // Find which hex was clicked
            for (let row = 0; row < height; row++) {
                for (let col = 0; col < width; col++) {
                    // Check if this hex is removed by the removal pattern
                    let hexesToRemove = 0;
                    if (removePerRow > 0) {
                        hexesToRemove = Math.floor((row / (height - 1)) * removePerRow);
                    }
                    
                    let shouldHide = false;
                    if (hexesToRemove > 0) {
                        switch(removeDirection) {
                            case 'both':
                                const halfRemove = Math.ceil(hexesToRemove / 2);
                                if (col < halfRemove || col >= width - halfRemove) {
                                    shouldHide = true;
                                }
                                break;
                            case 'left':
                                if (col < hexesToRemove) shouldHide = true;
                                break;
                            case 'right':
                                if (col >= width - hexesToRemove) shouldHide = true;
                                break;
                            case 'alternate':
                                if (row % 2 === 0) {
                                    if (col < hexesToRemove) shouldHide = true;
                                } else {
                                    if (col >= width - hexesToRemove) shouldHide = true;
                                }
                                break;
                        }
                    }
                    
                    if (shouldHide) continue;
                    
                    // Apply row offset to odd columns
                    const adjustedRow = row + (col % 2 === 1 ? rowOffset : 0);
                    
                    const hx = centerX + (col - width/2) * horizontalSpacing;
                    const hy = centerY + (adjustedRow - height/2) * verticalSpacing + (col % 2) * (verticalSpacing * 0.5);
                    const dist = Math.sqrt((x - hx) ** 2 + (y - hy) ** 2);
                    
                    if (dist < bHexSize) {
                        const hexKey = `${row}-${col}`;
                        
                        if (currentBoardTool === 'delete') {
                            const idx = gameData.board.deletedHexes.indexOf(hexKey);
                            if (idx >= 0) {
                                gameData.board.deletedHexes.splice(idx, 1);
                            } else {
                                gameData.board.deletedHexes.push(hexKey);
                            }
                            redrawBoard();
                        } else if (currentBoardTool === 'place') {
                            console.log('Place piece at', hexKey);
                        }
                        return;
                    }
                }
            }
        }

        function pixelToHex(x, y, canvasW, canvasH, gridW, gridH) {
            const centerX = canvasW / 2;
            const centerY = canvasH / 2;
            
            const horizontalSpacing = hexWidth * 0.75;
            const verticalSpacing = hexHeight * 0.75;

            for (let row = 0; row < gridH; row++) {
                for (let col = 0; col < gridW; col++) {
                    const hx = centerX + (col - gridW/2) * horizontalSpacing;
                    const hy = centerY + (row - gridH/2) * verticalSpacing + (col % 2) * (verticalSpacing * 0.5);
                    const dist = Math.sqrt((x - hx) ** 2 + (y - hy) ** 2);
                    if (dist < hexSize) return {row, col};
                }
            }
            return null;
        }

        function redrawShapeCanvas() {
            drawHexGrid(shapeCtx, 450, 450, 7, 7);
            const color = document.getElementById('pieceColor').value;
            const centerX = 450 / 2;
            const centerY = 450 / 2;
            
            const horizontalSpacing = hexWidth * 0.75;
            const verticalSpacing = hexHeight * 0.75;

            currentShapeHexes.forEach(hex => {
                const x = centerX + (hex.col - 3.5) * horizontalSpacing;
                const y = centerY + (hex.row - 3.5) * verticalSpacing + (hex.col % 2) * (verticalSpacing * 0.5);
                drawHexagon(shapeCtx, x, y, hexSize, color, '#333', 2);
            });
        }

        function redrawMoveCanvas() {
            drawHexGrid(moveCtx, 600, 600, 11, 11);
            const centerX = 600 / 2;
            const centerY = 600 / 2;
            
            const horizontalSpacing = hexWidth * 0.75;
            const verticalSpacing = hexHeight * 0.75;

            // Draw piece in center (at grid position 5,5)
            if (gameData.currentPieceId) {
                const piece = gameData.pieces.find(p => p.id === gameData.currentPieceId);
                if (piece) {
                    piece.hexes.forEach(hex => {
                        const x = centerX + (hex.col - 3.5 + 2) * horizontalSpacing;
                        const y = centerY + (hex.row - 3.5 + 2) * verticalSpacing + (hex.col % 2) * (verticalSpacing * 0.5);
                        drawHexagon(moveCtx, x, y, hexSize, piece.color, '#333', 2);
                    });
                }
            }

            // Draw movement patterns (centered at 5,5 in 11x11 grid)
            currentMovement.move.forEach(hex => {
                const x = centerX + (hex.col - 5.5) * horizontalSpacing;
                const y = centerY + (hex.row - 5.5) * verticalSpacing + (hex.col % 2) * (verticalSpacing * 0.5);
                drawHexagon(moveCtx, x, y, hexSize, '#2ecc71', '#27ae60', 2);
            });

            currentMovement.attack.forEach(hex => {
                const x = centerX + (hex.col - 5.5) * horizontalSpacing;
                const y = centerY + (hex.row - 5.5) * verticalSpacing + (hex.col % 2) * (verticalSpacing * 0.5);
                drawHexagon(moveCtx, x, y, hexSize, '#e74c3c', '#c0392b', 2);
            });

            currentMovement.special.forEach(hex => {
                const x = centerX + (hex.col - 5.5) * horizontalSpacing;
                const y = centerY + (hex.row - 5.5) * verticalSpacing + (hex.col % 2) * (verticalSpacing * 0.5);
                drawHexagon(moveCtx, x, y, hexSize, '#f39c12', '#e67e22', 2);
            });
        }

        function redrawBoard() {
            const width = parseInt(document.getElementById('boardWidth').value);
            const height = parseInt(document.getElementById('boardHeight').value);
            const rowOffset = parseInt(document.getElementById('rowOffset').value);
            const removePerRow = parseInt(document.getElementById('removePerRow').value);
            const removeDirection = document.getElementById('removeDirection').value;
            
            boardCtx.clearRect(0, 0, 700, 600);
            const centerX = 350;
            const centerY = 300;
            const bHexSize = 20;
            
            // Adjusted honeycomb spacing for board to prevent overlap
            const bHexWidth = Math.sqrt(3) * bHexSize;
            const bHexHeight = bHexSize * 2;
            const horizontalSpacing = bHexWidth * 0.75;
            const verticalSpacing = bHexHeight * 0.75;

            for (let row = 0; row < height; row++) {
                for (let col = 0; col < width; col++) {
                    // Calculate how many hexes to remove from this row
                    let hexesToRemove = 0;
                    if (removePerRow > 0) {
                        hexesToRemove = Math.floor((row / (height - 1)) * removePerRow);
                    }
                    
                    // Determine if this hex should be hidden based on removal pattern
                    let shouldHide = false;
                    if (hexesToRemove > 0) {
                        switch(removeDirection) {
                            case 'both':
                                const halfRemove = Math.ceil(hexesToRemove / 2);
                                if (col < halfRemove || col >= width - halfRemove) {
                                    shouldHide = true;
                                }
                                break;
                            case 'left':
                                if (col < hexesToRemove) {
                                    shouldHide = true;
                                }
                                break;
                            case 'right':
                                if (col >= width - hexesToRemove) {
                                    shouldHide = true;
                                }
                                break;
                            case 'alternate':
                                if (row % 2 === 0) {
                                    if (col < hexesToRemove) shouldHide = true;
                                } else {
                                    if (col >= width - hexesToRemove) shouldHide = true;
                                }
                                break;
                        }
                    }
                    
                    if (shouldHide) continue;
                    
                    // Apply row offset to odd columns
                    const adjustedRow = row + (col % 2 === 1 ? rowOffset : 0);
                    
                    const x = centerX + (col - width/2) * horizontalSpacing;
                    const y = centerY + (adjustedRow - height/2) * verticalSpacing + (col % 2) * (verticalSpacing * 0.5);
                    
                    const hexKey = `${row}-${col}`;
                    const isDeleted = gameData.board.deletedHexes.includes(hexKey);
                    
                    if (isDeleted) {
                        drawHexagon(boardCtx, x, y, bHexSize, '#333', '#f00', 2);
                        boardCtx.strokeStyle = '#f00';
                        boardCtx.lineWidth = 3;
                        boardCtx.beginPath();
                        boardCtx.moveTo(x - 10, y - 10);
                        boardCtx.lineTo(x + 10, y + 10);
                        boardCtx.moveTo(x + 10, y - 10);
                        boardCtx.lineTo(x - 10, y + 10);
                        boardCtx.stroke();
                    } else {
                        let color = '#f57d2d';
                        if (row < 2 || row >= height - 2) color = '#6d3a13';
                        else if (row >= 2 && row < 4 || row >= height - 4 && row < height - 2) color = '#fcc49c';
                        
                        drawHexagon(boardCtx, x, y, bHexSize, color, '#555', 1);
                    }
                }
            }
        }

        function clearShape() {
            currentShapeHexes = [];
            redrawShapeCanvas();
        }

        function centerShape() {
            if (currentShapeHexes.length === 0) return;
            const avgRow = currentShapeHexes.reduce((s, h) => s + h.row, 0) / currentShapeHexes.length;
            const avgCol = currentShapeHexes.reduce((s, h) => s + h.col, 0) / currentShapeHexes.length;
            const offsetRow = Math.round(3.5 - avgRow);
            const offsetCol = Math.round(3.5 - avgCol);
            currentShapeHexes = currentShapeHexes.map(h => ({
                row: h.row + offsetRow,
                col: h.col + offsetCol
            }));
            redrawShapeCanvas();
        }

        function savePieceShape() {
            const name = document.getElementById('pieceName').value.trim();
            if (!name || currentShapeHexes.length === 0) {
                alert('Please enter a name and draw a shape!');
                return;
            }

            const piece = {
                id: Date.now(),
                name: name,
                color: document.getElementById('pieceColor').value,
                description: document.getElementById('pieceDesc').value,
                hexes: [...currentShapeHexes],
                canRotate: document.getElementById('canRotate').checked,
                canFlip: document.getElementById('canFlip').checked,
                svg: null,
                movement: { move: [], attack: [], special: [], type: 'adjacent', range: 1 }
            };

            gameData.pieces.push(piece);
            updatePieceGallery();
            updateSelectors();
            
            document.getElementById('pieceName').value = '';
            document.getElementById('pieceDesc').value = '';
            clearShape();
            
            alert('Piece saved!');
        }

        function updatePieceGallery() {
            const gallery = document.getElementById('pieceGallery');
            if (gameData.pieces.length === 0) {
                gallery.innerHTML = '<div class="alert alert-info">No pieces created yet.</div>';
                return;
            }

            gallery.innerHTML = gameData.pieces.map(p => `
                <div class="piece-card" onclick="selectPieceCard(${p.id})">
                    <button class="delete-btn" onclick="event.stopPropagation(); deletePiece(${p.id})">√ó</button>
                    <h3>${p.name}</h3>
                    <p style="font-size: 0.9em; color: #666;">${p.description || 'No description'}</p>
                    <canvas class="piece-preview" id="preview-${p.id}"></canvas>
                    <div style="font-size: 0.85em; color: #999;">
                        ${p.canRotate ? 'üîÑ Rotatable' : ''} ${p.canFlip ? '‚ÜïÔ∏è Flippable' : ''}
                    </div>
                </div>
            `).join('');

            // Draw previews
            gameData.pieces.forEach(p => {
                const canvas = document.getElementById(`preview-${p.id}`);
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    drawPiecePreview(ctx, p, canvas.width, canvas.height);
                }
            });
        }

        function drawPiecePreview(ctx, piece, w, h) {
            ctx.clearRect(0, 0, w, h);
            const cx = w / 2;
            const cy = h / 2;
            const ps = 12;
            
            const pHexWidth = Math.sqrt(3) * ps;
            const pHexHeight = ps * 2;
            const horizontalSpacing = pHexWidth * 0.75;
            const verticalSpacing = pHexHeight * 0.75;

            piece.hexes.forEach(hex => {
                const x = cx + (hex.col - 3.5) * horizontalSpacing;
                const y = cy + (hex.row - 3.5) * verticalSpacing + (hex.col % 2) * (verticalSpacing * 0.5);
                drawHexagon(ctx, x, y, ps, piece.color, '#333', 1);
            });
        }

        function deletePiece(id) {
            if (confirm('Delete this piece?')) {
                gameData.pieces = gameData.pieces.filter(p => p.id !== id);
                updatePieceGallery();
                updateSelectors();
            }
        }

        function selectPieceCard(id) {
            document.querySelectorAll('.piece-card').forEach(c => c.classList.remove('selected'));
            event.currentTarget.classList.add('selected');
        }

        function updateSelectors() {
            const selectors = ['svgPieceSelector', 'movePieceSelector', 'placePieceSelector'];
            selectors.forEach(id => {
                const sel = document.getElementById(id);
                sel.innerHTML = '<option value="">-- Select piece --</option>' +
                    gameData.pieces.map(p => `<option value="${p.id}">${p.name}</option>`).join('');
            });
        }

        function goToStep(step) {
            document.querySelectorAll('.step').forEach((s, i) => {
                s.classList.toggle('active', i === step);
                s.classList.toggle('completed', i < step);
            });
            document.querySelectorAll('.content').forEach((c, i) => {
                c.classList.toggle('active', i === step);
            });
            gameData.currentStep = step;
            document.getElementById('progressFill').style.width = ((step + 1) * 20) + '%';
        }

        function loadPieceForSVG() {
            const id = parseInt(document.getElementById('svgPieceSelector').value);
            if (!id) return;
            gameData.currentPieceId = id;
            const piece = gameData.pieces.find(p => p.id === id);
            if (piece.svg) {
                document.getElementById('customSVG').value = piece.svg;
            }
        }

        function selectShape(shape) {
            selectedSVGShape = shape;
            document.querySelectorAll('.shape-option').forEach(o => o.classList.remove('selected'));
            event.currentTarget.classList.add('selected');

            const svgTemplates = {
                square: '<rect class="shape-fill shape-stroke" x="15" y="15" width="70" height="70"/>',
                triangle: '<polygon class="shape-fill shape-stroke" points="50,15 85,85 15,85"/>',
                rhombus: '<polygon class="shape-fill shape-stroke" points="50,15 85,50 50,85 15,50"/>',
                circle: '<circle class="shape-fill shape-stroke" cx="50" cy="50" r="35"/>',
                hexagon: '<polygon class="shape-fill shape-stroke" points="50,15 80,30 80,60 50,75 20,60 20,30"/>',
                star: '<polygon class="shape-fill shape-stroke" points="50,15 58,40 85,40 63,55 70,80 50,65 30,80 37,55 15,40 42,40"/>',
                cross: '<path class="shape-fill shape-stroke" d="M 30,20 L 70,20 L 70,30 L 80,30 L 80,70 L 70,70 L 70,80 L 30,80 L 30,70 L 20,70 L 20,30 L 30,30 Z"/>'
            };

            if (svgTemplates[shape]) {
                document.getElementById('customSVG').value = svgTemplates[shape];
            }
        }

        function applySVGToPiece() {
            if (!gameData.currentPieceId) {
                alert('Please select a piece first!');
                return;
            }
            const svg = document.getElementById('customSVG').value;
            const piece = gameData.pieces.find(p => p.id === gameData.currentPieceId);
            piece.svg = svg;
            alert('SVG applied to ' + piece.name);
        }

        function loadPieceForMovement() {
            const id = parseInt(document.getElementById('movePieceSelector').value);
            if (!id) return;
            gameData.currentPieceId = id;
            const piece = gameData.pieces.find(p => p.id === id);
            currentMovement = {
                move: [...(piece.movement.move || [])],
                attack: [...(piece.movement.attack || [])],
                special: [...(piece.movement.special || [])]
            };
            document.getElementById('moveType').value = piece.movement.type || 'adjacent';
            document.getElementById('moveRange').value = piece.movement.range || 1;
            redrawMoveCanvas();
        }

        function setMoveTool(tool) {
            gameData.currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
        }

        function clearCurrentMovementType() {
            const tool = gameData.currentTool;
            currentMovement[tool] = [];
            redrawMoveCanvas();
        }

        function clearAllMovement() {
            if (confirm('Clear all movement, attack, and special patterns?')) {
                currentMovement = { move: [], attack: [], special: [] };
                redrawMoveCanvas();
            }
        }

        function saveMovementPattern() {
            if (!gameData.currentPieceId) {
                alert('Please select a piece!');
                return;
            }
            const piece = gameData.pieces.find(p => p.id === gameData.currentPieceId);
            piece.movement = {
                move: [...currentMovement.move],
                attack: [...currentMovement.attack],
                special: [...currentMovement.special],
                type: document.getElementById('moveType').value,
                range: parseInt(document.getElementById('moveRange').value),
                canJump: document.getElementById('canJump').checked,
                canCapture: document.getElementById('canCapture').checked,
                mustCapture: document.getElementById('mustCapture').checked,
                specialAbility: document.getElementById('specialAbility').value
            };
            alert('Movement saved for ' + piece.name);
        }

        function setBoardTool(tool) {
            currentBoardTool = tool;
            document.querySelectorAll('.tool-bar .tool-btn').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
            
            // Update cursor
            if (tool === 'delete') {
                boardCanvas.style.cursor = 'not-allowed';
            } else if (tool === 'place') {
                boardCanvas.style.cursor = 'copy';
            } else {
                boardCanvas.style.cursor = 'default';
            }
        }

        function clearBoardPlacements() {
            gameData.board.placements = [];
            gameData.board.deletedHexes = [];
            redrawBoard();
        }

        function generateFullGame() {
            const config = {
                metadata: {
                    name: document.getElementById('gameName').value || 'Untitled Game',
                    description: document.getElementById('gameDesc').value,
                    created: new Date().toISOString(),
                    version: '1.0',
                    author: 'Game Creator'
                },
                pieces: gameData.pieces,
                board: {
                    width: parseInt(document.getElementById('boardWidth').value),
                    height: parseInt(document.getElementById('boardHeight').value),
                    shape: document.getElementById('boardShape').value,
                    rowOffset: parseInt(document.getElementById('rowOffset').value),
                    removePerRow: parseInt(document.getElementById('removePerRow').value),
                    removeDirection: document.getElementById('removeDirection').value,
                    zones: {
                        zone1: document.getElementById('zone1Color').value,
                        zone2: document.getElementById('zone2Color').value,
                        zone3: document.getElementById('zone3Color').value
                    },
                    startZones: {
                        player1: document.getElementById('p1Zone').value,
                        player2: document.getElementById('p2Zone').value
                    },
                    placements: gameData.board.placements,
                    deletedHexes: gameData.board.deletedHexes
                },
                rules: {
                    winCondition: document.getElementById('winCondition').value,
                    turnLimit: parseInt(document.getElementById('turnLimit').value),
                    maxTurns: parseInt(document.getElementById('maxTurns').value),
                    enableUndo: document.getElementById('enableUndo').checked,
                    showHistory: document.getElementById('showHistory').checked,
                    enableChat: document.getElementById('enableChat').checked,
                    enablePreview: document.getElementById('enablePreview').checked,
                    allowGuests: document.getElementById('allowGuests').checked,
                    customRules: document.getElementById('customRules').value
                }
            };

            const output = document.getElementById('exportResult');
            output.innerHTML = `
                <div class="alert alert-success">‚úì Game configuration generated successfully!</div>
                <div class="json-viewer">${JSON.stringify(config, null, 2)}</div>
            `;

            window.gameConfig = config;
        }

        function downloadJSON() {
            if (!window.gameConfig) {
                generateFullGame();
            }
            const name = document.getElementById('gameName').value || 'game';
            const blob = new Blob([JSON.stringify(window.gameConfig, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${name.toLowerCase().replace(/\s+/g, '-')}-config.json`;
            a.click();
        }

        function downloadHTML() {
            alert('HTML generation coming soon! Use JSON for now.');
        }

        function copyConfig() {
            if (!window.gameConfig) generateFullGame();
            navigator.clipboard.writeText(JSON.stringify(window.gameConfig, null, 2));
            alert('Configuration copied to clipboard!');
        }

        function startNewGame() {
            if (confirm('Start a new game? Current progress will be lost.')) {
                gameData.pieces = [];
                gameData.board.placements = [];
                currentShapeHexes = [];
                goToStep(0);
                updatePieceGallery();
                updateSelectors();
            }
        }
    </script>
</body>
</html>
