<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Play Custom Game - Romgon</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1e26 0%, #23272e 100%);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            padding: 20px 0;
            border-bottom: 2px solid rgba(78, 205, 196, 0.3);
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            color: #4ecdc4;
            margin-bottom: 10px;
        }

        .game-layout {
            display: grid;
            grid-template-columns: 250px 1fr 250px;
            gap: 20px;
            margin-bottom: 30px;
        }

        .side-panel {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(78, 205, 196, 0.3);
            border-radius: 12px;
            padding: 20px;
            height: fit-content;
        }

        .side-panel h3 {
            color: #4ecdc4;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .game-info-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 10px;
        }

        .info-label {
            color: #4ecdc4;
            font-size: 0.85em;
            margin-bottom: 3px;
        }

        .info-value {
            font-size: 1.1em;
            font-weight: 600;
        }

        .board-container {
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(78, 205, 196, 0.3);
            border-radius: 12px;
            padding: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 700px;
        }

        /* Hexagon board styles */
        .board {
            display: flex;
            flex-direction: column;
            align-items: center;
            transform: rotate(90deg);
            position: relative;
        }

        .hex-row {
            display: flex;
            justify-content: center;
            margin-top: -15px;
        }

        .hex-row:first-child {
            margin-top: 0;
        }

        .hex-row.offset {
            margin-left: 26px;
        }

        .hexagon {
            position: relative;
            width: 52px;
            height: 60px;
            background-color: #f57d2d;
            margin: 0 2px;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            cursor: pointer;
            transition: filter 0.2s ease;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .hexagon:hover {
            filter: brightness(1.2);
        }

        /* Zone colors */
        .zone-base { background-color: #6d3a13; }
        .zone-inner { background-color: #fcc49c; }
        .zone-middle { background-color: #f57d2d; }
        .zone-outer { background-color: #f57d2d; }
        .zone-dead { background-color: #6d3a13; }

        /* Piece styles */
        .piece {
            width: 42px;
            height: 42px;
            transform: rotate(-90deg);
            cursor: grab;
            user-select: none;
            pointer-events: all;
            position: relative;
            z-index: 10;
        }

        .piece.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }
        
        .piece.selected {
            filter: drop-shadow(0 0 8px #f1c40f) brightness(1.3);
        }

        .piece img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: block;
        }
        
        /* Movement highlighting */
        .hexagon.valid-move {
            filter: brightness(1.3);
            box-shadow: 0 0 15px #2ecc71, inset 0 0 10px rgba(46, 204, 113, 0.3);
            border: 2px solid #2ecc71 !important;
            animation: pulse-green 1.5s infinite;
        }

        .hexagon.valid-attack {
            filter: brightness(1.3);
            box-shadow: 0 0 15px #e74c3c, inset 0 0 10px rgba(231, 76, 60, 0.3);
            border: 2px solid #e74c3c !important;
            animation: pulse-red 1.5s infinite;
        }
        
        @keyframes pulse-green {
            0%, 100% { box-shadow: 0 0 15px #2ecc71, inset 0 0 10px rgba(46, 204, 113, 0.3); }
            50% { box-shadow: 0 0 25px #2ecc71, inset 0 0 15px rgba(46, 204, 113, 0.5); }
        }
        
        @keyframes pulse-red {
            0%, 100% { box-shadow: 0 0 15px #e74c3c, inset 0 0 10px rgba(231, 76, 60, 0.3); }
            50% { box-shadow: 0 0 25px #e74c3c, inset 0 0 15px rgba(231, 76, 60, 0.5); }
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .btn {
            background: linear-gradient(135deg, #4ecdc4 0%, #44a08d 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 1em;
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(78, 205, 196, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .error-message {
            background: rgba(255, 107, 107, 0.2);
            border: 2px solid #ff6b6b;
            color: #ff8a8a;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            margin: 20px 0;
        }

        .loading {
            text-align: center;
            padding: 40px;
            font-size: 1.2em;
            color: #4ecdc4;
        }

        .loading::after {
            content: '...';
            animation: dots 1.5s infinite;
        }

        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }

        .turn-indicator {
            text-align: center;
            padding: 15px;
            background: rgba(78, 205, 196, 0.2);
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 1.1em;
            font-weight: 600;
        }

        .move-list {
            max-height: 300px;
            overflow-y: auto;
            font-size: 0.9em;
        }

        .move-item {
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            margin-bottom: 5px;
            border-radius: 4px;
            font-family: monospace;
        }

        @media (max-width: 1200px) {
            .game-layout {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto auto;
            }

            .board {
                transform: none;
            }

            .hex-row.offset {
                margin-left: 0;
                margin-top: -20px;
            }

            .hexagon {
                transform: rotate(-90deg);
            }

            .piece {
                transform: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéÆ Custom Game</h1>
            <div id="loading" class="loading">Loading game</div>
        </div>

        <div id="error-container"></div>

        <div id="game-content" style="display: none;">
            <div class="game-layout">
                <!-- Left Panel: White Info -->
                <div class="side-panel">
                    <h3>‚ö™ White Player</h3>
                    <div class="turn-indicator" id="white-turn" style="display: none; background: rgba(255, 255, 255, 0.2);">
                        Your Turn
                    </div>
                    <div class="game-info-item">
                        <div class="info-label">Pieces Captured</div>
                        <div class="info-value" id="white-captured">0</div>
                    </div>
                    <div class="game-info-item">
                        <div class="info-label">Score</div>
                        <div class="info-value" id="white-score">0</div>
                    </div>
                    <h4 style="margin-top: 20px; margin-bottom: 10px; color: #4ecdc4;">Pieces</h4>
                    <div id="white-pieces-list"></div>
                </div>

                <!-- Center: Game Board -->
                <div class="board-container">
                    <div id="board-display"></div>
                </div>

                <!-- Right Panel: Black Info & Game Info -->
                <div class="side-panel">
                    <h3>‚ö´ Black Player</h3>
                    <div class="turn-indicator" id="black-turn" style="display: block; background: rgba(0, 0, 0, 0.4);">
                        Your Turn
                    </div>
                    <div class="game-info-item">
                        <div class="info-label">Pieces Captured</div>
                        <div class="info-value" id="black-captured">0</div>
                    </div>
                    <div class="game-info-item">
                        <div class="info-label">Score</div>
                        <div class="info-value" id="black-score">0</div>
                    </div>
                    <h4 style="margin-top: 20px; margin-bottom: 10px; color: #4ecdc4;">Pieces</h4>
                    <div id="black-pieces-list"></div>

                    <hr style="margin: 20px 0; border: 1px solid rgba(78, 205, 196, 0.3);">

                    <h3>üìä Game Info</h3>
                    <div class="game-info-item">
                        <div class="info-label">Name</div>
                        <div class="info-value" id="game-name">---</div>
                    </div>
                    <div class="game-info-item">
                        <div class="info-label">Creator</div>
                        <div class="info-value" id="game-creator">---</div>
                    </div>
                    <div class="game-info-item">
                        <div class="info-label">Total Plays</div>
                        <div class="info-value" id="game-plays">0</div>
                    </div>
                </div>
            </div>

            <div class="controls">
                <button class="btn" onclick="resetGame()">üîÑ Reset Game</button>
                <button class="btn btn-secondary" onclick="undoMove()" id="undo-btn" disabled>‚Ü∂ Undo Move</button>
                <button class="btn btn-secondary" onclick="window.location.href='game-creator.html'">‚Üê Back to Creator</button>
            </div>
        </div>
    </div>

    <script>
        const API_BASE = 'https://api.romgon.net/api/custom-games';
        let currentGameConfig = null;
        let gameState = {
            currentPlayer: 'black',
            moveHistory: [],
            capturedPieces: { white: [], black: [] },
            boardState: {}
        };

        let draggedPiece = null;
        let draggedFromHex = null;

        async function loadGame(gameId) {
            try {
                console.log(`üì• Loading game: ${gameId}`);
                const response = await fetch(`${API_BASE}/game/${gameId}`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                console.log('‚úÖ Game loaded:', data);

                if (!data.success || !data.game) {
                    throw new Error(data.error || 'Game not found');
                }

                const game = data.game;
                currentGameConfig = typeof game.config === 'string' 
                    ? JSON.parse(game.config) 
                    : game.config;

                // Update UI
                document.getElementById('loading').style.display = 'none';
                document.getElementById('game-content').style.display = 'block';
                document.getElementById('game-name').textContent = game.name;
                document.getElementById('game-creator').textContent = game.creator || 'Anonymous';
                document.getElementById('game-plays').textContent = game.plays || 0;

                // Initialize game
                initializeGame(currentGameConfig);

                // Increment play count
                incrementPlayCount(gameId);

            } catch (error) {
                console.error('‚ùå Load error:', error);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error-container').innerHTML = `
                    <div class="error-message">
                        <h3>‚ùå Error Loading Game</h3>
                        <p>${error.message}</p>
                        <button class="btn" onclick="window.location.href='game-creator.html'">‚Üê Back to Creator</button>
                    </div>
                `;
            }
        }

        function initializeGame(config) {
            console.log('üéÆ Initializing game with config:', config);
            
            // Debug logging
            console.log('üìã Board config:', config.board);
            console.log('üìã Zones:', config.board?.zones);
            console.log('üìã Placements:', config.board?.placements);
            console.log('üìã Pieces count:', config.pieces?.length);
            
            if (!config.board) {
                console.error('‚ùå No board config found!');
                return;
            }
            
            if (!config.pieces || config.pieces.length === 0) {
                console.error('‚ùå No pieces found!');
            }
            
            if (!config.board.placements || config.board.placements.length === 0) {
                console.warn('‚ö†Ô∏è No piece placements found!');
            }
            
            // Reset game state
            gameState = {
                currentPlayer: 'black',
                moveHistory: [],
                capturedPieces: { white: [], black: [] },
                boardState: {}
            };

            // Render board
            renderBoard(config.board);
            
            // Place pieces
            placePieces(config.pieces, config.board.placements);

            // Update piece lists
            updatePieceLists(config.pieces);

            // Update turn indicator
            updateTurnIndicator();
        }

        function renderBoard(boardConfig) {
            const boardDisplay = document.getElementById('board-display');
            boardDisplay.innerHTML = '';

            const board = document.createElement('div');
            board.className = 'board';
            board.id = 'game-board';

            // Handle both old and new board formats
            let rows, colsPerRow;
            
            // PRIORITY: If both formats exist, use width/height (old format) as it's more reliable
            if (boardConfig.height && boardConfig.width) {
                // Old format - convert to new format
                rows = boardConfig.height;
                const maxWidth = boardConfig.width;
                
                // Generate hexagon shape: expand to middle, then contract
                const mid = Math.floor(rows / 2);
                colsPerRow = [];
                
                for (let i = 0; i < rows; i++) {
                    let cols;
                    if (i <= mid) {
                        // Expanding rows: start small, grow to maxWidth at middle
                        cols = Math.max(1, maxWidth - (mid - i));
                    } else {
                        // Contracting rows: shrink from maxWidth back down
                        cols = Math.max(1, maxWidth - (i - mid));
                    }
                    colsPerRow.push(cols);
                }
                
                console.log('üîÑ Converted old board format:', { height: rows, width: maxWidth, colsPerRow });
            } else if (boardConfig.rows && boardConfig.colsPerRow) {
                // New format
                rows = boardConfig.rows;
                colsPerRow = boardConfig.colsPerRow;
            } else {
                // Fallback to default
                rows = 7;
                colsPerRow = [4, 5, 6, 7, 6, 5, 4];
            }

            const zones = boardConfig.zones || {};
            const deletedHexes = boardConfig.deletedHexes || [];

            console.log(`üî∑ Rendering board: ${rows} rows`);
            console.log(`üî∑ Cols per row:`, colsPerRow);
            console.log(`üî∑ Zones:`, Object.keys(zones).length, 'zones');
            console.log(`üî∑ Deleted hexes:`, deletedHexes.length);

            for (let r = 0; r < rows; r++) {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'hex-row';
                
                // Even rows need offset
                if (r % 2 === 0) {
                    rowDiv.classList.add('offset');
                }

                const cols = colsPerRow[r] || 0;
                for (let c = 0; c < cols; c++) {
                    const hexId = `${r}-${c}`;
                    
                    // Skip deleted hexes
                    if (deletedHexes.includes(hexId)) {
                        continue;
                    }

                    const hex = document.createElement('div');
                    hex.className = 'hexagon';
                    hex.id = `hex-${hexId}`;
                    hex.dataset.row = r;
                    hex.dataset.col = c;

                    // Apply zone color
                    const zone = getZoneForHex(hexId, zones);
                    if (zone) {
                        hex.classList.add(`zone-${zone}`);
                        console.log(`üé® Applied zone-${zone} to hex ${hexId}`);
                    } else {
                        console.log(`‚ö™ No zone for hex ${hexId}, using default`);
                    }

                    // Setup drag & drop
                    hex.addEventListener('dragover', handleDragOver);
                    hex.addEventListener('drop', handleDrop);
                    hex.addEventListener('click', handleHexClick);

                    rowDiv.appendChild(hex);
                }

                board.appendChild(rowDiv);
            }

            boardDisplay.appendChild(board);
            console.log('‚úÖ Board rendered');
        }

        function getZoneForHex(hexId, zones) {
            if (!zones || Object.keys(zones).length === 0) {
                return 'middle'; // default
            }
            
            // Handle both zone formats:
            // Format 1: {base: ['4-6', '2-6'], inner: [...]}  (new format)
            // Format 2: {'4-6': 'base', '2-6': 'base'}  (old format)
            
            // Check if first value is an array (new format)
            const firstValue = Object.values(zones)[0];
            if (Array.isArray(firstValue)) {
                // New format: {base: ['4-6', '2-6']}
                for (const [zoneName, hexList] of Object.entries(zones)) {
                    if (hexList && hexList.includes(hexId)) {
                        return zoneName;
                    }
                }
            } else {
                // Old format: {'4-6': 'base'}
                if (zones[hexId]) {
                    return zones[hexId];
                }
            }
            
            return 'middle'; // default
        }

        function placePieces(pieces, placements) {
            if (!pieces || !placements) {
                console.warn('‚ö†Ô∏è No pieces or placements provided');
                return;
            }

            console.log(`üéØ Placing ${placements.length} pieces...`);

            placements.forEach(placement => {
                // Handle both old and new placement formats
                let pieceName, color, row, col;
                
                if (placement.hex && placement.pieceId) {
                    // Old format: {pieceId: 123, player: 'black', hex: '5-8'}
                    const [r, c] = placement.hex.split('-').map(Number);
                    row = r;
                    col = c;
                    color = placement.player;
                    // Find piece by ID
                    const piece = pieces.find(p => p.id === placement.pieceId);
                    if (!piece) {
                        console.warn(`‚ö†Ô∏è Piece not found with ID: ${placement.pieceId}`);
                        return;
                    }
                    pieceName = piece.name;
                } else {
                    // New format: {piece: "PieceName", color: "black", row: 5, col: 8}
                    pieceName = placement.piece;
                    color = placement.color;
                    row = placement.row;
                    col = placement.col;
                }
                
                const piece = pieces.find(p => p.name === pieceName);
                if (!piece) {
                    console.warn(`‚ö†Ô∏è Piece not found: ${pieceName}`);
                    return;
                }

                const hexId = `${row}-${col}`;
                const hexEl = document.getElementById(`hex-${hexId}`);
                if (!hexEl) {
                    console.warn(`‚ö†Ô∏è Hex not found: ${hexId}`);
                    return;
                }

                const pieceEl = createPieceElement(piece, color);
                hexEl.appendChild(pieceEl);

                // Store in board state
                gameState.boardState[hexId] = {
                    piece: piece.name,
                    color: color
                };
                
                console.log(`  ‚úì Placed ${piece.name} (${color}) at ${hexId}`);
            });

            console.log('‚úÖ Pieces placed');
        }

        function createPieceElement(piece, color) {
            const pieceEl = document.createElement('div');
            pieceEl.className = `piece piece-${color}`;
            pieceEl.draggable = true;
            pieceEl.dataset.pieceName = piece.name;
            pieceEl.dataset.color = color;
            
            // Store full piece data for highlighting
            pieceEl.dataset.pieceData = JSON.stringify(piece);

            const img = document.createElement('img');
            img.src = piece.imageUrl || `ASSETS/${piece.shape} ${color} front.png`;
            img.alt = piece.name;
            img.draggable = false;

            pieceEl.appendChild(img);

            // Drag events
            pieceEl.addEventListener('dragstart', handleDragStart);
            pieceEl.addEventListener('dragend', handleDragEnd);
            
            // Click to select/highlight
            pieceEl.addEventListener('click', handlePieceClick);

            return pieceEl;
        }
        
        let selectedPiece = null;

        function handlePieceClick(e) {
            e.stopPropagation();
            const pieceEl = e.target.closest('.piece');
            if (!pieceEl) return;
            
            const color = pieceEl.dataset.color;
            
            // Only allow current player to select their pieces
            if (color !== gameState.currentPlayer) {
                console.log('‚ùå Not your turn');
                return;
            }
            
            // Clear previous highlights
            clearHighlights();
            
            // If clicking same piece, deselect
            if (selectedPiece === pieceEl) {
                selectedPiece.classList.remove('selected');
                selectedPiece = null;
                return;
            }
            
            // Select new piece
            if (selectedPiece) {
                selectedPiece.classList.remove('selected');
            }
            
            selectedPiece = pieceEl;
            pieceEl.classList.add('selected');
            
            // Get piece position
            const hexEl = pieceEl.parentElement;
            const currentRow = parseInt(hexEl.dataset.row);
            const currentCol = parseInt(hexEl.dataset.col);
            
            // Get piece data
            const pieceData = JSON.parse(pieceEl.dataset.pieceData);
            
            // Highlight valid moves
            highlightValidMoves(pieceData, currentRow, currentCol);
            
            console.log(`‚úÖ Selected ${pieceData.name} at (${currentRow},${currentCol})`);
        }
        
        function highlightValidMoves(piece, currentRow, currentCol) {
            console.log('üîç Attempting to highlight moves for piece:', piece.name);
            console.log('üìç Current position:', currentRow, currentCol);
            console.log('üéØ Movement data:', piece.movement);
            
            if (!piece.movement) {
                console.warn('‚ö†Ô∏è No movement data found for piece:', piece.name);
                return;
            }
            
            let moveCount = 0;
            let attackCount = 0;
            
            // Use hardcoded patterns if available (preferred method)
            if (piece.movement.hardcodedMove && piece.movement.hardcodedMove.length > 0) {
                console.log('üü¢ Processing hardcodedMove patterns:', piece.movement.hardcodedMove);
                piece.movement.hardcodedMove.forEach(offset => {
                    const targetRow = currentRow + offset.rowOffset;
                    const targetCol = currentCol + offset.colOffset;
                    
                    const hexEl = document.getElementById(`hex-${targetRow}-${targetCol}`);
                    console.log(`  ‚Üí Trying to highlight move hex-${targetRow}-${targetCol}:`, hexEl ? '‚úÖ Found' : '‚ùå Not found');
                    if (hexEl) {
                        hexEl.classList.add('valid-move');
                        moveCount++;
                    }
                });
            } else {
                console.warn('‚ö†Ô∏è No hardcodedMove patterns found');
            }
            
            if (piece.movement.hardcodedAttack && piece.movement.hardcodedAttack.length > 0) {
                console.log('üî¥ Processing hardcodedAttack patterns:', piece.movement.hardcodedAttack);
                piece.movement.hardcodedAttack.forEach(offset => {
                    const targetRow = currentRow + offset.rowOffset;
                    const targetCol = currentCol + offset.colOffset;
                    
                    const hexEl = document.getElementById(`hex-${targetRow}-${targetCol}`);
                    console.log(`  ‚Üí Trying to highlight attack hex-${targetRow}-${targetCol}:`, hexEl ? '‚úÖ Found' : '‚ùå Not found');
                    if (hexEl) {
                        hexEl.classList.add('valid-attack');
                        attackCount++;
                    }
                });
            } else {
                console.warn('‚ö†Ô∏è No hardcodedAttack patterns found');
            }
            
            console.log(`üí° Successfully highlighted ${moveCount} moves, ${attackCount} attacks`);
        }
        
        function clearHighlights() {
            document.querySelectorAll('.valid-move').forEach(el => el.classList.remove('valid-move'));
            document.querySelectorAll('.valid-attack').forEach(el => el.classList.remove('valid-attack'));
        }

        function handleDragStart(e) {
            const pieceEl = e.target.closest('.piece');
            const color = pieceEl.dataset.color;

            // Only allow current player to drag their pieces
            if (color !== gameState.currentPlayer) {
                e.preventDefault();
                return;
            }

            draggedPiece = pieceEl;
            draggedFromHex = pieceEl.parentElement;
            pieceEl.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleDragEnd(e) {
            const pieceEl = e.target.closest('.piece');
            if (pieceEl) {
                pieceEl.classList.remove('dragging');
                pieceEl.classList.remove('selected');
            }
            draggedPiece = null;
            draggedFromHex = null;
            clearHighlights(); // Clear highlights after drag
            if (selectedPiece) {
                selectedPiece.classList.remove('selected');
                selectedPiece = null;
            }
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }

        function handleDrop(e) {
            e.preventDefault();
            
            if (!draggedPiece || !draggedFromHex) return;

            const targetHex = e.target.closest('.hexagon');
            if (!targetHex) return;

            const fromRow = parseInt(draggedFromHex.dataset.row);
            const fromCol = parseInt(draggedFromHex.dataset.col);
            const toRow = parseInt(targetHex.dataset.row);
            const toCol = parseInt(targetHex.dataset.col);
            
            const fromId = `${fromRow}-${fromCol}`;
            const toId = `${toRow}-${toCol}`;

            // Get piece data
            const pieceData = JSON.parse(draggedPiece.dataset.pieceData);
            
            // Validate move using hardcoded patterns
            const isValidMove = validateMove(pieceData, fromRow, fromCol, toRow, toCol);
            
            if (!isValidMove) {
                console.log('‚ùå Invalid move');
                return;
            }

            // Check if target has a piece
            const targetPiece = targetHex.querySelector('.piece');
            if (targetPiece) {
                const targetColor = targetPiece.dataset.color;
                
                // Cannot move to own piece
                if (targetColor === gameState.currentPlayer) {
                    console.log('‚ùå Cannot move to own piece');
                    return;
                }
                
                // Check if this is a valid attack
                const isValidAttack = isAttackMove(pieceData, fromRow, fromCol, toRow, toCol);
                if (!isValidAttack) {
                    console.log('‚ùå Cannot attack this position');
                    return;
                }
                
                // Capture piece
                console.log(`‚öîÔ∏è Captured ${targetPiece.dataset.pieceName}`);
                targetPiece.remove();
                gameState.capturedPieces[targetColor].push(targetPiece.dataset.pieceName);
                updateCaptureCount();
            }

            // Move piece
            targetHex.appendChild(draggedPiece);

            // Update board state
            delete gameState.boardState[fromId];
            gameState.boardState[toId] = {
                piece: draggedPiece.dataset.pieceName,
                color: draggedPiece.dataset.color
            };

            // Record move
            gameState.moveHistory.push({
                from: fromId,
                to: toId,
                piece: draggedPiece.dataset.pieceName,
                captured: targetPiece ? targetPiece.dataset.pieceName : null
            });

            // Check for win conditions BEFORE switching turns
            const winResult = checkWinCondition(toRow, toCol, pieceData, targetPiece);
            if (winResult) {
                showGameOver(winResult.winner, winResult.reason);
                return;
            }

            // Switch turns
            gameState.currentPlayer = gameState.currentPlayer === 'black' ? 'white' : 'black';
            updateTurnIndicator();
            updateUndoButton();
            clearHighlights(); // Clear highlights after move

            console.log(`‚úÖ Move: ${fromId} ‚Üí ${toId}`);
        }
        
        function validateMove(piece, fromRow, fromCol, toRow, toCol) {
            if (!piece.movement) return false;
            
            const rowOffset = toRow - fromRow;
            const colOffset = toCol - fromCol;
            
            // Check if move matches any hardcoded move pattern
            if (piece.movement.hardcodedMove && piece.movement.hardcodedMove.length > 0) {
                const isValid = piece.movement.hardcodedMove.some(pattern => 
                    pattern.rowOffset === rowOffset && pattern.colOffset === colOffset
                );
                if (isValid) return true;
            }
            
            // Check if it's an attack move (can move to attack positions)
            if (piece.movement.hardcodedAttack && piece.movement.hardcodedAttack.length > 0) {
                const isValid = piece.movement.hardcodedAttack.some(pattern => 
                    pattern.rowOffset === rowOffset && pattern.colOffset === colOffset
                );
                if (isValid) return true;
            }
            
            return false;
        }
        
        function isAttackMove(piece, fromRow, fromCol, toRow, toCol) {
            if (!piece.movement || !piece.movement.hardcodedAttack) return false;
            
            const rowOffset = toRow - fromRow;
            const colOffset = toCol - fromCol;
            
            // Check if this move matches an attack pattern
            return piece.movement.hardcodedAttack.some(pattern => 
                pattern.rowOffset === rowOffset && pattern.colOffset === colOffset
            );
        }

        function checkWinCondition(toRow, toCol, movingPiece, capturedPiece) {
            const currentPlayer = gameState.currentPlayer;
            const opponent = currentPlayer === 'black' ? 'white' : 'black';
            
            // 1. CHECK: King Capture (if a "King" piece was captured)
            if (capturedPiece) {
                const capturedName = capturedPiece.dataset.pieceName.toLowerCase();
                if (capturedName.includes('king') || capturedName.includes('monarch') || capturedName.includes('ruler')) {
                    console.log(`üëë King captured! ${currentPlayer} wins!`);
                    return {
                        winner: currentPlayer,
                        reason: `${currentPlayer === 'black' ? 'Black' : 'White'} captured the enemy King!`
                    };
                }
            }
            
            // 2. CHECK: Base Capture (piece reached opponent's base zone)
            const hexId = `${toRow}-${toCol}`;
            const hexEl = document.getElementById(`hex-${hexId}`);
            if (hexEl && hexEl.classList.contains('zone-base')) {
                // Check if this is the OPPONENT's base
                // In a typical setup, black bases are at low rows, white bases at high rows
                // We'll use a simple heuristic: if current player is black and reached a base in top half, or vice versa
                const boardConfig = currentGameConfig.board;
                const midRow = Math.floor((boardConfig.rows || boardConfig.height || 7) / 2);
                
                if ((currentPlayer === 'black' && toRow < midRow) || 
                    (currentPlayer === 'white' && toRow > midRow)) {
                    console.log(`üèÅ Base captured! ${currentPlayer} wins!`);
                    return {
                        winner: currentPlayer,
                        reason: `${currentPlayer === 'black' ? 'Black' : 'White'} reached the opponent's base!`
                    };
                }
            }
            
            // 3. CHECK: Elimination (all opponent pieces captured)
            const opponentPieces = Object.values(gameState.boardState).filter(
                state => state.color === opponent
            );
            
            if (opponentPieces.length === 0) {
                console.log(`üéØ All pieces eliminated! ${currentPlayer} wins!`);
                return {
                    winner: currentPlayer,
                    reason: `${currentPlayer === 'black' ? 'Black' : 'White'} eliminated all enemy pieces!`
                };
            }
            
            // No win condition met
            return null;
        }
        
        function showGameOver(winner, reason) {
            console.log(`üéâ GAME OVER! Winner: ${winner}, Reason: ${reason}`);
            
            // Disable all piece interactions
            document.querySelectorAll('.piece').forEach(piece => {
                piece.draggable = false;
                piece.style.cursor = 'default';
            });
            
            // Show modal
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                animation: fadeIn 0.3s ease;
            `;
            
            const winnerColor = winner === 'black' ? '#2c3e50' : '#ecf0f1';
            const winnerText = winner === 'black' ? 'BLACK' : 'WHITE';
            
            modal.innerHTML = `
                <div style="
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    padding: 40px;
                    border-radius: 20px;
                    text-align: center;
                    max-width: 500px;
                    box-shadow: 0 20px 60px rgba(0,0,0,0.5);
                    animation: slideIn 0.5s ease;
                ">
                    <h1 style="
                        font-size: 3em;
                        margin: 0 0 20px 0;
                        color: ${winnerColor};
                        text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
                    ">üèÜ VICTORY!</h1>
                    <h2 style="
                        font-size: 2em;
                        margin: 0 0 15px 0;
                        color: ${winnerColor};
                    ">${winnerText} WINS!</h2>
                    <p style="
                        font-size: 1.2em;
                        color: #fff;
                        margin: 20px 0 30px 0;
                    ">${reason}</p>
                    <button onclick="window.location.reload()" style="
                        padding: 15px 40px;
                        font-size: 1.2em;
                        background: ${winnerColor};
                        color: ${winner === 'black' ? '#fff' : '#2c3e50'};
                        border: none;
                        border-radius: 10px;
                        cursor: pointer;
                        font-weight: bold;
                        margin-right: 10px;
                        box-shadow: 0 4px 15px rgba(0,0,0,0.3);
                        transition: transform 0.2s;
                    " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        Play Again
                    </button>
                    <button onclick="window.location.href='game-library.html'" style="
                        padding: 15px 40px;
                        font-size: 1.2em;
                        background: rgba(255,255,255,0.2);
                        color: #fff;
                        border: 2px solid #fff;
                        border-radius: 10px;
                        cursor: pointer;
                        font-weight: bold;
                        box-shadow: 0 4px 15px rgba(0,0,0,0.2);
                        transition: transform 0.2s;
                    " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        Game Library
                    </button>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Add CSS animations
            const style = document.createElement('style');
            style.textContent = `
                @keyframes fadeIn {
                    from { opacity: 0; }
                    to { opacity: 1; }
                }
                @keyframes slideIn {
                    from { transform: translateY(-50px); opacity: 0; }
                    to { transform: translateY(0); opacity: 1; }
                }
            `;
            document.head.appendChild(style);
        }

        function handleHexClick(e) {
            // Clear piece selection if clicking empty hex
            if (selectedPiece) {
                selectedPiece.classList.remove('selected');
                selectedPiece = null;
                clearHighlights();
            }
        }

        function updatePieceLists(pieces) {
            const whitePieces = pieces.filter(p => 
                Object.values(gameState.boardState).some(bs => bs.piece === p.name && bs.color === 'white')
            );
            const blackPieces = pieces.filter(p => 
                Object.values(gameState.boardState).some(bs => bs.piece === p.name && bs.color === 'black')
            );

            const whiteList = document.getElementById('white-pieces-list');
            const blackList = document.getElementById('black-pieces-list');

            whiteList.innerHTML = whitePieces.map(p => `
                <div class="game-info-item">
                    <div class="info-value">${p.name}</div>
                    <div class="info-label">${p.shape}</div>
                </div>
            `).join('');

            blackList.innerHTML = blackPieces.map(p => `
                <div class="game-info-item">
                    <div class="info-value">${p.name}</div>
                    <div class="info-label">${p.shape}</div>
                </div>
            `).join('');
        }

        function updateTurnIndicator() {
            const whiteIndicator = document.getElementById('white-turn');
            const blackIndicator = document.getElementById('black-turn');

            if (gameState.currentPlayer === 'white') {
                whiteIndicator.style.display = 'block';
                blackIndicator.style.display = 'none';
            } else {
                whiteIndicator.style.display = 'none';
                blackIndicator.style.display = 'block';
            }
        }

        function updateCaptureCount() {
            document.getElementById('white-captured').textContent = gameState.capturedPieces.white.length;
            document.getElementById('black-captured').textContent = gameState.capturedPieces.black.length;
        }

        function updateUndoButton() {
            const undoBtn = document.getElementById('undo-btn');
            undoBtn.disabled = gameState.moveHistory.length === 0;
        }

        function undoMove() {
            if (gameState.moveHistory.length === 0) return;

            const lastMove = gameState.moveHistory.pop();
            
            // Find piece and move it back
            const toHex = document.getElementById(`hex-${lastMove.to}`);
            const fromHex = document.getElementById(`hex-${lastMove.from}`);
            const pieceEl = toHex.querySelector('.piece');

            if (pieceEl && fromHex) {
                fromHex.appendChild(pieceEl);

                // Restore captured piece if any
                if (lastMove.captured) {
                    const capturedColor = gameState.currentPlayer; // opposite of current
                    gameState.capturedPieces[capturedColor].pop();
                    updateCaptureCount();
                }

                // Update board state
                gameState.boardState[lastMove.from] = gameState.boardState[lastMove.to];
                delete gameState.boardState[lastMove.to];

                // Switch turn back
                gameState.currentPlayer = gameState.currentPlayer === 'black' ? 'white' : 'black';
                updateTurnIndicator();
                updateUndoButton();

                console.log('‚Ü∂ Move undone');
            }
        }

        function resetGame() {
            if (currentGameConfig) {
                initializeGame(currentGameConfig);
                console.log('üîÑ Game reset');
            }
        }

        async function incrementPlayCount(gameId) {
            try {
                await fetch(`${API_BASE}/game/${gameId}/play`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                console.log('‚úÖ Play count incremented');
            } catch (error) {
                console.error('‚ö†Ô∏è Failed to increment play count:', error);
            }
        }

        // Extract game ID from URL
        const urlParams = new URLSearchParams(window.location.search);
        const gameId = urlParams.get('id') || urlParams.get('game');

        if (gameId) {
            loadGame(gameId);
        } else {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('error-container').innerHTML = `
                <div class="error-message">
                    <h3>‚ùå No Game ID</h3>
                    <p>Please provide a game ID in the URL (?id=... or ?game=...)</p>
                    <button class="btn" onclick="window.location.href='game-creator.html'">‚Üê Back to Creator</button>
                </div>
            `;
        }
    </script>
</body>
</html>
