    <!-- Sign Up Modal -->
    <div id="signup-modal" style="
        display: none;
        position: fixed;
        top: 0; left: 0; width: 100vw; height: 100vh;
        background: rgba(20, 24, 32, 0.98);
        z-index: 3001;
        overflow-y: auto;
        padding: 0; margin: 0;
        backdrop-filter: blur(4px);
    ">
        <div style="
            max-width: 500px;
            margin: 80px auto;
            background: #23272e;
            border-radius: 18px;
            box-shadow: 0 8px 40px #000a;
            padding: 40px 36px;
            color: #fff;
            position: relative;
        ">
            <button onclick="hideSignUpModal()" style="
                position: absolute; top: 18px; right: 18px;
                background: #ff6b6b; color: #23272e;
                border: none; border-radius: 8px;
                font-size: 1.2em; font-weight: bold;
                padding: 6px 16px; cursor: pointer; z-index: 10;
                transition: all 0.3s ease;
            " onmouseover="this.style.transform='scale(1.1)'" onmouseout="this.style.transform='scale(1)'">‚úñÔ∏è</button>
            
            <h2 style="color: #ff6b6b; margin-top: 0; text-align: center; font-size: 1.8em;">üìù Create Account</h2>
            <p style="color: #aaa; text-align: center; margin-bottom: 30px;">Join to save your progress and stats</p>
            
            <form id="signup-form" onsubmit="handleSignUp(event)" style="display: flex; flex-direction: column; gap: 18px;">
                <div>
                    <label style="display: block; color: #4ecdc4; font-weight: bold; margin-bottom: 8px;">Username</label>
                    <input type="text" id="signup-username" placeholder="Choose a username" required style="
                        width: 100%;
                        padding: 12px 16px;
                        background: #1a1e26;
                        border: 2px solid #4ecdc4;
                        border-radius: 8px;
                        color: #fff;
                        font-size: 1em;
                        box-sizing: border-box;
                        transition: all 0.3s ease;
                    " onmouseover="this.style.borderColor='#5eddd4'" onmouseout="this.style.borderColor='#4ecdc4'" onfocus="this.style.boxShadow='0 0 12px rgba(78, 205, 196, 0.3)'" onblur="this.style.boxShadow='none'">
                </div>
                
                <div>
                    <label style="display: block; color: #4ecdc4; font-weight: bold; margin-bottom: 8px;">Email</label>
                    <input type="email" id="signup-email" placeholder="your.email@example.com" required style="
                        width: 100%;
                        padding: 12px 16px;
                        background: #1a1e26;
                        border: 2px solid #4ecdc4;
                        border-radius: 8px;
                        color: #fff;
                        font-size: 1em;
                        box-sizing: border-box;
                        transition: all 0.3s ease;
                    " onmouseover="this.style.borderColor='#5eddd4'" onmouseout="this.style.borderColor='#4ecdc4'" onfocus="this.style.boxShadow='0 0 12px rgba(78, 205, 196, 0.3)'" onblur="this.style.boxShadow='none'">
                </div>
                
                <div>
                    <label style="display: block; color: #4ecdc4; font-weight: bold; margin-bottom: 8px;">Password</label>
                    <input type="password" id="signup-password" placeholder="Enter password (min 6 characters)" required minlength="6" style="
                        width: 100%;
                        padding: 12px 16px;
                        background: #1a1e26;
                        border: 2px solid #4ecdc4;
                        border-radius: 8px;
                        color: #fff;
                        font-size: 1em;
                        box-sizing: border-box;
                        transition: all 0.3s ease;
                    " onmouseover="this.style.borderColor='#5eddd4'" onmouseout="this.style.borderColor='#4ecdc4'" onfocus="this.style.boxShadow='0 0 12px rgba(78, 205, 196, 0.3)'" onblur="this.style.boxShadow='none'">
                </div>
                
                <div>
                    <label style="display: block; color: #4ecdc4; font-weight: bold; margin-bottom: 8px;">Confirm Password</label>
                    <input type="password" id="signup-confirm-password" placeholder="Re-enter your password" required minlength="6" style="
                        width: 100%;
                        padding: 12px 16px;
                        background: #1a1e26;
                        border: 2px solid #4ecdc4;
                        border-radius: 8px;
                        color: #fff;
                        font-size: 1em;
                        box-sizing: border-box;
                        transition: all 0.3s ease;
                    " onmouseover="this.style.borderColor='#5eddd4'" onmouseout="this.style.borderColor='#4ecdc4'" onfocus="this.style.boxShadow='0 0 12px rgba(78, 205, 196, 0.3)'" onblur="this.style.boxShadow='none'">
                </div>
                
                <div id="signup-error" style="display: none; background: rgba(255, 107, 107, 0.2); color: #ff8a8a; padding: 12px; border-radius: 8px; font-size: 0.95em; text-align: center; border-left: 4px solid #ff6b6b;"></div>
                
                <button type="submit" style="
                    background: linear-gradient(135deg, #ff6b6b, #ff8a8a);
                    color: white;
                    border: none;
                    padding: 14px 24px;
                    border-radius: 8px;
                    font-weight: 700;
                    font-size: 0.95em;
                    cursor: pointer;
                    box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
                    transition: all 0.3s ease;
                    margin-top: 10px;
                " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(255, 107, 107, 0.5)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(255, 107, 107, 0.3)'">
                    ‚úì Create Account
                </button>
            </form>
            
            <p style="color: #888; text-align: center; margin-top: 24px; font-size: 0.95em;">
                Already have an account? <a href="#" onclick="hideSignUpModal(); showLoginOptions();" style="color: #4ecdc4; text-decoration: none; font-weight: bold;">Sign in with Google</a>
            </p>
        </div>
    </div>

    <!-- Enhanced Sign In Modal -->
    <div id="signin-modal" style="
        display: none;
        position: fixed;
        top: 0; left: 0; width: 100vw; height: 100vh;
        background: rgba(15, 20, 30, 0.98);
        z-index: 3001;
        overflow-y: auto;
        padding: 0; margin: 0;
        backdrop-filter: blur(8px);
    ">
        <div style="
            max-width: 480px;
            margin: 60px auto;
            background: linear-gradient(135deg, #23272e 0%, #2c313a 100%);
            border-radius: 24px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            padding: 50px 40px;
            color: #fff;
            position: relative;
            border: 1px solid rgba(102, 126, 234, 0.3);
        ">
            <!-- Close Button -->
            <button onclick="hideSignInModal()" style="
                position: absolute; top: 20px; right: 20px;
                background: rgba(255, 107, 107, 0.2);
                color: #ff6b6b;
                border: 2px solid #ff6b6b;
                border-radius: 50%;
                width: 42px;
                height: 42px;
                font-size: 1.4em;
                font-weight: bold;
                cursor: pointer;
                z-index: 10;
                transition: all 0.3s ease;
                display: flex;
                align-items: center;
                justify-content: center;
            " onmouseover="this.style.background='rgba(255, 107, 107, 0.3)'; this.style.transform='rotate(90deg)'" onmouseout="this.style.background='rgba(255, 107, 107, 0.2)'; this.style.transform='rotate(0)'">√ó</button>
            
            <!-- Header -->
            <div style="text-align: center; margin-bottom: 40px;">
                <div style="
                    width: 80px;
                    height: 80px;
                    margin: 0 auto 20px;
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    border-radius: 50%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 40px;
                    box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
                ">üîê</div>
                <h2 style="color: #667eea; margin: 0 0 10px 0; font-size: 2em; font-weight: 800;">Welcome Back!</h2>
                <p style="color: #aaa; margin: 0; font-size: 0.95em;">Sign in to continue your strategy journey</p>
            </div>
            
            <!-- Login Form -->
            <form id="signin-form" onsubmit="handleSignIn(event)" style="display: flex; flex-direction: column; gap: 20px;">
                <!-- Username/Email -->
                <div>
                    <label style="display: block; color: #667eea; font-weight: 600; margin-bottom: 10px; font-size: 0.95em;">
                        <span style="margin-right: 8px;">üë§</span> Username or Email
                    </label>
                    <input type="text" id="signin-username" placeholder="Enter your username or email" required style="
                        width: 100%;
                        padding: 14px 18px;
                        background: rgba(26, 30, 38, 0.8);
                        border: 2px solid rgba(102, 126, 234, 0.3);
                        border-radius: 12px;
                        color: #fff;
                        font-size: 1em;
                        box-sizing: border-box;
                        transition: all 0.3s ease;
                    " onfocus="this.style.borderColor='#667eea'; this.style.boxShadow='0 0 20px rgba(102, 126, 234, 0.3)'; this.style.background='rgba(26, 30, 38, 1)'" onblur="this.style.borderColor='rgba(102, 126, 234, 0.3)'; this.style.boxShadow='none'; this.style.background='rgba(26, 30, 38, 0.8)'">
                </div>
                
                <!-- Password with Toggle -->
                <div>
                    <label style="display: block; color: #667eea; font-weight: 600; margin-bottom: 10px; font-size: 0.95em;">
                        <span style="margin-right: 8px;">üîë</span> Password
                    </label>
                    <div style="position: relative;">
                        <input type="password" id="signin-password" placeholder="Enter your password" required style="
                            width: 100%;
                            padding: 14px 18px;
                            padding-right: 50px;
                            background: rgba(26, 30, 38, 0.8);
                            border: 2px solid rgba(102, 126, 234, 0.3);
                            border-radius: 12px;
                            color: #fff;
                            font-size: 1em;
                            box-sizing: border-box;
                            transition: all 0.3s ease;
                        " onfocus="this.style.borderColor='#667eea'; this.style.boxShadow='0 0 20px rgba(102, 126, 234, 0.3)'; this.style.background='rgba(26, 30, 38, 1)'" onblur="this.style.borderColor='rgba(102, 126, 234, 0.3)'; this.style.boxShadow='none'; this.style.background='rgba(26, 30, 38, 0.8)'">
                        <button type="button" onclick="toggleSignInPassword()" style="
                            position: absolute;
                            right: 15px;
                            top: 50%;
                            transform: translateY(-50%);
                            background: transparent;
                            border: none;
                            color: #667eea;
                            cursor: pointer;
                            font-size: 1.2em;
                            padding: 5px;
                            transition: all 0.3s ease;
                        " onmouseover="this.style.color='#764ba2'" onmouseout="this.style.color='#667eea'">üëÅÔ∏è</button>
                    </div>
                </div>
                
                <!-- Remember Me & Forgot Password -->
                <div style="display: flex; justify-content: space-between; align-items: center; margin-top: -10px;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; color: #aaa; font-size: 0.9em;">
                        <input type="checkbox" id="remember-me" style="
                            width: 18px;
                            height: 18px;
                            cursor: pointer;
                            accent-color: #667eea;
                        ">
                        <span>Remember me</span>
                    </label>
                    <a href="#" onclick="alert('Password reset coming soon!'); return false;" style="
                        color: #667eea;
                        text-decoration: none;
                        font-size: 0.9em;
                        font-weight: 600;
                        transition: all 0.3s ease;
                    " onmouseover="this.style.color='#764ba2'; this.style.textDecoration='underline'" onmouseout="this.style.color='#667eea'; this.style.textDecoration='none'">
                        Forgot password?
                    </a>
                </div>
                
                <!-- Error Message -->
                <div id="signin-error" style="
                    display: none;
                    background: linear-gradient(135deg, rgba(255, 107, 107, 0.2), rgba(255, 107, 107, 0.1));
                    color: #ff8a8a;
                    padding: 14px 16px;
                    border-radius: 12px;
                    font-size: 0.95em;
                    text-align: center;
                    border-left: 4px solid #ff6b6b;
                    box-shadow: 0 4px 15px rgba(255, 107, 107, 0.2);
                "></div>
                
                <!-- Sign In Button -->
                <button type="submit" style="
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    border: none;
                    padding: 16px 24px;
                    border-radius: 12px;
                    font-weight: 700;
                    font-size: 1.05em;
                    cursor: pointer;
                    box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
                    transition: all 0.3s ease;
                    margin-top: 10px;
                " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 10px 30px rgba(102, 126, 234, 0.6)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 6px 20px rgba(102, 126, 234, 0.4)'">
                    ‚úì Sign In
                </button>
            </form>
            
            <!-- Divider -->
            <div style="
                display: flex;
                align-items: center;
                gap: 15px;
                margin: 30px 0;
                color: #666;
                font-size: 0.9em;
            ">
                <div style="flex: 1; height: 1px; background: linear-gradient(90deg, transparent, #444, transparent);"></div>
                <span>OR</span>
                <div style="flex: 1; height: 1px; background: linear-gradient(90deg, transparent, #444, transparent);"></div>
            </div>
            
            <!-- Social Login Options -->
            <div style="display: flex; flex-direction: column; gap: 12px;">
                <button onclick="handleGoogleLogin()" style="
                    background: rgba(255, 255, 255, 0.05);
                    color: #fff;
                    border: 2px solid rgba(255, 255, 255, 0.1);
                    padding: 14px 20px;
                    border-radius: 12px;
                    cursor: pointer;
                    font-weight: 600;
                    font-size: 0.95em;
                    transition: all 0.3s ease;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    gap: 12px;
                " onmouseover="this.style.background='rgba(255, 255, 255, 0.1)'; this.style.borderColor='rgba(255, 255, 255, 0.2)'" onmouseout="this.style.background='rgba(255, 255, 255, 0.05)'; this.style.borderColor='rgba(255, 255, 255, 0.1)'">
                    <svg width="20" height="20" viewBox="0 0 24 24">
                        <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                        <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                        <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                        <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                    </svg>
                    Continue with Google
                </button>
                
                <button onclick="handleGuestLoginWithBackend()" style="
                    background: linear-gradient(135deg, rgba(78, 205, 196, 0.2), rgba(78, 205, 196, 0.1));
                    color: #4ecdc4;
                    border: 2px solid rgba(78, 205, 196, 0.5);
                    padding: 14px 20px;
                    border-radius: 12px;
                    cursor: pointer;
                    font-weight: 600;
                    font-size: 0.95em;
                    transition: all 0.3s ease;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    gap: 12px;
                " onmouseover="this.style.background='linear-gradient(135deg, rgba(78, 205, 196, 0.3), rgba(78, 205, 196, 0.2))'; this.style.transform='translateY(-2px)'" onmouseout="this.style.background='linear-gradient(135deg, rgba(78, 205, 196, 0.2), rgba(78, 205, 196, 0.1))'; this.style.transform='translateY(0)'">
                    üéÆ Quick Play as Guest
                </button>
            </div>
            
            <!-- Sign Up Link -->
            <p style="
                color: #888;
                text-align: center;
                margin-top: 30px;
                font-size: 0.95em;
                border-top: 1px solid rgba(255, 255, 255, 0.1);
                padding-top: 25px;
            ">
                Don't have an account? 
                <a href="#" onclick="hideSignInModal(); showSignUpModal(); return false;" style="
                    color: #667eea;
                    text-decoration: none;
                    font-weight: 700;
                    transition: all 0.3s ease;
                " onmouseover="this.style.color='#764ba2'; this.style.textDecoration='underline'" onmouseout="this.style.color='#667eea'; this.style.textDecoration='none'">
                    Create one now! ‚Üí
                </a>
            </p>
            
            <!-- Quick Stats Preview (if available) -->
            <div style="
                margin-top: 25px;
                padding: 20px;
                background: rgba(102, 126, 234, 0.1);
                border-radius: 12px;
                border: 1px solid rgba(102, 126, 234, 0.2);
                text-align: center;
            ">
                <div style="color: #aaa; font-size: 0.85em; margin-bottom: 8px;">üåü Active Players Today</div>
                <div style="color: #667eea; font-size: 1.8em; font-weight: 800;" id="active-players-count">---</div>
            </div>
        </div>
    </div>

    <!-- Account Modal -->
    <div id="account-modal" style="
        display: none;
        position: fixed;
        top: 0; left: 0; width: 100vw; height: 100vh;
        background: rgba(10, 12, 15, 0.98);
        z-index: 3001;
        overflow-y: auto;
        padding: 0; margin: 0;
        backdrop-filter: blur(4px);
    ">
        <div style="
            max-width: 1200px;
            width: 97vw;
            margin: 20px auto;
            background: #1a1e26;
            border-radius: 20px;
            box-shadow: 0 10px 50px #0009;
            padding: 0;
            color: #fff;
            position: relative;
            display: flex;
            flex-direction: column;
            max-height: 90vh;
            overflow: hidden;
        ">
            <!-- Header with Close Button -->
            <div style="
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                padding: 28px 32px;
                display: flex;
                justify-content: space-between;
                align-items: center;
                border-bottom: 2px solid #667eea;
            ">
                <h2 style="margin: 0; font-size: 1.8em; color: #fff;">üë§ Player Hub</h2>
                <button onclick="hideAccountModal()" style="
                    background: rgba(255, 255, 255, 0.2);
                    color: white;
                    border: 2px solid rgba(255, 255, 255, 0.5);
                    border-radius: 50%;
                    font-size: 1.3em;
                    width: 40px;
                    height: 40px;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                " onmouseover="this.style.background='rgba(255, 255, 255, 0.3)'" onmouseout="this.style.background='rgba(255, 255, 255, 0.2)'">‚úñ</button>
            </div>

            <!-- Tab Navigation -->
            <div style="
                display: flex;
                background: #141820;
                border-bottom: 2px solid #2a2f3a;
                padding: 0;
                overflow-x: auto;
            ">
                <button onclick="switchAccountTab('overview')" class="account-tab-btn" style="
                    flex: 1;
                    padding: 16px 20px;
                    background: transparent;
                    border: none;
                    color: #999;
                    font-size: 0.95em;
                    font-weight: 600;
                    cursor: pointer;
                    border-bottom: 3px solid transparent;
                    transition: all 0.3s ease;
                    white-space: nowrap;
                " data-tab="overview" onmouseover="this.style.color='#fff'" onmouseout="this.style.color=this.classList.contains('active') ? '#fff' : '#999'">
                    üìä Overview
                </button>
                <button onclick="switchAccountTab('analytics')" class="account-tab-btn" style="
                    flex: 1;
                    padding: 16px 20px;
                    background: transparent;
                    border: none;
                    color: #999;
                    font-size: 0.95em;
                    font-weight: 600;
                    cursor: pointer;
                    border-bottom: 3px solid transparent;
                    transition: all 0.3s ease;
                    white-space: nowrap;
                " data-tab="analytics" onmouseover="this.style.color='#fff'" onmouseout="this.style.color=this.classList.contains('active') ? '#fff' : '#999'">
                    üìà Analytics
                </button>
                <button onclick="switchAccountTab('variations')" class="account-tab-btn" style="
                    flex: 1;
                    padding: 16px 20px;
                    background: transparent;
                    border: none;
                    color: #999;
                    font-size: 0.95em;
                    font-weight: 600;
                    cursor: pointer;
                    border-bottom: 3px solid transparent;
                    transition: all 0.3s ease;
                    white-space: nowrap;
                " data-tab="variations" onmouseover="this.style.color='#fff'" onmouseout="this.style.color=this.classList.contains('active') ? '#fff' : '#999'">
                    üéÆ Variations
                </button>
                <button onclick="switchAccountTab('achievements')" class="account-tab-btn" style="
                    flex: 1;
                    padding: 16px 20px;
                    background: transparent;
                    border: none;
                    color: #999;
                    font-size: 0.95em;
                    font-weight: 600;
                    cursor: pointer;
                    border-bottom: 3px solid transparent;
                    transition: all 0.3s ease;
                    white-space: nowrap;
                " data-tab="achievements" onmouseover="this.style.color='#fff'" onmouseout="this.style.color=this.classList.contains('active') ? '#fff' : '#999'">
                    üèÜ Achievements
                </button>
                <button onclick="switchAccountTab('ratings')" class="account-tab-btn" style="
                    flex: 1;
                    padding: 16px 20px;
                    background: transparent;
                    border: none;
                    color: #999;
                    font-size: 0.95em;
                    font-weight: 600;
                    cursor: pointer;
                    border-bottom: 3px solid transparent;
                    transition: all 0.3s ease;
                    white-space: nowrap;
                " data-tab="ratings" onmouseover="this.style.color='#fff'" onmouseout="this.style.color=this.classList.contains('active') ? '#fff' : '#999'">
                    ‚≠ê Ratings
                </button>
                <button onclick="switchAccountTab('settings')" class="account-tab-btn" style="
                    flex: 1;
                    padding: 16px 20px;
                    background: transparent;
                    border: none;
                    color: #999;
                    font-size: 0.95em;
                    font-weight: 600;
                    cursor: pointer;
                    border-bottom: 3px solid transparent;
                    transition: all 0.3s ease;
                    white-space: nowrap;
                " data-tab="settings" onmouseover="this.style.color='#fff'" onmouseout="this.style.color=this.classList.contains('active') ? '#fff' : '#999'">
                    ‚öôÔ∏è Settings
                </button>
            </div>

            <!-- Main Content Area -->
            <div style="
                flex: 1;
                padding: 32px;
                display: flex;
                gap: 32px;
                overflow-y: auto;
            ">
                <!-- Sidebar -->
                <div style="
                    min-width: 280px;
                    background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
                    padding: 24px;
                    border-radius: 16px;
                    border: 1px solid rgba(102, 126, 234, 0.3);
                    height: fit-content;
                ">
                    <div style="text-align: center; margin-bottom: 24px;">
                        <div id="account-avatar" style="
                            width: 120px;
                            height: 120px;
                            border-radius: 50%;
                            background: rgba(255, 255, 255, 0.1);
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            margin: 0 auto 16px;
                            font-size: 3em;
                            border: 4px solid rgba(102, 126, 234, 0.6);
                            overflow: hidden;
                        ">üë§</div>
                        <h3 id="account-sidebar-name" style="
                            margin: 0 0 8px 0;
                            font-size: 1.3em;
                            color: #fff;
                            word-break: break-word;
                        ">Guest Player</h3>
                        <p id="account-sidebar-email" style="
                            margin: 0 0 16px 0;
                            color: #999;
                            font-size: 0.85em;
                            word-break: break-all;
                        ">Session User</p>
                    </div>
                    
                    <div style="border-top: 1px solid rgba(255, 255, 255, 0.1); padding-top: 16px;">
                        <div style="margin-bottom: 16px;">
                            <p style="color: #999; font-size: 0.85em; margin: 0 0 4px 0;">Registered</p>
                            <p id="account-sidebar-date" style="color: #4ecdc4; font-weight: 600; margin: 0;">Not registered</p>
                        </div>
                        <div style="margin-bottom: 16px;">
                            <p style="color: #999; font-size: 0.85em; margin: 0 0 4px 0;">Member Level</p>
                            <p id="account-member-level" style="color: #ffd700; font-weight: 600; margin: 0;">Bronze</p>
                        </div>
                        <div>
                            <p style="color: #999; font-size: 0.85em; margin: 0 0 4px 0;">Total Games</p>
                            <p id="account-total-games" style="color: #4ecdc4; font-weight: 600; margin: 0; font-size: 1.3em;">0</p>
                        </div>
                    </div>
                </div>

                <!-- Main Tab Content -->
                <div style="flex: 1; overflow-y: auto;">
                    
                    <!-- OVERVIEW TAB -->
                    <div id="account-tab-overview" class="account-tab-content" style="display: block;">
                        <h3 style="color: #667eea; margin-top: 0; margin-bottom: 24px; font-size: 1.4em;">Profile & Quick Stats</h3>
                        
                        <!-- Profile Info -->
                        <div style="
                            background: rgba(78, 205, 196, 0.1);
                            padding: 20px;
                            border-radius: 12px;
                            border-left: 4px solid #4ecdc4;
                            margin-bottom: 24px;
                        ">
                            <p style="color: #aaa; margin: 8px 0;"><strong style="color: #4ecdc4;">Username:</strong> <span id="account-username">Loading...</span></p>
                            <p style="color: #aaa; margin: 8px 0;"><strong style="color: #4ecdc4;">Email:</strong> <span id="account-email">Loading...</span></p>
                        </div>

                        <!-- Quick Stats Grid -->
                        <div style="margin-bottom: 24px;">
                            <h4 style="color: #999; margin: 0 0 16px 0; font-size: 0.95em; text-transform: uppercase; letter-spacing: 1px;">Game Record</h4>
                            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 12px;">
                                <div style="
                                    background: linear-gradient(135deg, rgba(38, 222, 129, 0.1) 0%, rgba(38, 222, 129, 0.05) 100%);
                                    padding: 18px;
                                    border-radius: 10px;
                                    border: 1px solid rgba(38, 222, 129, 0.3);
                                    text-align: center;
                                ">
                                    <div style="color: #26de81; font-size: 2em; font-weight: bold;" id="account-wins">0</div>
                                    <div style="color: #999; font-size: 0.85em; margin-top: 6px;">Wins</div>
                                </div>
                                <div style="
                                    background: linear-gradient(135deg, rgba(255, 107, 107, 0.1) 0%, rgba(255, 107, 107, 0.05) 100%);
                                    padding: 18px;
                                    border-radius: 10px;
                                    border: 1px solid rgba(255, 107, 107, 0.3);
                                    text-align: center;
                                ">
                                    <div style="color: #ff6b6b; font-size: 2em; font-weight: bold;" id="account-losses">0</div>
                                    <div style="color: #999; font-size: 0.85em; margin-top: 6px;">Losses</div>
                                </div>
                                <div style="
                                    background: linear-gradient(135deg, rgba(255, 215, 0, 0.1) 0%, rgba(255, 215, 0, 0.05) 100%);
                                    padding: 18px;
                                    border-radius: 10px;
                                    border: 1px solid rgba(255, 215, 0, 0.3);
                                    text-align: center;
                                ">
                                    <div style="color: #ffd700; font-size: 2em; font-weight: bold;" id="account-winrate">0%</div>
                                    <div style="color: #999; font-size: 0.85em; margin-top: 6px;">Win Rate</div>
                                </div>
                                <div style="
                                    background: linear-gradient(135deg, rgba(78, 205, 196, 0.1) 0%, rgba(78, 205, 196, 0.05) 100%);
                                    padding: 18px;
                                    border-radius: 10px;
                                    border: 1px solid rgba(78, 205, 196, 0.3);
                                    text-align: center;
                                ">
                                    <div style="color: #4ecdc4; font-size: 2em; font-weight: bold;" id="account-games">0</div>
                                    <div style="color: #999; font-size: 0.85em; margin-top: 6px;">Total</div>
                                </div>
                            </div>
                        </div>

                        <!-- Account Activity -->
                        <div style="
                            background: rgba(165, 94, 234, 0.1);
                            padding: 20px;
                            border-radius: 12px;
                            border-left: 4px solid #a55eea;
                            margin-bottom: 24px;
                        ">
                            <h4 style="color: #a55eea; margin: 0 0 12px 0;">üìÖ Activity</h4>
                            <p style="color: #aaa; margin: 8px 0;"><strong style="color: #a55eea;">Last Login:</strong> <span id="account-last-login">Never</span></p>
                            <p style="color: #aaa; margin: 8px 0;"><strong style="color: #a55eea;">Saved Games:</strong> <span id="account-saved-games">0</span></p>
                            <p style="color: #aaa; margin: 8px 0;"><strong style="color: #a55eea;">Total Moves Made:</strong> <span id="account-total-moves">0</span></p>
                            <p style="color: #aaa; margin: 8px 0;"><strong style="color: #a55eea;">Pieces Captured:</strong> <span id="account-total-captures">0</span></p>
                        </div>

                        <!-- Delete Account -->
                        <button onclick="deleteAccount()" style="
                            width: 100%;
                            background: linear-gradient(135deg, #ff6b6b, #ff8a8a);
                            color: white;
                            border: none;
                            padding: 14px 24px;
                            border-radius: 10px;
                            font-weight: 700;
                            font-size: 0.95em;
                            cursor: pointer;
                            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
                            transition: all 0.3s ease;
                        " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(255, 107, 107, 0.5)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(255, 107, 107, 0.3)'">
                            üóëÔ∏è Delete Account
                        </button>
                    </div>

                    <!-- ANALYTICS TAB -->
                    <div id="account-tab-analytics" class="account-tab-content" style="display: none;">
                        <h3 style="color: #667eea; margin-top: 0; margin-bottom: 24px; font-size: 1.4em;">Performance Analytics</h3>
                        
                        <!-- Win/Loss Trend -->
                        <div style="
                            background: rgba(102, 126, 234, 0.1);
                            padding: 20px;
                            border-radius: 12px;
                            border-left: 4px solid #667eea;
                            margin-bottom: 24px;
                        ">
                            <h4 style="color: #667eea; margin: 0 0 16px 0;">üéØ Performance</h4>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
                                <div>
                                    <p style="color: #999; font-size: 0.9em; margin: 0 0 8px 0;">Avg Moves per Game</p>
                                    <p style="color: #667eea; font-size: 1.6em; font-weight: bold; margin: 0;" id="account-avg-moves">0</p>
                                </div>
                                <div>
                                    <p style="color: #999; font-size: 0.9em; margin: 0 0 8px 0;">Fastest Win</p>
                                    <p style="color: #667eea; font-size: 1.6em; font-weight: bold; margin: 0;" id="account-fastest-win">‚Äî</p>
                                </div>
                            </div>
                        </div>

                        <!-- Piece Performance -->
                        <div style="
                            background: rgba(78, 205, 196, 0.1);
                            padding: 20px;
                            border-radius: 12px;
                            border-left: 4px solid #4ecdc4;
                            margin-bottom: 24px;
                        ">
                            <h4 style="color: #4ecdc4; margin: 0 0 16px 0;">‚ôüÔ∏è Piece Usage</h4>
                            <div style="overflow-x: auto;">
                                <table style="width: 100%; border-collapse: collapse;">
                                    <thead style="border-bottom: 2px solid #4ecdc4;">
                                        <tr style="color: #999; font-size: 0.9em;">
                                            <th style="text-align: left; padding: 12px 8px;">Piece</th>
                                            <th style="text-align: center; padding: 12px 8px;">Captures</th>
                                            <th style="text-align: center; padding: 12px 8px;">Survived</th>
                                            <th style="text-align: center; padding: 12px 8px;">Lost</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr style="border-bottom: 1px solid rgba(78, 205, 196, 0.2); color: #ccc; font-size: 0.95em;">
                                            <td style="padding: 12px 8px;">üü¶ Square</td>
                                            <td style="text-align: center; padding: 12px 8px;" id="piece-square-captures">0</td>
                                            <td style="text-align: center; padding: 12px 8px;" id="piece-square-survived">0</td>
                                            <td style="text-align: center; padding: 12px 8px;" id="piece-square-lost">0</td>
                                        </tr>
                                        <tr style="border-bottom: 1px solid rgba(78, 205, 196, 0.2); color: #ccc; font-size: 0.95em;">
                                            <td style="padding: 12px 8px;">üî∫ Triangle</td>
                                            <td style="text-align: center; padding: 12px 8px;" id="piece-triangle-captures">0</td>
                                            <td style="text-align: center; padding: 12px 8px;" id="piece-triangle-survived">0</td>
                                            <td style="text-align: center; padding: 12px 8px;" id="piece-triangle-lost">0</td>
                                        </tr>
                                        <tr style="border-bottom: 1px solid rgba(78, 205, 196, 0.2); color: #ccc; font-size: 0.95em;">
                                            <td style="padding: 12px 8px;">‚ô¶Ô∏è Rhombus</td>
                                            <td style="text-align: center; padding: 12px 8px;" id="piece-rhombus-captures">0</td>
                                            <td style="text-align: center; padding: 12px 8px;" id="piece-rhombus-survived">0</td>
                                            <td style="text-align: center; padding: 12px 8px;" id="piece-rhombus-lost">0</td>
                                        </tr>
                                        <tr style="border-bottom: 1px solid rgba(78, 205, 196, 0.2); color: #ccc; font-size: 0.95em;">
                                            <td style="padding: 12px 8px;">‚óè Circle</td>
                                            <td style="text-align: center; padding: 12px 8px;" id="piece-circle-captures">0</td>
                                            <td style="text-align: center; padding: 12px 8px;" id="piece-circle-survived">0</td>
                                            <td style="text-align: center; padding: 12px 8px;" id="piece-circle-lost">0</td>
                                        </tr>
                                        <tr style="color: #ccc; font-size: 0.95em;">
                                            <td style="padding: 12px 8px;">‚¨° Hexagon</td>
                                            <td style="text-align: center; padding: 12px 8px;" id="piece-hexagon-captures">0</td>
                                            <td style="text-align: center; padding: 12px 8px;" id="piece-hexagon-survived">0</td>
                                            <td style="text-align: center; padding: 12px 8px;" id="piece-hexagon-lost">0</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>

                        <!-- Personal Records -->
                        <div style="
                            background: rgba(165, 94, 234, 0.1);
                            padding: 20px;
                            border-radius: 12px;
                            border-left: 4px solid #a55eea;
                        ">
                            <h4 style="color: #a55eea; margin: 0 0 16px 0;">üèÖ Personal Records</h4>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
                                <div>
                                    <p style="color: #999; font-size: 0.9em; margin: 0 0 8px 0;">Win Streak</p>
                                    <p style="color: #a55eea; font-size: 1.6em; font-weight: bold; margin: 0;" id="account-win-streak">0</p>
                                </div>
                                <div>
                                    <p style="color: #999; font-size: 0.9em; margin: 0 0 8px 0;">Total Captures</p>
                                    <p style="color: #a55eea; font-size: 1.6em; font-weight: bold; margin: 0;" id="account-captures">0</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- VARIATIONS TAB -->
                    <div id="account-tab-variations" class="account-tab-content" style="display: none;">
                        <h3 style="color: #667eea; margin-top: 0; margin-bottom: 24px; font-size: 1.4em;">Game Variations</h3>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                            <!-- Standard Romgon -->
                            <div style="
                                background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(102, 126, 234, 0.05) 100%);
                                padding: 24px;
                                border-radius: 14px;
                                border: 2px solid #667eea;
                                cursor: pointer;
                                transition: all 0.3s ease;
                            " onmouseover="this.style.transform='translateY(-4px)'; this.style.boxShadow='0 8px 20px rgba(102, 126, 234, 0.3)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                                <h4 style="color: #667eea; margin: 0 0 12px 0; font-size: 1.3em;">üéÆ Standard Romgon</h4>
                                <p style="color: #999; margin: 0 0 16px 0; font-size: 0.95em;">Classic ruleset. All pieces defend the base. Compete at the highest level.</p>
                                <ul style="color: #aaa; font-size: 0.9em; margin: 12px 0; padding-left: 20px;">
                                    <li>All 7 pieces per player</li>
                                    <li>Bases defend equally</li>
                                    <li>Standard capture rules</li>
                                </ul>
                                <button onclick="startGameWithVariant('standard')" style="
                                    width: 100%;
                                    background: linear-gradient(135deg, #667eea, #764ba2);
                                    color: white;
                                    border: none;
                                    padding: 12px 20px;
                                    border-radius: 8px;
                                    font-weight: 600;
                                    cursor: pointer;
                                    transition: all 0.3s ease;
                                    margin-top: 16px;
                                " onmouseover="this.style.transform='scale(1.02)'" onmouseout="this.style.transform='scale(1)'">Play Now</button>
                            </div>

                            <!-- Shapes Defense Variant -->
                            <div style="
                                background: linear-gradient(135deg, rgba(255, 107, 107, 0.1) 0%, rgba(255, 107, 107, 0.05) 100%);
                                padding: 24px;
                                border-radius: 14px;
                                border: 2px solid #ff6b6b;
                                cursor: pointer;
                                transition: all 0.3s ease;
                            " onmouseover="this.style.transform='translateY(-4px)'; this.style.boxShadow='0 8px 20px rgba(255, 107, 107, 0.3)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                                <h4 style="color: #ff6b6b; margin: 0 0 12px 0; font-size: 1.3em;">üõ°Ô∏è Shapes Defense</h4>
                                <p style="color: #999; margin: 0 0 16px 0; font-size: 0.95em;">Stronger piece-based defense. All pieces can defend your base against invaders.</p>
                                <ul style="color: #aaa; font-size: 0.9em; margin: 12px 0; padding-left: 20px;">
                                    <li>Enhanced defense mechanics</li>
                                    <li>Piece-based fortress building</li>
                                    <li>Strategic depth</li>
                                </ul>
                                <button onclick="startGameWithVariant('shapeDefense')" style="
                                    width: 100%;
                                    background: linear-gradient(135deg, #ff6b6b, #ff8a8a);
                                    color: white;
                                    border: none;
                                    padding: 12px 20px;
                                    border-radius: 8px;
                                    font-weight: 600;
                                    cursor: pointer;
                                    transition: all 0.3s ease;
                                    margin-top: 16px;
                                " onmouseover="this.style.transform='scale(1.02)'" onmouseout="this.style.transform='scale(1)'">Play Now</button>
                            </div>

                            <!-- Rhombus Original -->
                            <div style="
                                background: linear-gradient(135deg, rgba(4, 206, 180, 0.1) 0%, rgba(4, 206, 180, 0.05) 100%);
                                padding: 24px;
                                border-radius: 14px;
                                border: 2px solid #04ceb4;
                                cursor: pointer;
                                transition: all 0.3s ease;
                            " onmouseover="this.style.transform='translateY(-4px)'; this.style.boxShadow='0 8px 20px rgba(4, 206, 180, 0.3)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                                <h4 style="color: #04ceb4; margin: 0 0 12px 0; font-size: 1.3em;">‚ô¶Ô∏è Rhombus Original</h4>
                                <p style="color: #999; margin: 0 0 16px 0; font-size: 0.95em;">Only rhombuses can defend. Fast-paced endgames. For master-level play.</p>
                                <ul style="color: #aaa; font-size: 0.9em; margin: 12px 0; padding-left: 20px;">
                                    <li>Rhombus-only defense</li>
                                    <li>Intense endgames</li>
                                    <li>High-risk gameplay</li>
                                </ul>
                                <button onclick="startGameWithVariant('rhombusOriginal')" style="
                                    width: 100%;
                                    background: linear-gradient(135deg, #04ceb4, #12d8d8);
                                    color: white;
                                    border: none;
                                    padding: 12px 20px;
                                    border-radius: 8px;
                                    font-weight: 600;
                                    cursor: pointer;
                                    transition: all 0.3s ease;
                                    margin-top: 16px;
                                " onmouseover="this.style.transform='scale(1.02)'" onmouseout="this.style.transform='scale(1)'">Play Now</button>
                            </div>

                            <!-- Fortress Variant -->
                            <div style="
                                background: linear-gradient(135deg, rgba(255, 215, 0, 0.1) 0%, rgba(255, 215, 0, 0.05) 100%);
                                padding: 24px;
                                border-radius: 14px;
                                border: 2px solid #ffd700;
                                cursor: pointer;
                                transition: all 0.3s ease;
                            " onmouseover="this.style.transform='translateY(-4px)'; this.style.boxShadow='0 8px 20px rgba(255, 215, 0, 0.3)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                                <h4 style="color: #ffd700; margin: 0 0 12px 0; font-size: 1.3em;">üè∞ Fortress</h4>
                                <p style="color: #999; margin: 0 0 16px 0; font-size: 0.95em;">Enhanced defense with fortress mechanics. Build and maintain impenetrable bases.</p>
                                <ul style="color: #aaa; font-size: 0.9em; margin: 12px 0; padding-left: 20px;">
                                    <li>Fortress zones</li>
                                    <li>Enhanced defenses</li>
                                    <li>Longer games</li>
                                </ul>
                                <button onclick="startGameWithVariant('fortress')" style="
                                    width: 100%;
                                    background: linear-gradient(135deg, #ffd700, #ffed4e);
                                    color: #1a1a1a;
                                    border: none;
                                    padding: 12px 20px;
                                    border-radius: 8px;
                                    font-weight: 600;
                                    cursor: pointer;
                                    transition: all 0.3s ease;
                                    margin-top: 16px;
                                " onmouseover="this.style.transform='scale(1.02)'" onmouseout="this.style.transform='scale(1)'">Play Now</button>
                            </div>
                        </div>
                    </div>

                    <!-- ACHIEVEMENTS TAB -->
                    <div id="account-tab-achievements" class="account-tab-content" style="display: none;">
                        <h3 style="color: #667eea; margin-top: 0; margin-bottom: 24px; font-size: 1.4em;">üèÜ Achievements & Badges</h3>
                        
                        <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 16px;">
                            <div style="
                                background: rgba(102, 126, 234, 0.1);
                                padding: 20px;
                                border-radius: 12px;
                                text-align: center;
                                border: 2px solid #667eea;
                                opacity: 0.7;
                            ">
                                <div style="font-size: 2.5em; margin-bottom: 8px;">üî∞</div>
                                <p style="color: #999; font-size: 0.85em; margin: 0;">First Game</p>
                                <p style="color: #667eea; font-size: 0.8em; margin: 8px 0 0 0;">Locked</p>
                            </div>
                            <div style="
                                background: rgba(38, 222, 129, 0.1);
                                padding: 20px;
                                border-radius: 12px;
                                text-align: center;
                                border: 2px solid #26de81;
                            ">
                                <div style="font-size: 2.5em; margin-bottom: 8px;">ü•á</div>
                                <p style="color: #999; font-size: 0.85em; margin: 0;">First Win</p>
                                <p style="color: #26de81; font-size: 0.8em; margin: 8px 0 0 0;">Unlocked</p>
                            </div>
                            <div style="
                                background: rgba(255, 215, 0, 0.1);
                                padding: 20px;
                                border-radius: 12px;
                                text-align: center;
                                border: 2px solid #ffd700;
                                opacity: 0.7;
                            ">
                                <div style="font-size: 2.5em; margin-bottom: 8px;">‚≠ê</div>
                                <p style="color: #999; font-size: 0.85em; margin: 0;">10-Win Streak</p>
                                <p style="color: #ffd700; font-size: 0.8em; margin: 8px 0 0 0;">Locked</p>
                            </div>
                            <div style="
                                background: rgba(78, 205, 196, 0.1);
                                padding: 20px;
                                border-radius: 12px;
                                text-align: center;
                                border: 2px solid #4ecdc4;
                                opacity: 0.7;
                            ">
                                <div style="font-size: 2.5em; margin-bottom: 8px;">üéØ</div>
                                <p style="color: #999; font-size: 0.85em; margin: 0;">Master Tactician</p>
                                <p style="color: #4ecdc4; font-size: 0.8em; margin: 8px 0 0 0;">Locked</p>
                            </div>
                            <div style="
                                background: rgba(165, 94, 234, 0.1);
                                padding: 20px;
                                border-radius: 12px;
                                text-align: center;
                                border: 2px solid #a55eea;
                                opacity: 0.7;
                            ">
                                <div style="font-size: 2.5em; margin-bottom: 8px;">üëë</div>
                                <p style="color: #999; font-size: 0.85em; margin: 0;">Champion</p>
                                <p style="color: #a55eea; font-size: 0.8em; margin: 8px 0 0 0;">Locked</p>
                            </div>
                        </div>

                        <div style="
                            margin-top: 32px;
                            background: rgba(102, 126, 234, 0.1);
                            padding: 24px;
                            border-radius: 12px;
                            border-left: 4px solid #667eea;
                        ">
                            <h4 style="color: #667eea; margin: 0 0 16px 0;">üìà Progress</h4>
                            <p style="color: #aaa; margin: 0 0 12px 0;">1 of 5 achievements unlocked (20%)</p>
                            <div style="
                                background: rgba(0, 0, 0, 0.3);
                                height: 8px;
                                border-radius: 4px;
                                overflow: hidden;
                            ">
                                <div style="
                                    background: linear-gradient(90deg, #667eea, #764ba2);
                                    height: 100%;
                                    width: 20%;
                                    transition: width 0.3s ease;
                                "></div>
                            </div>
                        </div>
                    </div>

                    <!-- RATINGS TAB -->
                    <div id="account-tab-ratings" class="account-tab-content" style="display: none;">
                        <h3 style="color: #f39c12; margin-top: 0; margin-bottom: 24px; font-size: 1.4em;">‚≠ê Rating & Skill Progression</h3>
                        
                        <!-- Current Rating Section -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 32px;">
                            <!-- Rating Card -->
                            <div style="
                                background: linear-gradient(135deg, rgba(243, 156, 18, 0.1), rgba(41, 128, 185, 0.1));
                                padding: 24px;
                                border-radius: 12px;
                                border: 2px solid #f39c12;
                            ">
                                <p style="color: #999; font-size: 0.85em; margin: 0 0 12px 0; font-weight: 600;">CURRENT RATING</p>
                                <div style="font-size: 2.5em; font-weight: bold; color: #f39c12; margin-bottom: 8px;" id="hub-current-rating">1600</div>
                                <div style="font-size: 1.1em; color: #4ecdc4; font-weight: bold;" id="hub-rating-tier">ü•à Intermediate</div>
                            </div>

                            <!-- Stats Card -->
                            <div style="
                                background: linear-gradient(135deg, rgba(39, 174, 96, 0.1), rgba(78, 205, 196, 0.1));
                                padding: 24px;
                                border-radius: 12px;
                                border: 2px solid #27ae60;
                            ">
                                <p style="color: #999; font-size: 0.85em; margin: 0 0 12px 0; font-weight: 600;">RATING STATS</p>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                                    <div>
                                        <p style="color: #999; font-size: 0.8em; margin: 0;">Games</p>
                                        <p style="color: #27ae60; font-size: 1.5em; font-weight: bold; margin: 0;" id="hub-rating-games">0</p>
                                    </div>
                                    <div>
                                        <p style="color: #999; font-size: 0.8em; margin: 0;">Changes</p>
                                        <p style="color: #4ecdc4; font-size: 1.5em; font-weight: bold; margin: 0;" id="hub-rating-changes">0</p>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Rating Tier Guide -->
                        <div style="
                            background: rgba(243, 156, 18, 0.1);
                            padding: 24px;
                            border-radius: 12px;
                            border-left: 4px solid #f39c12;
                            margin-bottom: 32px;
                        ">
                            <h4 style="color: #f39c12; margin: 0 0 16px 0; font-size: 1.1em;">üìä Rating Tiers</h4>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px;">
                                <div style="background: rgba(255, 215, 0, 0.1); padding: 12px; border-radius: 8px; border-left: 3px solid #FFD700;">
                                    <p style="color: #FFD700; font-weight: bold; margin: 0; font-size: 0.9em;">üëë Grandmaster</p>
                                    <p style="color: #999; margin: 0; font-size: 0.8em;">2400+</p>
                                </div>
                                <div style="background: rgba(255, 105, 180, 0.1); padding: 12px; border-radius: 8px; border-left: 3px solid #FF69B4;">
                                    <p style="color: #FF69B4; font-weight: bold; margin: 0; font-size: 0.9em;">üèÜ Master</p>
                                    <p style="color: #999; margin: 0; font-size: 0.8em;">2200-2399</p>
                                </div>
                                <div style="background: rgba(255, 107, 107, 0.1); padding: 12px; border-radius: 8px; border-left: 3px solid #FF6B6B;">
                                    <p style="color: #FF6B6B; font-weight: bold; margin: 0; font-size: 0.9em;">‚≠ê Expert</p>
                                    <p style="color: #999; margin: 0; font-size: 0.8em;">2000-2199</p>
                                </div>
                                <div style="background: rgba(243, 156, 18, 0.1); padding: 12px; border-radius: 8px; border-left: 3px solid #F39C12;">
                                    <p style="color: #F39C12; font-weight: bold; margin: 0; font-size: 0.9em;">ü•á Advanced</p>
                                    <p style="color: #999; margin: 0; font-size: 0.8em;">1800-1999</p>
                                </div>
                                <div style="background: rgba(78, 205, 196, 0.1); padding: 12px; border-radius: 8px; border-left: 3px solid #4ecdc4;">
                                    <p style="color: #4ecdc4; font-weight: bold; margin: 0; font-size: 0.9em;">ü•à Intermediate</p>
                                    <p style="color: #999; margin: 0; font-size: 0.8em;">1600-1799</p>
                                </div>
                                <div style="background: rgba(39, 174, 96, 0.1); padding: 12px; border-radius: 8px; border-left: 3px solid #27ae60;">
                                    <p style="color: #27ae60; font-weight: bold; margin: 0; font-size: 0.9em;">ü•â Beginner</p>
                                    <p style="color: #999; margin: 0; font-size: 0.8em;">1400-1599</p>
                                </div>
                            </div>
                        </div>

                        <!-- Recent Rating Changes -->
                        <div style="
                            background: rgba(78, 205, 196, 0.1);
                            padding: 24px;
                            border-radius: 12px;
                            border-left: 4px solid #4ecdc4;
                        ">
                            <h4 style="color: #4ecdc4; margin: 0 0 16px 0; font-size: 1.1em;">üìà Recent Rating Changes</h4>
                            <div id="hub-rating-history" style="display: flex; flex-direction: column; gap: 12px; max-height: 300px; overflow-y: auto;">
                                <p style="color: #999; text-align: center; padding: 20px;">No rating changes yet. Play a game to start!</p>
                            </div>
                        </div>
                    </div>
                    
                    <!-- SETTINGS TAB -->
                    <div id="account-tab-settings" class="account-tab-content" style="display: none;">
                        <h3 style="color: #667eea; margin-top: 0; margin-bottom: 24px; font-size: 1.4em;">‚öôÔ∏è Profile Settings</h3>
                        
                        <!-- Display Name Section -->
                        <div style="
                            background: rgba(102, 126, 234, 0.1);
                            padding: 24px;
                            border-radius: 12px;
                            border-left: 4px solid #667eea;
                            margin-bottom: 24px;
                        ">
                            <h4 style="color: #667eea; margin: 0 0 16px 0; font-size: 1.1em;">‚úèÔ∏è Display Name</h4>
                            <div style="display: flex; gap: 12px; align-items: flex-start;">
                                <input type="text" id="hub-username-input" placeholder="Enter new username" style="
                                    flex: 1;
                                    padding: 12px 16px;
                                    background: #1a1e26;
                                    border: 2px solid #667eea;
                                    border-radius: 8px;
                                    color: #fff;
                                    font-size: 1em;
                                " />
                                <button onclick="saveUsername()" style="
                                    background: linear-gradient(135deg, #667eea, #764ba2);
                                    color: white;
                                    border: none;
                                    padding: 12px 24px;
                                    border-radius: 8px;
                                    cursor: pointer;
                                    font-weight: 600;
                                    transition: all 0.3s;
                                " onmouseover="this.style.transform='translateY(-2px)'" onmouseout="this.style.transform='translateY(0)'">
                                    Save
                                </button>
                            </div>
                            <p style="color: #999; font-size: 0.85em; margin: 8px 0 0 0;">This is how other players will see you</p>
                        </div>
                        
                        <!-- Avatar Selection -->
                        <div style="
                            background: rgba(78, 205, 196, 0.1);
                            padding: 24px;
                            border-radius: 12px;
                            border-left: 4px solid #4ecdc4;
                            margin-bottom: 24px;
                        ">
                            <h4 style="color: #4ecdc4; margin: 0 0 16px 0; font-size: 1.1em;">üé® Avatar</h4>
                            <div id="avatar-grid" style="
                                display: grid;
                                grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
                                gap: 12px;
                                margin-bottom: 16px;
                            ">
                                <!-- Avatar options will be populated here -->
                            </div>
                            <p style="color: #999; font-size: 0.85em; margin: 0;">Click an avatar to select it</p>
                        </div>
                        
                        <!-- Badge Selection -->
                        <div style="
                            background: rgba(255, 215, 0, 0.1);
                            padding: 24px;
                            border-radius: 12px;
                            border-left: 4px solid #ffd700;
                            margin-bottom: 24px;
                        ">
                            <h4 style="color: #ffd700; margin: 0 0 16px 0; font-size: 1.1em;">üèÖ Badge</h4>
                            <div id="badge-grid" style="
                                display: grid;
                                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
                                gap: 12px;
                                margin-bottom: 16px;
                            ">
                                <!-- Badge options will be populated here -->
                            </div>
                            <p style="color: #999; font-size: 0.85em; margin: 0;">Badges are earned through achievements and milestones</p>
                        </div>
                        
                        <!-- Account Actions -->
                        <div style="
                            background: rgba(255, 107, 107, 0.1);
                            padding: 24px;
                            border-radius: 12px;
                            border-left: 4px solid #ff6b6b;
                        ">
                            <h4 style="color: #ff6b6b; margin: 0 0 16px 0; font-size: 1.1em;">‚ö†Ô∏è Account Actions</h4>
                            <button onclick="confirmDeleteAccount()" style="
                                background: transparent;
                                color: #ff6b6b;
                                border: 2px solid #ff6b6b;
                                padding: 12px 24px;
                                border-radius: 8px;
                                cursor: pointer;
                                font-weight: 600;
                                transition: all 0.3s;
                            " onmouseover="this.style.background='rgba(255, 107, 107, 0.2)'" onmouseout="this.style.background='transparent'">
                                Delete Account
                            </button>
                            <p style="color: #999; font-size: 0.85em; margin: 8px 0 0 0;">This action cannot be undone</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" style="
        display: none;
        position: fixed;
        top: 0; left: 0; width: 100vw; height: 100vh;
        background: rgba(20, 24, 32, 0.98);
        z-index: 3001;
        overflow-y: auto;
        padding: 0; margin: 0;
        backdrop-filter: blur(4px);
    ">
        <div style="
            max-width: 600px;
            margin: 60px auto;
            background: #23272e;
            border-radius: 18px;
            box-shadow: 0 8px 40px #000a;
            padding: 40px 36px;
            color: #fff;
            position: relative;
        ">
            <button onclick="hideSettingsModal()" style="
                position: absolute; top: 18px; right: 18px;
                background: #a55eea; color: #23272e;
                border: none; border-radius: 8px;
                font-size: 1.2em; font-weight: bold;
                padding: 6px 16px; cursor: pointer; z-index: 10;
                transition: all 0.3s ease;
            " onmouseover="this.style.transform='scale(1.1)'" onmouseout="this.style.transform='scale(1)'">‚úñÔ∏è</button>
            
            <h2 style="color: #a55eea; margin-top: 0; text-align: center; font-size: 1.8em;">‚öôÔ∏è Preferences</h2>
            
            <!-- Tab Navigation -->
            <div style="display: flex; gap: 8px; margin: 20px 0; border-bottom: 2px solid #333; flex-wrap: wrap;">
                <button onclick="switchPrefsTab('general')" id="tab-general" class="pref-tab active-tab" style="
                    background: transparent; border: none; color: #fff; padding: 12px 20px;
                    cursor: pointer; font-weight: 600; border-bottom: 3px solid #a55eea;
                    transition: all 0.3s;
                ">üéÆ General</button>
                <button onclick="switchPrefsTab('gameplay')" id="tab-gameplay" class="pref-tab" style="
                    background: transparent; border: none; color: #888; padding: 12px 20px;
                    cursor: pointer; font-weight: 600; border-bottom: 3px solid transparent;
                    transition: all 0.3s;
                ">‚ôüÔ∏è Gameplay</button>
                <button onclick="switchPrefsTab('lobby')" id="tab-lobby" class="pref-tab" style="
                    background: transparent; border: none; color: #888; padding: 12px 20px;
                    cursor: pointer; font-weight: 600; border-bottom: 3px solid transparent;
                    transition: all 0.3s;
                ">üè† Lobby</button>
                <button onclick="switchPrefsTab('custom-games')" id="tab-custom-games" class="pref-tab" style="
                    background: transparent; border: none; color: #888; padding: 12px 20px;
                    cursor: pointer; font-weight: 600; border-bottom: 3px solid transparent;
                    transition: all 0.3s;
                ">üé® Custom Games</button>
                <button onclick="switchPrefsTab('game-creator')" id="tab-game-creator" class="pref-tab" style="
                    background: transparent; border: none; color: #888; padding: 12px 20px;
                    cursor: pointer; font-weight: 600; border-bottom: 3px solid transparent;
                    transition: all 0.3s;
                ">üõ†Ô∏è Game Creator</button>
                <button onclick="switchPrefsTab('engine')" id="tab-engine" class="pref-tab" style="
                    background: transparent; border: none; color: #888; padding: 12px 20px;
                    cursor: pointer; font-weight: 600; border-bottom: 3px solid transparent;
                    transition: all 0.3s;
                ">‚ö° Engine</button>
                <button onclick="switchPrefsTab('account')" id="tab-account" class="pref-tab" style="
                    background: transparent; border: none; color: #888; padding: 12px 20px;
                    cursor: pointer; font-weight: 600; border-bottom: 3px solid transparent;
                    transition: all 0.3s;
                ">üë§ Account</button>
                <button onclick="switchPrefsTab('advanced')" id="tab-advanced" class="pref-tab" style="
                    background: transparent; border: none; color: #888; padding: 12px 20px;
                    cursor: pointer; font-weight: 600; border-bottom: 3px solid transparent;
                    transition: all 0.3s;
                ">üîß Advanced</button>
            </div>
            
            <form id="settings-form" onsubmit="handleSettingsSave(event)" style="margin-top: 30px;">
                
                <!-- GENERAL TAB -->
                <div id="pref-panel-general" class="pref-panel" style="display: flex; flex-direction: column; gap: 24px;">
                    <h3 style="color: #4ecdc4; margin: 0 0 12px 0; font-size: 1.2em;">üé® Appearance</h3>
                    
                    <div>
                        <label style="display: block; color: #4ecdc4; font-weight: 600; margin-bottom: 8px; font-size: 0.95em;">Theme</label>
                        <select id="settings-theme" style="
                            width: 100%; padding: 10px 12px; background: #1a1e26;
                            border: 2px solid #a55eea; border-radius: 8px; color: #fff;
                            font-size: 1em; cursor: pointer; transition: all 0.3s ease;
                        ">
                            <option value="dark">üåô Dark Mode (Default)</option>
                            <option value="light">‚òÄÔ∏è Light Mode</option>
                            <option value="wooden">ü™µ Wooden Theme</option>
                            <option value="neon">üåà Neon Theme</option>
                        </select>
                    </div>
                    
                    <div>
                        <label style="display: block; color: #4ecdc4; font-weight: 600; margin-bottom: 12px; font-size: 0.95em;">Board Zoom</label>
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <input type="range" id="settings-zoom" min="0.5" max="2" step="0.1" value="1" style="flex: 1; cursor: pointer;">
                            <span id="zoom-value" style="color: #ffd700; font-weight: bold; min-width: 50px;">100%</span>
                        </div>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 0;">Adjust board scale for comfort</p>
                    </div>
                    
                    <h3 style="color: #4ecdc4; margin: 24px 0 12px 0; font-size: 1.2em;">üîä Audio & Notifications</h3>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-audio" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Enable Audio</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Sound effects and music</p>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-move-sounds" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Move Sounds</span>
                        </label>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-capture-sounds" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Capture Sounds</span>
                        </label>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-notifications" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Desktop Notifications</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Get notified when it's your turn</p>
                    </div>
                </div>
                
                <!-- GAMEPLAY TAB -->
                <div id="pref-panel-gameplay" class="pref-panel" style="display: none; flex-direction: column; gap: 24px;">
                    <h3 style="color: #4ecdc4; margin: 0 0 12px 0; font-size: 1.2em;">üéØ Move Assistance</h3>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-show-legal-moves" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Show Legal Moves</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Highlight valid moves when selecting piece</p>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-show-attack-moves" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Show Attack Moves</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Highlight attack moves with red indicators</p>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-show-threatened" style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Show Threatened Pieces</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Highlight pieces under attack</p>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-show-last-move" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Highlight Last Move</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Show opponent's previous move</p>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-confirm-moves" style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Confirm Dangerous Moves</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Ask before risky moves (sacrifice, blunder)</p>
                    </div>
                    
                    <h3 style="color: #4ecdc4; margin: 24px 0 12px 0; font-size: 1.2em;">‚öôÔ∏è Input Controls</h3>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-drag-drop" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Enable Drag & Drop</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Drag pieces to move them</p>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-click-move" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Enable Click-to-Move</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Click piece then destination hex</p>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-keyboard-navigation" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Keyboard Navigation</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Use arrow keys and Enter to move</p>
                    </div>
                    
                    <h3 style="color: #4ecdc4; margin: 24px 0 12px 0; font-size: 1.2em;">‚ôüÔ∏è Game Rules</h3>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-auto-queen" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Auto-Promote to Queen</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Automatically promote rhombus reaching back line</p>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-enforce-legal-moves" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Enforce Legal Moves Only</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Prevent illegal moves (disable for testing)</p>
                    </div>
                    
                    <div>
                        <label style="display: block; color: #4ecdc4; font-weight: 600; margin-bottom: 8px; font-size: 0.95em;">Move Speed Limit</label>
                        <select id="settings-move-speed" style="
                            width: 100%; padding: 10px 12px; background: #1a1e26;
                            border: 2px solid #a55eea; border-radius: 8px; color: #fff;
                            font-size: 1em; cursor: pointer;
                        ">
                            <option value="none">None (instant moves)</option>
                            <option value="250">Fast (0.25s delay)</option>
                            <option value="500" selected>Normal (0.5s delay)</option>
                            <option value="1000">Slow (1s delay)</option>
                        </select>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 0;">Minimum time between moves (prevents accidents)</p>
                    </div>
                    
                    <h3 style="color: #4ecdc4; margin: 24px 0 12px 0; font-size: 1.2em;">üìä Board Display</h3>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-show-coords" style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Show Hex Coordinates</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Display coordinate labels (0-0, 1-2, etc.)</p>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-show-zones" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Show Zone Colors</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Color-code board zones (custom games)</p>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-piece-shadows" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Piece Shadows</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Add drop shadow to pieces for depth</p>
                    </div>
                    
                    <h3 style="color: #4ecdc4; margin: 24px 0 12px 0; font-size: 1.2em;">üìä Analysis & Learning</h3>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-engine-analysis" style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Enable Engine Analysis</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Show position evaluation bar (Coming Soon)</p>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-move-hints" style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Show Move Hints</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Suggest good moves during games</p>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-blunder-warnings" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Warn About Blunders</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Alert when making a bad move</p>
                    </div>
                </div>
                
                <!-- LOBBY TAB -->
                <div id="pref-panel-lobby" class="pref-panel" style="display: none; flex-direction: column; gap: 24px;">
                    <h3 style="color: #4ecdc4; margin: 0 0 12px 0; font-size: 1.2em;">üéÆ Matchmaking</h3>
                    
                    <div>
                        <label style="display: block; color: #4ecdc4; font-weight: 600; margin-bottom: 8px; font-size: 0.95em;">Quick Match Time Control</label>
                        <select id="settings-quickmatch-time" style="
                            width: 100%; padding: 10px 12px; background: #1a1e26;
                            border: 2px solid #a55eea; border-radius: 8px; color: #fff;
                            font-size: 1em; cursor: pointer;
                        ">
                            <option value="1min">‚ö° Bullet (1 min)</option>
                            <option value="3min">üöÄ Blitz (3 min)</option>
                            <option value="5min" selected>‚è±Ô∏è Rapid (5 min)</option>
                            <option value="10min">üéØ Standard (10 min)</option>
                            <option value="30min">‚ôüÔ∏è Classical (30 min)</option>
                            <option value="unlimited">‚àû Unlimited</option>
                        </select>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 0;">Default time for Quick Match</p>
                    </div>
                    
                    <div>
                        <label style="display: block; color: #4ecdc4; font-weight: 600; margin-bottom: 8px; font-size: 0.95em;">Skill Range</label>
                        <select id="settings-skill-range" style="
                            width: 100%; padding: 10px 12px; background: #1a1e26;
                            border: 2px solid #a55eea; border-radius: 8px; color: #fff;
                            font-size: 1em; cursor: pointer;
                        ">
                            <option value="strict">¬±50 rating (strict)</option>
                            <option value="moderate" selected>¬±150 rating (moderate)</option>
                            <option value="wide">¬±300 rating (wide)</option>
                            <option value="any">Any rating</option>
                        </select>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 0;">Match with similar skill level</p>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-auto-accept" style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Auto-Accept Matches</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Automatically accept when match found</p>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-rematch-prompt" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Prompt for Rematch</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Ask after game if you want a rematch</p>
                    </div>
                    
                    <h3 style="color: #4ecdc4; margin: 24px 0 12px 0; font-size: 1.2em;">üë• Social Features</h3>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-show-player-avatars" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Show Player Avatars</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Display profile pictures in lobby</p>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-show-player-count" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Show Online Player Count</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Display number of active players</p>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-lobby-chat" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Enable Lobby Chat</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Show global chat in main lobby</p>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-friend-notifications" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Friend Login Notifications</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Get notified when friends come online</p>
                    </div>
                    
                    <h3 style="color: #4ecdc4; margin: 24px 0 12px 0; font-size: 1.2em;">üé® Lobby Appearance</h3>
                    
                    <div>
                        <label style="display: block; color: #4ecdc4; font-weight: 600; margin-bottom: 8px; font-size: 0.95em;">Game List Sort</label>
                        <select id="settings-game-sort" style="
                            width: 100%; padding: 10px 12px; background: #1a1e26;
                            border: 2px solid #a55eea; border-radius: 8px; color: #fff;
                            font-size: 1em; cursor: pointer;
                        ">
                            <option value="recent">üìÖ Most Recent</option>
                            <option value="rating">‚≠ê Highest Rating</option>
                            <option value="time">‚è±Ô∏è Time Control</option>
                            <option value="players">üë• Most Players</option>
                        </select>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-show-game-previews" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Show Game Previews</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Display board thumbnails in lobby</p>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-compact-lobby" style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Compact Lobby View</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Show more games per screen</p>
                    </div>
                    
                    <h3 style="color: #4ecdc4; margin: 24px 0 12px 0; font-size: 1.2em;">üîî Game Invitations</h3>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-accept-challenges" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Accept Challenges from Anyone</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Allow strangers to invite you</p>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-friends-only" style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Friends Only Mode</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Only accept from friends list</p>
                    </div>
                </div>
                
                <!-- CUSTOM GAMES TAB -->
                <div id="pref-panel-custom-games" class="pref-panel" style="display: none; flex-direction: column; gap: 24px;">
                    <h3 style="color: #4ecdc4; margin: 0 0 12px 0; font-size: 1.2em;">üé® Creator Preferences</h3>
                    
                    <div>
                        <label style="display: block; color: #4ecdc4; font-weight: 600; margin-bottom: 8px; font-size: 0.95em;">Default Board Size</label>
                        <select id="settings-default-board" style="
                            width: 100%; padding: 10px 12px; background: #1a1e26;
                            border: 2px solid #a55eea; border-radius: 8px; color: #fff;
                            font-size: 1em; cursor: pointer;
                        ">
                            <option value="7x7">7√ó7 (Classic)</option>
                            <option value="9x11">9√ó11 (Extended)</option>
                            <option value="11x13">11√ó13 (Medium)</option>
                            <option value="13x15">13√ó15 (Large)</option>
                        </select>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-auto-save" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Auto-Save Games</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Automatically save custom games while creating</p>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-show-grid" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Show Grid in Designer</span>
                        </label>
                    </div>
                    
                    <h3 style="color: #4ecdc4; margin: 24px 0 12px 0; font-size: 1.2em;">ÔøΩ Publishing & Privacy</h3>
                    
                    <div>
                        <label style="display: block; color: #4ecdc4; font-weight: 600; margin-bottom: 8px; font-size: 0.95em;">Default Visibility</label>
                        <select id="settings-game-visibility" style="
                            width: 100%; padding: 10px 12px; background: #1a1e26;
                            border: 2px solid #a55eea; border-radius: 8px; color: #fff;
                            font-size: 1em; cursor: pointer;
                        ">
                            <option value="public">üåç Public (Anyone can play)</option>
                            <option value="unlisted">üîó Unlisted (Only with link)</option>
                            <option value="private">üîí Private (Only you)</option>
                        </select>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-allow-remixes" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Allow Others to Remix</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Let others create variants of your games</p>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-show-creator-name" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Show Creator Name</span>
                        </label>
                    </div>
                </div>
                
                <!-- ACCOUNT TAB -->
                <div id="pref-panel-account" class="pref-panel" style="display: none; flex-direction: column; gap: 24px;">
                    <h3 style="color: #4ecdc4; margin: 0 0 12px 0; font-size: 1.2em;">üë§ Profile Settings</h3>
                    
                    <!-- Player Hub Button -->
                    <div style="
                        background: linear-gradient(135deg, rgba(102, 126, 234, 0.15), rgba(118, 75, 162, 0.15));
                        border: 2px solid rgba(102, 126, 234, 0.4);
                        border-radius: 12px;
                        padding: 20px;
                        text-align: center;
                    ">
                        <h4 style="margin: 0 0 12px 0; color: #667eea; font-size: 1.1em;">üéÆ Player Hub</h4>
                        <p style="color: #aaa; font-size: 0.9em; margin: 0 0 16px 0;">
                            View your complete profile, stats, achievements, and game history
                        </p>
                        <button onclick="hideSettingsModal(); showAccountModal();" style="
                            background: linear-gradient(135deg, #667eea, #764ba2);
                            color: white;
                            border: none;
                            padding: 12px 32px;
                            border-radius: 8px;
                            font-size: 1em;
                            font-weight: 600;
                            cursor: pointer;
                            transition: all 0.3s ease;
                            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
                        " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(102, 126, 234, 0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(102, 126, 234, 0.3)'">
                            üöÄ Open Player Hub
                        </button>
                    </div>
                    
                    <div style="border-top: 2px solid rgba(78, 205, 196, 0.2); padding-top: 20px;"></div>
                    
                    <div>
                        <label style="display: block; color: #4ecdc4; font-weight: 600; margin-bottom: 8px; font-size: 0.95em;">Display Name</label>
                        <input type="text" id="settings-display-name" placeholder="Your Name" style="
                            width: 100%; padding: 10px 12px; background: #1a1e26;
                            border: 2px solid #a55eea; border-radius: 8px; color: #fff;
                            font-size: 1em; box-sizing: border-box;
                        ">
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 0;">How others see you in multiplayer</p>
                    </div>
                    
                    <div>
                        <label style="display: block; color: #4ecdc4; font-weight: 600; margin-bottom: 8px; font-size: 0.95em;">Email (Optional)</label>
                        <input type="email" id="settings-email" placeholder="your@email.com" style="
                            width: 100%; padding: 10px 12px; background: #1a1e26;
                            border: 2px solid #a55eea; border-radius: 8px; color: #fff;
                            font-size: 1em; box-sizing: border-box;
                        ">
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 0;">For password recovery and notifications</p>
                    </div>
                    
                    <h3 style="color: #4ecdc4; margin: 24px 0 12px 0; font-size: 1.2em;">ÔøΩ Privacy</h3>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-show-stats" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Show My Statistics</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Allow others to see your win/loss record</p>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-show-online" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Show Online Status</span>
                        </label>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-allow-challenges" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Allow Game Challenges</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Let others invite you to games</p>
                    </div>
                    
                    <h3 style="color: #4ecdc4; margin: 24px 0 12px 0; font-size: 1.2em;">üéÆ Guest Mode</h3>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-guest-access" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Enable Guest Access</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Allow playing without account creation</p>
                    </div>
                </div>
                
                <!-- GAME CREATOR TAB -->
                <div id="pref-panel-game-creator" class="pref-panel" style="display: none; flex-direction: column; gap: 24px;">
                    <h3 style="color: #4ecdc4; margin: 0 0 12px 0; font-size: 1.2em;">üõ†Ô∏è Creator Interface</h3>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-show-grid-creator" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Show Hex Grid</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Display grid lines between hexagons</p>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-snap-to-grid" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Snap to Grid</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Auto-align pieces to hex centers</p>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-show-zone-names" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Show Zone Names</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Label zones with their names</p>
                    </div>
                    
                    <div>
                        <label style="display: block; color: #4ecdc4; font-weight: 600; margin-bottom: 8px; font-size: 0.95em;">Auto-Save Frequency</label>
                        <select id="settings-autosave-freq" style="
                            width: 100%; padding: 10px 12px; background: #1a1e26;
                            border: 2px solid #a55eea; border-radius: 8px; color: #fff;
                            font-size: 1em; cursor: pointer;
                        ">
                            <option value="off">Off (manual only)</option>
                            <option value="30s">Every 30 seconds</option>
                            <option value="1min">Every minute</option>
                            <option value="3min" selected>Every 3 minutes</option>
                            <option value="5min">Every 5 minutes</option>
                        </select>
                    </div>
                    
                    <h3 style="color: #4ecdc4; margin: 24px 0 12px 0; font-size: 1.2em;">üé® Piece Tools</h3>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-multi-select" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Enable Multi-Select</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Select multiple pieces with Ctrl+Click</p>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-copy-paste" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Enable Copy/Paste</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Duplicate pieces with Ctrl+C/V</p>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-undo-redo" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Unlimited Undo/Redo</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Track full edit history</p>
                    </div>
                    
                    <div>
                        <label style="display: block; color: #4ecdc4; font-weight: 600; margin-bottom: 8px; font-size: 0.95em;">Piece Palette Layout</label>
                        <select id="settings-palette-layout" style="
                            width: 100%; padding: 10px 12px; background: #1a1e26;
                            border: 2px solid #a55eea; border-radius: 8px; color: #fff;
                            font-size: 1em; cursor: pointer;
                        ">
                            <option value="sidebar" selected>Sidebar (right panel)</option>
                            <option value="bottom">Bottom toolbar</option>
                            <option value="floating">Floating palette</option>
                            <option value="popup">Click-to-open popup</option>
                        </select>
                    </div>
                    
                    <h3 style="color: #4ecdc4; margin: 24px 0 12px 0; font-size: 1.2em;">üß™ Testing & Validation</h3>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-auto-validate" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Auto-Validate Rules</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Check for errors while creating</p>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-playtest-mode" style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Quick Playtest Mode</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Test game without saving (Alt+P)</p>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-warn-unfinished" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Warn About Incomplete Games</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Alert if missing pieces, zones, or patterns</p>
                    </div>
                    
                    <h3 style="color: #4ecdc4; margin: 24px 0 12px 0; font-size: 1.2em;">üìö Templates & Presets</h3>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-show-templates" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Show Template Library</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Browse starting templates on launch</p>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-save-as-template" style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Save Custom Templates</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Create reusable starting boards</p>
                    </div>
                </div>
                
                <!-- ENGINE TAB -->
                <div id="pref-panel-engine" class="pref-panel" style="display: none; flex-direction: column; gap: 24px;">
                    <h3 style="color: #4ecdc4; margin: 0 0 12px 0; font-size: 1.2em;">‚ö° Performance Settings</h3>
                    
                    <div>
                        <label style="display: block; color: #4ecdc4; font-weight: 600; margin-bottom: 8px; font-size: 0.95em;">Engine Strength</label>
                        <select id="settings-engine-strength" style="
                            width: 100%; padding: 10px 12px; background: #1a1e26;
                            border: 2px solid #a55eea; border-radius: 8px; color: #fff;
                            font-size: 1em; cursor: pointer;
                        ">
                            <option value="1">Level 1 (Beginner)</option>
                            <option value="3">Level 3 (Novice)</option>
                            <option value="5" selected>Level 5 (Intermediate)</option>
                            <option value="7">Level 7 (Advanced)</option>
                            <option value="10">Level 10 (Expert)</option>
                            <option value="max">Maximum (Unlimited)</option>
                        </select>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 0;">CPU strength for computer opponent</p>
                    </div>
                    
                    <div>
                        <label style="display: block; color: #4ecdc4; font-weight: 600; margin-bottom: 12px; font-size: 0.95em;">Search Depth</label>
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <input type="range" id="settings-search-depth" min="3" max="20" step="1" value="10" style="flex: 1; cursor: pointer;">
                            <span id="depth-value" style="color: #ffd700; font-weight: bold; min-width: 70px;">10 moves</span>
                        </div>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 0;">How many moves ahead to analyze</p>
                    </div>
                    
                    <div>
                        <label style="display: block; color: #4ecdc4; font-weight: 600; margin-bottom: 8px; font-size: 0.95em;">Move Time Limit</label>
                        <select id="settings-move-time-limit" style="
                            width: 100%; padding: 10px 12px; background: #1a1e26;
                            border: 2px solid #a55eea; border-radius: 8px; color: #fff;
                            font-size: 1em; cursor: pointer;
                        ">
                            <option value="100">0.1s (Lightning)</option>
                            <option value="500">0.5s (Fast)</option>
                            <option value="1000">1s (Quick)</option>
                            <option value="3000" selected>3s (Normal)</option>
                            <option value="5000">5s (Thoughtful)</option>
                            <option value="10000">10s (Deep)</option>
                            <option value="unlimited">Unlimited (Best Move)</option>
                        </select>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 0;">Max time per move calculation</p>
                    </div>
                    
                    <h3 style="color: #4ecdc4; margin: 24px 0 12px 0; font-size: 1.2em;">üß† AI Behavior</h3>
                    
                    <div>
                        <label style="display: block; color: #4ecdc4; font-weight: 600; margin-bottom: 8px; font-size: 0.95em;">Playing Style</label>
                        <select id="settings-ai-style" style="
                            width: 100%; padding: 10px 12px; background: #1a1e26;
                            border: 2px solid #a55eea; border-radius: 8px; color: #fff;
                            font-size: 1em; cursor: pointer;
                        ">
                            <option value="balanced" selected>‚öñÔ∏è Balanced</option>
                            <option value="aggressive">‚öîÔ∏è Aggressive (attacks)</option>
                            <option value="defensive">üõ°Ô∏è Defensive (safe)</option>
                            <option value="positional">‚ôüÔ∏è Positional (strategic)</option>
                            <option value="tactical">üéØ Tactical (tricky)</option>
                            <option value="random">üé≤ Random (unpredictable)</option>
                        </select>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-opening-book" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Use Opening Book</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Play known openings (first 10 moves)</p>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-endgame-tables" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Endgame Tablebases</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Perfect play in 5-piece endgames</p>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-contempt-factor" style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Contempt (Avoid Draws)</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Engine prefers winning chances over draws</p>
                    </div>
                    
                    <h3 style="color: #4ecdc4; margin: 24px 0 12px 0; font-size: 1.2em;">üìä Analysis Display</h3>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-show-eval-bar" style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Show Evaluation Bar</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Display position advantage (¬±score)</p>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-show-best-move" style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Highlight Best Move</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Show engine's top choice</p>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-multi-pv" style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Show Multiple Lines</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Display top 3 move candidates</p>
                    </div>
                    
                    <div>
                        <label style="display: block; color: #4ecdc4; font-weight: 600; margin-bottom: 8px; font-size: 0.95em;">Analysis Updates</label>
                        <select id="settings-analysis-frequency" style="
                            width: 100%; padding: 10px 12px; background: #1a1e26;
                            border: 2px solid #a55eea; border-radius: 8px; color: #fff;
                            font-size: 1em; cursor: pointer;
                        ">
                            <option value="realtime" selected>Real-time (live)</option>
                            <option value="1s">Every 1 second</option>
                            <option value="3s">Every 3 seconds</option>
                            <option value="5s">Every 5 seconds</option>
                            <option value="manual">Manual only (Ctrl+A)</option>
                        </select>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 0;">How often to refresh analysis</p>
                    </div>
                    
                    <h3 style="color: #4ecdc4; margin: 24px 0 12px 0; font-size: 1.2em;">üîß Advanced Tuning</h3>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-multi-threading" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Multi-Threading</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Use all CPU cores (4x faster on quad-core)</p>
                    </div>
                    
                    <div>
                        <label style="display: block; color: #4ecdc4; font-weight: 600; margin-bottom: 8px; font-size: 0.95em;">Hash Table Size</label>
                        <select id="settings-hash-size" style="
                            width: 100%; padding: 10px 12px; background: #1a1e26;
                            border: 2px solid #a55eea; border-radius: 8px; color: #fff;
                            font-size: 1em; cursor: pointer;
                        ">
                            <option value="16">16 MB (Low RAM)</option>
                            <option value="64">64 MB (Standard)</option>
                            <option value="128" selected>128 MB (Recommended)</option>
                            <option value="256">256 MB (High)</option>
                            <option value="512">512 MB (Maximum)</option>
                        </select>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 0;">Memory for move caching</p>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-syzygy-probe" style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Syzygy Tablebase Probing</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Query online endgame databases</p>
                    </div>
                </div>
                
                <!-- ADVANCED TAB -->
                <div id="pref-panel-advanced" class="pref-panel" style="display: none; flex-direction: column; gap: 24px;">
                    <h3 style="color: #4ecdc4; margin: 0 0 12px 0; font-size: 1.2em;">üîß Performance</h3>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-hardware-accel" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Hardware Acceleration</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Use GPU for rendering (restart required)</p>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-animations" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Enable Animations</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Smooth transitions and effects</p>
                    </div>
                    
                    <h3 style="color: #4ecdc4; margin: 24px 0 12px 0; font-size: 1.2em;">üíæ Data Management</h3>
                    
                    <div>
                        <button type="button" onclick="exportUserData()" style="
                            width: 100%; padding: 12px; background: #4ecdc4; color: #23272e;
                            border: none; border-radius: 8px; font-weight: 700; cursor: pointer;
                            transition: all 0.3s;
                        " onmouseover="this.style.background='#5ee6d6'" onmouseout="this.style.background='#4ecdc4'">
                            üì¶ Export My Data
                        </button>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 0;">Download all your games, stats, and settings</p>
                    </div>
                    
                    <div>
                        <button type="button" onclick="importUserData()" style="
                            width: 100%; padding: 12px; background: #f1c40f; color: #23272e;
                            border: none; border-radius: 8px; font-weight: 700; cursor: pointer;
                            transition: all 0.3s;
                        " onmouseover="this.style.background='#f5d657'" onmouseout="this.style.background='#f1c40f'">
                            üì• Import Data
                        </button>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 0;">Restore from backup file</p>
                    </div>
                    
                    <div>
                        <button type="button" onclick="clearAllData()" style="
                            width: 100%; padding: 12px; background: #e74c3c; color: #fff;
                            border: none; border-radius: 8px; font-weight: 700; cursor: pointer;
                            transition: all 0.3s;
                        " onmouseover="this.style.background='#f55e4e'" onmouseout="this.style.background='#e74c3c'">
                            üóëÔ∏è Clear All Local Data
                        </button>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 0;">‚ö†Ô∏è This will delete all saved games and settings</p>
                    </div>
                    
                    <h3 style="color: #4ecdc4; margin: 24px 0 12px 0; font-size: 1.2em;">üêõ Debugging</h3>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-debug-mode" style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Enable Debug Mode</span>
                        </label>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 30px;">Show console logs and diagnostic info</p>
                    </div>
                    
                    <div>
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                            <input type="checkbox" id="settings-fps-counter" style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: #fff; font-weight: 600; font-size: 0.95em;">Show FPS Counter</span>
                        </label>
                    </div>
                    
                    <h3 style="color: #4ecdc4; margin: 24px 0 12px 0; font-size: 1.2em;">üîß Developer Tools</h3>
                    
                    <div>
                        <button type="button" onclick="window.open('engine-analysis.html', '_blank')" style="
                            width: 100%; padding: 12px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: #fff;
                            border: none; border-radius: 8px; font-weight: 700; cursor: pointer;
                            transition: all 0.3s;
                        " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(102, 126, 234, 0.4)'" 
                           onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                            üîç Open Engine Analysis Dashboard
                        </button>
                        <p style="color: #999; font-size: 0.9em; margin: 8px 0 0 0;">Monitor health, performance, connections & optimizations</p>
                    </div>
                </div>
                
                <div style="display: flex; gap: 12px; padding-top: 24px; border-top: 2px solid #333;">
                    <button type="submit" style="
                        flex: 1;
                        background: linear-gradient(135deg, #a55eea, #b075ff);
                        color: white;
                        border: none;
                        padding: 12px 24px;
                        border-radius: 8px;
                        font-weight: 700;
                        font-size: 1em;
                        cursor: pointer;
                        box-shadow: 0 4px 15px rgba(165, 94, 234, 0.3);
                        transition: all 0.3s ease;
                    " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(165, 94, 234, 0.5)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(165, 94, 234, 0.3)'">
                        ‚úì Save All Settings
                    </button>
                    <button type="button" onclick="resetToDefaults()" style="
                        flex: 0.8;
                        background: transparent;
                        color: #888;
                        border: 2px solid #888;
                        padding: 10px 24px;
                        border-radius: 8px;
                        font-weight: 600;
                        font-size: 1em;
                        cursor: pointer;
                        transition: all 0.3s ease;
                    " onmouseover="this.style.color='#aaa'; this.style.borderColor='#aaa'" onmouseout="this.style.color='#888'; this.style.borderColor='#888'">
                        üîÑ Reset
                    </button>
                    <button type="button" onclick="hideSettingsModal()" style="
                        flex: 0.7;
                        background: transparent;
                        color: #888;
                        border: 2px solid #888;
                        padding: 10px 24px;
                        border-radius: 8px;
                        font-weight: 600;
                        font-size: 1em;
                        cursor: pointer;
                        transition: all 0.3s ease;
                    " onmouseover="this.style.color='#aaa'; this.style.borderColor='#aaa'" onmouseout="this.style.color='#888'; this.style.borderColor='#888'">
                        Cancel
                    </button>
                </div>
            </form>
        </div>
    </div>

    <!-- Statistics Dashboard Modal -->
    <!-- TEST: This comment was added to verify live deployment on romgon.net -->
    <div id="stats-dashboard-modal" style="
        display: none;
        position: fixed;
        top: 0; left: 0; width: 100vw; height: 100vh;
        background: rgba(10, 12, 15, 0.98);
        z-index: 3000;
        overflow-y: auto;
        padding: 0; margin: 0;
    ">
        <div style="
            max-width: 800px;
            margin: 40px auto;
            background: #0e1013;
            border-radius: 18px;
            box-shadow: 0 8px 40px #000a;
            padding: 36px 32px 32px 32px;
            color: #fff;
            position: relative;
        ">
            <button onclick="hideStatsDashboard()" style="
                position: absolute; top: 18px; right: 18px;
                background: #f1c40f; color: #23272e;
                border: none; border-radius: 8px;
                font-size: 1.2em; font-weight: bold;
                padding: 6px 16px; cursor: pointer; z-index: 10;">‚úñÔ∏è Close</button>
            <h2 style="color: #f1c40f; margin-top: 0;">üìä Romgon Statistics Dashboard</h2>
            <div id="stats-dashboard-content">
                <!-- Stats will be rendered here -->
            </div>
        </div>
    </div>
    <script>
    // Show/hide Statistics Dashboard modal
    function showStatsDashboard() {
        document.getElementById('stats-dashboard-modal').style.display = 'block';
        renderStatsDashboard();
    }
    function hideStatsDashboard() {
        document.getElementById('stats-dashboard-modal').style.display = 'none';
    }
    // Render statistics dashboard content (placeholder data)
    function renderStatsDashboard() {
        const currentUser = JSON.parse(localStorage.getItem('romgon-user') || '{}');
        if (!currentUser.username) {
            const content = document.getElementById('stats-dashboard-content');
            if (content) content.innerHTML = '<p style="color: #aaa;">Please log in to view statistics</p>';
            return;
        }
        
        const stats = getUserStats(currentUser.username);
        if (!stats) {
            const content = document.getElementById('stats-dashboard-content');
            if (content) content.innerHTML = '<p style="color: #aaa;">No statistics available</p>';
            return;
        }
        
        const winRate = getWinRate(currentUser.username);
        const avgMoves = getAvgMovesPerGame(currentUser.username);
        const totalCaptures = getTotalCaptures(currentUser.username);
        
        const content = document.getElementById('stats-dashboard-content');
        content.innerHTML = `
            <div style='margin-bottom:24px;'>
                <h3 style='color:#4ecdc4;'>üèÜ Win/Loss Record</h3>
                <p style='font-size:1.1em;'>Wins: <b>${stats.gamesWon}</b> | Losses: <b>${stats.gamesLost}</b> | Draws: <b>${stats.gamesDrawn}</b></p>
                <p style='color:#aaa; margin-top:8px;'>Win Rate: <b>${winRate}%</b> (${stats.gamesPlayed} total games)</p>
            </div>
            <div style='margin-bottom:24px;'>
                <h3 style='color:#a55eea;'>‚ôüÔ∏è Piece Performance</h3>
                <table style='width:100%; border-collapse:collapse;'>
                    <thead><tr style='color:#aaa;'><th>Piece</th><th>Captures</th><th>Survived</th><th>Lost</th></tr></thead>
                    <tbody>
                        <tr><td>Square</td><td>${stats.pieceStats.square.captures}</td><td>${stats.pieceStats.square.survived}</td><td>${stats.pieceStats.square.lost}</td></tr>
                        <tr><td>Triangle</td><td>${stats.pieceStats.triangle.captures}</td><td>${stats.pieceStats.triangle.survived}</td><td>${stats.pieceStats.triangle.lost}</td></tr>
                        <tr><td>Rhombus</td><td>${stats.pieceStats.rhombus.captures}</td><td>${stats.pieceStats.rhombus.survived}</td><td>${stats.pieceStats.rhombus.lost}</td></tr>
                        <tr><td>Circle</td><td>${stats.pieceStats.circle.captures}</td><td>${stats.pieceStats.circle.survived}</td><td>${stats.pieceStats.circle.lost}</td></tr>
                        <tr><td>Hexagon</td><td>${stats.pieceStats.hexagon.captures}</td><td>${stats.pieceStats.hexagon.survived}</td><td>${stats.pieceStats.hexagon.lost}</td></tr>
                    </tbody>
                </table>
            </div>
            <div style='margin-bottom:24px;'>
                <h3 style='color:#00b894;'>üìö Opening Repertoire</h3>
                <p style='color:#aaa;'>Opening data will be tracked during gameplay</p>
            </div>
            <div style='margin-bottom:24px;'>
                <h3 style='color:#0984e3;'>ÔøΩ Move Quality</h3>
                <p style='color:#aaa;'>Average Moves per Game: <b>${avgMoves}</b></p>
                <p style='color:#aaa;'>Average Captures per Game: <b>${stats.gamesPlayed > 0 ? Math.round(totalCaptures / stats.gamesPlayed) : 0}</b></p>
            </div>
            <div style='margin-bottom:24px;'>
                <h3 style='color:#ff6b6b;'>üèÖ Personal Records</h3>
                <ul style='color:#fff; font-size:1.05em;'>
                    <li>Longest Win Streak: <b>${stats.longestWinStreak}</b></li>
                    <li>Fastest Win: <b>${stats.fastestWin ? stats.fastestWin + ' moves' : 'N/A'}</b></li>
                    <li>Total Pieces Captured: <b>${totalCaptures}</b></li>
                    <li>Member Since: <b>${new Date(stats.registeredDate).toLocaleDateString()}</b></li>
                </ul>
            </div>
        `;
    }
    </script>
    <!-- Opening Book Modal -->
    <div id="opening-book-modal" style="
        display: none;
        position: fixed;
        top: 0; left: 0; width: 100vw; height: 100vh;
        background: rgba(20, 24, 32, 0.98);
        z-index: 3000;
        overflow-y: auto;
        padding: 0; margin: 0;
    ">
        <div style="
            max-width: 800px;
            margin: 40px auto;
            background: #23272e;
            border-radius: 18px;
            box-shadow: 0 8px 40px #000a;
            padding: 36px 32px 32px 32px;
            color: #fff;
            position: relative;
        ">
            <button onclick="hideOpeningBook()" style="
                position: absolute; top: 18px; right: 18px;
                background: #4ecdc4; color: #23272e;
                border: none; border-radius: 8px;
                font-size: 1.2em; font-weight: bold;
                padding: 6px 16px; cursor: pointer; z-index: 10;">‚úñÔ∏è Close</button>
            <h2 style="color: #4ecdc4; margin-top: 0;">üìñ Romgon Opening Book</h2>
            <div id="opening-book-content">
                <!-- Opening list will be rendered here -->
            </div>
        </div>
    </div>
    <script>
    // Show/hide Opening Book modal
    function showOpeningBook() {
        document.getElementById('opening-book-modal').style.display = 'block';
        renderOpeningBook();
    }
    function hideOpeningBook() {
        document.getElementById('opening-book-modal').style.display = 'none';
    }
    
    // Sign Up Modal Functions (moved to main script block at line ~6250)
    // Sign In handler (moved to main script block at line ~6340)
    
    function showSignUpError(message) {
        const errorDiv = document.getElementById('signup-error');
        errorDiv.textContent = message;
        errorDiv.style.display = 'block';
    }
    
    // ============================================
    // SIGN IN MODAL FUNCTIONS (showSignInModal moved to main script block at line ~6200)
    // ============================================
    
    function toggleSignInPassword() {
        const input = document.getElementById('signin-password');
        const button = event.target;
        
        if (input.type === 'password') {
            input.type = 'text';
            button.textContent = 'üôà';
        } else {
            input.type = 'password';
            button.textContent = 'üëÅÔ∏è';
        }
    }
    
    // handleSignIn moved to main script block at line ~6340
    
    function showSignInError(message) {
        const errorDiv = document.getElementById('signin-error');
        errorDiv.textContent = message;
        errorDiv.style.display = 'block';
    }
    
    async function loadActivePlayersCount() {
        try {
            // Fetch real data from backend
            const response = await romgonAPI.request('/stats/player-counts');
            
            const total = response.totalRegistered + response.activePlayers;
            document.getElementById('active-players-count').textContent = total;
            
            // Store for other uses
            window.playerCounts = response;
            
            console.log('üìä Player counts loaded:', response);
        } catch (error) {
            console.error('‚ùå Failed to load player counts:', error);
            // Fallback to demo
            const count = Math.floor(Math.random() * 50) + 25;
            document.getElementById('active-players-count').textContent = count;
        }
    }
    
    // Account Modal Functions
    async function showAccountModal() {
        console.log('üîì Opening Player Hub...');
        
        // Debug: Check all possible sources of user data
        const storedUser = localStorage.getItem('romgon-user');
        const jwtToken = localStorage.getItem('romgon-jwt');
        
        console.log('üìã Debug - localStorage romgon-user:', storedUser);
        console.log('üìã Debug - JWT token exists:', !!jwtToken);
        console.log('üìã Debug - window.currentUser:', window.currentUser);
        
        let currentUser = window.currentUser || (storedUser ? JSON.parse(storedUser) : {});
        
        // If we have a JWT but user data is missing/incomplete, try to decode JWT
        if (jwtToken && (!currentUser.id || !currentUser.username || currentUser.username === 'Guest Player')) {
            try {
                const jwtPayload = JSON.parse(atob(jwtToken.split('.')[1]));
                console.log('üîë JWT payload:', jwtPayload);
                
                // Update currentUser with JWT data (handle both old and new JWT formats)
                if (jwtPayload.userId || jwtPayload.username) {
                    currentUser = {
                        id: jwtPayload.userId || jwtPayload.id,
                        username: jwtPayload.username || jwtPayload.name || jwtPayload.email?.split('@')[0] || 'Player',
                        email: jwtPayload.email || currentUser.email || null,
                        name: jwtPayload.name || jwtPayload.username,
                        picture: jwtPayload.picture || currentUser.picture,
                        type: 'registered',
                        google_id: jwtPayload.google_id
                    };
                    
                    // Save corrected user data
                    localStorage.setItem('romgon-user', JSON.stringify(currentUser));
                    window.currentUser = currentUser;
                    
                    console.log('‚úÖ Corrected user data from JWT:', currentUser);
                }
            } catch (error) {
                console.error('‚ùå Failed to decode JWT:', error);
            }
        }
        
        console.log('üìã Final user data to display:', currentUser);
        
        // Check if user is logged in
        if (!currentUser.id && !currentUser.username && !currentUser.email) {
            alert('üìù Please sign in to access Player Hub!');
            return;
        }
        
        // Show modal immediately
        document.getElementById('account-modal').style.display = 'block';
        
        // Get local stats as fallback
        const localStats = getUserStats(currentUser.username) || {
            gamesWon: 0,
            gamesLost: 0,
            gamesPlayed: 0,
            totalMoves: 0,
            totalCaptures: 0,
            fastestWin: null
        };
        
        // Set initial values from local data
        const username = currentUser.username || currentUser.name || currentUser.email?.split('@')[0] || 'Player';
        const email = currentUser.email || 'No email';
        // Determine account type: if has JWT token or email, it's registered
        const hasJWT = !!localStorage.getItem('romgon-jwt');
        const accountType = (currentUser.type === 'guest' && !hasJWT && !currentUser.email) ? 'Guest' : 'Registered';
        const avatar = currentUser.avatar || currentUser.picture || 'üë§';
        
        console.log('üìä Displaying - Username:', username, 'Email:', email, 'Type:', accountType, 'Has JWT:', hasJWT);
        
        // Update sidebar immediately with local data
        document.getElementById('account-sidebar-name').textContent = username;
        document.getElementById('account-username').textContent = username;
        document.getElementById('account-sidebar-email').textContent = email;
        document.getElementById('account-email').textContent = email;
        
        // Set avatar
        const avatarEl = document.getElementById('account-avatar');
        if (currentUser.picture) {
            avatarEl.innerHTML = `<img src="${currentUser.picture}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%;" />`;
        } else {
            avatarEl.textContent = avatar;
            avatarEl.style.fontSize = '3em';
        }
        
        // Update account type badge
        const accountTypeEl = document.getElementById('user-home-account-type');
        if (accountTypeEl) {
            accountTypeEl.textContent = accountType;
            if (accountType === 'Registered') {
                accountTypeEl.style.background = 'rgba(78, 205, 196, 0.2)';
                accountTypeEl.style.color = '#4ecdc4';
            }
        }
        
        // Update stats with local data
        const wins = localStats.gamesWon || 0;
        const losses = localStats.gamesLost || 0;
        const totalGames = wins + losses;
        const winRate = totalGames > 0 ? Math.round((wins / totalGames) * 100) : 0;
        
        document.getElementById('account-wins').textContent = wins;
        document.getElementById('account-losses').textContent = losses;
        document.getElementById('account-games').textContent = totalGames;
        document.getElementById('account-total-games').textContent = totalGames;
        
        const winRateEl = document.getElementById('account-winrate');
        if (winRateEl) winRateEl.textContent = winRate + '%';
        
        // Update member level
        const memberLevelEl = document.getElementById('account-member-level');
        if (memberLevelEl) {
            if (totalGames >= 100) memberLevelEl.textContent = 'Gold';
            else if (totalGames >= 50) memberLevelEl.textContent = 'Silver';
            else memberLevelEl.textContent = 'Bronze';
        }
        
        // Update registration date
        const regDate = currentUser.created_at ? new Date(currentUser.created_at) : new Date();
        document.getElementById('account-sidebar-date').textContent = regDate.toLocaleDateString();
        
        // Update activity
        document.getElementById('account-last-login').textContent = accountType === 'Guest' ? 'Session only' : 'Today';
        document.getElementById('account-saved-games').textContent = accountType === 'Guest' ? '0 (session)' : totalGames;
        document.getElementById('account-total-moves').textContent = localStats.totalMoves || 0;
        document.getElementById('account-total-captures').textContent = localStats.totalCaptures || 0;
        
        updateTopBarStats(wins, losses, winRate);
        
        // Try to fetch from backend if registered user (non-blocking)
        console.log('üîç Checking if should fetch backend data...');
        console.log('  currentUser.id:', currentUser.id);
        console.log('  currentUser.type:', currentUser.type);
        console.log('  Has JWT token:', !!localStorage.getItem('romgon-jwt'));
        console.log('  Full currentUser:', currentUser);
        
        // Fetch backend data if: has ID AND (is registered OR has JWT token)
        const shouldFetchBackend = currentUser.id && (currentUser.type !== 'guest' || localStorage.getItem('romgon-jwt'));
        console.log('  Should fetch backend?', shouldFetchBackend);
        
        if (shouldFetchBackend) {
            try {
                console.log('üîÑ Fetching backend data...');
                
                // Fetch stats (required) and games (optional)
                const statsPromise = fetchUserStats();
                const gamesPromise = fetchUserGames(10).catch(err => {
                    console.warn('‚ö†Ô∏è Could not fetch game history:', err);
                    return [];
                });
                
                const [stats, games] = await Promise.all([statsPromise, gamesPromise]);
                
                console.log('üìä Backend data:', { stats, games });
                
                // Update with backend data if available
                if (stats) {
                    // Update email if available from backend
                    if (stats.email) {
                        console.log('‚úÖ Updating email from backend:', stats.email);
                        document.getElementById('account-sidebar-email').textContent = stats.email;
                        document.getElementById('account-email').textContent = stats.email;
                        
                        // Also update currentUser and localStorage
                        currentUser.email = stats.email;
                        localStorage.setItem('romgon-user', JSON.stringify(currentUser));
                        window.currentUser = currentUser;
                    }
                    
                    // Update username if available
                    if (stats.username) {
                        console.log('‚úÖ Updating username from backend:', stats.username);
                        document.getElementById('account-sidebar-name').textContent = stats.username;
                        document.getElementById('account-username').textContent = stats.username;
                    }
                }
                
                if (stats && stats.stats) {
                    // Backend returns { stats: { wins, losses, totalGames, ... } }
                    const backendStats = stats.stats;
                    const backendWins = backendStats.wins || 0;
                    const backendLosses = backendStats.losses || 0;
                    const backendTotal = backendStats.totalGames || 0;
                    const backendWinRate = backendStats.winRate || 0;
                    
                    console.log('‚úÖ Using backend stats:', backendStats);
                    console.log('üìù Updating DOM elements with backend stats...');
                    
                    const winsEl = document.getElementById('account-wins');
                    const lossesEl = document.getElementById('account-losses');
                    const gamesEl = document.getElementById('account-games');
                    const totalGamesEl = document.getElementById('account-total-games');
                    
                    if (winsEl) {
                        winsEl.textContent = backendWins;
                        console.log('  ‚úì Updated account-wins:', backendWins);
                    }
                    if (lossesEl) {
                        lossesEl.textContent = backendLosses;
                        console.log('  ‚úì Updated account-losses:', backendLosses);
                    }
                    if (gamesEl) {
                        gamesEl.textContent = backendTotal;
                        console.log('  ‚úì Updated account-games:', backendTotal);
                    }
                    if (totalGamesEl) {
                        totalGamesEl.textContent = backendTotal;
                        console.log('  ‚úì Updated account-total-games:', backendTotal);
                    }
                    
                    if (winRateEl) {
                        winRateEl.textContent = Math.round(backendWinRate) + '%';
                        console.log('  ‚úì Updated winRate:', Math.round(backendWinRate) + '%');
                    }
                    
                    // Update member level from backend
                    if (memberLevelEl && stats.memberLevel) {
                        memberLevelEl.textContent = stats.memberLevel;
                        console.log('  ‚úì Updated memberLevel:', stats.memberLevel);
                    } else if (memberLevelEl) {
                        const level = backendTotal >= 100 ? 'Gold' : backendTotal >= 50 ? 'Silver' : 'Bronze';
                        memberLevelEl.textContent = level;
                        console.log('  ‚úì Updated memberLevel (calculated):', level);
                    }
                    
                    // Update moves and captures
                    const movesEl = document.getElementById('account-total-moves');
                    const capturesEl = document.getElementById('account-total-captures');
                    
                    if (movesEl && backendStats.totalMoves !== undefined) {
                        movesEl.textContent = backendStats.totalMoves;
                        console.log('  ‚úì Updated totalMoves:', backendStats.totalMoves);
                    }
                    if (capturesEl && backendStats.totalCaptures !== undefined) {
                        capturesEl.textContent = backendStats.totalCaptures;
                        console.log('  ‚úì Updated totalCaptures:', backendStats.totalCaptures);
                    }
                    
                    updateTopBarStats(backendWins, backendLosses, Math.round(backendWinRate));
                    console.log('‚úÖ All backend stats applied to Player Hub');
                } else {
                    console.warn('‚ö†Ô∏è Backend stats not in expected format:', stats);
                }
                
                console.log('‚úÖ Backend data loaded');
            } catch (error) {
                console.warn('‚ö†Ô∏è Backend data fetch failed, using local data:', error);
                // Local data already shown, just log the error
            }
        }
        
        // Show/hide delete button
        const deleteBtn = document.querySelector('button[onclick="deleteAccount()"]');
        if (deleteBtn) {
            deleteBtn.style.display = currentUser.type === 'guest' ? 'none' : 'block';
        }
        
        console.log('‚úÖ Player Hub opened');
    }
    
    function updateTopBarStats(wins, losses, winRate) {
        // Update stats in local top bar (user-home)
        const winsEl = document.getElementById('user-home-wins-mini');
        const lossesEl = document.getElementById('user-home-losses-mini');
        const winRateEl = document.getElementById('user-home-winrate-mini');
        
        if (winsEl) winsEl.textContent = wins;
        if (lossesEl) lossesEl.textContent = losses;
        if (winRateEl) winRateEl.textContent = winRate + '%';
        
        // Update global top bar
        const globalWinsEl = document.getElementById('global-wins');
        const globalLossesEl = document.getElementById('global-losses');
        const globalWinRateEl = document.getElementById('global-winrate');
        
        if (globalWinsEl) globalWinsEl.textContent = wins;
        if (globalLossesEl) globalLossesEl.textContent = losses;
        if (globalWinRateEl) globalWinRateEl.textContent = winRate + '%';
        
        // Also update the larger stats display if present
        const winsLargeEl = document.getElementById('user-home-wins');
        const lossesLargeEl = document.getElementById('user-home-losses');
        const winRateLargeEl = document.getElementById('user-home-winrate');
        const gamesEl = document.getElementById('user-home-games');
        
        if (winsLargeEl) winsLargeEl.textContent = wins;
        if (lossesLargeEl) lossesLargeEl.textContent = losses;
        if (winRateLargeEl) winRateLargeEl.textContent = winRate + '%';
        if (gamesEl) gamesEl.textContent = wins + losses;
    }
    
    function updateGlobalAccountBar(username, accountType, avatarInitial) {
        // Update global account bar with user info
        const globalUsernameEl = document.getElementById('global-username');
        const globalAccountTypeEl = document.getElementById('global-account-type');
        const globalAvatarEl = document.getElementById('global-avatar');
        
        if (globalUsernameEl) globalUsernameEl.textContent = username || 'Player';
        
        if (globalAccountTypeEl) {
            globalAccountTypeEl.textContent = accountType || 'Guest';
            if (accountType === 'Registered') {
                globalAccountTypeEl.style.background = 'rgba(78, 205, 196, 0.2)';
                globalAccountTypeEl.style.color = '#4ecdc4';
            } else {
                globalAccountTypeEl.style.background = 'rgba(255, 215, 0, 0.2)';
                globalAccountTypeEl.style.color = '#ffd700';
            }
        }
        
        if (globalAvatarEl && avatarInitial) {
            globalAvatarEl.textContent = avatarInitial;
        }
    }
    
    function showGlobalAccountBar() {
        const bar = document.getElementById('global-account-bar');
        if (bar) bar.style.display = 'flex';
    }
    
    function hideGlobalAccountBar() {
        const bar = document.getElementById('global-account-bar');
        if (bar) bar.style.display = 'none';
    }
    
    function openPlayerHubFromTopBar() {
        console.log('üéØ Opening Player Hub from top bar');
        showAccountModal();
    }
    
    function hideAccountModal() {
        document.getElementById('account-modal').style.display = 'none';
    }

    // ===== NEW PLAYER HUB FUNCTIONS =====
    
    // Switch between Player Hub tabs
    function switchAccountTab(tabName) {
        // Hide all tabs
        const tabs = document.querySelectorAll('.account-tab-content');
        tabs.forEach(tab => tab.style.display = 'none');
        
        // Show selected tab
        const selectedTab = document.getElementById('account-tab-' + tabName);
        if (selectedTab) {
            selectedTab.style.display = 'block';
            populateTabContent(tabName);
        }
        
        // Update active button
        const buttons = document.querySelectorAll('.account-tab-btn');
        buttons.forEach(btn => {
            if (btn.dataset.tab === tabName) {
                btn.classList.add('active');
                btn.style.borderBottomColor = '#667eea';
                btn.style.color = '#fff';
            } else {
                btn.classList.remove('active');
                btn.style.borderBottomColor = 'transparent';
                btn.style.color = '#999';
            }
        });
    }
    
    // Populate tab-specific content
    function populateTabContent(tabName) {
        const currentUser = JSON.parse(localStorage.getItem('romgon-user') || '{}');
        const allUsers = JSON.parse(localStorage.getItem('romgon-users') || '{}');
        
        if (tabName === 'analytics' && currentUser.username && allUsers[currentUser.username]) {
            populateAnalyticsTab(currentUser.username);
        }
        
        if (tabName === 'settings') {
            populateSettingsTab();
        }
    }
    
    // Populate Analytics tab with detailed stats
    function populateAnalyticsTab(username) {
        const stats = getUserStats(username);
        if (!stats) return;
        
        // Win rate calculation
        const winRate = stats.gamesPlayed > 0 ? Math.round((stats.gamesWon / stats.gamesPlayed) * 100) : 0;
        const avgMoves = stats.gamesPlayed > 0 ? Math.round(stats.totalMoves / stats.gamesPlayed) : 0;
        
        // Update elements
        document.getElementById('account-avg-moves').textContent = avgMoves;
        document.getElementById('account-fastest-win').textContent = stats.fastestWin ? stats.fastestWin + ' moves' : '‚Äî';
        document.getElementById('account-win-streak').textContent = stats.longestWinStreak || 0;
        document.getElementById('account-captures').textContent = stats.totalCaptures || 0;
        
        // Piece stats
        document.getElementById('piece-square-captures').textContent = stats.pieceStats.square.captures || 0;
        document.getElementById('piece-square-survived').textContent = stats.pieceStats.square.survived || 0;
        document.getElementById('piece-square-lost').textContent = stats.pieceStats.square.lost || 0;
        
        document.getElementById('piece-triangle-captures').textContent = stats.pieceStats.triangle.captures || 0;
        document.getElementById('piece-triangle-survived').textContent = stats.pieceStats.triangle.survived || 0;
        document.getElementById('piece-triangle-lost').textContent = stats.pieceStats.triangle.lost || 0;
        
        document.getElementById('piece-rhombus-captures').textContent = stats.pieceStats.rhombus.captures || 0;
        document.getElementById('piece-rhombus-survived').textContent = stats.pieceStats.rhombus.survived || 0;
        document.getElementById('piece-rhombus-lost').textContent = stats.pieceStats.rhombus.lost || 0;
        
        document.getElementById('piece-circle-captures').textContent = stats.pieceStats.circle.captures || 0;
        document.getElementById('piece-circle-survived').textContent = stats.pieceStats.circle.survived || 0;
        document.getElementById('piece-circle-lost').textContent = stats.pieceStats.circle.lost || 0;
        
        document.getElementById('piece-hexagon-captures').textContent = stats.pieceStats.hexagon.captures || 0;
        document.getElementById('piece-hexagon-survived').textContent = stats.pieceStats.hexagon.survived || 0;
        document.getElementById('piece-hexagon-lost').textContent = stats.pieceStats.hexagon.lost || 0;
    }
    
    // Start game with selected variation
    function startGameWithVariant(variant) {
        console.log('Starting game with variant:', variant);
        
        // Save variant preference
        const currentUser = JSON.parse(localStorage.getItem('romgon-user') || '{}');
        const allUsers = JSON.parse(localStorage.getItem('romgon-users') || '{}');
        
        if (currentUser.username && allUsers[currentUser.username]) {
            if (!allUsers[currentUser.username].preferences) {
                allUsers[currentUser.username].preferences = {};
            }
            allUsers[currentUser.username].preferences.lastVariant = variant;
            localStorage.setItem('romgon-users', JSON.stringify(allUsers));
        } else {
            // Guest user preference
            const guestSettings = JSON.parse(localStorage.getItem('romgon-guest-settings') || '{}');
            guestSettings.lastVariant = variant;
            localStorage.setItem('romgon-guest-settings', JSON.stringify(guestSettings));
        }
        
        // Close modal and update game settings based on variant
        hideAccountModal();
        
        // Apply variant-specific rules
        window.gameSettings = window.gameSettings || {};
        switch(variant) {
            case 'standard':
                window.gameSettings.baseDefenseVariant = 'original';
                break;
            case 'shapeDefense':
                window.gameSettings.baseDefenseVariant = 'shapeDefense';
                break;
            case 'rhombusOriginal':
                window.gameSettings.baseDefenseVariant = 'rhombusOriginal';
                break;
            case 'fortress':
                window.gameSettings.baseDefenseVariant = 'fortress';
                break;
        }
        
        // Show game mode selection for choosing opponent
        if (typeof openGameModesModal === 'function') {
            openGameModesModal();
        }
    }
    
    // ===== SETTINGS TAB FUNCTIONS =====
    
    // Avatar options
    const AVATAR_OPTIONS = [
        'üòÄ', 'üòé', 'üòä', 'ü§©', 'üòá', 'ü•≥', 'ü§ì', 'üßê',
        'ü§ñ', 'üëΩ', 'üéÉ', 'ü¶ä', 'üê∂', 'üê±', 'üêº', 'ü¶Å',
        'üê∏', 'ü¶Ñ', 'üêâ', 'ü¶ñ', 'üåü', '‚ö°', 'üî•', 'üíé',
        'üéÆ', 'üéØ', 'üèÜ', 'üëë', '‚öîÔ∏è', 'üõ°Ô∏è', 'üé≤', 'üÉè'
    ];
    
    // Comprehensive Badge System - 210+ Badges
    const BADGE_SYSTEM = {
        // ===== üèÜ ACHIEVEMENT BADGES (First Steps) =====
        'üéÆ First Move': { category: 'Achievement', rarity: 'common', requirement: 'Make your first move', unlocked: true, points: 5 },
        'üéØ First Game': { category: 'Achievement', rarity: 'common', requirement: 'Complete your first game', games_played: 1, points: 10 },
        'ü•á First Victory': { category: 'Achievement', rarity: 'common', requirement: 'Win your first game', games_won: 1, points: 25 },
        'üèÜ First Checkmate': { category: 'Achievement', rarity: 'common', requirement: 'Win by checkmate', checkmate_wins: 1, points: 30 },
        'üé™ First Base Capture': { category: 'Achievement', rarity: 'common', requirement: 'Win by base capture', base_capture_wins: 1, points: 30 },
        
        // Game Count Milestones
        'üé≤ Apprentice Player': { category: 'Achievement', rarity: 'common', requirement: 'Play 10 games', games_played: 10, points: 50 },
        'üéØ Dedicated Player': { category: 'Achievement', rarity: 'uncommon', requirement: 'Play 50 games', games_played: 50, points: 100 },
        'üéÆ Veteran Player': { category: 'Achievement', rarity: 'rare', requirement: 'Play 100 games', games_played: 100, points: 250 },
        'üèÜ Master Player': { category: 'Achievement', rarity: 'epic', requirement: 'Play 500 games', games_played: 500, points: 1000 },
        'üíé Legend Player': { category: 'Achievement', rarity: 'legendary', requirement: 'Play 1000 games', games_played: 1000, points: 2500 },
        
        // Win Streaks
        'üî• On Fire': { category: 'Achievement', rarity: 'uncommon', requirement: 'Win 3 games in a row', win_streak: 3, points: 75 },
        'üåü Unstoppable': { category: 'Achievement', rarity: 'rare', requirement: 'Win 5 games in a row', win_streak: 5, points: 150 },
        '‚ö° Dominating': { category: 'Achievement', rarity: 'epic', requirement: 'Win 10 games in a row', win_streak: 10, points: 500 },
        'üå™Ô∏è Unstoppable Force': { category: 'Achievement', rarity: 'legendary', requirement: 'Win 20 games in a row', win_streak: 20, points: 1500 },
        
        // Win Count Milestones
        'ü•à Ten Victories': { category: 'Achievement', rarity: 'common', requirement: 'Achieve 10 wins', games_won: 10, points: 100 },
        'ü•á Half Century': { category: 'Achievement', rarity: 'uncommon', requirement: 'Achieve 50 wins', games_won: 50, points: 300 },
        'üèÜ Centurion': { category: 'Achievement', rarity: 'rare', requirement: 'Achieve 100 wins', games_won: 100, points: 750 },
        'üëë Champion': { category: 'Achievement', rarity: 'epic', requirement: 'Achieve 500 wins', games_won: 500, points: 2500 },
        'üåü Immortal': { category: 'Achievement', rarity: 'legendary', requirement: 'Achieve 1000 wins', games_won: 1000, points: 10000 },
        
        // ===== üéØ SKILL BADGES (Performance) =====
        // Speed & Efficiency
        '‚ö° Lightning Fast': { category: 'Skill', rarity: 'uncommon', requirement: 'Win in under 15 moves', fastest_win: 15, points: 100 },
        'üöÄ Blitz Master': { category: 'Skill', rarity: 'rare', requirement: 'Win 10 games in under 20 moves', fast_wins_count: 10, points: 300 },
        'üí® Speed Demon': { category: 'Skill', rarity: 'epic', requirement: 'Win in under 10 moves', fastest_win: 10, points: 500 },
        'ÔøΩÔ∏è Fastest Win Record': { category: 'Skill', rarity: 'legendary', requirement: 'Win in 8 moves or less', fastest_win: 8, points: 1000 },
        
        // Win Rate Excellence
        'üìä Solid Record': { category: 'Skill', rarity: 'uncommon', requirement: '60% win rate (20+ games)', win_rate: 60, min_games: 20, points: 150 },
        'üéØ Sharp Player': { category: 'Skill', rarity: 'rare', requirement: '70% win rate (50+ games)', win_rate: 70, min_games: 50, points: 400 },
        'üèÜ Dominant Force': { category: 'Skill', rarity: 'epic', requirement: '80% win rate (100+ games)', win_rate: 80, min_games: 100, points: 1000 },
        'üëë Untouchable': { category: 'Skill', rarity: 'legendary', requirement: '90% win rate (200+ games)', win_rate: 90, min_games: 200, points: 5000 },
        
        // Perfect Games
        '‚ú® Flawless Victory': { category: 'Skill', rarity: 'rare', requirement: 'Win without losing pieces', perfect_wins: 1, points: 200 },
        'üíé Perfection': { category: 'Skill', rarity: 'epic', requirement: 'Win 10 games without losing pieces', perfect_wins: 10, points: 750 },
        'üåü Untouchable Master': { category: 'Skill', rarity: 'legendary', requirement: 'Win 50 games without losing pieces', perfect_wins: 50, points: 3000 },
        
        // Comeback King
        'üîÑ Comeback Kid': { category: 'Skill', rarity: 'uncommon', requirement: 'Win from material disadvantage', comeback_wins: 1, points: 150 },
        'ü¶Ö Phoenix Rising': { category: 'Skill', rarity: 'rare', requirement: 'Win 10 comeback games', comeback_wins: 10, points: 400 },
        'üî• Miracle Worker': { category: 'Skill', rarity: 'epic', requirement: 'Win from 4-piece deficit', comeback_from_4: 1, points: 1000 },
        
        // ===== üß† STRATEGIC BADGES =====
        // Tactical Genius
        'üéØ Fork Master': { category: 'Strategic', rarity: 'uncommon', requirement: 'Execute 50 fork attacks', forks: 50, points: 200 },
        'üó°Ô∏è Pin Specialist': { category: 'Strategic', rarity: 'rare', requirement: 'Pin 100 enemy pieces', pins: 100, points: 300 },
        '‚ôüÔ∏è Discovered Attack': { category: 'Strategic', rarity: 'rare', requirement: 'Execute 25 discovered attacks', discovered_attacks: 25, points: 350 },
        'üß© Tactical Genius': { category: 'Strategic', rarity: 'epic', requirement: '10 tactical moves in one game', tactics_single_game: 10, points: 500 },
        
        // Positional Mastery
        'üè∞ Fortress Builder': { category: 'Strategic', rarity: 'uncommon', requirement: 'Win 20 fortress games', fortress_wins: 20, points: 200 },
        'üõ°Ô∏è Defender': { category: 'Strategic', rarity: 'rare', requirement: 'Block 100 base captures', defenses: 100, points: 300 },
        'üó∫Ô∏è Zone Controller': { category: 'Strategic', rarity: 'epic', requirement: 'Control all zones at once', zone_control: 1, points: 500 },
        'üëÅÔ∏è Positional Master': { category: 'Strategic', rarity: 'legendary', requirement: 'Win 50 games down material', material_disadvantage_wins: 50, points: 2000 },
        
        // Endgame Mastery
        'üé≠ Endgame Artist': { category: 'Strategic', rarity: 'rare', requirement: 'Win 20 Rhombus-only endgames', rhombus_only_wins: 20, points: 400 },
        '‚öîÔ∏è Minimal Pieces': { category: 'Strategic', rarity: 'epic', requirement: 'Win with only 2 pieces left', minimal_piece_wins: 1, points: 600 },
        'ÔøΩ King Walk': { category: 'Strategic', rarity: 'legendary', requirement: 'Solo Rhombus base capture', solo_rhombus_win: 1, points: 1500 },
        
        // Opening Mastery
        'üìñ Opening Scholar': { category: 'Strategic', rarity: 'common', requirement: 'Try 10 different openings', unique_openings: 10, points: 100 },
        'üéì Opening Expert': { category: 'Strategic', rarity: 'rare', requirement: 'Play 100 games from same opening', same_opening: 100, points: 400 },
        'üìö Opening Theorist': { category: 'Strategic', rarity: 'epic', requirement: 'Win with 20 different openings', unique_opening_wins: 20, points: 800 },
        
        // ===== ‚ôüÔ∏è PIECE MASTERY BADGES =====
        // Rhombus Mastery
        'üíé Rhombus Guardian': { category: 'Piece Mastery', rarity: 'uncommon', requirement: 'Never lose Rhombus in 50 games', rhombus_survival: 50, points: 200 },
        'üëë Kings March': { category: 'Piece Mastery', rarity: 'rare', requirement: '20 Rhombus base captures', rhombus_captures: 20, points: 400 },
        'üèÜ Rhombus Master': { category: 'Piece Mastery', rarity: 'epic', requirement: '100 base capture wins', rhombus_captures: 100, points: 1000 },
        
        // Hexagon Mastery
        '‚¨° Hexagon Apprentice': { category: 'Piece Mastery', rarity: 'common', requirement: '50 Hexagon captures', hexagon_captures: 50, points: 100 },
        'üåÄ Rotation Specialist': { category: 'Piece Mastery', rarity: 'uncommon', requirement: '100 Hexagon rotations', hexagon_rotations: 100, points: 200 },
        '‚ö° Hexagon Dominance': { category: 'Piece Mastery', rarity: 'rare', requirement: '5 captures with one Hexagon', hexagon_multi_capture: 5, points: 500 },
        'üéØ Hexagon Master': { category: 'Piece Mastery', rarity: 'epic', requirement: 'Hexagon MVP 50 times', hexagon_mvp: 50, points: 1500 },
        
        // Triangle Mastery
        'üî∫ Triangle Tactician': { category: 'Piece Mastery', rarity: 'common', requirement: '50 Triangle captures', triangle_captures: 50, points: 100 },
        'üó°Ô∏è Directional Strike': { category: 'Piece Mastery', rarity: 'uncommon', requirement: '25 combo moves with Triangle', triangle_combos: 25, points: 250 },
        'üéØ Arrow Strike': { category: 'Piece Mastery', rarity: 'rare', requirement: '3 linear captures in one game', triangle_linear: 3, points: 400 },
        '‚öîÔ∏è Triangle Master': { category: 'Piece Mastery', rarity: 'epic', requirement: 'Triangle MVP 50 times', triangle_mvp: 50, points: 1500 },
        
        // Square Mastery
        'üü¶ Square Defender': { category: 'Piece Mastery', rarity: 'common', requirement: '100 defensive blocks', square_blocks: 100, points: 100 },
        'üè∞ Fortress Piece': { category: 'Piece Mastery', rarity: 'uncommon', requirement: 'All Squares survive 30 games', square_survival: 30, points: 300 },
        'üõ°Ô∏è Wall of Steel': { category: 'Piece Mastery', rarity: 'rare', requirement: 'Win with 0 Square losses', square_perfect: 1, points: 500 },
        'üèÜ Square Master': { category: 'Piece Mastery', rarity: 'epic', requirement: 'Square MVP 50 times', square_mvp: 50, points: 1500 },
        
        // Circle Mastery
        '‚ö™ Circle Striker': { category: 'Piece Mastery', rarity: 'common', requirement: '50 Circle captures', circle_captures: 50, points: 100 },
        'ÔøΩ Jump Master': { category: 'Piece Mastery', rarity: 'uncommon', requirement: '100 Circle jumps', circle_jumps: 100, points: 200 },
        'üåü Surprise Attack': { category: 'Piece Mastery', rarity: 'rare', requirement: '50 surprise Circle captures', circle_surprise: 50, points: 400 },
        'ÔøΩüèÜ Circle Master': { category: 'Piece Mastery', rarity: 'epic', requirement: 'Circle MVP 50 times', circle_mvp: 50, points: 1500 },
        
        // ===== üéÆ GAME MODE BADGES =====
        // Standard Romgon
        'üéØ Standard Player': { category: 'Game Mode', rarity: 'common', requirement: '10 Standard games', standard_games: 10, points: 50 },
        'üèÜ Standard Expert': { category: 'Game Mode', rarity: 'uncommon', requirement: '50 Standard wins', standard_wins: 50, points: 300 },
        'üëë Standard Master': { category: 'Game Mode', rarity: 'rare', requirement: '200 Standard wins', standard_wins: 200, points: 1000 },
        
        // Shapes Defense
        'üõ°Ô∏è Defense Initiate': { category: 'Game Mode', rarity: 'common', requirement: '10 Shapes Defense games', defense_games: 10, points: 50 },
        'üè∞ Fortress Commander': { category: 'Game Mode', rarity: 'uncommon', requirement: '50 Shapes Defense wins', defense_wins: 50, points: 300 },
        'ÔøΩÔ∏è Defense Master': { category: 'Game Mode', rarity: 'rare', requirement: '200 Shapes Defense wins', defense_wins: 200, points: 1000 },
        
        // Rhombus Original
        '‚ô¶Ô∏è Original Player': { category: 'Game Mode', rarity: 'common', requirement: '10 Rhombus Original games', original_games: 10, points: 50 },
        '‚ö° Speed Specialist': { category: 'Game Mode', rarity: 'uncommon', requirement: '50 Rhombus Original wins', original_wins: 50, points: 300 },
        'üíé Original Master': { category: 'Game Mode', rarity: 'rare', requirement: '200 Rhombus Original wins', original_wins: 200, points: 1000 },
        
        // Fortress Mode
        'üè∞ Fortress Beginner': { category: 'Game Mode', rarity: 'common', requirement: '10 Fortress games', fortress_games: 10, points: 50 },
        'ÔøΩ Siege Expert': { category: 'Game Mode', rarity: 'uncommon', requirement: '50 Fortress wins', fortress_wins_mode: 50, points: 300 },
        'üëë Fortress Master': { category: 'Game Mode', rarity: 'rare', requirement: '200 Fortress wins', fortress_wins_mode: 200, points: 1000 },
        
        // Versatility
        'üé® Versatile Player': { category: 'Game Mode', rarity: 'uncommon', requirement: 'Win in all 4 game modes', all_modes: 1, points: 200 },
        'üåü Jack of All Trades': { category: 'Game Mode', rarity: 'rare', requirement: '10 wins in each mode', all_modes_10: 1, points: 600 },
        'üèÜ Master of All': { category: 'Game Mode', rarity: 'epic', requirement: '100 wins in each mode', all_modes_100: 1, points: 3000 },
        
        // ===== üë• SOCIAL BADGES =====
        'üëã Friendly Player': { category: 'Social', rarity: 'common', requirement: '10 games with friends', friend_games: 10, points: 100 },
        'üí¨ Chatty': { category: 'Social', rarity: 'common', requirement: '100 chat messages', chat_messages: 100, points: 50 },
        'ü§ù Good Sport': { category: 'Social', rarity: 'uncommon', requirement: '50 GG reactions', gg_received: 50, points: 200 },
        'üåü Popular Player': { category: 'Social', rarity: 'rare', requirement: '50 friends', friends_count: 50, points: 300 },
        'üëë Community Leader': { category: 'Social', rarity: 'epic', requirement: '100 helpful forum posts', forum_posts: 100, points: 1000 },
        
        // Teaching & Mentoring
        'üéì Teacher': { category: 'Social', rarity: 'uncommon', requirement: 'Help 10 new players', tutorials: 10, points: 300 },
        'üìö Mentor': { category: 'Social', rarity: 'rare', requirement: 'Mentor 25 players', mentorships: 25, points: 750 },
        'üèÜ Master Teacher': { category: 'Social', rarity: 'epic', requirement: 'Create 10 guides', guides_created: 10, points: 1500 },
        
        // Spectating
        'üëÅÔ∏è Observer': { category: 'Social', rarity: 'common', requirement: 'Watch 20 complete games', spectated: 20, points: 50 },
        'üé¨ Spectator': { category: 'Social', rarity: 'uncommon', requirement: 'Watch 100 complete games', spectated: 100, points: 200 },
        'üì∫ Viewer Extraordinaire': { category: 'Social', rarity: 'rare', requirement: 'Watch 500 complete games', spectated: 500, points: 750 },
        
        // ===== üé® CREATOR BADGES =====
        // Game Creation
        'üé® First Creation': { category: 'Creator', rarity: 'common', requirement: 'Create your first game', games_created: 1, points: 100 },
        'üõ†Ô∏è Game Designer': { category: 'Creator', rarity: 'uncommon', requirement: 'Create 10 custom games', games_created: 10, points: 300 },
        'üèóÔ∏è Prolific Creator': { category: 'Creator', rarity: 'rare', requirement: 'Create 50 custom games', games_created: 50, points: 1000 },
        'üëë Master Creator': { category: 'Creator', rarity: 'epic', requirement: 'Create 100 custom games', games_created: 100, points: 3000 },
        
        // Popular Creations
        '‚≠ê First Plays': { category: 'Creator', rarity: 'common', requirement: '10 plays on a game', game_plays: 10, points: 150 },
        'ÔøΩ Popular Game': { category: 'Creator', rarity: 'uncommon', requirement: '100 plays on a game', game_plays: 100, points: 400 },
        'üî• Viral Game': { category: 'Creator', rarity: 'rare', requirement: '1000 plays on a game', game_plays: 1000, points: 1500 },
        'üíé Legendary Creator': { category: 'Creator', rarity: 'legendary', requirement: '10K total plays', total_plays: 10000, points: 5000 },
        
        // Quality & Recognition
        '‚≠ê Well Rated': { category: 'Creator', rarity: 'uncommon', requirement: '4+ star average on 10 games', rated_games: 10, points: 300 },
        'üèÜ Highly Rated': { category: 'Creator', rarity: 'rare', requirement: '4.5+ stars on 20 games', highly_rated: 20, points: 800 },
        'üí´ Perfect Score': { category: 'Creator', rarity: 'epic', requirement: '5 stars with 50+ ratings', perfect_rating: 1, points: 2000 },
        'üëë Game of the Week': { category: 'Creator', rarity: 'legendary', requirement: 'Featured game', featured: 1, points: 3000 },
        
        // Innovation
        'üí° Innovative Mechanic': { category: 'Creator', rarity: 'rare', requirement: 'Create unique mechanic', innovative: 1, points: 1000 },
        'üéØ Balanced Designer': { category: 'Creator', rarity: 'epic', requirement: 'Game with <5% draw rate', balanced_game: 1, points: 2000 },
        'üåü Genre Creator': { category: 'Creator', rarity: 'legendary', requirement: 'Create new game category', genre_creator: 1, points: 5000 },
        
        // ===== üèÖ COMPETITIVE BADGES =====
        // Rating Milestones
        'ü•â Bronze Rank': { category: 'Competitive', rarity: 'common', requirement: 'Reach 1400 rating', rating: 1400, points: 100 },
        'ü•à Silver Rank': { category: 'Competitive', rarity: 'uncommon', requirement: 'Reach 1600 rating', rating: 1600, points: 300 },
        'ü•á Gold Rank': { category: 'Competitive', rarity: 'rare', requirement: 'Reach 1800 rating', rating: 1800, points: 750 },
        'üíé Diamond Rank': { category: 'Competitive', rarity: 'epic', requirement: 'Reach 2000 rating', rating: 2000, points: 2000 },
        'üëë Master Rank': { category: 'Competitive', rarity: 'legendary', requirement: 'Reach 2200 rating', rating: 2200, points: 5000 },
        'üåü Grandmaster': { category: 'Competitive', rarity: 'mythic', requirement: 'Reach 2400+ rating', rating: 2400, points: 10000 },
        
        // Tournament Achievements
        'üèÜ Tournament Participant': { category: 'Competitive', rarity: 'common', requirement: 'Join a tournament', tournaments: 1, points: 100 },
        'üéñÔ∏è Tournament Winner': { category: 'Competitive', rarity: 'rare', requirement: 'Win a tournament', tournament_wins: 1, points: 1000 },
        'ü•á Triple Crown': { category: 'Competitive', rarity: 'epic', requirement: 'Win 3 tournaments', tournament_wins: 3, points: 3000 },
        'üëë Tournament Champion': { category: 'Competitive', rarity: 'legendary', requirement: 'Win 10 tournaments', tournament_wins: 10, points: 10000 },
        
        // Ranked Performance
        'üìà Climber': { category: 'Competitive', rarity: 'uncommon', requirement: '+100 ELO in 30 days', rating_gain_month: 100, points: 200 },
        'üöÄ Rocket Rise': { category: 'Competitive', rarity: 'rare', requirement: '+200 ELO in 30 days', rating_gain_month: 200, points: 500 },
        '‚ö° Meteoric Rise': { category: 'Competitive', rarity: 'epic', requirement: '+300 ELO in 30 days', rating_gain_month: 300, points: 1500 },
        'üèÜ Top 10': { category: 'Competitive', rarity: 'legendary', requirement: 'Reach top 10 on leaderboard', leaderboard_rank: 10, points: 5000 },
        'ÔøΩ #1 Player': { category: 'Competitive', rarity: 'mythic', requirement: 'Reach #1 global rank', leaderboard_rank: 1, points: 25000 },
        
        // ===== üåü RARE & SPECIAL BADGES =====
        // Lucky Achievements
        'üçÄ Lucky Break': { category: 'Rare', rarity: 'rare', requirement: 'Win from forced move', lucky_win: 1, points: 500 },
        'üé∞ Against All Odds': { category: 'Rare', rarity: 'epic', requirement: 'Win with 10% probability', unlikely_win: 1, points: 1500 },
        '‚ú® Miracle': { category: 'Rare', rarity: 'legendary', requirement: 'Win with 1% probability', miracle_win: 1, points: 5000 },
        
        // AI Achievements
        'ü§ñ AI Challenger': { category: 'Rare', rarity: 'common', requirement: '50 games against AI', ai_games: 50, points: 100 },
        'üß† AI Destroyer': { category: 'Rare', rarity: 'rare', requirement: 'Beat AI max difficulty', ai_max_win: 1, points: 750 },
        'üíª Machine Slayer': { category: 'Rare', rarity: 'epic', requirement: '100 wins vs max AI', ai_max_wins: 100, points: 2500 },
        
        // ChatGPT Mode
        'ü§ñüí¨ AI Assisted': { category: 'Rare', rarity: 'common', requirement: 'Use ChatGPT mode 10 times', chatgpt_uses: 10, points: 50 },
        'üß† Learning with AI': { category: 'Rare', rarity: 'uncommon', requirement: 'Follow 50 AI suggestions', chatgpt_followed: 50, points: 200 },
        'üéì AI Graduate': { category: 'Rare', rarity: 'rare', requirement: 'Improve after AI training', ai_improvement: 1, points: 500 },
        
        // ===== üìä ANALYTICS BADGES =====
        'üìä Statistician': { category: 'Analytics', rarity: 'common', requirement: 'View dashboard 50 times', dashboard_views: 50, points: 50 },
        'üìà Data Analyst': { category: 'Analytics', rarity: 'uncommon', requirement: 'Export data 10 times', data_exports: 10, points: 100 },
        'üîç Performance Tracker': { category: 'Analytics', rarity: 'rare', requirement: 'Review 100 replays', replays_viewed: 100, points: 300 },
        'üìù Record Keeper': { category: 'Analytics', rarity: 'uncommon', requirement: 'Set 10 personal records', personal_records: 10, points: 200 },
        'ÔøΩ Achievement Hunter': { category: 'Analytics', rarity: 'rare', requirement: 'Unlock 50 badges', badges_unlocked: 50, points: 500 },
        'üíé Completionist': { category: 'Analytics', rarity: 'epic', requirement: 'Unlock 100 badges', badges_unlocked: 100, points: 2500 },
        'üåü Ultimate Collector': { category: 'Analytics', rarity: 'legendary', requirement: 'Unlock 200 badges', badges_unlocked: 200, points: 10000 },
        
        // ===== üî• LEGENDARY & MYTHIC BADGES =====
        'üèÜ Undefeated Streak': { category: 'Legendary', rarity: 'mythic', requirement: '50-game win streak', win_streak: 50, points: 10000 },
        'üëë Perfect Season': { category: 'Legendary', rarity: 'mythic', requirement: '100 wins in a month (100%)', perfect_season: 1, points: 25000 },
        'üíé Flawless Master': { category: 'Legendary', rarity: 'mythic', requirement: '100 perfect victories in a row', perfect_streak: 100, points: 50000 },
        '‚ö° Lightning God': { category: 'Legendary', rarity: 'mythic', requirement: '100 sub-10-move wins', lightning_wins: 100, points: 50000 },
        'üåü ROMGON Legend': { category: 'Legendary', rarity: 'mythic', requirement: 'Unlock all other badges', all_badges: 1, points: 100000 },
        'üëÅÔ∏è The Architect': { category: 'Legendary', rarity: 'mythic', requirement: '10K plays on one game', architect: 1, points: 25000 },
        'üî• Hall of Fame': { category: 'Legendary', rarity: 'mythic', requirement: 'Top 100 all-time player', hall_of_fame: 1, points: 100000 }
    };
    
    // Populate Settings tab
    function populateSettingsTab() {
        const currentUser = window.currentUser || JSON.parse(localStorage.getItem('romgon-user') || '{}');
        
        // Set current username in input
        const usernameInput = document.getElementById('settings-username-input');
        if (usernameInput && currentUser.username) {
            usernameInput.value = currentUser.username;
        }
        
        // Populate avatar grid
        populateAvatarGrid(currentUser.avatar || 'üòÄ');
        
        // Populate badge grid
        populateBadgeGrid(currentUser);
    }
    
    // Populate avatar selection grid
    function populateAvatarGrid(currentAvatar) {
        const avatarGrid = document.getElementById('avatar-selection-grid');
        if (!avatarGrid) return;
        
        avatarGrid.innerHTML = '';
        
        AVATAR_OPTIONS.forEach(emoji => {
            const avatarBtn = document.createElement('button');
            avatarBtn.className = 'avatar-option';
            if (emoji === currentAvatar) {
                avatarBtn.classList.add('selected');
            }
            avatarBtn.textContent = emoji;
            avatarBtn.onclick = () => selectAvatar(emoji);
            avatarGrid.appendChild(avatarBtn);
        });
    }
    
    // Populate badge selection grid
    function populateBadgeGrid(currentUser) {
        const badgeGrid = document.getElementById('badge-selection-grid');
        if (!badgeGrid) return;
        
        badgeGrid.innerHTML = '';
        
        // Get user stats
        const stats = getUserStats(currentUser.username) || {};
        
        // Group badges by category
        const badgesByCategory = {};
        Object.entries(BADGE_SYSTEM).forEach(([badge, data]) => {
            const category = data.category || 'Other';
            if (!badgesByCategory[category]) {
                badgesByCategory[category] = [];
            }
            badgesByCategory[category].push({ name: badge, data: data });
        });
        
        // Render each category
        Object.entries(badgesByCategory).forEach(([category, badges]) => {
            // Category header
            const categoryHeader = document.createElement('div');
            categoryHeader.style.cssText = `
                grid-column: 1 / -1;
                color: #4ecdc4;
                font-weight: 700;
                font-size: 14px;
                margin-top: 20px;
                margin-bottom: 10px;
                padding-bottom: 5px;
                border-bottom: 2px solid rgba(78, 205, 196, 0.3);
            `;
            categoryHeader.textContent = `${getCategoryIcon(category)} ${category.toUpperCase()}`;
            badgeGrid.appendChild(categoryHeader);
            
            // Render badges in category
            badges.forEach(({ name: badge, data }) => {
                const isUnlocked = checkBadgeUnlocked(data, stats);
                const isSelected = badge === currentUser.badge;
                
                const badgeBtn = document.createElement('button');
                badgeBtn.className = `badge-option ${data.rarity}`;
                
                if (isUnlocked) {
                    badgeBtn.classList.add('unlocked');
                    if (isSelected) {
                        badgeBtn.classList.add('selected');
                    }
                    badgeBtn.onclick = () => selectBadge(badge);
                } else {
                    badgeBtn.classList.add('locked');
                    badgeBtn.disabled = true;
                }
                
                const badgeIcon = badge.split(' ')[0];
                const badgeName = badge.split(' ').slice(1).join(' ');
                
                badgeBtn.innerHTML = `
                    <div class="badge-emoji">${badgeIcon}</div>
                    <div class="badge-name">${badgeName}</div>
                    <div class="badge-rarity-tag ${data.rarity}">${data.rarity}</div>
                    <div class="badge-requirement">${isUnlocked ? '‚úì Unlocked' : 'üîí ' + data.requirement}</div>
                    <div class="badge-points">${data.points} pts</div>
                `;
                
                badgeGrid.appendChild(badgeBtn);
            });
        });
    }
    
    // Get category icon
    function getCategoryIcon(category) {
        const icons = {
            'Achievement': 'üèÜ',
            'Skill': 'üéØ',
            'Strategic': 'üß†',
            'Piece Mastery': '‚ôüÔ∏è',
            'Game Mode': 'üéÆ',
            'Social': 'üë•',
            'Creator': 'üé®',
            'Competitive': 'üèÖ',
            'Rare': 'üåü',
            'Analytics': 'üìä',
            'Legendary': 'üî•'
        };
        return icons[category] || 'üìå';
    }
    
    // Check if badge is unlocked (comprehensive)
    function checkBadgeUnlocked(badgeData, stats) {
        if (badgeData.unlocked) return true;
        
        // Basic stats
        if (badgeData.games_won && stats.gamesWon >= badgeData.games_won) return true;
        if (badgeData.games_played && stats.gamesPlayed >= badgeData.games_played) return true;
        if (badgeData.win_streak && stats.longestWinStreak >= badgeData.win_streak) return true;
        if (badgeData.fastest_win && stats.fastestWin && stats.fastestWin <= badgeData.fastest_win) return true;
        
        // Win rate (must have min games)
        if (badgeData.win_rate && badgeData.min_games) {
            if (stats.gamesPlayed >= badgeData.min_games) {
                const winRate = (stats.gamesWon / stats.gamesPlayed) * 100;
                if (winRate >= badgeData.win_rate) return true;
            }
        }
        
        // Perfect games
        if (badgeData.perfect_wins && stats.perfectWins >= badgeData.perfect_wins) return true;
        if (badgeData.perfect_win && stats.perfectWins >= badgeData.perfect_win) return true;
        
        // Comeback wins
        if (badgeData.comeback_wins && stats.comebackWins >= badgeData.comeback_wins) return true;
        if (badgeData.comeback_from_4 && stats.comebackFrom4 >= badgeData.comeback_from_4) return true;
        
        // Tactical stats
        if (badgeData.forks && stats.forks >= badgeData.forks) return true;
        if (badgeData.pins && stats.pins >= badgeData.pins) return true;
        if (badgeData.discovered_attacks && stats.discoveredAttacks >= badgeData.discovered_attacks) return true;
        
        // Piece-specific stats
        if (badgeData.hexagon_captures && stats.hexagonCaptures >= badgeData.hexagon_captures) return true;
        if (badgeData.triangle_captures && stats.triangleCaptures >= badgeData.triangle_captures) return true;
        if (badgeData.square_blocks && stats.squareBlocks >= badgeData.square_blocks) return true;
        if (badgeData.circle_captures && stats.circleCaptures >= badgeData.circle_captures) return true;
        if (badgeData.rhombus_captures && stats.rhombusCaptures >= badgeData.rhombus_captures) return true;
        
        // Game mode stats
        if (badgeData.standard_games && stats.standardGames >= badgeData.standard_games) return true;
        if (badgeData.standard_wins && stats.standardWins >= badgeData.standard_wins) return true;
        if (badgeData.defense_games && stats.defenseGames >= badgeData.defense_games) return true;
        if (badgeData.defense_wins && stats.defenseWins >= badgeData.defense_wins) return true;
        
        // Rating
        if (badgeData.rating && stats.rating >= badgeData.rating) return true;
        
        // Tournament
        if (badgeData.tournaments && stats.tournaments >= badgeData.tournaments) return true;
        if (badgeData.tournament_wins && stats.tournamentWins >= badgeData.tournament_wins) return true;
        
        // Social
        if (badgeData.friend_games && stats.friendGames >= badgeData.friend_games) return true;
        if (badgeData.chat_messages && stats.chatMessages >= badgeData.chat_messages) return true;
        if (badgeData.friends_count && stats.friendsCount >= badgeData.friends_count) return true;
        
        // Creator
        if (badgeData.games_created && stats.gamesCreated >= badgeData.games_created) return true;
        if (badgeData.game_plays && stats.maxGamePlays >= badgeData.game_plays) return true;
        if (badgeData.total_plays && stats.totalCreatorPlays >= badgeData.total_plays) return true;
        
        // Analytics
        if (badgeData.badges_unlocked && stats.badgesUnlocked >= badgeData.badges_unlocked) return true;
        if (badgeData.dashboard_views && stats.dashboardViews >= badgeData.dashboard_views) return true;
        
        // AI stats
        if (badgeData.ai_games && stats.aiGames >= badgeData.ai_games) return true;
        if (badgeData.ai_max_win && stats.aiMaxWin >= badgeData.ai_max_win) return true;
        if (badgeData.ai_max_wins && stats.aiMaxWins >= badgeData.ai_max_wins) return true;
        
        // Captures
        if (badgeData.total_captures && stats.totalCaptures >= badgeData.total_captures) return true;
        
        return false;
    }
    
    // Select avatar
    async function selectAvatar(emoji) {
        const currentUser = window.currentUser || JSON.parse(localStorage.getItem('romgon-user') || '{}');
        
        // Update local user data
        currentUser.avatar = emoji;
        localStorage.setItem('romgon-user', JSON.stringify(currentUser));
        window.currentUser = currentUser;
        
        // Update UI
        populateAvatarGrid(emoji);
        updateGlobalAccountBar();
        
        // Update backend if registered user
        if (currentUser.id && currentUser.type !== 'guest') {
            try {
                await updateUserProfile({ avatar: emoji });
                showNotification('‚úÖ Avatar updated!', 'success');
            } catch (error) {
                console.error('Failed to update avatar on backend:', error);
                showNotification('‚ö†Ô∏è Avatar saved locally only', 'warning');
            }
        } else {
            showNotification('‚úÖ Avatar updated!', 'success');
        }
    }
    
    // Select badge
    async function selectBadge(badge) {
        const currentUser = window.currentUser || JSON.parse(localStorage.getItem('romgon-user') || '{}');
        
        // Update local user data
        currentUser.badge = badge;
        localStorage.setItem('romgon-user', JSON.stringify(currentUser));
        window.currentUser = currentUser;
        
        // Update UI
        populateBadgeGrid(currentUser);
        updateGlobalAccountBar();
        
        // Update backend if registered user
        if (currentUser.id && currentUser.type !== 'guest') {
            try {
                await updateUserProfile({ badge: badge });
                showNotification('‚úÖ Badge equipped!', 'success');
            } catch (error) {
                console.error('Failed to update badge on backend:', error);
                showNotification('‚ö†Ô∏è Badge saved locally only', 'warning');
            }
        } else {
            showNotification('‚úÖ Badge equipped!', 'success');
        }
    }
    
    // Save username
    async function saveUsername() {
        const usernameInput = document.getElementById('settings-username-input');
        const newUsername = usernameInput.value.trim();
        
        if (!newUsername) {
            showNotification('‚ùå Username cannot be empty', 'error');
            return;
        }
        
        if (newUsername.length < 3 || newUsername.length > 20) {
            showNotification('‚ùå Username must be 3-20 characters', 'error');
            return;
        }
        
        const currentUser = window.currentUser || JSON.parse(localStorage.getItem('romgon-user') || '{}');
        
        if (newUsername === currentUser.username) {
            showNotification('‚ö†Ô∏è Username unchanged', 'warning');
            return;
        }
        
        // Update local user data
        currentUser.username = newUsername;
        localStorage.setItem('romgon-user', JSON.stringify(currentUser));
        window.currentUser = currentUser;
        
        // Update UI
        updateGlobalAccountBar();
        
        // Update backend if registered user
        if (currentUser.id && currentUser.type !== 'guest') {
            try {
                await updateUserProfile({ username: newUsername });
                showNotification('‚úÖ Username updated!', 'success');
            } catch (error) {
                console.error('Failed to update username on backend:', error);
                showNotification('‚ö†Ô∏è Username saved locally only', 'warning');
            }
        } else {
            showNotification('‚úÖ Username updated!', 'success');
        }
    }
    
    // Confirm account deletion
    function confirmDeleteAccount() {
        if (confirm('‚ö†Ô∏è Are you sure you want to delete your account? This action cannot be undone.\n\nAll your stats, games, and progress will be permanently deleted.')) {
            deleteAccount();
        }
    }
    
    // Delete account
    async function deleteAccount() {
        const currentUser = window.currentUser || JSON.parse(localStorage.getItem('romgon-user') || '{}');
        
        if (currentUser.id && currentUser.type !== 'guest') {
            try {
                const response = await fetch('https://api.romgon.net/api/users/delete', {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('romgon-jwt')}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (response.ok) {
                    // Clear all data
                    localStorage.removeItem('romgon-user');
                    localStorage.removeItem('romgon-jwt');
                    window.currentUser = null;
                    
                    showNotification('‚úÖ Account deleted', 'success');
                    
                    // Return to splash page
                    setTimeout(() => {
                        window.location.reload();
                    }, 1500);
                } else {
                    showNotification('‚ùå Failed to delete account', 'error');
                }
            } catch (error) {
                console.error('Failed to delete account:', error);
                showNotification('‚ùå Connection error', 'error');
            }
        } else {
            // Guest account - just clear local data
            localStorage.removeItem('romgon-user');
            window.currentUser = null;
            showNotification('‚úÖ Guest data cleared', 'success');
            setTimeout(() => {
                window.location.reload();
            }, 1500);
        }
    }
    
    // ===== END SETTINGS TAB FUNCTIONS =====
    
    // Update Player Hub on modal show with real backend data
    async function updatePlayerHubData() {
        const currentUser = window.currentUser || JSON.parse(localStorage.getItem('romgon-user') || '{}');
        
        // Show loading indicator
        showLoadingIndicator('Loading your stats...');
        
        try {
            // Check if user is registered and has ID
            const isGuest = currentUser.type === 'guest' || !currentUser.id;
            
            if (isGuest) {
                // Guest user - show local data
                hideLoadingIndicator();
                displayGuestStats(currentUser);
                return;
            }
            
            // Registered user - fetch real stats from backend
            const stats = await romgonAPI.getPlayerStats(currentUser.id);
            
            hideLoadingIndicator();
            displayRegisteredUserStats(currentUser, stats);
            
        } catch (error) {
            console.error('‚ùå Failed to load player stats:', error);
            hideLoadingIndicator();
            
            // Fallback to localStorage
            displayLocalStats(currentUser);
        }
    }
    
    // Display guest stats
    function displayGuestStats(user) {
        document.getElementById('account-sidebar-name').textContent = 'Guest Player';
        document.getElementById('account-sidebar-email').textContent = 'Session: ' + (user.id || 'Anonymous');
        document.getElementById('account-sidebar-date').textContent = 'Not registered';
        document.getElementById('account-member-level').textContent = 'Guest';
        document.getElementById('account-total-games').textContent = '0';
        
        document.getElementById('account-avatar').textContent = 'üë§';
        document.getElementById('account-username').textContent = 'Guest Player';
        document.getElementById('account-email').textContent = 'Session: Anonymous';
        
        // Use local stats if available
        document.getElementById('account-wins').textContent = user.wins || 0;
        document.getElementById('account-losses').textContent = user.losses || 0;
        const total = (user.wins || 0) + (user.losses || 0);
        document.getElementById('account-games').textContent = total;
        document.getElementById('account-winrate').textContent = total > 0 ? Math.round((user.wins / total) * 100) + '%' : '0%';
        
        // Activity
        document.getElementById('account-last-login').textContent = 'Never';
        document.getElementById('account-saved-games').textContent = '0';
        document.getElementById('account-total-moves').textContent = '0';
        document.getElementById('account-total-captures').textContent = '0';
        
        // Hide delete button for guests
        const deleteBtn = document.querySelector('button[onclick="deleteAccount()"]');
        if (deleteBtn) deleteBtn.style.display = 'none';
    }
    
    // Display registered user stats from backend
    function displayRegisteredUserStats(user, stats) {
        // Update sidebar
        document.getElementById('account-sidebar-name').textContent = stats.username || user.username;
        document.getElementById('account-sidebar-email').textContent = user.email || 'No email';
        
        const createdDate = new Date(stats.timestamps?.createdAt || Date.now());
        document.getElementById('account-sidebar-date').textContent = createdDate.toLocaleDateString();
        
        // Member level from backend
        document.getElementById('account-member-level').textContent = stats.tier?.name || 'Bronze';
        document.getElementById('account-total-games').textContent = stats.stats?.games?.total || 0;
        
        // Avatar
        const avatarEl = document.getElementById('account-avatar');
        if (user.picture) {
            avatarEl.innerHTML = `<img src="${user.picture}" style="width: 100%; height: 100%; object-fit: cover;" />`;
        } else {
            const initials = (stats.username || 'U').charAt(0).toUpperCase();
            avatarEl.textContent = initials;
            avatarEl.style.fontSize = '3em';
        }
        
        // Main content
        document.getElementById('account-username').textContent = stats.username || user.username;
        document.getElementById('account-email').textContent = user.email || 'No email';
        
        // Stats from backend
        document.getElementById('account-wins').textContent = stats.stats?.games?.wins || 0;
        document.getElementById('account-losses').textContent = stats.stats?.games?.losses || 0;
        document.getElementById('account-games').textContent = stats.stats?.games?.total || 0;
        document.getElementById('account-winrate').textContent = (stats.stats?.games?.winRate || 0) + '%';
        
        // Activity
        document.getElementById('account-last-login').textContent = stats.timestamps?.updatedAt 
            ? new Date(stats.timestamps.updatedAt).toLocaleString()
            : 'Never';
        document.getElementById('account-saved-games').textContent = stats.recentGames?.length || 0;
        document.getElementById('account-total-moves').textContent = stats.stats?.moves?.total || 0;
        document.getElementById('account-total-captures').textContent = stats.stats?.captures?.total || 0;
        
        // Rating information
        document.getElementById('hub-current-rating').textContent = stats.rating || 1600;
        
        if (stats.tier) {
            const tierEmojis = {
                'Bronze': 'ü•â',
                'Silver': 'ü•à', 
                'Gold': 'ü•á',
                'Platinum': 'üíé',
                'Diamond': 'üí†',
                'Master': 'üëë',
                'Grandmaster': 'üèÜ'
            };
            const emoji = tierEmojis[stats.tier.name] || 'üéÆ';
            document.getElementById('hub-rating-tier').textContent = emoji + ' ' + stats.tier.name;
            document.getElementById('hub-rating-tier').style.color = stats.tier.color || '#fff';
        }
        
        // Rating stats
        document.getElementById('hub-rating-games').textContent = stats.stats?.games?.total || 0;
        document.getElementById('hub-rating-changes').textContent = stats.recentGames?.length || 0;
        
        // Recent games
        displayRecentGames(stats.recentGames || []);
        
        console.log('‚úÖ Player Hub updated with backend data:', stats);
    }
    
    // Display local fallback stats
    function displayLocalStats(user) {
        const allUsers = JSON.parse(localStorage.getItem('romgon-users') || '{}');
        const userAccount = allUsers[user.username];
        
        if (userAccount) {
            document.getElementById('account-sidebar-name').textContent = userAccount.username;
            document.getElementById('account-sidebar-email').textContent = userAccount.email;
            document.getElementById('account-sidebar-date').textContent = new Date(userAccount.registeredDate).toLocaleDateString();
            
            const stats = userAccount.stats || {};
            document.getElementById('account-wins').textContent = stats.gamesWon || 0;
            document.getElementById('account-losses').textContent = stats.gamesLost || 0;
            document.getElementById('account-games').textContent = stats.gamesPlayed || 0;
            
            const winRate = stats.gamesPlayed > 0 ? Math.round((stats.gamesWon / stats.gamesPlayed) * 100) : 0;
            document.getElementById('account-winrate').textContent = winRate + '%';
        }
    }
    
    // Display recent games in rating history
    function displayRecentGames(recentGames) {
        const ratingHistoryContainer = document.getElementById('hub-rating-history');
        
        if (!recentGames || recentGames.length === 0) {
            ratingHistoryContainer.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">No games played yet</div>';
            return;
        }
        
        ratingHistoryContainer.innerHTML = recentGames.map(game => {
            const isWin = game.result === 'win';
            const changeColor = isWin ? '#27ae60' : '#e74c3c';
            const resultIcon = isWin ? '‚úÖ' : '‚ùå';
            const completedDate = new Date(game.completedAt).toLocaleDateString();
            
            return `
                <div style="
                    background: rgba(0, 0, 0, 0.3);
                    padding: 14px;
                    border-radius: 10px;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    border-left: 4px solid ${changeColor};
                    margin-bottom: 8px;
                ">
                    <div style="flex: 1;">
                        <div style="color: #fff; font-weight: 600; margin-bottom: 4px;">
                            ${resultIcon} ${isWin ? 'Victory' : 'Defeat'} ‚Ä¢ ${completedDate}
                        </div>
                        <div style="color: #999; font-size: 0.85em;">
                            Playing as ${game.playerColor} ‚Ä¢ ${game.totalMoves} moves
                        </div>
                        <div style="color: #777; font-size: 0.75em; margin-top: 2px;">
                            ${game.reason}
                        </div>
                    </div>
                </div>
            `;
        }).join('');
    }
    
    // Modified showAccountModal to use new Player Hub
    // COMMENTED OUT - Using backend-integrated version at line 2424
    /*
    const originalShowAccountModal = showAccountModal;
    showAccountModal = function() {
        updatePlayerHubData();
        switchAccountTab('overview');
        document.getElementById('account-modal').style.display = 'block';
    };
    */
    
    function deleteAccount() {
        const confirmed = confirm('Are you sure? This will permanently delete your account and all progress.');
        if (!confirmed) return;
        
        const currentUser = JSON.parse(localStorage.getItem('romgon-user'));
        if (!currentUser || !currentUser.username) return;
        
        const allUsers = JSON.parse(localStorage.getItem('romgon-users') || '{}');
        delete allUsers[currentUser.username];
        localStorage.setItem('romgon-users', JSON.stringify(allUsers));
        
        hideAccountModal();
        quitAndLogout();
        alert('Your account has been deleted.');
    }
    
    // Settings Modal Functions
    function showSettingsModal() {
        const currentUser = JSON.parse(localStorage.getItem('romgon-user'));
        const allUsers = JSON.parse(localStorage.getItem('romgon-users') || '{}');
        
        // Allow both registered and guest users to access settings
        let userSettings = {};
        
        if (currentUser && currentUser.username && allUsers[currentUser.username]) {
            // Registered user - load their settings
            userSettings = allUsers[currentUser.username].settings;
        } else {
            // Guest user - use default settings
            userSettings = {
                audioEnabled: true,
                theme: 'dark',
                boardZoom: 1
            };
        }
        
        // Load current settings
        document.getElementById('settings-audio').checked = userSettings.audioEnabled !== false;
        document.getElementById('settings-theme').value = userSettings.theme || 'dark';
        document.getElementById('settings-zoom').value = userSettings.boardZoom || 1;
        updateZoomDisplay();
        
        document.getElementById('settings-modal').style.display = 'block';
    }
    
    function hideSettingsModal() {
        document.getElementById('settings-modal').style.display = 'none';
    }
    
    function handleSettingsSave(event) {
        event.preventDefault();
        
        const currentUser = JSON.parse(localStorage.getItem('romgon-user'));
        const allUsers = JSON.parse(localStorage.getItem('romgon-users') || '{}');
        
        const audioEnabled = document.getElementById('settings-audio').checked;
        const theme = document.getElementById('settings-theme').value;
        const zoom = parseFloat(document.getElementById('settings-zoom').value);
        
        // Save settings
        if (currentUser && currentUser.username && allUsers[currentUser.username]) {
            // Registered user - save to their profile
            allUsers[currentUser.username].settings = {
                audioEnabled: audioEnabled,
                theme: theme,
                boardZoom: zoom
            };
            localStorage.setItem('romgon-users', JSON.stringify(allUsers));
        } else {
            // Guest user - save to localStorage with 'guest' key
            localStorage.setItem('romgon-guest-settings', JSON.stringify({
                audioEnabled: audioEnabled,
                theme: theme,
                boardZoom: zoom
            }));
        }
        
        // Apply theme if needed
        if (theme === 'wooden') {
            document.body.classList.add('wooden-theme');
        } else {
            document.body.classList.remove('wooden-theme');
        }
        
        console.log('‚úÖ Settings saved');
        hideSettingsModal();
    }
    
    function updateZoomDisplay() {
        const zoomValue = parseFloat(document.getElementById('settings-zoom').value);
        document.getElementById('zoom-value').textContent = Math.round(zoomValue * 100) + '%';
    }
    
    // Add zoom slider listener
    document.addEventListener('DOMContentLoaded', function() {
        const zoomSlider = document.getElementById('settings-zoom');
        if (zoomSlider) {
            zoomSlider.addEventListener('input', updateZoomDisplay);
        }
    });
    
    // NEW: Tab switching for preferences
    function switchPrefsTab(tabName) {
        console.log('Switching to tab:', tabName);
        
        // Hide all panels
        document.querySelectorAll('.pref-panel').forEach(panel => {
            panel.style.display = 'none';
        });
        
        // Remove active class from all tabs
        document.querySelectorAll('.pref-tab').forEach(tab => {
            tab.style.color = '#888';
            tab.style.borderBottom = '3px solid transparent';
        });
        
        // Show selected panel with proper flex settings
        const panel = document.getElementById('pref-panel-' + tabName);
        if (panel) {
            panel.style.display = 'flex';
            panel.style.flexDirection = 'column';
            panel.style.gap = '24px';
            console.log('Panel shown:', 'pref-panel-' + tabName);
        } else {
            console.error('Panel not found:', 'pref-panel-' + tabName);
        }
        
        // Activate selected tab
        const activeTab = document.getElementById('tab-' + tabName);
        if (activeTab) {
            activeTab.style.color = '#fff';
            activeTab.style.borderBottom = '3px solid #a55eea';
        } else {
            console.error('Tab button not found:', 'tab-' + tabName);
        }
    }
    
    // NEW: Mockup functions (to be implemented later)
    function exportUserData() {
        const currentUser = JSON.parse(localStorage.getItem('romgon-user') || '{}');
        const allUsers = JSON.parse(localStorage.getItem('romgon-users') || '{}');
        const myGames = JSON.parse(localStorage.getItem('romgon_my_published_games') || '[]');
        
        const exportData = {
            user: currentUser,
            userData: allUsers[currentUser.username],
            myGames: myGames,
            exportDate: new Date().toISOString()
        };
        
        const blob = new Blob([JSON.stringify(exportData, null, 2)], {type: 'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `romgon_backup_${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
        
        alert('‚úÖ Data exported successfully!');
    }
    
    function importUserData() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = (e) => {
            const file = e.target.files[0];
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const data = JSON.parse(event.target.result);
                    // TODO: Implement import logic
                    alert('‚úÖ Data imported successfully!\n\n(Feature in development - data validation pending)');
                } catch (err) {
                    alert('‚ùå Invalid backup file!');
                }
            };
            reader.readAsText(file);
        };
        input.click();
    }
    
    function clearAllData() {
        if (confirm('‚ö†Ô∏è Are you sure you want to delete ALL local data?\n\nThis will remove:\n‚Ä¢ Your account\n‚Ä¢ All custom games\n‚Ä¢ All statistics\n‚Ä¢ All settings\n\nThis action CANNOT be undone!')) {
            if (confirm('‚ö†Ô∏è‚ö†Ô∏è FINAL WARNING ‚ö†Ô∏è‚ö†Ô∏è\n\nAre you ABSOLUTELY sure?')) {
                localStorage.clear();
                alert('üóëÔ∏è All data cleared!\n\nThe page will now reload.');
                window.location.reload();
            }
        }
    }
    
    function resetToDefaults() {
        if (confirm('üîÑ Reset all settings to defaults?\n\nThis will not delete your games or account.')) {
            // Reset form values to defaults
            document.getElementById('settings-audio').checked = true;
            document.getElementById('settings-move-sounds').checked = true;
            document.getElementById('settings-capture-sounds').checked = true;
            document.getElementById('settings-notifications').checked = true;
            document.getElementById('settings-theme').value = 'dark';
            document.getElementById('settings-zoom').value = 1;
            updateZoomDisplay();
            
            // Gameplay
            document.getElementById('settings-show-legal-moves').checked = true;
            document.getElementById('settings-show-attack-moves').checked = true;
            document.getElementById('settings-confirm-moves').checked = false;
            document.getElementById('settings-auto-queen').checked = true;
            document.getElementById('settings-drag-drop').checked = true;
            document.getElementById('settings-click-move').checked = true;
            document.getElementById('settings-show-coords').checked = false;
            document.getElementById('settings-engine-analysis').checked = false;
            
            // Custom Games
            document.getElementById('settings-default-board').value = '7x7';
            document.getElementById('settings-auto-save').checked = true;
            document.getElementById('settings-show-grid').checked = true;
            document.getElementById('settings-game-visibility').value = 'public';
            document.getElementById('settings-allow-remixes').checked = true;
            document.getElementById('settings-show-creator-name').checked = true;
            
            // Account
            document.getElementById('settings-display-name').value = '';
            document.getElementById('settings-email').value = '';
            document.getElementById('settings-show-stats').checked = true;
            document.getElementById('settings-show-online').checked = true;
            document.getElementById('settings-allow-challenges').checked = true;
            document.getElementById('settings-guest-access').checked = true;
            
            // Advanced
            document.getElementById('settings-hardware-accel').checked = true;
            document.getElementById('settings-animations').checked = true;
            document.getElementById('settings-debug-mode').checked = false;
            document.getElementById('settings-fps-counter').checked = false;
            
            alert('‚úÖ All settings reset to defaults!');
        }
    }
    
    // ============================================
    // STATISTICS TRACKING SYSTEM
    // ============================================
    
    // Initialize or get user statistics
    function getUserStats(username) {
        const allUsers = JSON.parse(localStorage.getItem('romgon-users') || '{}');
        if (!allUsers[username]) return null;
        
        // Ensure stats object exists and has proper structure
        const user = allUsers[username];
        if (!user.stats) {
            user.stats = {
                gamesPlayed: 0,
                gamesWon: 0,
                gamesLost: 0,
                gamesDrawn: 0
            };
            // Save the updated user back to localStorage
            localStorage.setItem('romgon-users', JSON.stringify(allUsers));
        }
        
        return {
            gamesPlayed: user.stats.gamesPlayed || 0,
            gamesWon: user.stats.gamesWon || 0,
            gamesLost: user.stats.gamesLost || 0,
            gamesDrawn: user.stats.gamesDrawn || 0,
            lastLogin: user.lastLogin || null,
            savedGames: user.savedGames || [],
            pieceStats: user.pieceStats || {
                square: { captures: 0, survived: 0, lost: 0 },
                triangle: { captures: 0, survived: 0, lost: 0 },
                rhombus: { captures: 0, survived: 0, lost: 0 },
                circle: { captures: 0, survived: 0, lost: 0 },
                hexagon: { captures: 0, survived: 0, lost: 0 }
            },
            longestWinStreak: user.longestWinStreak || 0,
            fastestWin: user.fastestWin || null,
            totalCaptures: user.totalCaptures || 0,
            totalMoves: user.totalMoves || 0,
            registeredDate: user.registeredDate
        };
    }
    
    // Update user statistics after game ends
    function recordGameResult(username, result) {
        // result = { winner: 'username', loser: 'username', moves: number, captureCount: number }
        const allUsers = JSON.parse(localStorage.getItem('romgon-users') || '{}');
        
        if (!allUsers[username]) return false;
        
        const stats = allUsers[username].stats;
        stats.gamesPlayed = (stats.gamesPlayed || 0) + 1;
        
        if (result.winner === username) {
            stats.gamesWon = (stats.gamesWon || 0) + 1;
        } else if (result.loser === username) {
            stats.gamesLost = (stats.gamesLost || 0) + 1;
        } else {
            stats.gamesDrawn = (stats.gamesDrawn || 0) + 1;
        }
        
        // Update fastest win
        if (result.winner === username) {
            const fastestWin = allUsers[username].fastestWin || result.moves;
            allUsers[username].fastestWin = Math.min(fastestWin, result.moves);
        }
        
        // Track total captures
        allUsers[username].totalCaptures = (allUsers[username].totalCaptures || 0) + (result.captureCount || 0);
        allUsers[username].totalMoves = (allUsers[username].totalMoves || 0) + result.moves;
        
        localStorage.setItem('romgon-users', JSON.stringify(allUsers));
        return true;
    }
    
    // Record last login
    function recordLastLogin(username) {
        const allUsers = JSON.parse(localStorage.getItem('romgon-users') || '{}');
        if (!allUsers[username]) return false;
        
        allUsers[username].lastLogin = new Date().toISOString();
        localStorage.setItem('romgon-users', JSON.stringify(allUsers));
        return true;
    }
    
    // Save game state
    function saveGame(username, gameName, gameData) {
        const allUsers = JSON.parse(localStorage.getItem('romgon-users') || '{}');
        if (!allUsers[username]) return false;
        
        if (!allUsers[username].savedGames) {
            allUsers[username].savedGames = [];
        }
        
        const savedGame = {
            name: gameName,
            timestamp: new Date().toISOString(),
            data: gameData
        };
        
        allUsers[username].savedGames.push(savedGame);
        localStorage.setItem('romgon-users', JSON.stringify(allUsers));
        return true;
    }
    
    // Get saved games
    function getSavedGames(username) {
        const stats = getUserStats(username);
        return stats ? stats.savedGames : [];
    }
    
    // Get win/loss ratio
    function getWinRate(username) {
        const stats = getUserStats(username);
        if (!stats || stats.gamesPlayed === 0) return 0;
        return Math.round((stats.gamesWon / stats.gamesPlayed) * 100);
    }
    
    // Get average moves per game
    function getAvgMovesPerGame(username) {
        const stats = getUserStats(username);
        if (!stats || stats.gamesPlayed === 0) return 0;
        return Math.round(stats.totalMoves / stats.gamesPlayed);
    }
    
    // Get total captures
    function getTotalCaptures(username) {
        const stats = getUserStats(username);
        return stats ? stats.totalCaptures : 0;
    }
    
    // Demo function: Simulate a game result for testing
    function simulateGameResult(username) {
        if (!username) {
            console.warn('No username provided for simulation');
            return false;
        }
        
        const result = {
            winner: username,
            loser: 'AI',
            moves: Math.floor(Math.random() * 80) + 20,
            captureCount: Math.floor(Math.random() * 8) + 3
        };
        
        recordGameResult(username, result);
        console.log('‚úÖ Demo: Game result recorded:', result);
        
        // Refresh the stats dashboard if it's displayed
        renderStatsDashboard();
        
        return true;
    }
    
    // Render opening book content (placeholder for now)
    // --- Opening Book Data ---
    const OPENING_BOOK = [
    {
        name: 'Triangle Coop',
        rpn: 'S4s/1T05/C5t0h0/R7r/H0T05c/5t01/S4s b 2 - - - t5-6>5-5;T1-0>1-1;t1-6>2-6;T5-0>4-1 whiteblack - -',
        moves: ['t5-6>5-5', 't1-6>2-6'],
        description: 'Both black triangles advance cooperatively.'
    },
    {
        name: 'Triangle Coop',
        rpn: 'S4s/1T05/C5t0h0/R7r/H0T05c/5t01/S4s b 2 - - - t5-6>5-5;T1-0>1-1;t1-6>2-6;T5-0>4-1 whiteblack - -',
        moves: ['T1-0>1-1', 'T5-0>4-1'],
        description: 'Both white triangles advance cooperatively.'
    },
    {
        name: '2 Square Advance',
        rpn: '6/T0S3st0/C6h0/R7r/H06c/T0S3st0/6 b 2 - - - s6-5>5-5;S0-0>1-1;s0-5>1-5;S6-0>5-1 whiteblack - -',
        moves: ['s6-5>5-5', 's0-5>1-5'],
        description: 'Both black squares advance aggressively on the right.'
    },
    {
        name: '2 Square Advance',
        rpn: '6/T0S3st0/C6h0/R7r/H06c/T0S3st0/6 b 2 - - - s6-5>5-5;S0-0>1-1;s0-5>1-5;S6-0>5-1 whiteblack - -',
        moves: ['S0-0>1-1', 'S6-0>5-1'],
        description: 'Both white squares advance aggressively on the left.'
    },
    // --- User-supplied and mirrored openings ---
    {
        name: 'Rhombus Roster (Black)',
        rpn: 'r3-8>3-6 c4-7>4-6',
        moves: ['r3-8>3-6', 'c4-7>4-6'],
        description: 'Black rhombus and circle both advance on the right.'
    },
    {
        name: 'Rhombus Roster (White)',
        rpn: 'R3-0>3-2 C2-0>2-1',
        moves: ['R3-0>3-2', 'C2-0>2-1'],
        description: 'White rhombus and circle both advance on the left.'
    },
    {
        name: 'Hexagon Push (Black)',
        rpn: 's6-5>5-5 h2-7>3-6',
        moves: ['s6-5>5-5', 'h2-7>3-6'],
        description: 'Black square and hexagon push forward.'
    },
    {
        name: 'Hexagon Push (White)',
        rpn: 'S0-0>1-1 H4-0>3-2',
        moves: ['S0-0>1-1', 'H4-0>3-2'],
        description: 'White square and hexagon push forward.'
    },
    {
        name: 'Rhombus Straw',
        rpn: 'r3-8>3-6 r3-6>3-4',
        moves: ['r3-8>3-6', 'r3-6>3-4'],
        description: 'Black rhombus advances twice down the center.'
    },
    {
        name: 'Rhombus Straw',
        rpn: 'R3-0>3-2 R3-2>3-4',
        moves: ['R3-0>3-2', 'R3-2>3-4'],
        description: 'White rhombus advances twice up the center.'
    },
        {
            name: 'Triangle Gateway Attack',
            rpn: 'T2-1-3-2 s5-0-5-1',
            moves: ['T2-1-3-2', 's5-0-5-1'],
            description: 'Triangle advances through the gateway, black responds with central square.'
        },
        {
            name: 'Central Hexagon Push',
            rpn: 'H3-2-3-3 t4-1-4-2',
            moves: ['H3-2-3-3', 't4-1-4-2'],
            description: 'Hexagon pushes to the center, triangle responds.'
        },
        {
            name: 'Rhombus Diagonal Entry',
            rpn: 'R3-0-2-1 s1-0-1-1',
            moves: ['R3-0-2-1', 's1-0-1-1'],
            description: 'Rhombus enters diagonally, square advances.'
        },
        {
            name: 'Circle Central Jump',
            rpn: 'C0-2-2-3 h3-2-rotR',
            moves: ['C0-2-2-3', 'h3-2-rotR'],
            description: 'Circle jumps to center, hexagon rotates right.'
        },
        {
            name: 'Square Side Push',
            rpn: 'S1-0-2-0 t4-1-3-2',
            moves: ['S1-0-2-0', 't4-1-3-2'],
            description: 'Square pushes side, triangle advances.'
        },
        {
            name: 'Triangle Flank Advance',
            rpn: 'T4-1-5-2 s1-0-1-1',
            moves: ['T4-1-5-2', 's1-0-1-1'],
            description: 'Triangle advances on the flank, square responds.'
        },
        {
            name: 'Hexagon Diagonal Move',
            rpn: 'H3-2-2-3 c0-2-2-1',
            moves: ['H3-2-2-3', 'c0-2-2-1'],
            description: 'Hexagon moves diagonally, circle jumps.'
        },
        {
            name: 'Rhombus Central Advance',
            rpn: 'R3-0-3-1 h3-2-3-3',
            moves: ['R3-0-3-1', 'h3-2-3-3'],
            description: 'Rhombus advances centrally, hexagon pushes.'
        },
        {
            name: 'Square Central Advance',
            rpn: 'S5-0-5-1 t2-1-2-2',
            moves: ['S5-0-5-1', 't2-1-2-2'],
            description: 'Square advances to center, triangle pushes.'
        },
        {
            name: 'Circle Zone Jump',
            rpn: 'C0-2-1-3 r3-0-4-1',
            moves: ['C0-2-1-3', 'r3-0-4-1'],
            description: 'Circle jumps to zone, rhombus enters.'
        },
        {
            name: 'Hexagon Rotate Left',
            rpn: 'H3-2-rotL t2-1-3-2',
            moves: ['H3-2-rotL', 't2-1-3-2'],
            description: 'Hexagon rotates left, triangle advances.'
        },
        {
            name: 'Triangle Central Push',
            rpn: 'T2-1-2-2 s5-0-4-0',
            moves: ['T2-1-2-2', 's5-0-4-0'],
            description: 'Triangle pushes to center, square flanks.'
        },
        {
            name: 'Square Flank Push',
            rpn: 'S1-0-2-0 h3-2-2-3',
            moves: ['S1-0-2-0', 'h3-2-2-3'],
            description: 'Square flanks, hexagon moves.'
        },
        {
            name: 'Rhombus Flank Entry',
            rpn: 'R3-0-4-1 t4-1-4-2',
            moves: ['R3-0-4-1', 't4-1-4-2'],
            description: 'Rhombus enters on the flank, triangle responds.'
        },
        {
            name: 'Hexagon Rotate Right',
            rpn: 'H3-2-rotR s1-0-1-1',
            moves: ['H3-2-rotR', 's1-0-1-1'],
            description: 'Hexagon rotates right, square advances.'
        },
        {
            name: 'Hexagon Push',
            rpn: 's6-5>5-5 h2-7>3-6',
            moves: ['s6-5>5-5', 'h2-7>3-6'],
            description: 'Square pushes, hexagon advances.'
        },
        {
            name: 'Rhombus Roster',
            rpn: 'r3-8>3-6 c4-7>4-6',
            moves: ['r3-8>3-6', 'c4-7>4-6'],
            description: 'Rhombus and circle both advance.'
        }
    ];

    // Update the small side-panel indicators showing the active base variant
    function updateVariantIndicators() {
        try {
            var label = (window.baseDefenseVariant === 'shape-defense') ? 'BASE: Shape Defence' : 'BASE: Original';
            var w = document.getElementById('white-variant-indicator');
            var b = document.getElementById('black-variant-indicator');
            if (w) w.textContent = label;
            if (b) b.textContent = label;
        } catch (e) {
            // Fail silently if indicators missing
        }
    }

    // Render a mini board for a given RPN (simple static rendering)
    function renderMiniBoardForRPN(rpn) {
        // For now, just show the RPN as text. (Can be replaced with a real mini board renderer)
        return `<div style='font-size: 0.9em; color: #4ecdc4; background: #181b20; border-radius: 6px; padding: 6px 10px; margin: 4px 0;'>${rpn}</div>`;
    }

    function renderOpeningBook() {
        const content = document.getElementById('opening-book-content');
        // Helper: get side from name
        function getSide(name) {
            if (name.toLowerCase().includes('white')) return 'White';
            if (name.toLowerCase().includes('black')) return 'Black';
            return 'Both';
        }
        // Helper: piece icon
        function pieceIcon(move) {
            const p = move[0].toLowerCase();
            if (p === 's') return '‚ñ†';
            if (p === 't') return '‚ñ≤';
            if (p === 'r') return '‚óÜ';
            if (p === 'c') return '‚óè';
            if (p === 'h') return '‚¨°';
            return '';
        }
        // Helper: color for side
        function sideColor(side) {
            if (side === 'White') return '#4ecdc4';
            if (side === 'Black') return '#ffd700';
            return '#aaa';
        }
        let html = `<table style='width:100%; border-collapse:collapse; margin-top:10px;'>
            <thead>
                <tr style='background:#23272e; color:#4ecdc4;'>
                    <th style='padding:8px 4px; text-align:left;'>Opening Name</th>
                    <th style='padding:8px 4px; text-align:left;'>Side</th>
                    <th style='padding:8px 4px; text-align:left;'>Moves</th>
                    <th style='padding:8px 4px; text-align:left;'>Description</th>
                </tr>
            </thead>
            <tbody>`;
        for (const opening of OPENING_BOOK) {
            const side = getSide(opening.name);
            html += `<tr style='border-bottom:1px solid #333;'>
                <td style='padding:8px 4px; font-weight:bold; color:#fff;'>${opening.name.replace(/ \((White|Black)\)/,'')}</td>
                <td style='padding:8px 4px; color:${sideColor(side)}; font-weight:bold;'>${side}</td>
                <td style='padding:8px 4px; color:#fff;'>
                    ${opening.moves.map(m => `<span style='font-family:monospace; margin-right:8px;'>${pieceIcon(m)} <span style='color:#4ecdc4;'>${m}</span></span>`).join('<br>')}
                </td>
                <td style='padding:8px 4px; color:#aaa;'>${opening.description}</td>
            </tr>`;
        }
        html += '</tbody></table>';
        content.innerHTML = html;
    }
    </script>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.5, maximum-scale=2.0, user-scalable=yes">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate, max-age=0">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <link rel="shortcut icon" href="favicon.ico">
    <link rel="apple-touch-icon" href="favicon.svg">
    <title>ROMGON</title>
    <!-- Version: 2025-10-26-PREFS-FIX-v4-DUPEBOOK -->
    <!-- Keyboard Navigation Systems -->
    <script src="keyboard-navigation-v2.js"></script>
    <script src="keyboard-general-navigation.js"></script>
    <script src="keyboard-system-router.js"></script>
    <!-- Socket.IO Client for Multiplayer & Chat -->
    <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
    <!-- Chat Client -->
    <script src="romgon-chat-client.js"></script>
    <!-- Rooms & Matchmaking Client -->
    <script src="romgon-rooms-client.js"></script>
    <style>
        :root { /* CSS variables - LIGHT MODE (Default) */
            --hex-size: 48px;
            --hex-gap: 1px;
            
            /* Light Mode Colors */
            --body-bg: #f0f0f0;
            --board-bg: #ffffff;
            --text-color: #333333;
            --hex-bg: #e8e8e8;
            --hex-border: #cccccc;
            --modal-bg: #ffffff;
            --modal-overlay: rgba(0, 0, 0, 0.7);
            --button-bg: #4ecdc4;
            --button-text: #ffffff;
            --turn-indicator-bg: rgba(255, 255, 255, 0.95);
            --turn-indicator-text: #333333;
            
            /* Legacy colors (kept for compatibility) */
            --bg-color: #1a1a1a;
            --color-dark-brown: #6d3a13;
            --color-orange-med: #f57d2d;
            --color-orange-light: #fcc49c;
            --hex-coords-color: rgba(100, 100, 100, 0.8);
            --vertical-shift: 18px;

            /* Calculated values */
            --hex-height: calc(var(--hex-size) * 2);
            --hex-width: calc(var(--hex-size) * 1.73205); /* sqrt(3) */
            --hex-margin-top: calc(var(--hex-height) * -0.1 - var(--hex-gap) * 0.5);
            --hex-row-offset: calc(var(--hex-width) / 2 + var(--hex-gap) * 0.866 / 2);
            --hex-horizontal-spacing: calc(var(--hex-gap) * 3.866 / 1);
        }

        /* Zoom & Aspect Ratio Fixes */
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        body {
            font-size: clamp(12px, 1.5vw, 16px);
            line-height: 1.6;
        }

        #start-menu {
            min-height: 100vh !important;
            transform-origin: center center !important;
            transform: scale(1) !important;
        }

        /* Dark Mode Theme */
        body.dark-mode {
            --body-bg: #11141a;
            background: #11141a;
            --board-bg: #262421;
            --text-color: #ffffff;
            --hex-bg: #2d2a27;
            --hex-border: #4a4641;
            --modal-bg: #262421;
            --modal-overlay: rgba(0, 0, 0, 0.9);
            --button-bg: #4ecdc4;
            --button-text: #ffffff;
            --turn-indicator-bg: rgba(38, 36, 33, 0.95);
            --turn-indicator-text: #ffffff;
            --hex-coords-color: rgba(255, 255, 255, 0.8);
        }

        /* Wooden Board Theme */
        body.wooden-theme .hexagon {
            /* Remove solid background colors */
            background-color: transparent !important;
            /* Use wooden texture images */
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }
        
        /* Wooden hexagon variants - map to different wood tones */
        body.wooden-theme .color-dark-brown {
            background-image: url('ASSETS/hexagons/hex-wood-light.png') !important;
        }
        
        body.wooden-theme .color-brown-med {
            background-image: url('ASSETS/hexagons/hex-wood-brown.png') !important;
        }
        
        body.wooden-theme .color-brown-light {
            background-image: url('ASSETS/hexagons/hex-wood-tan.png') !important;
        }
        
        body.wooden-theme .color-orange-dark {
            background-image: url('ASSETS/hexagons/hex-wood-reddish.png') !important;
        }
        
        body.wooden-theme .color-orange-med {
            background-image: url('ASSETS/hexagons/hex-wood-brown.png') !important;
        }
        
        body.wooden-theme .color-orange-light {
            background-image: url('ASSETS/hexagons/hex-wood-light.png') !important;
        }
        
        body.wooden-theme .color-yellow {
            background-image: url('ASSETS/hexagons/hex-wood-light.png') !important;
        }
        
        /* Wooden theme body background */
        body.wooden-theme {
            background: url('ASSETS/backgrounds/wooden background.png');
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
        }
        
        /* Wooden theme highlights - use box-shadow and borders instead of background */
        body.wooden-theme .highlight-green {
            box-shadow: inset 0 0 30px rgba(0, 255, 0, 0.7), 0 0 20px rgba(0, 255, 0, 0.8), inset 0 0 0 3px #00ff00 !important;
            animation: none !important;
        }
        
        body.wooden-theme .highlight-red {
            box-shadow: inset 0 0 30px rgba(255, 68, 68, 0.7), 0 0 20px rgba(255, 68, 68, 0.8), inset 0 0 0 3px #ff4444 !important;
            animation: none !important;
        }
        
        body.wooden-theme .highlight-danger {
            box-shadow: inset 0 0 30px rgba(255, 107, 107, 0.7), 0 0 20px rgba(255, 107, 107, 0.8), inset 0 0 0 2px #ff6b6b !important;
            animation: none !important;
        }
        
        body.wooden-theme .highlight-gray {
            box-shadow: inset 0 0 30px rgba(128, 128, 128, 0.7), 0 0 20px rgba(128, 128, 128, 0.8), inset 0 0 0 3px #808080 !important;
            animation: none !important;
        }
        
        body.wooden-theme .highlight-diagonal {
            box-shadow: inset 0 0 30px rgba(155, 89, 182, 0.7), 0 0 20px rgba(155, 89, 182, 0.8), inset 0 0 0 3px #9b59b6 !important;
            animation: none !important;
        }
        
        body.wooden-theme .highlight-under-attack {
            box-shadow: inset 0 0 30px rgba(255, 68, 68, 0.9), 0 0 25px rgba(255, 68, 68, 1), inset 0 0 0 4px #ff4444 !important;
            animation: none !important;
        }
        
        body.wooden-theme .highlight-rhombus-check {
            box-shadow: inset 0 0 30px rgba(255, 215, 0, 0.8), 0 0 25px rgba(255, 215, 0, 1), inset 0 0 0 4px #ffd700 !important;
            animation: none !important;
        }
        
        body.wooden-theme .highlight-selected {
            box-shadow: inset 0 0 30px rgba(255, 215, 0, 0.7), 0 0 20px rgba(255, 215, 0, 0.8), inset 0 0 0 3px #ffd700 !important;
            animation: none !important;
        }

        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        body {
            background: var(--body-bg);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 0;
            margin: 0;
            color: var(--text-color);
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        /* Board container - centered in game area */
        #board-display-container {
             position: fixed;
             top: 0;
             left: 0;
             display: flex;
             justify-content: center;
             align-items: center;
             width: 100%;
             height: 100%;
             padding-top: 16vh;
             padding-bottom: calc(10vh - 200px);
             padding-left: 260px; /* Make room for left panel (220px + 40px gap) */
             padding-right: 260px; /* Make room for right panel (220px + 40px gap) */
             box-sizing: border-box;
             overflow: visible;
             z-index: 3000;
             background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 25%, #0f1923 50%, #1a1f3a 75%, #0a0e27 100%);
        }

        .board {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0;
            transform: rotate(90deg) scale(0.85);
            transform-origin: center center;
            margin: 0 auto;
            flex-shrink: 1;
            width: auto;
            height: auto;
            max-width: 80vmin;
            max-height: 80vh;
            transition: transform 0.3s ease;
        }
        
        /* Board flip for white player perspective */
        .board.flipped {
            transform: rotate(270deg) scale(0.85);
            transform-origin: center center;
        }

        /* Mini Board for Analysis Modal */
        .mini-board {
            --mini-hex-size: 28px;
            --mini-hex-gap: 0.5px;
            --mini-hex-height: calc(var(--mini-hex-size) * 2);
            --mini-hex-width: calc(var(--mini-hex-size) * 1.73205);
            --mini-hex-margin-top: calc(var(--mini-hex-height) * -0.25 - var(--mini-hex-gap) * 0.5);
            --mini-hex-row-offset: calc(var(--mini-hex-width) / 2 + var(--mini-hex-gap) * 0.866 / 2);
            --mini-hex-horizontal-spacing: calc(var(--mini-hex-gap) * 3.866 / 1);
            
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transform: rotate(90deg) scale(1);
            transform-origin: center center;
            margin: 0 auto;
            min-width: 500px;
            min-height: 500px;
        }
        
        .mini-board .row {
            display: flex;
            margin-top: var(--mini-hex-margin-top);
            justify-content: center;
        }
        
        .mini-board .row:first-child {
            margin-top: 0;
        }
        
        .mini-board .row:nth-child(odd) {
            margin-left: var(--mini-hex-row-offset);
        }
        
        .mini-board .hexagon {
            position: relative;
            width: var(--mini-hex-width);
            height: var(--mini-hex-height);
            background-color: var(--color-orange-med);
            margin-left: var(--mini-hex-horizontal-spacing);
            margin-right: var(--mini-hex-horizontal-spacing);
            cursor: default;
            flex-shrink: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            box-shadow: inset 0 0 4px rgba(0,0,0,0.5);
        }
        
        .mini-board .piece {
            width: calc(var(--mini-hex-size) * 1.8);
            height: calc(var(--mini-hex-size) * 1.8);
            pointer-events: none;
            transform: rotate(-90deg); /* Counter-rotate to keep pieces upright */
        }

        .row {
            display: flex;
            margin-top: var(--hex-margin-top);
            justify-content: center;
        }
        .row:first-child {
            margin-top: 0;
        }
        .row:nth-child(even) {
            margin-left: var(--hex-row-offset); /* Stagger even rows */
        }

        .hexagon {
            position: relative;
            width: var(--hex-width);
            height: var(--hex-height);
            background-color: var(--color-orange-med); /* Default color */
            margin-left: var(--hex-horizontal-spacing);
            margin-right: var(--hex-horizontal-spacing);
            cursor: pointer;
            flex-shrink: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            box-shadow: inset 0 0 8px rgba(0,0,0,0.5); /* Inner shadow */
            transition: none;
        }

        /* Color override classes */
        .color-dark-brown { background-color: var(--color-dark-brown); }
        .color-orange-med { background-color: var(--color-orange-med); }
        .color-orange-light { background-color: var(--color-orange-light); }

        /* Highlight for movement pattern */
        .highlight-green {
            background-color: #4ecdc4 !important;
            box-shadow: none !important;
            z-index: 10;
            position: relative;
        }
        
        /* Highlight for diagonal rhombus moves (special ability) */
        .highlight-diagonal {
            background-color: #9b59b6 !important;
            box-shadow: none !important;
            z-index: 10;
            position: relative;
        }
        
        /* Highlight for attack pattern */
        .highlight-red {
            background-color: rgba(255, 68, 68, 0.8) !important;
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.9), inset 0 0 15px rgba(255, 0, 0, 0.6) !important;
            z-index: 10;
            position: relative;
            border: 2px solid #ff0000 !important;
        }
        
        /* Highlight for defensive positions (friendly protecting friendly) */
        .highlight-gray {
            background-color: rgba(128, 128, 128, 0.5) !important;
            box-shadow: none !important;
            z-index: 9;
            position: relative;
        }

        /* Keyboard Navigation - Piece Selection */
        .kb-piece-selected {
            outline: 3px solid #4ecdc4 !important;
            outline-offset: -2px !important;
            box-shadow: none !important;
            border: none !important;
            transition: none !important;
        }

        .kb-piece-selected .square-piece,
        .kb-piece-selected .triangle-piece,
        .kb-piece-selected .rhombus-piece,
        .kb-piece-selected .circle-piece,
        .kb-piece-selected .hexgon-piece {
            outline: 2px solid #4ecdc4 !important;
            outline-offset: -1px !important;
            box-shadow: none !important;
            border: none !important;
            transition: none !important;
        }

        /* Keyboard Navigation - Move Navigation */
        .kb-move-navigating {
            border: 2px solid #00ff00 !important;
            box-shadow: 0 0 12px #00ff00, inset 0 0 8px rgba(0, 255, 0, 0.3) !important;
            background-color: rgba(0, 255, 0, 0.1) !important;
            z-index: 15 !important;
        }

        /* General Navigation - Focus State */
        .kb-nav-focused {
            outline: 3px solid #00ccff !important;
            outline-offset: 2px !important;
            box-shadow: 0 0 15px rgba(0, 204, 255, 0.8) !important;
        }

        button.kb-nav-focused,
        a.kb-nav-focused {
            transform: scale(1.05) !important;
        }
        
        /* Menu Button Styling */
        .game-menu-button {
            background-color: #1a252f !important;
            color: #4ecdc4 !important;
            border: 2px solid #4ecdc4 !important;
            border-radius: 6px !important;
            cursor: pointer !important;
            font-weight: normal !important;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.6) !important;
            transition: all 0.2s ease !important;
            text-shadow: none !important;
            display: flex !important;
            flex-direction: column !important;
            align-items: center !important;
            justify-content: center !important;
            padding: 8px 10px !important;
            gap: 4px !important;
            min-height: auto !important;
            line-height: 1.1 !important;
            white-space: normal !important;
            vertical-align: middle !important;
            position: relative !important;
        }
        
        .game-menu-button-emoji {
            font-size: 14px !important;
            line-height: 1 !important;
        }
        
        .game-menu-button-label {
            font-size: 8px !important;
            color: #ffffff !important;
            font-weight: normal !important;
            line-height: 1.2 !important;
            text-align: center !important;
            word-break: break-word !important;
            max-width: 95% !important;
        }
        
        .game-menu-button:hover {
            background-color: #2c3e50 !important;
            box-shadow: 0 4px 12px rgba(78, 205, 196, 0.5) !important;
            transform: scale(1.05) !important;
        }
        
        /* Side Panel Styling */
        #game-buttons-panel {
            position: fixed;
            left: 0;
            top: 100px;
            width: 180px;
            max-height: calc(100vh - 120px);
            background-color: rgba(26, 37, 47, 0.95) !important;
            border: 2px solid #4ecdc4 !important;
            border-left: none !important;
            border-radius: 0 12px 12px 0 !important;
            padding: 10px !important;
            display: flex !important;
            flex-direction: column !important;
            gap: 8px !important;
            z-index: 3000 !important;
            overflow-y: auto !important;
            box-shadow: 2px 0 12px rgba(0, 0, 0, 0.5) !important;
            transition: transform 0.3s ease !important;
            transform: translateX(0) !important;
            pointer-events: auto !important;
        }
        
        #game-buttons-panel.hidden {
            transform: translateX(-200px) !important;
            pointer-events: none !important;
        }
        
        #game-buttons-panel button {
            width: 100% !important;
            padding: 8px 10px !important;
            text-align: center !important;
            font-size: 10px !important;
        }
        
        #toggle-panel-btn {
            display: inline-flex !important;
            align-items: center !important;
            justify-content: center !important;
            min-width: 45px !important;
            min-height: 28px !important;
        }
        
        /* NEW: Highlight for piece that just moved and is under attack */
        .highlight-under-attack {
            background-color: #ff4444 !important;
            box-shadow: none !important;
            animation: none !important;
            transition: none !important;
        }
        
        /* NEW: Special yellow highlight for RHOMBUS under attack (CHECK/DEADLOCK warning) */
        .highlight-rhombus-check {
            background-color: #ffd700 !important;
            box-shadow: none !important;
            animation: none !important;
            transition: none !important;
        }
        
        @keyframes pulse-red {
            0%, 100% { box-shadow: inset 0 0 10px rgba(0,0,0,0.6), 0 0 20px rgba(255, 68, 68, 0.9); }
            50% { box-shadow: inset 0 0 10px rgba(0,0,0,0.6), 0 0 30px rgba(255, 68, 68, 1); }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* Highlight for danger zone (where piece would be vulnerable) */
        .highlight-danger {
            background-color: #ff6b6b !important;
            box-shadow: none !important;
            z-index: 10;
            position: relative;
        }
        
        /* Highlight for pieces defended by friendly pieces */
        .highlight-defended {
            background-color: #3498db !important;
            box-shadow: none !important;
            z-index: 10;
            position: relative;
        }
        
        /* Highlight for last move - source hex */
        .highlight-last-move-from {
            background-color: rgba(255, 215, 0, 0.25) !important;
        }
        
        /* Highlight for last move - destination hex */
        .highlight-last-move-to {
            background-color: rgba(255, 215, 0, 0.4) !important;
        }
        
        /* Highlight for pieces under threat (centered warning circle) */
        .hexagon.highlight-threat::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 12px;
            height: 12px;
            background-color: #ff4444 !important;
            border-radius: 50%;
            z-index: 5;
            border: 2px solid #fff;
            box-shadow: 0 0 4px rgba(255, 68, 68, 0.8);
            pointer-events: none; /* Don't block clicks! */
        }
        
        /* Ensure the hexagon has relative positioning for absolute child */
        .hexagon.highlight-threat {
            position: relative;
        }

        /* FOG OF WAR EFFECTS */
        .hexagon.fog-hidden {
            background-color: rgba(40, 40, 40, 0.85) !important;
            background-image: repeating-linear-gradient(
                45deg,
                transparent,
                transparent 10px,
                rgba(0, 0, 0, 0.3) 10px,
                rgba(0, 0, 0, 0.3) 20px
            ) !important;
            filter: brightness(0.4) blur(1px);
            transition: all 0.3s ease;
        }
        
        body.dark-mode .hexagon.fog-hidden {
            background-color: rgba(10, 10, 10, 0.9) !important;
            filter: brightness(0.2) blur(2px);
        }
        
        body.wooden-theme .hexagon.fog-hidden {
            filter: brightness(0.3) blur(2px) grayscale(0.7);
        }
        
        .hexagon.fog-dimmed {
            opacity: 0.6;
            filter: grayscale(0.5);
        }
        
        .hexagon.fog-revealed-temp {
            animation: fogRevealFlash 0.5s ease-out;
        }
        
        @keyframes fogRevealFlash {
            0% { box-shadow: 0 0 0 rgba(255, 215, 0, 0); }
            50% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.8), inset 0 0 20px rgba(255, 215, 0, 0.4); }
            100% { box-shadow: 0 0 0 rgba(255, 215, 0, 0); }
        }
        
        @keyframes fogRevealPulse {
            0%, 100% { transform: scale(1); filter: brightness(1); }
            50% { transform: scale(1.1); filter: brightness(1.3); }
        }

        /* Shift class for specific rows (applied based on index in HTML) */
        .hexagon.shift-down {
            /* Because the board is rotated 90deg, translateX moves visually down */
            transform: translateX(var(--vertical-shift));
        }

        .hex-coords {
            position: absolute;
            top: 50%;
            left: 50%;
            color: var(--hex-coords-color);
            transform: translate(-50%, -50%) rotate(-90deg); /* Center and counter-rotate */
            font-size: 9px;
            pointer-events: none;
            z-index: 0;
            font-weight: bold;
            white-space: nowrap;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7); /* Shadow for readability */
        }
        
        /* Counter-rotate coords when board is flipped */
        .board.flipped .hex-coords {
            transform: translate(-50%, -50%) rotate(-90deg) rotate(-180deg);
        }

        /* Visual markers for circle zone-change gateways */
        .hexagon.gateway-highlight {
            position: relative;
        }
        .hexagon.gateway-highlight::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255, 215, 0, 0.28); /* warm gold tint */
            border: 2px dashed rgba(255, 215, 0, 0.8);
            border-radius: inherit;
            z-index: 1;
            pointer-events: none;
        }

        /* Square piece */
        .square-piece {
            position: absolute;
            width: 56px;
            height: 56px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(90deg);
            z-index: 2;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        /* Black square piece */
        .square-piece:not(.white-piece) {
            background-image: url('ASSETS/square black front.png');
        }

        /* White square piece variant */
        .square-piece.white-piece {
            background-image: url('ASSETS/square white Front.png');
        }

        /* Triangle piece */
        .triangle-piece {
            position: absolute;
            width: 56px;
            height: 56px;
            top: 50%;
            left: 50%;
            /* Default orientation 0 = 270deg (pointing up) for BOTH colors */
            transform: translate(-50%, -50%) rotate(270deg);
            z-index: 2;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        /* Black triangle piece - same default as white */
        .triangle-piece:not(.white-triangle) {
            background-image: url('ASSETS/Triangle black front.png');
            /* Inherit default 270deg from base .triangle-piece */
        }

        /* White triangle piece - same default as black */
        .triangle-piece.white-triangle {
            background-image: url('ASSETS/Triangle white front.png');
            /* Inherit default 270deg from base .triangle-piece */
        }

        /* Rhombus piece */
        .rhombus-piece {
            position: absolute;
            width: 60px;
            height: 60px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(90deg);
            z-index: 2;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        /* Black rhombus piece */
        .rhombus-piece:not(.white-rhombus) {
            background-image: url('ASSETS/Rhombus black front.png');
        }

        /* White rhombus piece variant */
        .rhombus-piece.white-rhombus {
            background-image: url('ASSETS/Rhombus white front.png');
        }

        /* Circle piece */
        .circle-piece {
            position: absolute;
            width: 60px;
            height: 60px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(90deg);
            z-index: 2;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        /* Black circle */
        .circle-piece:not(.white-circle) {
            background-image: url('ASSETS/circle black front.png');
        }

        /* White circle */
        .circle-piece.white-circle {
            background-image: url('ASSETS/circle white front.png');
        }

        /* Hexgon piece (board hexagon piece shape) */
        .hexgon-piece {
            position: absolute;
            width: 60px;
            height: 60px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(90deg);
            z-index: 2;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        .hexgon-piece:not(.white-hexgon) {
            background-image: url('ASSETS/hexagon black front.png');
        }

        .hexgon-piece.white-hexgon {
            background-image: url('ASSETS/hexagon white front.png');
        }

        /* Eliminated pieces display - Chess.com style */
        #eliminated-pieces-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        .variant-indicator {
            background-color: rgba(255, 121, 198, 0.15);
            color: #ff79c6;
            padding: 6px 10px;
            border-radius: 8px;
            font-weight: 700;
            font-size: 0.85em;
            text-align: center;
            margin-bottom: 8px;
            border: 1px solid rgba(255, 121, 198, 0.4);
        }

        /* Guest indicator badge and tooltip */
        .guest-indicator-badge { user-select: none; }
        .guest-indicator-badge:focus { outline: none; box-shadow: 0 0 0 3px rgba(255,107,107,0.15); }
        .guest-tooltip { pointer-events: none; }

        .eliminated-section {
            position: fixed;
            width: 220px;
            text-align: center;
            background: rgba(0, 0, 0, 0.9); /* Dark theme matching camera panel */
            border-radius: 15px;
            border: 2px solid rgba(78, 205, 196, 0.5); /* Teal border like camera */
            padding: 12px;
            pointer-events: auto;
            max-height: none;
            overflow: visible;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.6);
            z-index: 15;
            top: 80px;
            font-size: 0.85em;
        }
        
        /* Position left panel (White Eliminated) */
        .eliminated-section:first-child {
            left: 10px;
        }
        
        /* Position right panel (Black Eliminated) */
        .eliminated-section:last-child {
            right: 10px;
        }

        .eliminated-section h3 {
            color: #4ecdc4; /* Teal color matching camera panel */
            margin: 0 0 8px 0;
            font-size: 0.95em;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(78, 205, 196, 0.5);
        }

        /* Embedded movement-section inside each eliminated panel */
        .movement-section {
            width: 100%;
            text-align: left;
            background-color: rgba(78, 205, 196, 0.05);
            border-radius: 8px;
            padding: 8px;
            max-height: 200px;
            overflow-y: auto;
            overflow-x: hidden;
            scroll-behavior: smooth;
            pointer-events: auto;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.3);
            margin-top: 8px;
            border: 1px solid rgba(78, 205, 196, 0.2);
        }

        .movement-section h3 {
            color: #4ecdc4;
            margin: 0 0 6px 0;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
            padding: 4px 0;
            font-weight: 700;
        }

        .movement-list { list-style: none; padding: 0; margin: 0; }
        .movement-item { color: #4ecdc4; font-size: 0.85em; margin: 3px 0; padding: 5px 8px; background-color: rgba(0, 0, 0, 0.4); border-radius: 6px; font-family: 'Courier New', monospace; word-wrap: break-word; border-left: 2px solid rgba(78, 205, 196, 0.3); }
        .movement-item.white-move { color: #fff; background-color: rgba(78, 205, 196, 0.1); border-left-color: rgba(255, 255, 255, 0.5); }
        .movement-item.black-move { color: #ddd; background-color: rgba(0, 0, 0, 0.3); border-left-color: rgba(255, 121, 198, 0.5); }

        /* Eliminated circle sizes */
        .eliminated-piece.circle-piece {
            width: 40px;
            height: 40px;
            transform: rotate(90deg);
        }
        
        /* Movement tracking container removed (styles for .movement-section will be applied in-panel) */

        .eliminated-pieces {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 5px;
            min-height: 40px;
            padding: 8px;
            background-color: rgba(78, 205, 196, 0.08);
            border-radius: 8px;
            border: 1px solid rgba(78, 205, 196, 0.25);
        }

        .eliminated-piece {
            width: 25px;
            height: 25px;
            margin: 2px;
            opacity: 0.7;
            filter: grayscale(0.3);
            position: relative;
            display: inline-block;
        }

        .eliminated-piece.square-piece {
            width: 28px;
            height: 28px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            margin: 2px 5px;
            transform: rotate(90deg);
        }

        .eliminated-piece.square-piece:not(.white-piece) {
            background-image: url('ASSETS/square black front.png');
        }

        .eliminated-piece.square-piece.white-piece {
            background-image: url('ASSETS/square white Front.png');
        }

        .eliminated-piece.triangle-piece {
            width: 40px;
            height: 40px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            margin: 2px 5px;
            transform: rotate(90deg);
        }

        .eliminated-piece.triangle-piece:not(.white-triangle) {
            background-image: url('ASSETS/Triangle black front.png');
            transform: rotate(90deg) rotate(180deg);
        }

        .eliminated-piece.triangle-piece.white-triangle {
            background-image: url('ASSETS/Triangle white front.png');
            transform: rotate(270deg);
        }

        .eliminated-piece.rhombus-piece {
            width: 40px;
            height: 40px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            margin: 2px 5px;
            transform: rotate(90deg);
        }

        .eliminated-piece.rhombus-piece:not(.white-rhombus) {
            background-image: url('ASSETS/Rhombus black front.png');
        }

        .eliminated-piece.rhombus-piece.white-rhombus {
            background-image: url('ASSETS/Rhombus white front.png');
        }

        .eliminated-piece.circle-piece {
            width: 32px;
            height: 32px;
            transform: rotate(90deg);
        }

        .eliminated-piece.hexgon-piece {
            width: 40px;
            height: 40px;
            transform: rotate(90deg);
        }

        /* Responsive design for mobile */
        @media (max-width: 768px) {
            #board-display-container {
                padding: 80px 5px 120px 5px !important;
            }
            
            /* Hide side panels on mobile to avoid overlap */
            .eliminated-section {
                display: none !important;
            }
            
            /* Show camera controls on mobile - position at bottom right */
            #camera-panel {
                bottom: 70px !important;
                right: 5px !important;
                padding: 8px !important;
                font-size: 0.75em !important;
            }
            
            #camera-toggle-btn {
                bottom: 70px !important;
                right: 5px !important;
                padding: 6px 10px !important;
                font-size: 0.75em !important;
            }
            
            /* Larger hexagons for mobile touch */
            :root {
                --hex-size: 35px; /* Larger for touch targets */
            }
            
            /* Scale and rotate board 90¬∞ for mobile - BLACK'S TURN (default) */
            .board {
                transform: scale(0.7) rotate(90deg) !important;
                transform-origin: center center;
                margin: 0 auto;
            }
            
            /* WHITE'S TURN - flip board 180¬∞ from black's view */
            .board.flipped {
                transform: scale(0.7) rotate(270deg) !important;
                transform-origin: center center;
                margin: 0 auto;
            }
            
            /* Mobile-friendly top controls */
            #quit-game-btn {
                font-size: 0.9em !important;
                padding: 8px 15px !important;
                min-width: 100px !important;
            }
            
            /* Turn indicator - move to top right on mobile */
            #turn-display {
                position: fixed !important;
                top: 10px !important;
                right: 10px !important;
                left: auto !important;
                font-size: 0.6em !important;
                padding: 4px 8px !important;
                max-width: 100px !important;
                z-index: 1500 !important;
            }
            
            /* Make turn badge more compact */
            #turn-display .turn-badge {
                font-size: 0.6em !important;
                padding: 2px 4px !important;
            }
            
            /* Hide floating rotation overlay on mobile - use bottom bar instead */
            #rotation-overlay {
                display: none !important;
            }
            
            /* Mobile player timers */
            .player-timers {
                flex-direction: column !important;
                gap: 5px !important;
                top: 60px !important;
            }
            
            .timer-display {
                font-size: 0.9em !important;
                padding: 8px 15px !important;
            }
            
            #start-menu > div {
                padding: 15px !important;
                margin: 5px !important;
                max-width: 95vw !important;
            }
            
            #start-menu h1 {
                font-size: 1.8em !important;
            }
            
            #start-menu h2 {
                font-size: 1em !important;
            }
            
            #start-menu h3 {
                font-size: 0.85em !important;
            }
            
            #start-menu .grid {
                grid-template-columns: 1fr !important;
                gap: 8px !important;
            }
            
            #start-menu ul {
                font-size: 0.75em !important;
            }
            
            #start-menu p {
                font-size: 0.8em !important;
            }
            
            /* Mobile-friendly AI Provider Modal */
            #chatgpt-setup-modal > div {
                width: 95vw !important;
                max-width: 95vw !important;
                padding: 20px !important;
                max-height: 90vh !important;
                overflow-y: auto !important;
            }
            
            #chatgpt-setup-modal h2 {
                font-size: 1.3em !important;
            }
            
            #chatgpt-setup-modal p {
                font-size: 0.85em !important;
            }
            
            /* AI Provider Buttons - Stack Vertically on Mobile */
            #ai-provider-buttons {
                flex-direction: column !important;
                gap: 10px !important;
            }
            
            #ai-provider-buttons button {
                width: 100% !important;
                min-height: 50px !important;
                font-size: 14px !important;
                padding: 12px !important;
            }
            
            /* Cost Comparison Grid - Single Column on Mobile */
            #chatgpt-setup-modal .cost-comparison-grid {
                grid-template-columns: 1fr !important;
                gap: 8px !important;
                font-size: 0.75em !important;
            }
            
            /* API Key Input - Full Width */
            #chatgpt-api-key-input {
                width: 100% !important;
                font-size: 14px !important;
                padding: 12px !important;
            }
            
            /* Modal Buttons - Touch Friendly */
            #chatgpt-setup-modal button {
                min-height: 48px !important;
                font-size: 15px !important;
                padding: 12px 20px !important;
            }
            
            /* ChatGPT Suggestion Modal - Full Screen on Mobile */
            #chatgpt-suggestion-modal > div {
                width: 95vw !important;
                max-width: 95vw !important;
                max-height: 85vh !important;
                padding: 15px !important;
            }
            
            #chatgpt-suggestion-modal h3 {
                font-size: 1.1em !important;
            }
            
            #chatgpt-suggestion-modal .suggestion-content {
                font-size: 0.9em !important;
                max-height: 60vh !important;
            }
            
            /* Floating ChatGPT Button - Reposition for Mobile */
            #floating-chatgpt-btn {
                bottom: 15px !important;
                right: 15px !important;
                width: 55px !important;
                height: 55px !important;
                font-size: 20px !important;
            }
            
            /* Turn Indicator - Compact Layout */
            #turn-indicator {
                font-size: 0.8em !important;
                padding: 8px 15px !important;
            }
            
            /* User Home Menu - Touch Friendly Buttons */
            #user-home button {
                min-height: 48px !important;
                font-size: 15px !important;
                padding: 12px 20px !important;
            }
            
            /* Game Board - Center and Scale */
            #board-container {
                transform: scale(0.9) !important;
                transform-origin: center center !important;
            }
            
            /* Sandbox Tools Panel - Mobile Friendly */
            #sandbox-tools-panel {
                top: 10px !important;
                left: 10px !important;
                right: 10px !important;
                min-width: auto !important;
                max-width: calc(100vw - 20px) !important;
                padding: 15px !important;
                font-size: 0.9em !important;
            }
            
            #sandbox-tools-panel h3 {
                font-size: 1em !important;
            }
            
            #sandbox-tools-panel button {
                font-size: 0.85em !important;
                padding: 8px !important;
            }
            
            /* Hybrid Lobby Mobile Styles */
            #user-home {
                padding: 0 !important;
            }
            
            /* Lobby Header - Mobile */
            #user-home > div:first-child {
                padding: 12px 15px !important;
                flex-wrap: wrap !important;
            }
            
            #user-home h1 {
                font-size: 1.5em !important;
            }
            
            /* Lobby Content Container - Mobile Padding */
            #user-home > div:nth-child(2) {
                padding: 20px 15px !important;
            }
            
            /* Quick Play - Stack Buttons */
            #user-home h2 {
                font-size: 1.3em !important;
            }
            
            /* Two Column Grid - Stack on Mobile */
            #user-home > div:nth-child(2) > div:nth-child(2) {
                grid-template-columns: 1fr !important;
            }
            
            /* Features Grid - 2 Columns on Mobile */
            #user-home > div:nth-child(2) > div:nth-child(3) > div:last-child {
                grid-template-columns: repeat(2, 1fr) !important;
            }
            
            /* Feature Tiles - Compact */
            #user-home > div:nth-child(2) > div:nth-child(3) button {
                padding: 15px 10px !important;
                font-size: 0.85em !important;
            }
            
            /* Match History - Touch Friendly */
            #user-home > div:nth-child(2) > div:nth-child(4) button {
                font-size: 0.9em !important;
                padding: 10px !important;
            }
            
            /* Chat Section - Mobile */
            #global-chat-messages,
            #friends-list {
                height: 250px !important;
            }
            
            #global-chat-input,
            #add-friend-input {
                font-size: 0.85em !important;
                padding: 10px 12px !important;
            }
            
            #global-chat-tab,
            #friends-chat-tab {
                font-size: 0.85em !important;
                padding: 8px 12px !important;
            }
        }

        /* Multiplayer Modal Styles */
        #multiplayer-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }

        #multiplayer-modal.active {
            display: flex;
        }

        .multiplayer-container {
            background: #262421; /* Chess.com panel color */
            border: 2px solid #f57d2d;
            border-radius: 12px;
            padding: 40px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .multiplayer-container h2 {
            color: #f57d2d;
            text-align: center;
            margin-bottom: 30px;
            font-size: 28px;
        }

        .multiplayer-options {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .mp-button {
            background: linear-gradient(135deg, #f57d2d 0%, #d45a1f 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(245, 125, 45, 0.4);
        }

        .mp-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(245, 125, 45, 0.6);
        }

        .mp-button.secondary {
            background: linear-gradient(135deg, #4ecdc4 0%, #3aa89f 100%);
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.4);
        }

        .mp-button.secondary:hover {
            box-shadow: 0 6px 20px rgba(78, 205, 196, 0.6);
        }

        .mp-input {
            background-color: #333;
            border: 2px solid #555;
            color: white;
            padding: 12px;
            border-radius: 8px;
            font-size: 16px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .mp-input:focus {
            outline: none;
            border-color: #f57d2d;
            box-shadow: 0 0 10px rgba(245, 125, 45, 0.5);
        }

        .room-code-display {
            background-color: #333;
            border: 2px solid #4ecdc4;
            color: #4ecdc4;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            margin: 20px 0;
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 4px;
            font-family: 'Courier New', monospace;
        }

        .waiting-message {
            color: #fcc49c;
            text-align: center;
            font-size: 16px;
            margin: 15px 0;
        }

        .multiplayer-status {
            position: fixed;
            top: 80px;
            left: 20px;
            background-color: #262421; /* Chess.com panel color */
            border: 1px solid #3d3935;
            border-radius: 8px;
            padding: 15px;
            color: white;
            z-index: 9999;
            min-width: 200px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
        }
        
        /* Player Timers - Chess.com style */
        .player-timers {
            position: fixed;
            top: 20px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 100;
            pointer-events: none;
        }
        
        .timer-display {
            background-color: #262421;
            border: 2px solid #3d3935;
            border-radius: 8px;
            padding: 8px 16px;
            width: 180px; /* Match eliminated panel width */
            text-align: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            transition: all 0.3s ease;
            pointer-events: auto;
        }
        
        .timer-display.active {
            border-color: #4ecdc4;
            background-color: #2a3a38;
            box-shadow: 0 4px 16px rgba(78, 205, 196, 0.4);
        }
        
        .timer-display.low-time {
            border-color: #ff6b6b;
            background-color: #3a2626;
            animation: pulse-timer 1s infinite;
        }
        
        @keyframes pulse-timer {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .timer-label {
            font-size: 10px;
            color: #b8b6b3;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 3px;
            font-weight: 600;
        }
        
        .timer-time {
            font-size: 20px;
            font-weight: bold;
            color: #fff;
            font-family: 'Courier New', monospace;
        }
        
        .timer-display.low-time .timer-time {
            color: #ff6b6b;
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-indicator.connected {
            background-color: #4ecdc4;
            box-shadow: 0 0 10px #4ecdc4;
        }

        .status-indicator.disconnected {
            background-color: #ff4444;
            box-shadow: 0 0 10px #ff4444;
        }

        .status-indicator.waiting {
            background-color: #ffa502;
            box-shadow: 0 0 10px #ffa502;
        }

        .mp-error {
            color: #ff4444;
            text-align: center;
            margin: 10px 0;
            font-size: 14px;
        }

        .mp-back-button {
            background-color: #555;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 15px;
            width: 100%;
        }

        .mp-back-button:hover {
            background-color: #666;
        }

        /* ===== KEYBOARD NAVIGATION STYLES ===== */
        
        /* Keyboard-selected piece indicator */
        .kb-selected {
            outline: 3px solid #4ecdc4 !important;
            box-shadow: 0 0 15px rgba(78, 205, 196, 0.8),
                        inset 0 0 10px rgba(78, 205, 196, 0.3) !important;
            animation: kb-pulse 0.6s ease-in-out infinite;
        }
        
        @keyframes kb-pulse {
            0%, 100% {
                box-shadow: 0 0 15px rgba(78, 205, 196, 0.8),
                            inset 0 0 10px rgba(78, 205, 196, 0.3);
            }
            50% {
                box-shadow: 0 0 25px rgba(78, 205, 196, 1),
                            inset 0 0 15px rgba(78, 205, 196, 0.5);
            }
        }
        
        /* Keyboard navigation indicator */
        #kb-player-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 20px;
            background: #333;
            color: #fff;
            border-radius: 8px;
            font-weight: bold;
            font-size: 14px;
            letter-spacing: 1px;
            z-index: 9999;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            border: 2px solid #4ecdc4;
            transition: all 0.3s ease;
        }
        
        #kb-player-indicator:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(78, 205, 196, 0.4);
        }
        
        /* Keyboard help overlay */
        #kb-help-overlay {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(20, 24, 32, 0.95);
            border: 2px solid #4ecdc4;
            border-radius: 8px;
            padding: 15px;
            font-size: 12px;
            color: #4ecdc4;
            max-width: 250px;
            z-index: 9998;
            line-height: 1.6;
            font-family: 'Courier New', monospace;
        }
        
        #kb-help-overlay strong {
            color: #fff;
        }
        
        /* Keyboard-accessible board state */
        .kb-active-control {
            border: 2px solid #ffd700 !important;
        }
        
        /* ===== SETTINGS TAB STYLES ===== */
        
        /* Settings input fields */
        .settings-input-group {
            margin-bottom: 25px;
        }
        
        .settings-input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #4ecdc4;
        }
        
        #settings-username-input {
            width: calc(100% - 100px);
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(78, 205, 196, 0.3);
            border-radius: 6px;
            color: #fff;
            font-size: 14px;
        }
        
        #settings-username-input:focus {
            outline: none;
            border-color: #4ecdc4;
            box-shadow: 0 0 0 2px rgba(78, 205, 196, 0.2);
        }
        
        .save-button {
            margin-left: 10px;
            padding: 10px 20px;
            background: linear-gradient(135deg, #4ecdc4 0%, #44a08d 100%);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }
        
        .save-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(78, 205, 196, 0.4);
        }
        
        /* Avatar & Badge Grids */
        #avatar-selection-grid,
        #badge-selection-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        
        .avatar-option {
            width: 60px;
            height: 60px;
            font-size: 30px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(78, 205, 196, 0.3);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .avatar-option:hover {
            transform: scale(1.1);
            border-color: #4ecdc4;
            background: rgba(78, 205, 196, 0.1);
        }
        
        .avatar-option.selected {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.15);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.4);
        }
        
        .badge-option {
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(78, 205, 196, 0.3);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            position: relative;
        }
        
        /* Rarity-based badge borders */
        .badge-option.common {
            border-color: rgba(158, 158, 158, 0.5);
        }
        
        .badge-option.uncommon {
            border-color: rgba(30, 255, 0, 0.5);
        }
        
        .badge-option.rare {
            border-color: rgba(0, 112, 221, 0.5);
        }
        
        .badge-option.epic {
            border-color: rgba(163, 53, 238, 0.5);
        }
        
        .badge-option.legendary {
            border-color: rgba(255, 128, 0, 0.5);
        }
        
        .badge-option.mythic {
            border-color: rgba(255, 0, 220, 0.7);
            box-shadow: 0 0 20px rgba(255, 0, 220, 0.3);
        }
        
        .badge-option:hover:not(.locked) {
            transform: translateY(-2px);
            background: rgba(78, 205, 196, 0.1);
        }
        
        .badge-option.uncommon:hover:not(.locked) {
            border-color: rgba(30, 255, 0, 0.8);
            box-shadow: 0 4px 15px rgba(30, 255, 0, 0.3);
        }
        
        .badge-option.rare:hover:not(.locked) {
            border-color: rgba(0, 112, 221, 0.8);
            box-shadow: 0 4px 15px rgba(0, 112, 221, 0.3);
        }
        
        .badge-option.epic:hover:not(.locked) {
            border-color: rgba(163, 53, 238, 0.8);
            box-shadow: 0 4px 15px rgba(163, 53, 238, 0.3);
        }
        
        .badge-option.legendary:hover:not(.locked) {
            border-color: rgba(255, 128, 0, 0.8);
            box-shadow: 0 4px 15px rgba(255, 128, 0, 0.3);
        }
        
        .badge-option.mythic:hover:not(.locked) {
            border-color: rgba(255, 0, 220, 1);
            box-shadow: 0 4px 20px rgba(255, 0, 220, 0.5);
        }
        
        .badge-option.selected {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.15);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.4);
        }
        
        .badge-option.locked {
            opacity: 0.4;
            cursor: not-allowed;
            filter: grayscale(1);
        }
        
        .badge-emoji {
            font-size: 32px;
            margin-bottom: 8px;
        }
        
        .badge-name {
            font-weight: 600;
            color: #fff;
            margin-bottom: 4px;
            font-size: 13px;
        }
        
        .badge-rarity-tag {
            font-size: 9px;
            font-weight: 700;
            text-transform: uppercase;
            padding: 2px 6px;
            border-radius: 4px;
            margin: 4px auto;
            display: inline-block;
            letter-spacing: 0.5px;
        }
        
        .badge-rarity-tag.common {
            background: rgba(158, 158, 158, 0.3);
            color: #9e9e9e;
        }
        
        .badge-rarity-tag.uncommon {
            background: rgba(30, 255, 0, 0.2);
            color: #1eff00;
        }
        
        .badge-rarity-tag.rare {
            background: rgba(0, 112, 221, 0.2);
            color: #0070dd;
        }
        
        .badge-rarity-tag.epic {
            background: rgba(163, 53, 238, 0.2);
            color: #a335ee;
        }
        
        .badge-rarity-tag.legendary {
            background: rgba(255, 128, 0, 0.2);
            color: #ff8000;
        }
        
        .badge-rarity-tag.mythic {
            background: rgba(255, 0, 220, 0.2);
            color: #ff00dc;
        }
        
        .badge-requirement {
            font-size: 11px;
            color: #888;
            margin-top: 4px;
        }
        
        .badge-option.unlocked .badge-requirement {
            color: #4ecdc4;
        }
        
        .badge-points {
            font-size: 10px;
            color: #ffd700;
            margin-top: 4px;
            font-weight: 600;
        }
        
        /* Delete Account Button */
        .danger-button {
            padding: 12px 30px;
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            margin-top: 20px;
            transition: all 0.3s;
        }
        
        .danger-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(231, 76, 60, 0.4);
        }
        
        /* ===== END SETTINGS TAB STYLES ===== */

    </style>
</head>
<body>

    <!-- Global Account Status Bar (Visible on all pages) -->
    <div id="global-account-bar" style="
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        height: 45px;
        background: rgba(20, 24, 32, 0.95);
        backdrop-filter: blur(10px);
        border-bottom: 2px solid rgba(245, 125, 45, 0.3);
        display: none;
        align-items: center;
        justify-content: space-between;
        padding: 0 25px;
        z-index: 9997;
        box-sizing: border-box;
    ">
        <!-- Logo/Brand -->
        <div style="display: flex; align-items: center; gap: 15px;">
            <h1 style="
                margin: 0;
                font-size: 1.3em;
                background: linear-gradient(135deg, #f57d2d 0%, #fcc49c 100%);
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                background-clip: text;
                letter-spacing: 2px;
                cursor: pointer;
            " onclick="window.location.href='/'">ROMGON</h1>
        </div>
        
        <!-- Account Status -->
        <div style="display: flex; align-items: center; gap: 20px;">
            <!-- Account Card -->
            <div onclick="showAccountModal()" style="
                display: flex;
                align-items: center;
                gap: 10px;
                padding: 6px 14px;
                background: rgba(78, 205, 196, 0.15);
                border: 1px solid rgba(78, 205, 196, 0.3);
                border-radius: 10px;
                cursor: pointer;
                transition: all 0.3s ease;
            " onmouseover="this.style.background='rgba(78, 205, 196, 0.25)'; this.style.borderColor='rgba(78, 205, 196, 0.5)'" onmouseout="this.style.background='rgba(78, 205, 196, 0.15)'; this.style.borderColor='rgba(78, 205, 196, 0.3)'">
                <div id="global-avatar" style="
                    width: 30px;
                    height: 30px;
                    border-radius: 50%;
                    background: linear-gradient(135deg, #4ecdc4, #a55eea);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 14px;
                    font-weight: bold;
                    color: #fff;
                    border: 2px solid rgba(255, 255, 255, 0.3);
                ">G</div>
                <div style="display: flex; flex-direction: column; gap: 1px;">
                    <div style="display: flex; align-items: center; gap: 6px;">
                        <span id="global-username" style="font-weight: 600; color: #fff; font-size: 0.85em;">Player</span>
                        <span id="global-account-type" style="
                            font-size: 0.6em;
                            padding: 1px 5px;
                            background: rgba(255, 215, 0, 0.2);
                            color: #ffd700;
                            border-radius: 5px;
                            font-weight: 600;
                            text-transform: uppercase;
                        ">Guest</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 6px; font-size: 0.7em; color: #aaa;">
                        <span><span style="color: #26de81;" id="global-wins">0</span>W</span>
                        <span style="color: #555;">‚Ä¢</span>
                        <span><span style="color: #ff6b6b;" id="global-losses">0</span>L</span>
                        <span style="color: #555;">‚Ä¢</span>
                        <span id="global-winrate" style="color: #4ecdc4;">0%</span>
                    </div>
                </div>
            </div>
            
            <!-- Quick Action Buttons -->
            <button onclick="showSettingsModal()" style="
                background: transparent;
                border: none;
                color: #aaa;
                font-size: 1.1em;
                cursor: pointer;
                padding: 6px;
                transition: color 0.3s;
            " onmouseover="this.style.color='#fff'" onmouseout="this.style.color='#aaa'" title="Settings">
                ‚öôÔ∏è
            </button>
        </div>
    </div>

    <!-- Keyboard Navigation Player Indicator -->
    <div id="kb-player-indicator" style="display: none !important; position: fixed; top: 20px; right: 20px; padding: 12px 20px; background: #333; color: #fff; border-radius: 8px; font-weight: bold; z-index: 9999; border: 2px solid #4ecdc4;">
        ‚å®Ô∏è KB: Loaded
    </div>

    <!-- Keyboard Navigation Help -->
    <div id="kb-help-overlay" style="display: none !important; position: fixed; bottom: 20px; left: 20px; background: rgba(20, 24, 32, 0.95); border: 2px solid #4ecdc4; border-radius: 8px; padding: 15px; font-size: 12px; color: #4ecdc4; max-width: 250px; z-index: 9998; line-height: 1.6; font-family: 'Courier New', monospace;">
        <strong>‚å®Ô∏è KEYBOARD CONTROLS</strong><br>
        ‚Üë‚Üì‚Üê‚Üí / W,A,S,D: Move<br>
        Space / Enter: Confirm<br>
        Esc: Deselect
    </div>

    <!-- Keyboard Info Side Panel -->
    <div id="kb-info-panel" style="display: none; position: fixed; right: 0; top: 0; width: 350px; height: 100vh; background: rgba(20, 24, 32, 0.98); border-left: 3px solid #4ecdc4; overflow-y: auto; z-index: 3001; padding: 20px; box-sizing: border-box; font-family: 'Courier New', monospace; color: #4ecdc4; line-height: 1.8;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 2px solid #4ecdc4; padding-bottom: 15px;">
            <h2 style="margin: 0; font-size: 1.1em;">‚å®Ô∏è KEYBOARD INFO</h2>
            <button onclick="document.getElementById('kb-info-panel').style.display='none'" style="background: none; border: none; color: #4ecdc4; font-size: 1.5em; cursor: pointer; padding: 0;">‚úï</button>
        </div>
        
        <div style="margin-bottom: 20px;">
            <h3 style="color: #f57d2d; margin: 0 0 10px 0; font-size: 0.95em;">PIECE SELECTION</h3>
            <div style="font-size: 0.9em; line-height: 2;">
                W,A,S,D - Navigate pieces<br>
                E - Select piece<br>
                Esc - Deselect
            </div>
        </div>

        <div style="margin-bottom: 20px;">
            <h3 style="color: #f57d2d; margin: 0 0 10px 0; font-size: 0.95em;">MOVE SELECTION</h3>
            <div style="font-size: 0.9em; line-height: 2;">
                W,A,S,D - Navigate target hexes<br>
                E - Execute move<br>
                Esc - Back to piece selection
            </div>
        </div>

        <div style="margin-bottom: 20px;">
            <h3 style="color: #f57d2d; margin: 0 0 10px 0; font-size: 0.95em;">ROTATION (Triangle/Hexagon)</h3>
            <div style="font-size: 0.9em; line-height: 2;">
                A - Rotate LEFT<br>
                D - Rotate RIGHT<br>
                Space - End turn
            </div>
        </div>

        <div style="margin-bottom: 20px;">
            <h3 style="color: #f57d2d; margin: 0 0 10px 0; font-size: 0.95em;">OTHER PIECES</h3>
            <div style="font-size: 0.9em; line-height: 2;">
                After move: Turn ends<br>
                (No rotation needed)
            </div>
        </div>

        <div style="border-top: 2px solid #4ecdc4; padding-top: 15px; margin-top: 20px;">
            <h3 style="color: #f57d2d; margin: 0 0 15px 0; font-size: 0.95em;">KEYBOARD MODES</h3>
            
            <button id="kb-pvp-toggle" onclick="togglePVPKeyboard()" style="
                width: 100%;
                padding: 10px;
                margin-bottom: 10px;
                background-color: #26de81;
                color: white;
                border: none;
                border-radius: 8px;
                cursor: pointer;
                font-weight: bold;
                font-size: 0.9em;
                transition: all 0.3s ease;
                font-family: 'Courier New', monospace;
            " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                ‚úì PVP KEYBOARD
            </button>
            
            <button id="kb-general-toggle" onclick="toggleGeneralNavigation()" style="
                width: 100%;
                padding: 10px;
                margin-bottom: 15px;
                background-color: #888;
                color: white;
                border: none;
                border-radius: 8px;
                cursor: pointer;
                font-weight: bold;
                font-size: 0.9em;
                transition: all 0.3s ease;
                font-family: 'Courier New', monospace;
            " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                ‚óã GENERAL NAVIGATION
            </button>

            <p style="margin: 0; font-size: 0.85em; color: #888; line-height: 1.6;">
                <strong>PVP:</strong> Use WASD+E for piece/move selection and rotation<br>
                <strong>General:</strong> Navigate menus and UI with WASD+E
            </p>
        </div>
    </div>

    <!-- Splash Page -->
    <div id="splash-page" style="
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, #0f1923 0%, #1a2332 50%, #0f1923 100%);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 3000;
        color: white;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        overflow-y: auto;
        padding: 20px;
        box-sizing: border-box;
    ">
        <!-- Logo Section -->
        <div style="
            text-align: center;
            margin-bottom: 40px;
        ">
            <h1 style="
                font-size: 4em;
                font-weight: 800;
                margin: 0;
                background: linear-gradient(135deg, #f57d2d 0%, #fcc49c 100%);
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                background-clip: text;
                letter-spacing: 8px;
                text-shadow: 0 0 40px rgba(245, 125, 45, 0.5);
                animation: logoGlow 2s ease-in-out infinite alternate;
            ">ROMGON</h1>
            <p style="
                font-size: 1.2em;
                margin: 10px 0 0 0;
                color: #fcc49c;
                font-weight: 300;
                letter-spacing: 3px;
            ">HEXAGONAL STRATEGY GAME</p>
        </div>

        <!-- Game Description -->
        <div style="
            max-width: 600px;
            text-align: center;
            margin-bottom: 50px;
            padding: 0 20px;
        ">
            <p style="
                font-size: 0.95em;
                line-height: 1.6;
                color: #ddd;
                margin: 0 0 20px 0;
            ">
                Master the hexagonal battlefield in this strategic masterpiece. Command unique pieces with rotational abilities,
                navigate complex zone systems, and outmaneuver your opponent in a game of tactical brilliance.
            </p>
            <div style="
                display: flex;
                justify-content: center;
                gap: 30px;
                margin-top: 30px;
            ">
                <div style="text-align: center;">
                    <div style="font-size: 2em; margin-bottom: 5px;">‚ôüÔ∏è</div>
                    <div style="font-size: 0.9em; color: #4ecdc4; font-weight: 600;">7 Unique Pieces</div>
                </div>
                <div style="text-align: center;">
                    <div style="font-size: 2em; margin-bottom: 5px;">üîÑ</div>
                    <div style="font-size: 0.9em; color: #a55eea; font-weight: 600;">Rotational Tactics</div>
                </div>
                <div style="text-align: center;">
                    <div style="font-size: 2em; margin-bottom: 5px;">üéØ</div>
                    <div style="font-size: 0.9em; color: #ffd700; font-weight: 600;">Strategic Depth</div>
                </div>
            </div>
        </div>

        <!-- Login Options -->
        <div style="
            display: flex;
            flex-direction: column;
            gap: 20px;
            min-width: 300px;
            max-width: 400px;
        ">
            <!-- Google Login Button -->
            <button id="google-login-btn" style="
                background: linear-gradient(135deg, #4285f4 0%, #34a853 50%, #ea4335 100%);
                color: white;
                border: none;
                padding: 18px 30px;
                border-radius: 50px;
                cursor: pointer;
                font-weight: 700;
                font-size: 0.95em;
                box-shadow: 0 6px 20px rgba(66, 133, 244, 0.4);
                transition: all 0.3s ease;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 12px;
                letter-spacing: 0.5px;
            " onmouseover="this.style.transform='translateY(-3px)'; this.style.boxShadow='0 10px 30px rgba(66, 133, 244, 0.6)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 6px 20px rgba(66, 133, 244, 0.4)'">
                <svg width="20" height="20" viewBox="0 0 24 24">
                    <path fill="currentColor" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                    <path fill="currentColor" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                    <path fill="currentColor" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                    <path fill="currentColor" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                </svg>
                Sign in with Google
            </button>

            <!-- Traditional Sign In Button -->
            <button id="signin-login-btn" style="
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                border: none;
                padding: 18px 30px;
                border-radius: 50px;
                cursor: pointer;
                font-weight: 700;
                font-size: 0.95em;
                box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
                transition: all 0.3s ease;
                letter-spacing: 0.5px;
            " onmouseover="this.style.transform='translateY(-3px)'; this.style.boxShadow='0 10px 30px rgba(102, 126, 234, 0.6)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 6px 20px rgba(102, 126, 234, 0.4)'">
                üîê Sign In
            </button>

            <!-- Guest Login Button -->
            <button id="guest-login-btn" style="
                background: linear-gradient(135deg, rgba(78, 205, 196, 0.2), rgba(78, 205, 196, 0.1));
                color: #4ecdc4;
                border: 2px solid #4ecdc4;
                padding: 18px 30px;
                border-radius: 50px;
                cursor: pointer;
                font-weight: 700;
                font-size: 0.95em;
                box-shadow: 0 4px 15px rgba(78, 205, 196, 0.2);
                transition: all 0.3s ease;
                letter-spacing: 0.5px;
            " onmouseover="this.style.transform='translateY(-3px)'; this.style.boxShadow='0 8px 25px rgba(78, 205, 196, 0.4)'; this.style.background='linear-gradient(135deg, rgba(78, 205, 196, 0.3), rgba(78, 205, 196, 0.2))'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(78, 205, 196, 0.2)'; this.style.background='linear-gradient(135deg, rgba(78, 205, 196, 0.2), rgba(78, 205, 196, 0.1))'">
                üéÆ Continue as Guest
            </button>

            <!-- Sign Up Button -->
            <button id="signup-btn" style="
                background: linear-gradient(135deg, #ff6b6b, #ff5252);
                color: white;
                border: none;
                padding: 18px 30px;
                border-radius: 50px;
                cursor: pointer;
                font-weight: 700;
                font-size: 0.95em;
                box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
                transition: all 0.3s ease;
                letter-spacing: 0.5px;
            " onmouseover="this.style.transform='translateY(-3px)'; this.style.boxShadow='0 10px 30px rgba(255, 107, 107, 0.6)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 6px 20px rgba(255, 107, 107, 0.4)'" onclick="showSignUpModal()">
                üìù Create Account
            </button>
        </div>

        <!-- Footer Info -->
        <div style="
            position: absolute;
            bottom: 30px;
            text-align: center;
            color: #888;
            font-size: 0.9em;
        ">
            <p style="margin: 0;">¬© 2025 ROMGON - Strategic Hexagonal Gaming</p>
        </div>
    </div>

    <!-- User Home Page (shown after login) -->
    <div id="user-home" style="
        position: fixed;
        top: 45px;
        left: 0;
        width: 100%;
        height: calc(100% - 45px);
        background: linear-gradient(135deg, #0f1923 0%, #1a2332 50%, #0f1923 100%);
        display: none;
        flex-direction: column;
        z-index: 3000;
        color: white;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        overflow-y: auto;
        box-sizing: border-box;
    ">
        <!-- Main Content Area -->
        <div style="
            padding: 30px;
            max-width: 1400px;
            margin: 0 auto;
            width: 100%;
        ">
            <!-- Online Players Section -->
            <div style="
                background: rgba(78, 205, 196, 0.1);
                border: 1px solid rgba(78, 205, 196, 0.3);
                border-radius: 12px;
                padding: 15px 20px;
                margin-bottom: 20px;
                display: flex;
                align-items: center;
                justify-content: space-between;
                flex-wrap: wrap;
                gap: 15px;
            ">
                <div style="display: flex; align-items: center; gap: 15px;">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <div style="
                            width: 10px;
                            height: 10px;
                            border-radius: 50%;
                            background: #4ecdc4;
                            box-shadow: 0 0 10px rgba(78, 205, 196, 0.6);
                            animation: pulse 2s infinite;
                        "></div>
                        <span style="color: #4ecdc4; font-weight: 600; font-size: 1.1em;">
                            <span id="online-players-count">0</span> Players Online
                        </span>
                    </div>
                </div>
                
                <div id="online-players-list" style="
                    display: flex;
                    gap: 10px;
                    flex-wrap: wrap;
                    align-items: center;
                ">
                    <!-- Players will be added dynamically -->
                    <span style="color: #888; font-size: 0.9em;">Connecting...</span>
                </div>
            </div>
            
            <!-- Quick Play Bar (Highlighted) -->
            <div style="
                background: linear-gradient(135deg, #f57d2d 0%, #ff9a4d 100%);
                border-radius: 16px;
                padding: 30px;
                margin-bottom: 30px;
                box-shadow: 0 8px 30px rgba(245, 125, 45, 0.4);
            ">
                <h2 style="
                    margin: 0 0 20px 0;
                    font-size: 1.8em;
                    color: #fff;
                    font-weight: 700;
                ">‚ö° QUICK PLAY</h2>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px;">
                    <button onclick="openGameVariantsModal('ai')" style="
                        background: rgba(255, 255, 255, 0.95);
                        color: #1a1e26;
                        border: none;
                        padding: 18px;
                        border-radius: 12px;
                        cursor: pointer;
                        font-weight: 700;
                        font-size: 1em;
                        transition: all 0.3s;
                        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
                    " onmouseover="this.style.transform='translateY(-3px)'; this.style.boxShadow='0 6px 20px rgba(0, 0, 0, 0.3)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(0, 0, 0, 0.2)'">
                        ü§ñ vs AI
                    </button>
                    
                    <button onclick="startGameWithTime(10)" style="
                        background: rgba(255, 255, 255, 0.95);
                        color: #1a1e26;
                        border: none;
                        padding: 18px;
                        border-radius: 12px;
                        cursor: pointer;
                        font-weight: 700;
                        font-size: 1em;
                        transition: all 0.3s;
                        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
                    " onmouseover="this.style.transform='translateY(-3px)'; this.style.boxShadow='0 6px 20px rgba(0, 0, 0, 0.3)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(0, 0, 0, 0.2)'">
                        üë• vs Human
                    </button>
                    
                    <button onclick="alert('Online matchmaking coming soon!');" style="
                        background: rgba(255, 255, 255, 0.95);
                        color: #1a1e26;
                        border: none;
                        padding: 18px;
                        border-radius: 12px;
                        cursor: pointer;
                        font-weight: 700;
                        font-size: 1em;
                        transition: all 0.3s;
                        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
                    " onmouseover="this.style.transform='translateY(-3px)'; this.style.boxShadow='0 6px 20px rgba(0, 0, 0, 0.3)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(0, 0, 0, 0.2)'">
                        üåê Online
                    </button>
                    
                    <button onclick="startSandboxMode();" style="
                        background: rgba(255, 255, 255, 0.95);
                        color: #1a1e26;
                        border: none;
                        padding: 18px;
                        border-radius: 12px;
                        cursor: pointer;
                        font-weight: 700;
                        font-size: 1em;
                        transition: all 0.3s;
                        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
                    " onmouseover="this.style.transform='translateY(-3px)'; this.style.boxShadow='0 6px 20px rgba(0, 0, 0, 0.3)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(0, 0, 0, 0.2)'">
                        üõ†Ô∏è Practice
                    </button>
                </div>
            </div>

            <!-- Two Column Layout -->
            <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 30px; margin-bottom: 30px;">
                <!-- Left Column: Active Games -->
                <div style="
                    background: rgba(35, 39, 46, 0.8);
                    border-radius: 16px;
                    padding: 25px;
                    border: 1px solid rgba(78, 205, 196, 0.2);
                ">
                    <h3 style="margin: 0 0 20px 0; color: #4ecdc4; font-size: 1.3em;">üéÆ ACTIVE GAMES</h3>
                    <div id="active-games-list" style="display: flex; flex-direction: column; gap: 12px;">
                        <!-- Placeholder for active games -->
                        <div style="
                            background: rgba(78, 205, 196, 0.1);
                            border: 1px solid rgba(78, 205, 196, 0.3);
                            border-radius: 10px;
                            padding: 15px;
                            text-align: center;
                            color: #888;
                        ">
                            No active games. Start a new game to get started!
                        </div>
                    </div>
                </div>

                <!-- Right Column: Your Stats -->
                <div style="
                    background: rgba(35, 39, 46, 0.8);
                    border-radius: 16px;
                    padding: 25px;
                    border: 1px solid rgba(78, 205, 196, 0.2);
                ">
                    <h3 style="margin: 0 0 20px 0; color: #ffd700; font-size: 1.3em;">üìä YOUR STATS</h3>
                    <div style="display: flex; flex-direction: column; gap: 15px;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span style="color: #aaa;">Rating</span>
                            <span style="font-size: 1.5em; font-weight: 700; color: #ffd700;" id="user-rating">1420</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span style="color: #aaa;">Win / Loss</span>
                            <span style="font-weight: 600;"><span style="color: #26de81;" id="user-home-wins">0</span> - <span style="color: #ff6b6b;" id="user-home-losses">0</span></span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span style="color: #aaa;">Win Rate</span>
                            <span style="font-weight: 600; color: #4ecdc4;" id="user-home-winrate">0%</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span style="color: #aaa;">Games Played</span>
                            <span style="font-weight: 600; color: #fff;" id="user-home-games">0</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Features Grid -->
            <div style="
                background: rgba(35, 39, 46, 0.8);
                border-radius: 16px;
                padding: 25px;
                border: 1px solid rgba(78, 205, 196, 0.2);
                margin-bottom: 30px;
            ">
                <h3 style="margin: 0 0 20px 0; color: #a55eea; font-size: 1.3em;">‚ú® FEATURES</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px;">
                    <button onclick="alert('Daily puzzles coming soon!');" style="
                        background: rgba(165, 94, 234, 0.1);
                        border: 1px solid rgba(165, 94, 234, 0.3);
                        color: #a55eea;
                        padding: 20px 15px;
                        border-radius: 10px;
                        cursor: pointer;
                        font-weight: 600;
                        transition: all 0.3s;
                        text-align: center;
                    " onmouseover="this.style.background='rgba(165, 94, 234, 0.2)'" onmouseout="this.style.background='rgba(165, 94, 234, 0.1)'">
                        <div style="font-size: 2em; margin-bottom: 5px;">üß©</div>
                        <div>Daily Puzzle</div>
                    </button>
                    
                    <button onclick="showOpeningBook()" style="
                        background: rgba(78, 205, 196, 0.1);
                        border: 1px solid rgba(78, 205, 196, 0.3);
                        color: #4ecdc4;
                        padding: 20px 15px;
                        border-radius: 10px;
                        cursor: pointer;
                        font-weight: 600;
                        transition: all 0.3s;
                        text-align: center;
                    " onmouseover="this.style.background='rgba(78, 205, 196, 0.2)'" onmouseout="this.style.background='rgba(78, 205, 196, 0.1)'">
                        <div style="font-size: 2em; margin-bottom: 5px;">üìñ</div>
                        <div>Learn</div>
                    </button>
                    
                    <button onclick="alert('Achievements coming soon!');" style="
                        background: rgba(255, 215, 0, 0.1);
                        border: 1px solid rgba(255, 215, 0, 0.3);
                        color: #ffd700;
                        padding: 20px 15px;
                        border-radius: 10px;
                        cursor: pointer;
                        font-weight: 600;
                        transition: all 0.3s;
                        text-align: center;
                    " onmouseover="this.style.background='rgba(255, 215, 0, 0.2)'" onmouseout="this.style.background='rgba(255, 215, 0, 0.1)'">
                        <div style="font-size: 2em; margin-bottom: 5px;">üèÜ</div>
                        <div>Achievements</div>
                    </button>
                    
                    <button onclick="openAnalysisModal()" style="
                        background: rgba(78, 205, 196, 0.1);
                        border: 1px solid rgba(78, 205, 196, 0.3);
                        color: #4ecdc4;
                        padding: 20px 15px;
                        border-radius: 10px;
                        cursor: pointer;
                        font-weight: 600;
                        transition: all 0.3s;
                        text-align: center;
                    " onmouseover="this.style.background='rgba(78, 205, 196, 0.2)'" onmouseout="this.style.background='rgba(78, 205, 196, 0.1)'">
                        <div style="font-size: 2em; margin-bottom: 5px;">üìä</div>
                        <div>Analysis</div>
                    </button>
                    
                    <button onclick="alert('Friends coming soon!');" style="
                        background: rgba(255, 107, 107, 0.1);
                        border: 1px solid rgba(255, 107, 107, 0.3);
                        color: #ff6b6b;
                        padding: 20px 15px;
                        border-radius: 10px;
                        cursor: pointer;
                        font-weight: 600;
                        transition: all 0.3s;
                        text-align: center;
                    " onmouseover="this.style.background='rgba(255, 107, 107, 0.2)'" onmouseout="this.style.background='rgba(255, 107, 107, 0.1)'">
                        <div style="font-size: 2em; margin-bottom: 5px;">üë•</div>
                        <div>Friends</div>
                    </button>
                    
                    <button onclick="alert('Spectate coming soon!');" style="
                        background: rgba(165, 94, 234, 0.1);
                        border: 1px solid rgba(165, 94, 234, 0.3);
                        color: #a55eea;
                        padding: 20px 15px;
                        border-radius: 10px;
                        cursor: pointer;
                        font-weight: 600;
                        transition: all 0.3s;
                        text-align: center;
                    " onmouseover="this.style.background='rgba(165, 94, 234, 0.2)'" onmouseout="this.style.background='rgba(165, 94, 234, 0.1)'">
                        <div style="font-size: 2em; margin-bottom: 5px;">üéÆ</div>
                        <div>Spectate</div>
                    </button>
                </div>
            </div>

            <!-- Match History -->
            <div style="
                background: rgba(35, 39, 46, 0.8);
                border-radius: 16px;
                padding: 25px;
                border: 1px solid rgba(78, 205, 196, 0.2);
            ">
                <h3 style="margin: 0 0 20px 0; color: #00d2ff; font-size: 1.3em;">üìú MATCH HISTORY</h3>
                <div id="match-history-list" style="display: flex; flex-direction: column; gap: 10px;">
                    <!-- Placeholder for match history -->
                    <div style="
                        background: rgba(78, 205, 196, 0.05);
                        border-left: 3px solid #4ecdc4;
                        padding: 12px 15px;
                        border-radius: 6px;
                        color: #888;
                        text-align: center;
                    ">
                        No games played yet. Your match history will appear here.
                    </div>
                </div>
                <button onclick="alert('Full history coming soon!');" style="
                    width: 100%;
                    margin-top: 15px;
                    background: transparent;
                    border: 2px solid rgba(78, 205, 196, 0.3);
                    color: #4ecdc4;
                    padding: 12px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-weight: 600;
                    transition: all 0.3s;
                " onmouseover="this.style.background='rgba(78, 205, 196, 0.1)'" onmouseout="this.style.background='transparent'">
                    View All Games ‚Üí
                </button>
            </div>

            <!-- Chat/Messaging Section -->
            <div style="
                background: rgba(35, 39, 46, 0.8);
                border-radius: 16px;
                padding: 25px;
                border: 1px solid rgba(78, 205, 196, 0.2);
                margin-top: 30px;
            ">
                <h3 style="margin: 0 0 20px 0; color: #ff79c6; font-size: 1.3em;">üí¨ CHAT & MESSAGES</h3>
                
                <!-- Chat Tabs -->
                <div style="display: flex; gap: 10px; margin-bottom: 20px; border-bottom: 2px solid rgba(78, 205, 196, 0.2); padding-bottom: 10px;">
                    <button id="global-chat-tab" onclick="switchChatTab('global')" style="
                        background: linear-gradient(135deg, #ff79c6, #bd93f9);
                        color: white;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 8px;
                        cursor: pointer;
                        font-weight: 600;
                        font-size: 0.9em;
                        transition: all 0.3s;
                        flex: 1;
                    ">
                        üåê Global Chat
                    </button>
                    <button id="friends-chat-tab" onclick="switchChatTab('friends')" style="
                        background: rgba(78, 205, 196, 0.2);
                        color: #4ecdc4;
                        border: 1px solid rgba(78, 205, 196, 0.3);
                        padding: 10px 20px;
                        border-radius: 8px;
                        cursor: pointer;
                        font-weight: 600;
                        font-size: 0.9em;
                        transition: all 0.3s;
                        flex: 1;
                    ">
                        üë• Friends
                    </button>
                </div>

                <!-- Global Chat Panel -->
                <div id="global-chat-panel" style="display: block;">
                    <!-- Chat Messages -->
                    <div id="global-chat-messages" style="
                        background: rgba(0, 0, 0, 0.3);
                        border-radius: 10px;
                        padding: 15px;
                        height: 300px;
                        overflow-y: auto;
                        margin-bottom: 15px;
                        border: 1px solid rgba(255, 121, 198, 0.2);
                    ">
                        <!-- Sample Messages -->
                        <div style="margin-bottom: 12px;">
                            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                                <div style="
                                    width: 24px;
                                    height: 24px;
                                    border-radius: 50%;
                                    background: linear-gradient(135deg, #4ecdc4, #a55eea);
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    font-size: 12px;
                                    font-weight: bold;
                                    color: #fff;
                                ">S</div>
                                <span style="color: #4ecdc4; font-weight: 600; font-size: 0.9em;">StrategicMind</span>
                                <span style="color: #666; font-size: 0.75em;">2m ago</span>
                            </div>
                            <div style="color: #ccc; font-size: 0.9em; padding-left: 32px;">
                                Looking for a quick game! Anyone online?
                            </div>
                        </div>

                        <div style="margin-bottom: 12px;">
                            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                                <div style="
                                    width: 24px;
                                    height: 24px;
                                    border-radius: 50%;
                                    background: linear-gradient(135deg, #ff6b6b, #ffd700);
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    font-size: 12px;
                                    font-weight: bold;
                                    color: #fff;
                                ">H</div>
                                <span style="color: #ff6b6b; font-weight: 600; font-size: 0.9em;">HexMaster</span>
                                <span style="color: #666; font-size: 0.75em;">5m ago</span>
                            </div>
                            <div style="color: #ccc; font-size: 0.9em; padding-left: 32px;">
                                Just finished an amazing game! This fortress strategy is OP üî•
                            </div>
                        </div>

                        <div style="margin-bottom: 12px;">
                            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                                <div style="
                                    width: 24px;
                                    height: 24px;
                                    border-radius: 50%;
                                    background: linear-gradient(135deg, #a55eea, #5f27cd);
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    font-size: 12px;
                                    font-weight: bold;
                                    color: #fff;
                                ">R</div>
                                <span style="color: #a55eea; font-weight: 600; font-size: 0.9em;">RomgonPro</span>
                                <span style="color: #666; font-size: 0.75em;">8m ago</span>
                            </div>
                            <div style="color: #ccc; font-size: 0.9em; padding-left: 32px;">
                                Welcome to all new players! Check out the tutorial if you're just starting üìñ
                            </div>
                        </div>

                        <div style="
                            text-align: center;
                            color: #666;
                            font-size: 0.85em;
                            padding: 10px;
                            font-style: italic;
                        ">
                            Real-time chat coming soon! Connect with players worldwide.
                        </div>
                    </div>

                    <!-- Message Input -->
                    <div style="display: flex; gap: 10px;">
                        <input id="global-chat-input" type="text" placeholder="Type a message..." style="
                            flex: 1;
                            background: rgba(0, 0, 0, 0.3);
                            border: 1px solid rgba(255, 121, 198, 0.3);
                            border-radius: 8px;
                            padding: 12px 15px;
                            color: white;
                            font-size: 0.9em;
                            outline: none;
                            transition: all 0.3s;
                        " onfocus="this.style.borderColor='rgba(255, 121, 198, 0.6)'" onblur="this.style.borderColor='rgba(255, 121, 198, 0.3)'" oninput="handleGlobalChatTyping()" onkeypress="if(event.key==='Enter') sendGlobalMessage()">
                        <button onclick="sendGlobalMessage()" style="
                            background: linear-gradient(135deg, #ff79c6, #bd93f9);
                            color: white;
                            border: none;
                            padding: 12px 24px;
                            border-radius: 8px;
                            cursor: pointer;
                            font-weight: 600;
                            transition: all 0.3s;
                        " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                            Send üì§
                        </button>
                    </div>

                    <!-- Online Users Count -->
                    <div style="
                        margin-top: 15px;
                        padding: 10px 15px;
                        background: rgba(78, 205, 196, 0.1);
                        border-radius: 8px;
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        border: 1px solid rgba(78, 205, 196, 0.2);
                    ">
                        <span style="color: #4ecdc4; font-size: 0.9em; font-weight: 600;">
                            üü¢ <span id="online-users-count">42</span> players online
                        </span>
                        <button onclick="alert('User list coming soon!');" style="
                            background: transparent;
                            border: 1px solid rgba(78, 205, 196, 0.3);
                            color: #4ecdc4;
                            padding: 6px 12px;
                            border-radius: 6px;
                            cursor: pointer;
                            font-size: 0.85em;
                            transition: all 0.3s;
                        " onmouseover="this.style.background='rgba(78, 205, 196, 0.1)'" onmouseout="this.style.background='transparent'">
                            View All
                        </button>
                    </div>
                </div>

                <!-- Friends Chat Panel -->
                <div id="friends-chat-panel" style="display: none;">
                    <!-- Friends List -->
                    <div id="friends-list" style="
                        background: rgba(0, 0, 0, 0.3);
                        border-radius: 10px;
                        padding: 15px;
                        height: 300px;
                        overflow-y: auto;
                        margin-bottom: 15px;
                        border: 1px solid rgba(78, 205, 196, 0.2);
                    ">
                        <!-- Sample Friend Messages -->
                        <div style="
                            background: rgba(78, 205, 196, 0.1);
                            border-left: 3px solid #4ecdc4;
                            padding: 12px;
                            border-radius: 8px;
                            margin-bottom: 10px;
                            cursor: pointer;
                            transition: all 0.3s;
                        " onmouseover="this.style.background='rgba(78, 205, 196, 0.2)'" onmouseout="this.style.background='rgba(78, 205, 196, 0.1)'" onclick="openFriendChat('StrategicMind')">
                            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                                <div style="
                                    width: 32px;
                                    height: 32px;
                                    border-radius: 50%;
                                    background: linear-gradient(135deg, #4ecdc4, #a55eea);
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    font-size: 14px;
                                    font-weight: bold;
                                    color: #fff;
                                    position: relative;
                                ">
                                    S
                                    <div style="
                                        position: absolute;
                                        bottom: 0;
                                        right: 0;
                                        width: 10px;
                                        height: 10px;
                                        background: #26de81;
                                        border-radius: 50%;
                                        border: 2px solid #23272e;
                                    "></div>
                                </div>
                                <div style="flex: 1;">
                                    <div style="color: #4ecdc4; font-weight: 600; font-size: 0.95em;">StrategicMind</div>
                                    <div style="color: #888; font-size: 0.8em;">Online ‚Ä¢ Last seen now</div>
                                </div>
                                <div style="
                                    background: #ff79c6;
                                    color: white;
                                    font-size: 0.75em;
                                    padding: 3px 8px;
                                    border-radius: 12px;
                                    font-weight: 600;
                                ">2</div>
                            </div>
                            <div style="color: #aaa; font-size: 0.85em; padding-left: 42px;">
                                "Want to play a rematch? üòä"
                            </div>
                        </div>

                        <div style="
                            background: rgba(78, 205, 196, 0.05);
                            border-left: 3px solid rgba(78, 205, 196, 0.3);
                            padding: 12px;
                            border-radius: 8px;
                            margin-bottom: 10px;
                            cursor: pointer;
                            transition: all 0.3s;
                        " onmouseover="this.style.background='rgba(78, 205, 196, 0.1)'" onmouseout="this.style.background='rgba(78, 205, 196, 0.05)'" onclick="openFriendChat('HexMaster')">
                            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                                <div style="
                                    width: 32px;
                                    height: 32px;
                                    border-radius: 50%;
                                    background: linear-gradient(135deg, #ff6b6b, #ffd700);
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    font-size: 14px;
                                    font-weight: bold;
                                    color: #fff;
                                    position: relative;
                                ">
                                    H
                                    <div style="
                                        position: absolute;
                                        bottom: 0;
                                        right: 0;
                                        width: 10px;
                                        height: 10px;
                                        background: #888;
                                        border-radius: 50%;
                                        border: 2px solid #23272e;
                                    "></div>
                                </div>
                                <div style="flex: 1;">
                                    <div style="color: #ff6b6b; font-weight: 600; font-size: 0.95em;">HexMaster</div>
                                    <div style="color: #888; font-size: 0.8em;">Offline ‚Ä¢ Last seen 2h ago</div>
                                </div>
                            </div>
                            <div style="color: #aaa; font-size: 0.85em; padding-left: 42px;">
                                "GG! That was intense üî•"
                            </div>
                        </div>

                        <div style="
                            text-align: center;
                            color: #666;
                            font-size: 0.85em;
                            padding: 20px;
                            font-style: italic;
                        ">
                            Add friends to chat privately and challenge them to games!
                        </div>
                    </div>

                    <!-- Add Friend -->
                    <div style="display: flex; gap: 10px;">
                        <input id="add-friend-input" type="text" placeholder="Enter friend's username..." style="
                            flex: 1;
                            background: rgba(0, 0, 0, 0.3);
                            border: 1px solid rgba(78, 205, 196, 0.3);
                            border-radius: 8px;
                            padding: 12px 15px;
                            color: white;
                            font-size: 0.9em;
                            outline: none;
                            transition: all 0.3s;
                        " onfocus="this.style.borderColor='rgba(78, 205, 196, 0.6)'" onblur="this.style.borderColor='rgba(78, 205, 196, 0.3)'" onkeypress="if(event.key==='Enter') addFriend()">
                        <button onclick="addFriend()" style="
                            background: linear-gradient(135deg, #4ecdc4, #45b7aa);
                            color: white;
                            border: none;
                            padding: 12px 24px;
                            border-radius: 8px;
                            cursor: pointer;
                            font-weight: 600;
                            transition: all 0.3s;
                        " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                            Add Friend üë•
                        </button>
                    </div>

                    <!-- Friend Stats -->
                    <div style="
                        margin-top: 15px;
                        padding: 10px 15px;
                        background: rgba(165, 94, 234, 0.1);
                        border-radius: 8px;
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        border: 1px solid rgba(165, 94, 234, 0.2);
                    ">
                        <span style="color: #a55eea; font-size: 0.9em; font-weight: 600;">
                            üë• <span id="friends-count">2</span> friends
                        </span>
                        <button onclick="alert('Friend management coming soon!');" style="
                            background: transparent;
                            border: 1px solid rgba(165, 94, 234, 0.3);
                            color: #a55eea;
                            padding: 6px 12px;
                            border-radius: 6px;
                            cursor: pointer;
                            font-size: 0.85em;
                            transition: all 0.3s;
                        " onmouseover="this.style.background='rgba(165, 94, 234, 0.1)'" onmouseout="this.style.background='transparent'">
                            Manage
                        </button>
                    </div>
                </div>
            </div>

            <!-- Guest Upgrade Notice -->
            <div id="guest-upgrade-notice" style="
                background: linear-gradient(135deg, rgba(255, 215, 0, 0.15), rgba(255, 165, 0, 0.1));
                border: 2px solid rgba(255, 215, 0, 0.3);
                border-radius: 12px;
                padding: 20px;
                display: none;
                text-align: center;
                margin-top: 30px;
            ">
                <div style="font-size: 28px; margin-bottom: 10px;">üíé</div>
                <h4 style="margin: 0 0 8px 0; color: #ffd700; font-size: 16px;">Unlock Full Features</h4>
                <p style="margin: 0 0 15px 0; color: #aaa; font-size: 13px;">Create an account to save your progress, track stats, and compete on leaderboards!</p>
                <button onclick="hideUserHome(); showSignUpModal();" style="
                    background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
                    color: #1a1e26;
                    border: none;
                    padding: 12px 30px;
                    border-radius: 50px;
                    cursor: pointer;
                    font-weight: 700;
                    font-size: 0.9em;
                    box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
                    transition: all 0.3s ease;
                " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(255, 215, 0, 0.6)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(255, 215, 0, 0.4)'">
                    ‚ú® Create Free Account
                </button>
            </div>
        </div>
    </div>

    <style>
        @keyframes logoGlow {
            0% { text-shadow: 0 0 20px rgba(245, 125, 45, 0.3); }
            100% { text-shadow: 0 0 40px rgba(245, 125, 45, 0.7); }
        }

        @media (max-width: 768px) {
            #splash-page h1 {
                font-size: 3em !important;
                letter-spacing: 4px !important;
            }

            #splash-page {
                padding: 15px !important;
            }

            .login-options {
                min-width: 280px !important;
                max-width: 350px !important;
            }

            #user-home {
                padding: 20px !important;
            }
            
            /* Multiplayer Modal - Mobile Friendly */
            .multiplayer-container {
                padding: 25px 20px !important;
                max-width: 90vw !important;
            }
            
            .multiplayer-container h2 {
                font-size: 22px !important;
            }
            
            .mp-button {
                font-size: 14px !important;
                padding: 12px 20px !important;
                min-height: 48px !important;
            }
            
            /* Game Room Modal - Mobile Friendly */
            .game-room-container {
                padding: 25px 20px !important;
                max-width: 90vw !important;
            }
            
            /* Touch-Friendly Buttons Throughout */
            button, .btn, input[type="button"], input[type="submit"] {
                min-height: 44px !important;
                font-size: 14px !important;
            }
            
            /* Prevent Text Selection on Touch */
            .hex-cell, #board-container, .piece-icon {
                -webkit-user-select: none !important;
                -moz-user-select: none !important;
                -ms-user-select: none !important;
                user-select: none !important;
                -webkit-tap-highlight-color: transparent !important;
            }
            
            /* Improve Touch Target Sizes */
            .hex-cell {
                cursor: pointer;
                -webkit-tap-highlight-color: rgba(255, 255, 255, 0.2) !important;
            }
            
            /* Better Modal Scrolling on Mobile */
            .modal-content, .multiplayer-container, .game-room-container {
                -webkit-overflow-scrolling: touch !important;
            }
        }
    </style>

    <!-- Compact Professional Start Menu -->
    <div id="start-menu" style="
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, #0f1419 0%, #1a1f2e 50%, #0f1419 100%);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 2000;
        color: white;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        overflow-y: auto;
        padding: 40px 20px;
        box-sizing: border-box;
    ">
        <!-- Logo/Title Section -->
        <div style="
            text-align: center;
            margin-bottom: 60px;
            max-width: 800px;
        ">
            <h1 style="
                font-size: 3.5em;
                font-weight: 900;
                margin: 0 0 10px 0;
                background: linear-gradient(135deg, #f57d2d 0%, #ffa500 100%);
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                background-clip: text;
                letter-spacing: 8px;
            ">ROMGON</h1>
            <p style="
                font-size: 0.9em;
                margin: 0;
                color: #999;
                font-weight: 300;
                letter-spacing: 3px;
            ">HEXAGONAL STRATEGY GAME</p>
        </div>
        
        <!-- Return to Game Link (shown when in active game) -->
        <div id="return-to-game-container" style="
            display: none;
            text-align: center;
            margin-bottom: 50px;
        ">
            <a onclick="returnToGame()" style="
                color: #ff6b6b;
                font-size: 1.2em;
                font-weight: 700;
                cursor: pointer;
                text-decoration: none;
                letter-spacing: 2px;
                padding: 10px 20px;
                border-bottom: 2px solid #ff6b6b;
                transition: all 0.3s ease;
                display: inline-block;
            " onmouseover="this.style.color='#ff8a8a'; this.style.textShadow='0 0 20px rgba(255, 107, 107, 0.5)'" onmouseout="this.style.color='#ff6b6b'; this.style.textShadow='none'">
                ‚Üê RETURN TO GAME
            </a>
        </div>
        
        <!-- Main Menu - Text-Based Interface -->
        <div style="
            max-width: 850px;
            width: 90vw;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px;
            padding: 0 15px;
        ">
            <!-- Game Modes Section -->
            <div>
                <h2 style="
                    color: #f57d2d;
                    font-size: 1.5em;
                    margin: 0 0 30px 0;
                    font-weight: 700;
                    letter-spacing: 3px;
                    border-bottom: 2px solid #f57d2d;
                    padding-bottom: 10px;
                ">GAME MODES</h2>
                
                <div style="
                    display: flex;
                    flex-direction: column;
                    gap: 20px;
                ">
                    <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                        <span style="color: #4ecdc4; font-size: 1.8em;">üë•</span>
                        <a id="start-game-btn" onclick="startGameWithTime(10)" style="
                            color: #4ecdc4;
                            font-size: 0.95em;
                            font-weight: 600;
                            cursor: pointer;
                            text-decoration: none;
                            letter-spacing: 1px;
                            transition: all 0.3s ease;
                            display: inline-block;
                            white-space: nowrap;
                        " onmouseover="this.style.color='#5eddd4'; this.style.textShadow='0 0 15px rgba(78, 205, 196, 0.5)'" onmouseout="this.style.color='#4ecdc4'; this.style.textShadow='none'">LOCAL PVP</a>
                        <span style="color: #666; font-size: 0.8em; margin-left: auto;">Two players ‚Ä¢ Same</span>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                        <span style="color: #26de81; font-size: 1.8em;">üåê</span>
                        <a id="start-multiplayer-btn" style="
                            color: #26de81;
                            font-size: 0.95em;
                            font-weight: 600;
                            cursor: pointer;
                            text-decoration: none;
                            letter-spacing: 1px;
                            transition: all 0.3s ease;
                            display: inline-block;
                            white-space: nowrap;
                        " onmouseover="this.style.color='#3bed92'; this.style.textShadow='0 0 15px rgba(38, 222, 129, 0.5)'" onmouseout="this.style.color='#26de81'; this.style.textShadow='none'">ONLINE</a>
                        <span style="color: #666; font-size: 0.8em; margin-left: auto;">Play online ‚Ä¢ Friends</span>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                        <span style="color: #a55eea; font-size: 1.8em;">ü§ñ</span>
                        <a id="start-ai-mode-btn" style="
                            color: #a55eea;
                            font-size: 0.95em;
                            font-weight: 600;
                            cursor: pointer;
                            text-decoration: none;
                            letter-spacing: 1px;
                            transition: all 0.3s ease;
                            display: inline-block;
                            white-space: nowrap;
                        " onmouseover="this.style.color='#b075ff'; this.style.textShadow='0 0 15px rgba(165, 94, 234, 0.5)'" onmouseout="this.style.color='#a55eea'; this.style.textShadow='none'">VS AI</a>
                        <span style="color: #666; font-size: 0.8em; margin-left: auto;">Smart AI ‚Ä¢ Opponent</span>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                        <span style="color: #ffd700; font-size: 1.8em;">üß©</span>
                        <a id="start-puzzles-btn" style="
                            color: #ffd700;
                            font-size: 0.95em;
                            font-weight: 600;
                            cursor: pointer;
                            text-decoration: none;
                            letter-spacing: 1px;
                            transition: all 0.3s ease;
                            display: inline-block;
                            white-space: nowrap;
                        " onmouseover="this.style.color='#ffed4e'; this.style.textShadow='0 0 15px rgba(255, 215, 0, 0.5)'" onmouseout="this.style.color='#ffd700'; this.style.textShadow='none'">PUZZLES</a>
                        <span style="color: #666; font-size: 0.8em; margin-left: auto;">Train skills ‚Ä¢ Solve</span>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                        <span style="color: #00d2ff; font-size: 1.8em;">üß†</span>
                        <a id="start-llm-mode-btn" onclick="openGameVariantsModal('llm')" style="
                            color: #00d2ff;
                            font-size: 0.95em;
                            font-weight: 600;
                            cursor: pointer;
                            text-decoration: none;
                            letter-spacing: 1px;
                            transition: all 0.3s ease;
                            display: inline-block;
                            white-space: nowrap;
                        " onmouseover="this.style.color='#00ffff'; this.style.textShadow='0 0 15px rgba(0, 210, 255, 0.5)'" onmouseout="this.style.color='#00d2ff'; this.style.textShadow='none'">AI REASONING</a>
                        <span style="color: #666; font-size: 0.8em; margin-left: auto;">AI ‚Ä¢ Explanations</span>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                        <span style="color: #ff6b6b; font-size: 1.8em;">üéØ</span>
                        <a id="start-game-modes-btn" onclick="openGameModesModal()" style="
                            color: #ff6b6b;
                            font-size: 0.95em;
                            font-weight: 600;
                            cursor: pointer;
                            text-decoration: none;
                            letter-spacing: 1px;
                            transition: all 0.3s ease;
                            display: inline-block;
                            white-space: nowrap;
                        " onmouseover="this.style.color='#ff8a8a'; this.style.textShadow='0 0 15px rgba(255, 107, 107, 0.5)'" onmouseout="this.style.color='#ff6b6b'; this.style.textShadow='none'">VARIANTS</a>
                        <span style="color: #666; font-size: 0.8em; margin-left: auto;">Alt ‚Ä¢ Modes</span>
                    </div>
                </div>
            </div>
            
            <!-- Reference Section -->
            <div>
                <h2 style="
                    color: #00d2ff;
                    font-size: 1.5em;
                    margin: 0 0 30px 0;
                    font-weight: 700;
                    letter-spacing: 3px;
                    border-bottom: 2px solid #00d2ff;
                    padding-bottom: 10px;
                ">REFERENCE & LEARNING</h2>
                
                <div style="
                    display: flex;
                    flex-direction: column;
                    gap: 15px;
                ">
                    <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                        <span style="color: #f1c40f; font-size: 1.6em;">üìä</span>
                        <a onclick="showStatsDashboard()" style="
                            color: #f1c40f;
                            font-size: 0.95em;
                            font-weight: 600;
                            cursor: pointer;
                            text-decoration: none;
                            letter-spacing: 1px;
                            transition: all 0.3s ease;
                            display: inline-block;
                            white-space: nowrap;
                        " onmouseover="this.style.color='#ffd700'; this.style.textShadow='0 0 15px rgba(241, 196, 15, 0.5)'" onmouseout="this.style.color='#f1c40f'; this.style.textShadow='none'">STATISTICS</a>
                        <span style="color: #666; font-size: 0.75em; margin-left: auto;">Track ‚Ä¢ Stats</span>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                        <span style="color: #4ecdc4; font-size: 1.6em;">üìñ</span>
                        <a onclick="showOpeningBook()" style="
                            color: #4ecdc4;
                            font-size: 0.95em;
                            font-weight: 600;
                            cursor: pointer;
                            text-decoration: none;
                            letter-spacing: 1px;
                            transition: all 0.3s ease;
                            display: inline-block;
                            white-space: nowrap;
                        " onmouseover="this.style.color='#5eddd4'; this.style.textShadow='0 0 15px rgba(78, 205, 196, 0.5)'" onmouseout="this.style.color='#4ecdc4'; this.style.textShadow='none'">OPENING BOOK</a>
                        <span style="color: #666; font-size: 0.75em; margin-left: auto;">Openings ‚Ä¢ Diagrams</span>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                        <span style="color: #a55eea; font-size: 1.6em;">üß†</span>
                        <a onclick="openTheoryModal()" style="
                            color: #a55eea;
                            font-size: 0.95em;
                            font-weight: 600;
                            cursor: pointer;
                            text-decoration: none;
                            letter-spacing: 1px;
                            transition: all 0.3s ease;
                            display: inline-block;
                            white-space: nowrap;
                        " onmouseover="this.style.color='#b075ff'; this.style.textShadow='0 0 15px rgba(165, 94, 234, 0.5)'" onmouseout="this.style.color='#a55eea'; this.style.textShadow='none'">THEORY</a>
                        <span style="color: #666; font-size: 0.75em; margin-left: auto;">Strategy ‚Ä¢ Analysis</span>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                        <span style="color: #f57d2d; font-size: 1.6em;">üìú</span>
                        <a onclick="openRulebookModal()" style="
                            color: #f57d2d;
                            font-size: 0.95em;
                            font-weight: 600;
                            cursor: pointer;
                            text-decoration: none;
                            letter-spacing: 1px;
                            transition: all 0.3s ease;
                            display: inline-block;
                            white-space: nowrap;
                        " onmouseover="this.style.color='#ffa500'; this.style.textShadow='0 0 15px rgba(245, 125, 45, 0.5)'" onmouseout="this.style.color='#f57d2d'; this.style.textShadow='none'">RULEBOOK</a>
                        <span style="color: #666; font-size: 0.75em; margin-left: auto;">Rules ‚Ä¢ How to play</span>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                        <span style="color: #27ae60; font-size: 1.6em;">üí°</span>
                        <a onclick="openFaqModal()" style="
                            color: #27ae60;
                            font-size: 0.95em;
                            font-weight: 600;
                            cursor: pointer;
                            text-decoration: none;
                            letter-spacing: 1px;
                            transition: all 0.3s ease;
                            display: inline-block;
                            white-space: nowrap;
                        " onmouseover="this.style.color='#2ecc71'; this.style.textShadow='0 0 15px rgba(39, 174, 96, 0.5)'" onmouseout="this.style.color='#27ae60'; this.style.textShadow='none'">FAQ & TIPS</a>
                        <span style="color: #666; font-size: 0.75em; margin-left: auto;">Questions ‚Ä¢ Strategies</span>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                        <span style="color: #ffd700; font-size: 1.6em;">üèÜ</span>
                        <a onclick="openBadgeSystem()" style="
                            color: #ffd700;
                            font-size: 0.95em;
                            font-weight: 600;
                            cursor: pointer;
                            text-decoration: none;
                            letter-spacing: 1px;
                            transition: all 0.3s ease;
                            display: inline-block;
                            white-space: nowrap;
                        " onmouseover="this.style.color='#ffed4e'; this.style.textShadow='0 0 15px rgba(255, 215, 0, 0.5)'" onmouseout="this.style.color='#ffd700'; this.style.textShadow='none'">BADGE SYSTEM</a>
                        <span style="color: #666; font-size: 0.75em; margin-left: auto;">210+ Badges ‚Ä¢ Achievements</span>
                    </div>
                </div>
            </div>
            
            <!-- User Account Section -->
            <div>
                <h2 style="
                    color: #ffd700;
                    font-size: 1.5em;
                    margin: 0 0 30px 0;
                    font-weight: 700;
                    letter-spacing: 3px;
                    border-bottom: 2px solid #ffd700;
                    padding-bottom: 10px;
                ">ACCOUNT</h2>
                
                <div style="
                    display: flex;
                    flex-direction: column;
                    gap: 15px;
                ">
                    <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                        <span style="color: #4ecdc4; font-size: 1.6em;">üë§</span>
                        <a onclick="showAccountModal()" style="
                            color: #4ecdc4;
                            font-size: 0.95em;
                            font-weight: 600;
                            cursor: pointer;
                            text-decoration: none;
                            letter-spacing: 1px;
                            transition: all 0.3s ease;
                            display: inline-block;
                            white-space: nowrap;
                        " onmouseover="this.style.color='#5eddd4'; this.style.textShadow='0 0 15px rgba(78, 205, 196, 0.5)'" onmouseout="this.style.color='#4ecdc4'; this.style.textShadow='none'">ACCOUNT</a>
                        <span style="color: #666; font-size: 0.75em; margin-left: auto;">Profile ‚Ä¢ Stats</span>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                        <span style="color: #a55eea; font-size: 1.6em;">‚öôÔ∏è</span>
                        <a onclick="showSettingsModal()" style="
                            color: #a55eea;
                            font-size: 0.95em;
                            font-weight: 600;
                            cursor: pointer;
                            text-decoration: none;
                            letter-spacing: 1px;
                            transition: all 0.3s ease;
                            display: inline-block;
                            white-space: nowrap;
                        " onmouseover="this.style.color='#b075ff'; this.style.textShadow='0 0 15px rgba(165, 94, 234, 0.5)'" onmouseout="this.style.color='#a55eea'; this.style.textShadow='none'">PREFERENCES</a>
                        <span style="color: #666; font-size: 0.75em; margin-left: auto;">Audio ‚Ä¢ Display ‚Ä¢ Theme</span>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                        <span style="color: #4ecdc4; font-size: 1.6em;">üè†</span>
                        <a onclick="document.getElementById('start-menu').style.display='none'; showUserHome();" style="
                            color: #4ecdc4;
                            font-size: 0.95em;
                            font-weight: 600;
                            cursor: pointer;
                            text-decoration: none;
                            letter-spacing: 1px;
                            transition: all 0.3s ease;
                            display: inline-block;
                            white-space: nowrap;
                        " onmouseover="this.style.color='#5eddd4'; this.style.textShadow='0 0 15px rgba(78, 205, 196, 0.5)'" onmouseout="this.style.color='#4ecdc4'; this.style.textShadow='none'">LOBBY</a>
                        <span style="color: #666; font-size: 0.75em; margin-left: auto;">User home ‚Ä¢ Quick play</span>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                        <span style="color: #ff6b6b; font-size: 1.6em;">üé®</span>
                        <a onclick="window.location.href='game-creator.html'" style="
                            color: #ff6b6b;
                            font-size: 0.95em;
                            font-weight: 600;
                            cursor: pointer;
                            text-decoration: none;
                            letter-spacing: 1px;
                            transition: all 0.3s ease;
                            display: inline-block;
                            white-space: nowrap;
                        " onmouseover="this.style.color='#ff8787'; this.style.textShadow='0 0 15px rgba(255, 107, 107, 0.5)'" onmouseout="this.style.color='#ff6b6b'; this.style.textShadow='none'">GAME CREATOR</a>
                        <span style="color: #666; font-size: 0.75em; margin-left: auto;">Design games ‚Ä¢ Create</span>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                        <span style="color: #ff6b6b; font-size: 1.6em;">üö™</span>
                        <a onclick="quitAndLogout()" style="
                            color: #ff6b6b;
                            font-size: 0.95em;
                            font-weight: 600;
                            cursor: pointer;
                            text-decoration: none;
                            letter-spacing: 1px;
                            transition: all 0.3s ease;
                            display: inline-block;
                            white-space: nowrap;
                        " onmouseover="this.style.color='#ff8a8a'; this.style.textShadow='0 0 15px rgba(255, 107, 107, 0.5)'" onmouseout="this.style.color='#ff6b6b'; this.style.textShadow='none'">LOG OUT</a>
                        <span style="color: #666; font-size: 0.75em; margin-left: auto;">Sign out ‚Ä¢ Exit</span>
                    </div>
                </div>
            </div>
            
            <!-- AI & Advanced Options Section -->
            <div>
                <h2 style="
                    color: #00d2ff;
                    font-size: 1.5em;
                    margin: 0 0 30px 0;
                    font-weight: 700;
                    letter-spacing: 3px;
                    border-bottom: 2px solid #00d2ff;
                    padding-bottom: 10px;
                ">ADVANCED OPTIONS</h2>
                
                <div style="
                    display: flex;
                    flex-direction: column;
                    gap: 15px;
                ">
                    <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                        <span style="color: #667eea; font-size: 1.6em;">üîß</span>
                        <a onclick="window.open('engine-analysis.html', '_blank')" style="
                            color: #667eea;
                            font-size: 0.95em;
                            font-weight: 600;
                            cursor: pointer;
                            text-decoration: none;
                            letter-spacing: 1px;
                            transition: all 0.3s ease;
                            display: inline-block;
                            white-space: nowrap;
                        " onmouseover="this.style.color='#7c8ef5'; this.style.textShadow='0 0 15px rgba(102, 126, 234, 0.5)'" onmouseout="this.style.color='#667eea'; this.style.textShadow='none'">ENGINE ANALYSIS</a>
                        <span style="color: #666; font-size: 0.75em; margin-left: auto;">Monitor ‚Ä¢ Optimize</span>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                        <span style="color: #4ecdc4; font-size: 1.6em;">üìä</span>
                        <a onclick="openAnalysisModal()" style="
                            color: #4ecdc4;
                            font-size: 0.95em;
                            font-weight: 600;
                            cursor: pointer;
                            text-decoration: none;
                            letter-spacing: 1px;
                            transition: all 0.3s ease;
                            display: inline-block;
                            white-space: nowrap;
                        " onmouseover="this.style.color='#5eddd4'; this.style.textShadow='0 0 15px rgba(78, 205, 196, 0.5)'" onmouseout="this.style.color='#4ecdc4'; this.style.textShadow='none'">ANALYSIS</a>
                        <span style="color: #666; font-size: 0.75em; margin-left: auto;">Load ‚Ä¢ Review</span>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                        <span style="color: #9b59b6; font-size: 1.6em;">üìö</span>
                        <a onclick="window.location.href='game-library.html'" style="
                            color: #9b59b6;
                            font-size: 0.95em;
                            font-weight: 600;
                            cursor: pointer;
                            text-decoration: none;
                            letter-spacing: 1px;
                            transition: all 0.3s ease;
                            display: inline-block;
                            white-space: nowrap;
                        " onmouseover="this.style.color='#a569bd'; this.style.textShadow='0 0 15px rgba(155, 89, 182, 0.5)'" onmouseout="this.style.color='#9b59b6'; this.style.textShadow='none'">GAME LIBRARY</a>
                        <span style="color: #666; font-size: 0.75em; margin-left: auto;">Browse ‚Ä¢ Play</span>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                        <span style="color: #00d9ff; font-size: 1.6em;">üéÆ</span>
                        <a onclick="window.open('game-engine-api.html', '_blank')" style="
                            color: #00d9ff;
                            font-size: 0.95em;
                            font-weight: 600;
                            cursor: pointer;
                            text-decoration: none;
                            letter-spacing: 1px;
                            transition: all 0.3s ease;
                            display: inline-block;
                            white-space: nowrap;
                        " onmouseover="this.style.color='#33e6ff'; this.style.textShadow='0 0 15px rgba(0, 217, 255, 0.5)'" onmouseout="this.style.color='#00d9ff'; this.style.textShadow='none'">GAME ENGINE API</a>
                        <span style="color: #666; font-size: 0.75em; margin-left: auto;">For developers ‚Ä¢ AI tools</span>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                        <span style="color: #ffd700; font-size: 1.6em;">üîë</span>
                        <a onclick="window.open('api-keys.html', '_blank')" style="
                            color: #ffd700;
                            font-size: 0.95em;
                            font-weight: 600;
                            cursor: pointer;
                            text-decoration: none;
                            letter-spacing: 1px;
                            transition: all 0.3s ease;
                            display: inline-block;
                            white-space: nowrap;
                        " onmouseover="this.style.color='#ffed4e'; this.style.textShadow='0 0 15px rgba(255, 215, 0, 0.5)'" onmouseout="this.style.color='#ffd700'; this.style.textShadow='none'">API KEYS</a>
                        <span style="color: #666; font-size: 0.75em; margin-left: auto;">Manage ‚Ä¢ Generate</span>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                        <span style="color: #00bfff; font-size: 1.6em;">üîê</span>
                        <a onclick="window.open('auth.html', '_blank')" style="
                            color: #00bfff;
                            font-size: 0.95em;
                            font-weight: 600;
                            cursor: pointer;
                            text-decoration: none;
                            letter-spacing: 1px;
                            transition: all 0.3s ease;
                            display: inline-block;
                            white-space: nowrap;
                        " onmouseover="this.style.color='#66d9ff'; this.style.textShadow='0 0 15px rgba(0, 191, 255, 0.5)'" onmouseout="this.style.color='#00bfff'; this.style.textShadow='none'">AUTH</a>
                        <span style="color: #666; font-size: 0.75em; margin-left: auto;">Login ‚Ä¢ Register</span>
                    </div>
                </div>
            </div>
            <div style="
                text-align: center;
                color: #999;
                font-size: 0.85em;
                max-width: 600px;
                margin: 0 auto;
                line-height: 1.6;
                padding-top: 30px;
                border-top: 1px solid #333;
            ">
                <p style="margin: 0 0 10px 0;">
                    <strong style="color: #f57d2d;">Objective:</strong> Move your rhombus to opponent's base or trap theirs
                </p>
                <p style="margin: 0;">
                    <strong style="color: #4ecdc4;">Tip:</strong> Start with Local PVP to learn the basics
                </p>
            </div>
        </div>
    <!-- Theory Modal -->
    <div id="theory-modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.92); z-index:10001; justify-content:center; align-items:center; overflow-y:auto;">
        <div style="background:#262421; border:3px solid #a55eea; border-radius:20px; padding:40px 30px; max-width:900px; width:95vw; margin:40px auto; box-shadow:0 10px 50px rgba(165,94,234,0.2); position:relative; color:#fff;">
            <h2 style="color:#a55eea; text-align:center; margin-bottom:24px; font-size:2em;">üß† ROMGON Theory & Endgame Guide</h2>
            <div id="theory-content" style="max-height:65vh; overflow-y:auto; color:#eee; font-size:1.08em; line-height:1.7; background:rgba(0,0,0,0.10); padding:18px; border-radius:10px; border:1px solid #444; white-space:pre-wrap;"></div>
            <button onclick="closeTheoryModal()" style="margin-top:28px; background:#a55eea; color:#fff; border:none; padding:12px 32px; border-radius:8px; font-size:1.1em; font-weight:600; cursor:pointer; width:100%; transition:all 0.2s;" onmouseover="this.style.background='#8e44ad'" onmouseout="this.style.background='#a55eea'">Close</button>
        </div>
    </div>
    <script>
    // THEORY MODAL LOGIC
    function openTheoryModal() {
                const modal = document.getElementById('theory-modal');
                const contentDiv = document.getElementById('theory-content');
                if (!contentDiv.dataset.loaded) {
                                                contentDiv.innerHTML = `
<div style="color:#eee; font-size:1.08em; line-height:1.7;">
    <h2 style="color:#a55eea; text-align:center; margin-top:0;">üß† ROMGON Theoretical Aspects</h2>
    <div style="text-align:center; color:#ffd700; font-size:1em; margin-bottom:18px;">Last updated: October 12, 2025</div>
    <hr style="border:1px solid #444; margin:18px 0;"/>

    <h3 style="color:#4ecdc4;">1. State Space Complexity</h3>
    <ul>
        <li>The board has <span style="color:#ffd700; font-weight:bold;">51 hexes</span> (variable per row, with central symmetry).</li>
        <li>Each player has <span style="color:#ffd700; font-weight:bold;">7 pieces</span> (2 Triangles, 2 Squares, 1 Rhombus, 1 Circle, 1 Hexagon), all distinguishable by type and color.</li>
        <li>Piece orientation (for triangles/hexagons) increases the number of unique positions.</li>
        <li><b>Estimated arrangements:</b> <span style="color:#fdcb6e;">C(51,14) √ó 7! √ó 7! ‚âà 10<sup>18</sup></span>. Including empty hexes, captures, and orientation, the true number is much higher‚Äîlikely <span style="color:#fdcb6e; font-weight:bold;">10<sup>25</sup> to 10<sup>32</sup></span>.</li>
        <li><b>Comparison:</b> Similar to or greater than chess, but less than Go.</li>
    </ul>

    <h3 style="color:#a55eea;">2. Game Tree Complexity</h3>
    <ul>
        <li>Each turn: <span style="color:#ffd700;">10‚Äì40 legal moves</span> (varies by position, phase, and piece count).</li>
        <li>Rotations and zone transitions add to the branching factor.</li>
        <li>Average game length: <span style="color:#4ecdc4;">60‚Äì120 moves</span> (30‚Äì60 per player).</li>
        <li><b>Estimated total possible games:</b> <span style="color:#fdcb6e;">10<sup>80</sup> to 10<sup>120</sup></span>.</li>
        <li><b>Longest forced win:</b> Likely hundreds of moves in fortress/blockade endgames.</li>
    </ul>

    <h3 style="color:#ffd700;">3. Move Types and Branching</h3>
    <ul>
        <li><b>Move types:</b> Standard moves, rotations, captures, special moves (gateway, base entry, deadlock escapes).</li>
        <li><b>Branching factor:</b> Early: <span style="color:#4ecdc4;">20‚Äì40</span>, Midgame: <span style="color:#4ecdc4;">10‚Äì30</span>, Endgame: <span style="color:#4ecdc4;">2‚Äì10</span>.</li>
        <li>Rotational moves and zone transitions make Romgon's branching factor more volatile than chess.</li>
    </ul>

    <h3 style="color:#fdcb6e;">4. Symmetry and Redundancy</h3>
    <ul>
        <li><b>Hexagonal symmetry:</b> 6-fold, but piece orientation and color break most symmetries.</li>
        <li>Some positions are equivalent under rotation/reflection, but most are unique.</li>
        <li><b>Redundancy:</b> Many positions are theoretically possible but illegal (e.g., two pieces on one hex).</li>
        <li>Symmetry can reduce AI search space, but only partially.</li>
    </ul>

    <h3 style="color:#4ecdc4;">5. Draws, Forced Wins, and Zugzwang</h3>
    <ul>
        <li><b>No draws by repetition:</b> <span style="color:#ff6b6b;">Threefold repetition and fivefold shuttle are losses</span>, not draws.</li>
        <li><b>Forced wins:</b> Endgames with only rhombuses are often races; fortress variant allows for blockades and forced wins by attrition.</li>
        <li><b>Zugzwang:</b> Forced loss by moving is common, especially in endgames with few pieces.</li>
        <li><b>Deadlock:</b> Opponent's rhombus under attack with no legal moves is a win.</li>
        <li><b>Draglock:</b> No legal moves at all is a loss.</li>
    </ul>

    <h3 style="color:#a55eea;">6. Opening Theory</h3>
    <ul>
        <li><b>Opening book:</b> Still developing; few forced lines, but early mistakes can be decisive.</li>
        <li>Central control, base defense, and piece development are key.</li>
        <li>Early circle and hexagon moves can create threats or open gateways.</li>
        <li>Triangles are flexible but vulnerable to poor orientation.</li>
        <li><b>Typical themes:</b> Control of the Dead Zone and gateways, early base defense, avoiding congestion, maximizing mobility.</li>
    </ul>

    <h3 style="color:#ffd700;">7. Endgame Theory</h3>
    <ul>
        <li><b>Rhombus endgames:</b> Often races to the base or blockades; fortress variant increases defensive resources.</li>
        <li>Sacrifices and forced shuttles are common.</li>
        <li>Endgames can be very deep, with forced wins requiring precise calculation.</li>
        <li><b>Piece value:</b> Triangles and hexagons become more valuable for their mobility and rotation; circles can be decisive in zone transitions.</li>
    </ul>

    <h3 style="color:#fdcb6e;">8. Computational Complexity</h3>
    <ul>
        <li><b>Solving Romgon:</b> Likely <span style="color:#4ecdc4;">EXPTIME-complete</span> (like chess and hex), due to large state and game tree complexity.</li>
        <li>No known perfect play algorithm; AI uses heuristics, alpha-beta search, and Monte Carlo methods.</li>
        <li>Tablebases for small endgames are possible but would be very large.</li>
        <li><b>AI challenges:</b> Rotational moves and zone transitions make evaluation and search more difficult than in chess.</li>
        <li>Threat detection and deadlock/draglock recognition are nontrivial.</li>
    </ul>

    <h3 style="color:#a55eea;">Endgame and Base Defense Rules in Romgon</h3>
        <div style="margin-bottom:10px; color:#ffd700; font-weight:bold;">Romgon endgames can reach rare situations where a lone rhombus is blocked by non-rhombus pieces, creating a fortress or blockade. The game supports two base-defense variants to handle these:</div>
    <ol style="margin-left:18px;">
        <li><b style="color:#4ecdc4;">Repetition Rule (Default):</b> If the same position occurs three times, the player who repeats <span style="color:#ff6b6b;">loses</span>. Prevents endless blockades. <span style="color:#4ecdc4;">Pros:</span> Familiar, fair. <span style="color:#ff6b6b;">Cons:</span> Sometimes a player with a big advantage cannot win if blocked by a fortress.</li>
        <li><b style="color:#a55eea;">Unstoppable Rhombus Wins (Variant):</b> If a rhombus is one move from the goal and cannot be stopped or captured, that player wins immediately. <span style="color:#4ecdc4;">Pros:</span> Dramatic, rewards skillful play. <span style="color:#ff6b6b;">Cons:</span> Requires clear adjudication.</li>
        <li><b style="color:#ffd700;">Last Non-Rhombus Piece Lost = Game Over (Optional):</b> If a player loses their last non-rhombus piece, they lose. <span style="color:#4ecdc4;">Pros:</span> Simple. <span style="color:#ff6b6b;">Cons:</span> Removes rhombus-only races and can feel abrupt.</li>
    </ol>
    <div style="margin:10px 0; color:#4ecdc4; font-weight:bold;">Recommendation:</div>
    <ul>
        <li>The default Romgon rules use the repetition rule to resolve fortress/blockade situations.</li>
        <li>For advanced or tournament play, you may use the "Unstoppable Rhombus Wins" rule to reward decisive play and avoid unsatisfying blockades.</li>
        <li>The "Last Non-Rhombus Piece Lost" rule is not recommended for standard play, but may be used as a fast-paced variant.</li>
    </ul>
    <div style="color:#ffd700; font-weight:bold; margin-top:10px;">Players should agree on which rule to use before the game begins.</div>

    <hr style="border:1px solid #444; margin:18px 0;"/>
    <div style="color:#eee; font-size:1.08em; text-align:center; margin-top:18px;">
        Romgon is a deep, complex game with rich theoretical possibilities. Its combination of hex geometry, piece rotation, and unique rules creates a vast landscape for exploration, analysis, and creative play.<br>
        <span style="color:#4ecdc4;">Ongoing research may reveal new forced wins, opening traps, and endgame studies in the years to come!</span>
    </div>
</div>
    - Zugzwang (forced loss by moving) is common, especially in endgames with few pieces.
    - Some positions are mutual zugzwang, where either player to move loses.
- **Deadlock and draglock:**
    - Deadlock (opponent's rhombus under attack with no legal moves) is a win.
    - Draglock (no legal moves at all) is a loss.

## 6. Opening Theory
- **Opening book:**
    - Still developing; few forced lines, but early mistakes can be decisive.
    - Central control, base defense, and piece development are key.
    - Early circle and hexagon moves can create threats or open gateways.
    - Triangles are flexible but vulnerable to poor orientation.
- **Typical themes:**
    - Control of the Dead Zone and gateways
    - Early base defense (especially in fortress variant)
    - Avoiding piece congestion and maximizing mobility

## 7. Endgame Theory
- **Rhombus endgames:**
    - Often races to the base or blockades; fortress variant increases defensive resources.
    - Sacrifices and forced shuttles are common.
    - Endgames can be very deep, with forced wins requiring precise calculation.
- **Piece value:**
    - Value of pieces changes in the endgame; triangles and hexagons become more valuable for their mobility and rotation.
    - Circles can be decisive in zone transitions.

## 8. Computational Complexity
- **Solving Romgon:**
    - Likely EXPTIME-complete (like chess and hex), due to large state and game tree complexity.
    - No known perfect play algorithm; AI uses heuristics, alpha-beta search, and Monte Carlo methods.
    - Tablebases for small endgames are possible but would be very large.
- **AI challenges:**
    - Rotational moves and zone transitions make evaluation and search more difficult than in chess.
    - Threat detection and deadlock/draglock recognition are nontrivial.

## Fortress, Blockade, and Endgame Rules in Romgon

Romgon endgames can sometimes reach rare situations where a lone rhombus is blocked by non-rhombus pieces (such as two squares), creating a fortress or blockade. There are several ways to resolve these situations, each with different strategic implications:

### 1. Repetition Rule (Default)
- If the same position occurs three times (threefold repetition), the player who repeats loses.
- This prevents endless blockades: if the advanced rhombus cannot break through, the defender can force a repetition and win.
- **Pros:** Familiar, fair, and prevents infinite games.
- **Cons:** Sometimes a player with a big advantage cannot win if blocked by a fortress.

### 2. Unstoppable Rhombus Wins (Variant)
- If a rhombus is one move away from the goal and cannot be stopped or captured by any legal move, that player wins immediately.
- This rewards the player who creates an unstoppable threat, even if they have lost all other pieces.
- **Pros:** Dramatic finishes, rewards skillful play, avoids fortress draws.
- **Cons:** Requires clear adjudication; may not be suitable for all players.

### 3. Last Non-Rhombus Piece Lost = Game Over (Optional Variant)
- If a player loses their last non-rhombus piece, they lose the game.
- **Pros:** Simple, prevents fortress problems entirely.
- **Cons:** Removes rhombus-only races and can feel abrupt.

### Recommendation
- The default Romgon rules use the repetition rule to resolve fortress/blockade situations.
- For advanced or tournament play, you may use the "Unstoppable Rhombus Wins" rule to reward decisive play and avoid unsatisfying blockades.
- The "Last Non-Rhombus Piece Lost" rule is not recommended for standard play, but may be used as a fast-paced variant.

**Players should agree on which rule to use before the game begins.**

---

Romgon is a deep, complex game with rich theoretical possibilities. Its combination of hex geometry, piece rotation, and unique rules creates a vast landscape for exploration, analysis, and creative play. Ongoing research may reveal new forced wins, opening traps, and endgame studies in the years to come!
</pre>`;
                        contentDiv.dataset.loaded = '1';
                }
                modal.style.display = 'flex';
        }
    function closeTheoryModal() {
        document.getElementById('theory-modal').style.display = 'none';
    }
    </script>
            </div>
    <!-- Rulebook Modal -->
    <div id="rulebook-modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.92); z-index:10001; justify-content:center; align-items:center; overflow-y:auto;">
        <div style="background:#262421; border:3px solid #f57d2d; border-radius:20px; padding:40px 30px; max-width:900px; width:95vw; margin:40px auto; box-shadow:0 10px 50px rgba(245,125,45,0.2); position:relative; color:#fff;">
            <h2 style="color:#f57d2d; text-align:center; margin-bottom:24px; font-size:2em;">üìú ROMGON Official Rulebook</h2>
            <div id="rulebook-content" style="max-height:65vh; overflow-y:auto; color:#eee; font-size:1.08em; line-height:1.7; background:rgba(0,0,0,0.10); padding:18px; border-radius:10px; border:1px solid #444; white-space:pre-wrap;"></div>
            <button onclick="closeRulebookModal()" style="margin-top:28px; background:#f57d2d; color:#fff; border:none; padding:12px 32px; border-radius:8px; font-size:1.1em; font-weight:600; cursor:pointer; width:100%; transition:all 0.2s;" onmouseover="this.style.background='#e67e22'" onmouseout="this.style.background='#f57d2d'">Close</button>
        </div>
    </div>
    <script>
    // RULEBOOK MODAL LOGIC
    function openRulebookModal() {
        // If already loaded, just show
        const modal = document.getElementById('rulebook-modal');
        const contentDiv = document.getElementById('rulebook-content');
        if (!contentDiv.dataset.loaded) {
            // Insert the rulebook content as HTML (converted from markdown)
            contentDiv.innerHTML = `
<h3>ROMGON Official Rulebook</h3>
<p><em>Last updated: October 12, 2025</em></p>
<hr/>
<ol>
<li>Game Overview</li>
<li>Board Layout</li>
<li>Piece Types & Movement</li>
<li>Turn Structure</li>
<li>Special Rules</li>
        }
<li>Notation System</li>
<li>Advanced Features</li>
<li>Game Modes & Variants</li>
<li>FAQ & Tips</li>
<li>Base Defense Rule</li>
</ol>
<h4>1. Game Overview</h4>
<p>Romgon is a strategic hexagonal board game. Each player controls <b>7 pieces</b>:<br>- 5 unique types (Square, Triangle, Rhombus, Circle, Hexagon)<br>- <b>Plus 1 extra Triangle and 1 extra Square</b> (total: 2 Triangles, 2 Squares, 1 Rhombus, 1 Circle, 1 Hexagon per player)</p>
<p>The objective is to advance your rhombus to the opponent's base or create a deadlock (see below).</p>
<h4>2. Board Layout</h4>
<ul><li><b>Hexagonal grid</b>: 7 rows (0-6), variable columns per row</li><li><b>Zones</b>: Dead Zone (center), Inner, Middle, Outer Perimeter</li><li><b>Coordinates</b>: Each hex is labeled (e.g., 3-4)</li></ul>
<h4>3. Piece Types & Movement</h4>
<b>Square</b>: Moves orthogonally (adjacent hexes), attacks in same directions<br>
<b>Triangle</b>: 6 unique movement patterns (one for each orientation), can rotate left/right after moving (not after attacking), each orientation has its own movement pattern (no repeats)<br>
<b>Rhombus</b>: Must reach opponent's base to win (White: 3-8, Black: 3-0), moves orthogonally, special diagonal move between Dead Zone and Inner Perimeter (cannot capture), cannot capture other rhombuses, cannot move into deadlock (unless capturing attacker)<br>
<b>Circle</b>: Moves within current perimeter zone, uses gateways to change zones (ends turn), cannot jump friendly pieces<br>
<b>Hexagon</b>: 6 orientations (rotatable), 3 unique movement patterns, can rotate left/right after moving<br>
<h4>4. Turn Structure</h4>
<ul><li>Black moves first</li><li>One piece may move (and/or rotate) per turn</li><li>Triangles/Hexagons may rotate after moving (not after attacking)</li><li>Captures: Move to opponent's hex to capture</li><li>Cannot move to a hex occupied by a friendly piece</li></ul>
<h4>5. Special Rules</h4>
<ul><li><b>Base Defense</b>: Rhombus at base blocks opponent's win</li><li><b>Deadlock</b>: Win if opponent's rhombus is under attack with no legal moves</li><li><b>Draglock</b>: Lose if you have no legal moves (must resign)</li><li><b>Escape Race</b>: When only rhombuses remain, first to goal wins (Base Defense disabled)</li><li><b>Three-fold Repetition</b>: Loss if same position occurs three times (no draws in Romgon)</li><li><b>Five-fold Shuttle</b>: Lose if you repeat a shuttle pattern (A‚ÜíB‚ÜíA) five times</li><li><b>Undo/Redo</b>: Allowed unless playing online or in tournament</li></ul>
<h4>6. Victory Conditions</h4>
<ul><li>Move your rhombus to the opponent's base (3-0 for Black, 3-8 for White)</li><li>Create a deadlock (opponent's rhombus is under attack with no legal moves)</li><li>Opponent resigns or runs out of time (in timed modes)</li><li>Loss by three-fold repetition</li><li>Loss by five-fold shuttle</li></ul>
<h4>7. Notation System</h4>
<ul><li><b>RPN</b>: Romgon Position Notation (custom format)</li><li><b>RMN</b>: Romgon Move Notation (custom format)</li><li>Clipboard integration for import/export</li><li>Move history and game archiving supported</li></ul>
<h4>8. Advanced Features</h4>
<ul><li><b>Repetition Detection</b>: Three-fold repetition rule, visual warnings (loss, not draw)</li><li><b>Base Defense System</b>: Prevents early base captures, toggleable in settings</li><li><b>Threat Analysis</b>: Real-time threat and deadlock detection, highlights threatened pieces</li><li><b>Show All Moves</b>: Toggle to display all legal moves and rotations</li><li><b>Defense Highlights</b>: Highlights defended pieces, optional toggle</li><li><b>Dark Mode</b>: Switch between light/dark themes</li><li><b>Game Variants</b>: Blitz, Fog of War, King of the Hill (see Quick Reference)</li><li><b>Statistics Dashboard</b>: Win/loss, piece stats, move quality, opening repertoire, tactical success</li></ul>
<h4>9. Game Modes & Variants</h4>
<ul><li><b>Standard</b>: All 5 piece types</li><li><b>Square Attack</b>: Only Squares and Rhombuses</li><li><b>Blitz</b>: Timed games</li><li><b>Fog of War</b>: Limited visibility</li><li><b>King of the Hill</b>: Control the center</li><li><b>Custom</b>: User-defined setups</li></ul>
<h4>10. FAQ & Tips</h4>
<ul><li><b>Q: Can I rotate a triangle after attacking?</b><br>A: No, rotation is only allowed after a non-capturing move.</li><li><b>Q: What happens if both rhombuses reach the goal at the same time?</b><br>A: The first to reach wins; if simultaneous, the player who moved first wins.</li><li><b>Q: Can I undo moves?</b><br>A: Yes, unless in online/tournament mode.</li><li><b>Q: How do I export my game?</b><br>A: Use the export button in the analysis modal or copy RPN/RMN.</li><li><b>Q: Where can I find more strategy?</b><br>A: See the Opening Book and Analysis Features in the main menu.</li></ul>
<h4>11. Base Defense Rule</h4>
<ul><li><b>Original:</b> Only the defending rhombus (on its own base) can prevent the opponent‚Äôs rhombus from entering the base. This is the classic, casual rule where rhombus escapes are allowed unless the defending rhombus itself defends the base.<ul><li>If the defending rhombus is not present, the opponent‚Äôs rhombus may enter and win.</li></ul></li><li><b>Shape Defence:</b> Any attacking shape that threatens the base hex can prevent the opponent‚Äôs rhombus from entering until it is eliminated or moved. This enforces more tactical base defense.</li></ul>
<hr/>
<p>Enjoy playing Romgon! For more, see the in-game help, analysis, and statistics dashboards.</p>
            `;
            contentDiv.dataset.loaded = '1';
        }
        modal.style.display = 'flex';
    }
    function closeRulebookModal() {
        document.getElementById('rulebook-modal').style.display = 'none';
    }
    </script>
            </div>
                    
    <!-- FAQ & Tips Modal -->
    <div id="faq-modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.92); z-index:10001; justify-content:center; align-items:center; overflow-y:auto;">
        <div style="background:#262421; border:3px solid #27ae60; border-radius:20px; padding:40px 30px; max-width:900px; width:95vw; margin:40px auto; box-shadow:0 10px 50px rgba(39,174,96,0.2); position:relative; color:#fff;">
            <h2 style="color:#27ae60; text-align:center; margin-bottom:24px; font-size:2em;">üí° FAQ & Tips Guide</h2>
            <div id="faq-content" style="max-height:65vh; overflow-y:auto; color:#eee; font-size:1.05em; line-height:1.7; background:rgba(0,0,0,0.10); padding:18px; border-radius:10px; border:1px solid #444;"></div>
            <button onclick="closeFaqModal()" style="margin-top:28px; background:#27ae60; color:#fff; border:none; padding:12px 32px; border-radius:8px; font-size:1.1em; font-weight:600; cursor:pointer; width:100%; transition:all 0.2s;" onmouseover="this.style.background='#2ecc71'" onmouseout="this.style.background='#27ae60'">Close</button>
        </div>
    </div>
    <script>
    // FAQ & TIPS MODAL LOGIC
    function openFaqModal() {
        const modal = document.getElementById('faq-modal');
        const contentDiv = document.getElementById('faq-content');
        if (!contentDiv.dataset.loaded) {
            // Insert the FAQ content as HTML
            contentDiv.innerHTML = `
<p style="text-align:center; font-style:italic; color:#aaa; margin-bottom:20px;">Your comprehensive guide to mastering Romgon - from first moves to advanced tactics</p>

<h3 style="color:#27ae60; border-bottom:2px solid #27ae60; padding-bottom:8px; margin-top:30px;">üéÆ Game Basics</h3>

<h4 style="color:#2ecc71; margin-top:20px;">Q: What is Romgon?</h4>
<p><strong>A:</strong> Romgon is a strategic hexagonal board game where each player controls <strong>7 pieces</strong> (2 Triangles, 2 Squares, 1 Rhombus, 1 Circle, 1 Hexagon). The goal is to move your rhombus to the opponent's base or trap their rhombus.</p>

<h4 style="color:#2ecc71; margin-top:20px;">Q: How do I win?</h4>
<p><strong>A:</strong> There are three ways to win:</p>
<ol style="margin-left:20px;">
<li><strong>Base Capture</strong>: Move your rhombus to the opponent's base (White: row 3, column 8 / Black: row 3, column 0)</li>
<li><strong>Deadlock</strong>: Trap the opponent's rhombus with no legal moves while under attack</li>
<li><strong>Opponent Resignation</strong>: Your opponent runs out of legal moves (draglock) or resigns</li>
</ol>

<h4 style="color:#2ecc71; margin-top:20px;">Q: Who moves first?</h4>
<p><strong>A:</strong> Black always moves first in Romgon.</p>

<h4 style="color:#2ecc71; margin-top:20px;">Q: Can I undo moves?</h4>
<p><strong>A:</strong> Yes! You can use undo/redo freely in local games. However, undo is disabled in online matches and tournament play.</p>

<h4 style="color:#2ecc71; margin-top:20px;">Q: Is Romgon like chess?</h4>
<p><strong>A:</strong> Yes and no. Romgon has comparable complexity to chess (state space: 10¬≤‚Åµ to 10¬≥¬≤ positions, game tree: 10‚Å∏‚Å∞ to 10¬π¬≤‚Å∞ possible games), but with unique hexagonal movement and <strong>no draws</strong> - repetition is a loss!</p>

<h3 style="color:#27ae60; border-bottom:2px solid #27ae60; padding-bottom:8px; margin-top:30px;">üé≠ Pieces & Movement</h3>

<h4 style="color:#2ecc71; margin-top:20px;">Q: What pieces are in the game?</h4>
<p><strong>A:</strong> Each player has 7 pieces:</p>
<ul style="margin-left:20px;">
<li><strong>2 Triangles</strong> üî∫: Orientation-dependent movement (6 unique patterns)</li>
<li><strong>2 Squares</strong> ‚¨ú: Orthogonal movement (adjacent hexes)</li>
<li><strong>1 Rhombus</strong> üíé: Must reach opponent's base, special rules apply</li>
<li><strong>1 Circle</strong> ‚≠ï: Moves within zones, uses gateways</li>
<li><strong>1 Hexagon</strong> ‚¨°: Rotatable (3 unique movement patterns)</li>
</ul>

<h4 style="color:#2ecc71; margin-top:20px;">Q: How does the Triangle move?</h4>
<p><strong>A:</strong> The Triangle has <strong>6 unique movement patterns</strong> - one for each orientation it can face. Unlike other pieces, each orientation has completely different moves (no repeats). After moving (not attacking), you can rotate it left or right to change its orientation.</p>
<p style="background:rgba(39,174,96,0.1); padding:10px; border-left:3px solid #27ae60; margin:10px 0;"><strong>üí° TIP:</strong> Triangles are your most versatile tactical pieces. Master their orientations to unlock unexpected attacks!</p>

<h4 style="color:#2ecc71; margin-top:20px;">Q: What makes the Rhombus special?</h4>
<p><strong>A:</strong> The Rhombus is your <strong>king piece</strong>:</p>
<ul style="margin-left:20px;">
<li>Must reach the opponent's base to win</li>
<li>Cannot capture other rhombuses</li>
<li>Cannot be captured by opponent's rhombus</li>
<li>Has a special diagonal move between Dead Zone and Inner Perimeter (cannot capture while using this move)</li>
<li>Cannot voluntarily move into deadlock (unless capturing the attacking piece)</li>
</ul>

<h4 style="color:#2ecc71; margin-top:20px;">Q: Can pieces rotate?</h4>
<p><strong>A:</strong> Only <strong>Triangles</strong> and <strong>Hexagons</strong> can rotate. Rotation is allowed <strong>after moving</strong> (not after attacking). You can rotate left (counterclockwise) or right (clockwise), and rotation counts as part of your turn.</p>

<h3 style="color:#27ae60; border-bottom:2px solid #27ae60; padding-bottom:8px; margin-top:30px;">‚ö° Special Rules & Win Conditions</h3>

<h4 style="color:#2ecc71; margin-top:20px;">Q: What is "Deadlock"?</h4>
<p><strong>A:</strong> Deadlock occurs when a rhombus is under attack and has <strong>no legal moves</strong>. This is an instant win for the attacker! If your opponent's rhombus is surrounded and you attack it with no escape, you win immediately.</p>

<h4 style="color:#2ecc71; margin-top:20px;">Q: What is "Draglock"?</h4>
<p><strong>A:</strong> Draglock is when a player has <strong>no legal moves at all</strong> with any piece. If it's your turn and you cannot move, you must resign - you lose!</p>
<p style="background:rgba(231,76,60,0.1); padding:10px; border-left:3px solid #e74c3c; margin:10px 0;"><strong>‚ö†Ô∏è Prevention Tip:</strong> Always leave yourself escape options. Never sacrifice mobility for temporary gains.</p>

<h4 style="color:#2ecc71; margin-top:20px;">Q: What happens if I repeat the same position three times?</h4>
<p><strong>A: YOU LOSE!</strong> This is Romgon's most unique rule. Unlike chess where repetition is a draw, in Romgon <strong>threefold repetition is an automatic loss</strong>. The game detects this and warns you visually.</p>
<p style="background:rgba(39,174,96,0.1); padding:10px; border-left:3px solid #27ae60; margin:10px 0;"><strong>Strategic Implication:</strong> You cannot infinitely defend by repeating moves. Games MUST progress toward a conclusion.</p>

<h4 style="color:#2ecc71; margin-top:20px;">Q: What is an "Escape Race"?</h4>
<p><strong>A:</strong> When <strong>only rhombuses remain</strong> on the board, Base Defense is disabled and it becomes a pure race to the goal. First rhombus to reach the opponent's base wins!</p>

<h3 style="color:#27ae60; border-bottom:2px solid #27ae60; padding-bottom:8px; margin-top:30px;">üõ°Ô∏è Base Defense System</h3>

<h4 style="color:#2ecc71; margin-top:20px;">Q: What is Base Defense?</h4>
<p><strong>A:</strong> Base Defense prevents easy wins by requiring you to deal with defenders before entering the enemy base. There are <strong>two variants</strong>:</p>

<h4 style="color:#f39c12; margin-top:15px;">Variant 1: Original (Rhombus Defense Only)</h4>
<ul style="margin-left:20px;">
<li><strong>Rule:</strong> Only the opponent's rhombus (positioned on their own base) can block your rhombus from entering</li>
<li><strong>Best for:</strong> Casual games, faster-paced play</li>
<li><strong>Strategy:</strong> If the defending rhombus is away from base, your rhombus can enter and win</li>
</ul>

<h4 style="color:#f39c12; margin-top:15px;">Variant 2: Shape Defense</h4>
<ul style="margin-left:20px;">
<li><strong>Rule:</strong> <strong>Any piece</strong> attacking the base hex prevents the opponent's rhombus from entering until eliminated or moved</li>
<li><strong>Best for:</strong> Tactical games, deeper strategy</li>
<li><strong>Strategy:</strong> You can defend with Squares, Triangles, etc. - creates more complex endgames</li>
</ul>

<p style="background:rgba(39,174,96,0.1); padding:10px; border-left:3px solid #27ae60; margin:10px 0;"><strong>üí° Recommendation:</strong> New players start with <strong>Original</strong> (simpler, faster games). Experienced players try <strong>Shape Defense</strong> (more tactical depth). You can toggle this in game settings!</p>

<h3 style="color:#27ae60; border-bottom:2px solid #27ae60; padding-bottom:8px; margin-top:30px;">üåü Tips for Beginners</h3>

<div style="background:rgba(39,174,96,0.05); padding:15px; border-radius:8px; margin:15px 0;">
<h4 style="color:#2ecc71; margin-top:10px;">1. Control the Center</h4>
<p>The Dead Zone and Inner Perimeter are the most important areas. Controlling the center gives you more mobility options, better piece coordination, and defensive depth.</p>

<h4 style="color:#2ecc71; margin-top:15px;">2. Protect Your Rhombus</h4>
<p>Your rhombus is precious! Keep it behind your other pieces early game, don't rush it forward without support, and never let it get surrounded (deadlock = instant loss!).</p>

<h4 style="color:#2ecc71; margin-top:15px;">3. Learn Triangle Orientations</h4>
<p>Practice with each orientation in safe positions. Rotate after moving to set up threats. Remember: 6 orientations = 6 completely different move sets.</p>

<h4 style="color:#2ecc71; margin-top:15px;">4. Use Squares for Board Control</h4>
<p>Squares move orthogonally (like chess rooks but 1 space). They're excellent for creating defensive lines, controlling key gateway hexes, and early-game development.</p>

<h4 style="color:#2ecc71; margin-top:15px;">5. Don't Ignore the Circle</h4>
<p>Beginners often undervalue the Circle. It controls entire zones once positioned, is difficult to remove from strong zones, and can create "safe havens" for retreating pieces.</p>

<h4 style="color:#2ecc71; margin-top:15px;">6. Avoid Repetition</h4>
<p>Remember: <strong>repetition = loss</strong>. Don't shuttle pieces back and forth. Always have a plan to advance position. If you feel stuck, change your approach before repeating.</p>

<h4 style="color:#2ecc71; margin-top:15px;">7. Think Two Moves Ahead</h4>
<p>Early game has 20-40 legal moves. You can't calculate everything, but think 2-3 moves ahead. Look for opponent's threats and plan piece coordination, not just individual moves.</p>

<h4 style="color:#2ecc71; margin-top:15px;">8. Practice Base Defense</h4>
<p>Know which pieces can defend (based on your variant setting). Position defenders proactively and don't abandon your base until you're winning.</p>
</div>

<h3 style="color:#27ae60; border-bottom:2px solid #27ae60; padding-bottom:8px; margin-top:30px;">üß† Advanced Strategy</h3>

<h4 style="color:#2ecc71; margin-top:20px;">Zugzwang</h4>
<p><strong>Definition:</strong> A position where any move worsens your position. Create zugzwang by forcing opponent to move first in a locked position, creating situations where all their moves expose weaknesses. Common in endgames with limited pieces.</p>

<h4 style="color:#2ecc71; margin-top:20px;">Fortress Endgames</h4>
<p>When pieces blockade each other creating a "fortress":</p>
<ul style="margin-left:20px;">
<li><strong>Base Defense (Shape)</strong> prevents quick wins</li>
<li><strong>Repetition rule</strong> forces fortress-breaker to find new moves</li>
<li><strong>Tactical puzzle:</strong> Find the one breakthrough move</li>
</ul>

<h4 style="color:#2ecc71; margin-top:20px;">Piece Value Estimation</h4>
<table style="width:100%; border-collapse:collapse; margin:15px 0;">
<tr style="background:rgba(39,174,96,0.1);">
<th style="padding:8px; text-align:left; border:1px solid #444;">Piece</th>
<th style="padding:8px; text-align:left; border:1px solid #444;">Value</th>
<th style="padding:8px; text-align:left; border:1px solid #444;">Notes</th>
</tr>
<tr><td style="padding:8px; border:1px solid #444;"><strong>Rhombus</strong></td><td style="padding:8px; border:1px solid #444;">Infinite</td><td style="padding:8px; border:1px solid #444;">Lose it = lose game</td></tr>
<tr><td style="padding:8px; border:1px solid #444;"><strong>Triangle</strong></td><td style="padding:8px; border:1px solid #444;">5-7</td><td style="padding:8px; border:1px solid #444;">Most versatile, orientation-dependent</td></tr>
<tr><td style="padding:8px; border:1px solid #444;"><strong>Hexagon</strong></td><td style="padding:8px; border:1px solid #444;">4-6</td><td style="padding:8px; border:1px solid #444;">Rotatable, 3 patterns</td></tr>
<tr><td style="padding:8px; border:1px solid #444;"><strong>Square</strong></td><td style="padding:8px; border:1px solid #444;">3-4</td><td style="padding:8px; border:1px solid #444;">Reliable, orthogonal</td></tr>
<tr><td style="padding:8px; border:1px solid #444;"><strong>Circle</strong></td><td style="padding:8px; border:1px solid #444;">3-5</td><td style="padding:8px; border:1px solid #444;">Zone control specialist</td></tr>
</table>
<p style="font-style:italic; color:#aaa;">Context matters: A Circle in the Dead Zone may be worth more than a Triangle on the perimeter!</p>

<h3 style="color:#27ae60; border-bottom:2px solid #27ae60; padding-bottom:8px; margin-top:30px;">‚ùå Common Mistakes</h3>

<div style="background:rgba(231,76,60,0.05); padding:15px; border-radius:8px; margin:15px 0;">
<h4 style="color:#e74c3c; margin-top:10px;">1. Moving Without Purpose</h4>
<p><strong>Mistake:</strong> Making moves that don't advance your plan.<br>
<strong>Fix:</strong> Every move should either improve piece position, create threats, defend against opponent's plan, or control key territory.</p>

<h4 style="color:#e74c3c; margin-top:15px;">2. Ignoring Opponent's Threats</h4>
<p><strong>Mistake:</strong> Tunnel vision on your own plans.<br>
<strong>Fix:</strong> After every opponent move, ask: "What are they threatening? Can they deadlock my rhombus? Am I about to repeat a position?"</p>

<h4 style="color:#e74c3c; margin-top:15px;">3. Rushing the Rhombus</h4>
<p><strong>Mistake:</strong> Pushing rhombus forward too early.<br>
<strong>Fix:</strong> Develop other pieces first, clear the path with supporting pieces, and only advance rhombus when safe.</p>

<h4 style="color:#e74c3c; margin-top:15px;">4. Not Rotating</h4>
<p><strong>Mistake:</strong> Forgetting Triangles and Hexagons can rotate.<br>
<strong>Fix:</strong> After moving, consider rotation. Rotation can unlock new attacks/defenses. Think of rotation as part of the move.</p>

<h4 style="color:#e74c3c; margin-top:15px;">5. Neglecting Base Defense</h4>
<p><strong>Mistake:</strong> Leaving base undefended to attack.<br>
<strong>Fix:</strong> Keep at least one defender near base, position rhombus on base if using Original variant, and have pieces ready to return for defense.</p>

<h4 style="color:#e74c3c; margin-top:15px;">6. Creating Accidental Repetition</h4>
<p><strong>Mistake:</strong> Repeating position 3 times = instant loss.<br>
<strong>Fix:</strong> Watch for visual repetition warnings, vary your moves even when defending, and change piece positions slightly to avoid repeats.</p>
</div>

<h3 style="color:#27ae60; border-bottom:2px solid #27ae60; padding-bottom:8px; margin-top:30px;">ü§Ø Did You Know?</h3>

<div style="background:rgba(52,152,219,0.05); padding:15px; border-radius:8px; margin:15px 0;">
<h4 style="color:#3498db;">Complexity Stats</h4>
<ul style="margin-left:20px;">
<li><strong>State Space:</strong> 10¬≤‚Åµ to 10¬≥¬≤ possible board positions (comparable to chess at ~10‚Å¥‚Å¥)</li>
<li><strong>Game Tree:</strong> 10‚Å∏‚Å∞ to 10¬π¬≤‚Å∞ possible games (chess is ~10¬π¬≤¬≥)</li>
<li><strong>Branching Factor:</strong> Early game: 20-40 legal moves | Mid game: 10-30 legal moves | Endgame: 2-10 legal moves</li>
<li><strong>Average Game Length:</strong> 60-120 moves</li>
<li><strong>Computational Complexity:</strong> EXPTIME-complete (provably hard)</li>
</ul>

<h4 style="color:#3498db; margin-top:15px;">No Draws!</h4>
<p>Romgon is designed with <strong>zero draws</strong>:</p>
<ul style="margin-left:20px;">
<li>Threefold repetition = loss</li>
<li>Five-fold shuttle = loss</li>
<li>Draglock (no legal moves) = loss</li>
<li>Escape race forces decisive result</li>
</ul>
<p><strong>Result:</strong> Every game must have a winner - no boring draws!</p>

<h4 style="color:#3498db; margin-top:15px;">Opening Book Still Growing</h4>
<p>Unlike chess with centuries of opening theory, Romgon's opening book is still being developed. You can discover new openings and contribute to theory!</p>
</div>

<h3 style="color:#27ae60; border-bottom:2px solid #27ae60; padding-bottom:8px; margin-top:30px;">üéØ Final Tips</h3>

<ol style="margin-left:20px; line-height:1.8;">
<li><strong>Practice makes perfect:</strong> Play against AI to learn piece movements</li>
<li><strong>Study endgames:</strong> Most games are decided in endgame technique</li>
<li><strong>Learn from losses:</strong> Review games to understand mistakes</li>
<li><strong>Experiment:</strong> Try different openings and piece setups</li>
<li><strong>Use analysis tools:</strong> Toggle "Show All Moves" and threat highlights</li>
<li><strong>Stay calm:</strong> Complex positions are solvable with careful thought</li>
<li><strong>Have fun:</strong> Romgon is meant to be enjoyed!</li>
</ol>

<p style="text-align:center; margin-top:30px; padding:20px; background:rgba(39,174,96,0.1); border-radius:8px; font-size:1.1em;">
<strong style="color:#27ae60;">Ready to play?</strong><br>
<span style="color:#aaa; font-size:0.9em;">Visit <a href="https://romgon.net" style="color:#00d9ff;">romgon.net</a> and start your journey to mastery!</span>
</p>

<p style="text-align:center; font-style:italic; color:#666; margin-top:20px; font-size:0.9em;">Last updated: January 2025</p>
            `;
            contentDiv.dataset.loaded = '1';
        }
        modal.style.display = 'flex';
    }
    function closeFaqModal() {
        document.getElementById('faq-modal').style.display = 'none';
    }
    </script>
    
    <!-- Badge System Browser Modal -->
    <div id="badge-system-modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.92); z-index:10001; justify-content:center; align-items:center; overflow-y:auto;">
        <div style="background:#262421; border:3px solid #ffd700; border-radius:20px; padding:40px 30px; max-width:1200px; width:95vw; margin:40px auto; box-shadow:0 10px 50px rgba(255,215,0,0.3); position:relative; color:#fff;">
            <h2 style="color:#ffd700; text-align:center; margin-bottom:24px; font-size:2em;">üèÜ ROMGON Badge System</h2>
            <p style="text-align:center; color:#aaa; margin-bottom:30px;">210+ Badges across 11 categories ‚Ä¢ Unlock achievements through gameplay</p>
            
            <!-- Badge Category Filter -->
            <div style="display:flex; gap:10px; flex-wrap:wrap; justify-content:center; margin-bottom:30px;">
                <button onclick="filterBadges('all')" class="badge-filter-btn active" data-filter="all" style="padding:8px 16px; background:rgba(255,215,0,0.2); border:2px solid #ffd700; border-radius:6px; color:#ffd700; cursor:pointer; font-weight:600; transition:all 0.3s;">All Badges</button>
                <button onclick="filterBadges('Achievement')" class="badge-filter-btn" data-filter="Achievement" style="padding:8px 16px; background:rgba(255,255,255,0.05); border:2px solid #666; border-radius:6px; color:#aaa; cursor:pointer; font-weight:600; transition:all 0.3s;">üèÜ Achievement</button>
                <button onclick="filterBadges('Skill')" class="badge-filter-btn" data-filter="Skill" style="padding:8px 16px; background:rgba(255,255,255,0.05); border:2px solid #666; border-radius:6px; color:#aaa; cursor:pointer; font-weight:600; transition:all 0.3s;">üéØ Skill</button>
                <button onclick="filterBadges('Strategic')" class="badge-filter-btn" data-filter="Strategic" style="padding:8px 16px; background:rgba(255,255,255,0.05); border:2px solid #666; border-radius:6px; color:#aaa; cursor:pointer; font-weight:600; transition:all 0.3s;">üß† Strategic</button>
                <button onclick="filterBadges('Piece Mastery')" class="badge-filter-btn" data-filter="Piece Mastery" style="padding:8px 16px; background:rgba(255,255,255,0.05); border:2px solid #666; border-radius:6px; color:#aaa; cursor:pointer; font-weight:600; transition:all 0.3s;">‚ôüÔ∏è Piece Mastery</button>
                <button onclick="filterBadges('Game Mode')" class="badge-filter-btn" data-filter="Game Mode" style="padding:8px 16px; background:rgba(255,255,255,0.05); border:2px solid #666; border-radius:6px; color:#aaa; cursor:pointer; font-weight:600; transition:all 0.3s;">üéÆ Game Mode</button>
                <button onclick="filterBadges('Social')" class="badge-filter-btn" data-filter="Social" style="padding:8px 16px; background:rgba(255,255,255,0.05); border:2px solid #666; border-radius:6px; color:#aaa; cursor:pointer; font-weight:600; transition:all 0.3s;">üë• Social</button>
                <button onclick="filterBadges('Creator')" class="badge-filter-btn" data-filter="Creator" style="padding:8px 16px; background:rgba(255,255,255,0.05); border:2px solid #666; border-radius:6px; color:#aaa; cursor:pointer; font-weight:600; transition:all 0.3s;">üé® Creator</button>
                <button onclick="filterBadges('Competitive')" class="badge-filter-btn" data-filter="Competitive" style="padding:8px 16px; background:rgba(255,255,255,0.05); border:2px solid #666; border-radius:6px; color:#aaa; cursor:pointer; font-weight:600; transition:all 0.3s;">üèÖ Competitive</button>
                <button onclick="filterBadges('Rare')" class="badge-filter-btn" data-filter="Rare" style="padding:8px 16px; background:rgba(255,255,255,0.05); border:2px solid #666; border-radius:6px; color:#aaa; cursor:pointer; font-weight:600; transition:all 0.3s;">üåü Rare</button>
                <button onclick="filterBadges('Legendary')" class="badge-filter-btn" data-filter="Legendary" style="padding:8px 16px; background:rgba(255,255,255,0.05); border:2px solid #666; border-radius:6px; color:#aaa; cursor:pointer; font-weight:600; transition:all 0.3s;">üî• Legendary</button>
            </div>
            
            <!-- Badge Grid -->
            <div id="badge-browser-grid" style="display:grid; grid-template-columns:repeat(auto-fill, minmax(200px, 1fr)); gap:15px; max-height:60vh; overflow-y:auto; padding:20px; background:rgba(0,0,0,0.3); border-radius:12px; border:1px solid #444;"></div>
            
            <button onclick="closeBadgeSystem()" style="margin-top:28px; background:#ffd700; color:#1a1a1a; border:none; padding:12px 32px; border-radius:8px; font-size:1.1em; font-weight:600; cursor:pointer; width:100%; transition:all 0.2s;" onmouseover="this.style.background='#ffed4e'" onmouseout="this.style.background='#ffd700'">Close</button>
        </div>
    </div>
    <script>
    // BADGE SYSTEM BROWSER LOGIC
    function openBadgeSystem() {
        const modal = document.getElementById('badge-system-modal');
        const gridDiv = document.getElementById('badge-browser-grid');
        const currentUser = window.currentUser || JSON.parse(localStorage.getItem('romgon-user') || '{}');
        const stats = getUserStats(currentUser.username) || {};
        
        // Render all badges
        renderBadgeBrowser(stats, 'all');
        
        modal.style.display = 'flex';
    }
    
    function closeBadgeSystem() {
        document.getElementById('badge-system-modal').style.display = 'none';
    }
    
    function filterBadges(category) {
        const currentUser = window.currentUser || JSON.parse(localStorage.getItem('romgon-user') || '{}');
        const stats = getUserStats(currentUser.username) || {};
        
        // Update filter button states
        document.querySelectorAll('.badge-filter-btn').forEach(btn => {
            if (btn.dataset.filter === category) {
                btn.classList.add('active');
                btn.style.background = 'rgba(255,215,0,0.2)';
                btn.style.borderColor = '#ffd700';
                btn.style.color = '#ffd700';
            } else {
                btn.classList.remove('active');
                btn.style.background = 'rgba(255,255,255,0.05)';
                btn.style.borderColor = '#666';
                btn.style.color = '#aaa';
            }
        });
        
        renderBadgeBrowser(stats, category);
    }
    
    function renderBadgeBrowser(stats, filterCategory) {
        const gridDiv = document.getElementById('badge-browser-grid');
        gridDiv.innerHTML = '';
        
        // Group badges by category
        const badgesByCategory = {};
        Object.entries(BADGE_SYSTEM).forEach(([badge, data]) => {
            const category = data.category || 'Other';
            if (filterCategory === 'all' || category === filterCategory) {
                if (!badgesByCategory[category]) {
                    badgesByCategory[category] = [];
                }
                badgesByCategory[category].push({ name: badge, data: data });
            }
        });
        
        // Render each category
        Object.entries(badgesByCategory).forEach(([category, badges]) => {
            // Category header (spans full width)
            const categoryHeader = document.createElement('div');
            categoryHeader.style.cssText = `
                grid-column: 1 / -1;
                color: #4ecdc4;
                font-weight: 700;
                font-size: 16px;
                margin-top: 20px;
                margin-bottom: 10px;
                padding-bottom: 8px;
                border-bottom: 2px solid rgba(78, 205, 196, 0.3);
            `;
            categoryHeader.textContent = `${getCategoryIcon(category)} ${category.toUpperCase()}`;
            gridDiv.appendChild(categoryHeader);
            
            // Render badges in category
            badges.forEach(({ name: badge, data }) => {
                const isUnlocked = checkBadgeUnlocked(data, stats);
                
                const badgeCard = document.createElement('div');
                badgeCard.className = `badge-browser-card ${data.rarity} ${isUnlocked ? 'unlocked' : 'locked'}`;
                badgeCard.style.cssText = `
                    background: rgba(255, 255, 255, 0.05);
                    border: 2px solid ${getRarityColor(data.rarity)};
                    border-radius: 12px;
                    padding: 20px;
                    text-align: center;
                    transition: all 0.3s;
                    ${!isUnlocked ? 'opacity: 0.5; filter: grayscale(1);' : ''}
                    ${isUnlocked ? 'cursor: pointer;' : ''}
                `;
                
                if (isUnlocked) {
                    badgeCard.onmouseover = () => {
                        badgeCard.style.transform = 'translateY(-4px)';
                        badgeCard.style.boxShadow = `0 6px 20px ${getRarityColor(data.rarity)}40`;
                    };
                    badgeCard.onmouseout = () => {
                        badgeCard.style.transform = 'translateY(0)';
                        badgeCard.style.boxShadow = 'none';
                    };
                }
                
                const badgeIcon = badge.split(' ')[0];
                const badgeName = badge.split(' ').slice(1).join(' ');
                
                badgeCard.innerHTML = `
                    <div style="font-size: 48px; margin-bottom: 12px;">${badgeIcon}</div>
                    <div style="font-weight: 700; color: #fff; font-size: 14px; margin-bottom: 6px;">${badgeName}</div>
                    <div style="font-size: 10px; font-weight: 700; text-transform: uppercase; color: ${getRarityColor(data.rarity)}; margin-bottom: 8px;">${data.rarity}</div>
                    <div style="font-size: 11px; color: ${isUnlocked ? '#4ecdc4' : '#888'}; margin-bottom: 8px;">
                        ${isUnlocked ? '‚úì Unlocked' : 'üîí ' + data.requirement}
                    </div>
                    <div style="font-size: 12px; color: #ffd700; font-weight: 600;">${data.points} pts</div>
                `;
                
                gridDiv.appendChild(badgeCard);
            });
        });
        
        // Show count
        const totalBadges = Object.keys(BADGE_SYSTEM).length;
        const unlockedCount = Object.entries(BADGE_SYSTEM).filter(([_, data]) => 
            checkBadgeUnlocked(data, stats)
        ).length;
        
        const countDisplay = document.createElement('div');
        countDisplay.style.cssText = `
            grid-column: 1 / -1;
            text-align: center;
            color: #ffd700;
            font-weight: 700;
            font-size: 18px;
            margin-top: 20px;
            padding: 15px;
            background: rgba(255, 215, 0, 0.1);
            border-radius: 8px;
        `;
        countDisplay.textContent = `${unlockedCount} / ${totalBadges} Badges Unlocked (${Math.round(unlockedCount/totalBadges*100)}%)`;
        gridDiv.appendChild(countDisplay);
    }
    
    function getRarityColor(rarity) {
        const colors = {
            'common': '#9e9e9e',
            'uncommon': '#1eff00',
            'rare': '#0070dd',
            'epic': '#a335ee',
            'legendary': '#ff8000',
            'mythic': '#ff00dc'
        };
        return colors[rarity] || '#4ecdc4';
    }
    </script>
                    
            <!-- Quick Info -->
            <div style="
                text-align: center;
                color: #888;
                font-size: 0.8em;
                max-width: 550px;
                margin: 0 auto;
                line-height: 1.5;
            ">
                <p style="margin: 0 0 5px 0;">
                    <strong style="color: #f57d2d;">Objective:</strong> Move rhombus to opponent's base or trap theirs
                </p>
                <p style="margin: 0; color: #666;">
                    Press ‚ùì HELP in-game for rules
                </p>
                    </div>
                </div>
                    </div>
                    
    <!-- Puzzles Modal -->
    <div id="puzzles-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.9); z-index: 10000; justify-content: center; align-items: center;">
        <div style="background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%); border: 3px solid #ffd700; border-radius: 20px; padding: 40px; max-width: 600px; width: 90%; box-shadow: 0 10px 50px rgba(255, 215, 0, 0.3);">
            <h2 style="color: #ffd700; text-align: center; margin-bottom: 30px; font-size: 28px;">üß© Puzzle Challenges</h2>
            
            <!-- Puzzle Categories -->
            <div style="display: grid; gap: 15px; margin-bottom: 20px;">
                
                <!-- Escape Puzzles -->
                <div style="background: rgba(255, 215, 0, 0.1); border: 2px solid #ffd700; border-radius: 12px; padding: 20px;">
                    <h3 style="color: #ffd700; margin: 0 0 15px 0; font-size: 1.3em;">üèÉ Escape Rhombus</h3>
                    <p style="color: #ccc; margin: 0 0 15px 0; font-size: 0.9em;">Move your rhombus to the goal position within the move limit</p>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <button class="puzzle-btn" onclick="startPuzzle('escape-easy-1')" style="
                            background: linear-gradient(45deg, #4ecdc4, #44a08d);
                            color: white;
                            border: none;
                            padding: 10px 20px;
                            border-radius: 8px;
                            cursor: pointer;
                            font-weight: 600;
                            transition: all 0.3s ease;
                        " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                            ‚≠ê Easy #1 (2 moves)
                        </button>
                        <button class="puzzle-btn" onclick="alert('Coming soon!')" style="
                            background: #555;
                            color: #999;
                            border: none;
                            padding: 10px 20px;
                            border-radius: 8px;
                            cursor: not-allowed;
                            font-weight: 600;
                        ">
                            üîí More coming soon
                        </button>
                    </div>
                </div>
                
                <!-- Capture Puzzles -->
                <div style="background: rgba(255, 107, 107, 0.1); border: 2px solid #ff6b6b; border-radius: 12px; padding: 20px;">
                    <h3 style="color: #ff6b6b; margin: 0 0 15px 0; font-size: 1.3em;">‚öîÔ∏è Capture Challenge</h3>
                    <p style="color: #ccc; margin: 0 0 15px 0; font-size: 0.9em;">Capture the target piece within the move limit</p>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <button class="puzzle-btn" onclick="alert('Coming soon!')" style="
                            background: #555;
                            color: #999;
                            border: none;
                            padding: 10px 20px;
                            border-radius: 8px;
                            cursor: not-allowed;
                            font-weight: 600;
                        ">
                            üîí Coming soon
                        </button>
                        </div>
                        </div>
                
                <!-- Checkmate Puzzles -->
                <div style="background: rgba(165, 94, 234, 0.1); border: 2px solid #a55eea; border-radius: 12px; padding: 20px;">
                    <h3 style="color: #a55eea; margin: 0 0 15px 0; font-size: 1.3em;">‚ôüÔ∏è Checkmate in N</h3>
                    <p style="color: #ccc; margin: 0 0 15px 0; font-size: 0.9em;">Trap the opponent's rhombus for checkmate</p>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <button class="puzzle-btn" onclick="startPuzzle('checkmate-1')" style="
                            background: linear-gradient(45deg, #a55eea, #8b3fd4);
                            color: white;
                            border: none;
                            padding: 10px 20px;
                            border-radius: 8px;
                            cursor: pointer;
                            font-weight: 600;
                            transition: all 0.3s ease;
                        " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                            ‚≠ê Tactical #1 (3 moves)
                        </button>
                        <button class="puzzle-btn" onclick="alert('Coming soon!')" style="
                            background: #555;
                            color: #999;
                            border: none;
                            padding: 10px 20px;
                            border-radius: 8px;
                            cursor: not-allowed;
                            font-weight: 600;
                        ">
                            üîí More coming soon
                        </button>
                        </div>
                    </div>
                
            </div>
            
            <button onclick="closePuzzlesModal()" style="
                background-color: #555;
                color: white;
                border: none;
                padding: 12px 24px;
                border-radius: 8px;
                cursor: pointer;
                width: 100%;
                font-weight: 600;
                transition: all 0.3s ease;
            " onmouseover="this.style.background='#666'" onmouseout="this.style.background='#555'">
                ‚Üê Back to Menu
            </button>
                </div>
            </div>
            
    <!-- AI Game Variants Modal -->
    <div id="game-variants-ai-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.9); z-index: 10000; justify-content: center; align-items: center;">
        <div style="background: #262421; border: 3px solid #4ecdc4; border-radius: 20px; padding: 40px; max-width: 500px; width: 90%; box-shadow: 0 10px 50px rgba(78, 205, 196, 0.3); position:relative;">
            <h2 style="color: #4ecdc4; text-align: center; margin-bottom: 30px; font-size: 28px;">ü§ñ AI Game Variants</h2>
            
            <!-- AI Difficulty Selector -->
            <div style="display:flex;justify-content:center;align-items:center;margin-bottom:25px;gap:12px;flex-direction:column;">
                <label style="color:#ffd700;font-size:1.2em;margin-bottom:10px;">üéØ AI Difficulty:</label>
                <div style="display:flex;gap:10px;width:100%;justify-content:center;">
                    <button id="ai-diff-easy" onclick="selectAIDifficulty('easy')" style="
                        background: linear-gradient(45deg, #4ecdc4, #44a08d);
                        color: white;
                        border: 3px solid transparent;
                        padding: 12px 20px;
                        border-radius: 10px;
                        cursor: pointer;
                        font-weight: 600;
                        font-size: 16px;
                        flex: 1;
                        transition: all 0.3s ease;
                    " onmouseover="if(!this.classList.contains('selected')) this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        üòä Easy
                    </button>
                    <button id="ai-diff-medium" onclick="selectAIDifficulty('medium')" style="
                        background: linear-gradient(45deg, #ffd700, #f0ad4e);
                        color: white;
                        border: 3px solid transparent;
                        padding: 12px 20px;
                        border-radius: 10px;
                        cursor: pointer;
                        font-weight: 600;
                        font-size: 16px;
                        flex: 1;
                        transition: all 0.3s ease;
                    " onmouseover="if(!this.classList.contains('selected')) this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        ü§î Medium
                    </button>
                    <button id="ai-diff-hard" onclick="selectAIDifficulty('hard')" style="
                        background: linear-gradient(45deg, #ff6b6b, #c92a2a);
                        color: white;
                        border: 3px solid #ffd700;
                        padding: 12px 20px;
                        border-radius: 10px;
                        cursor: pointer;
                        font-weight: 600;
                        font-size: 16px;
                        flex: 1;
                        transition: all 0.3s ease;
                    " onmouseover="if(!this.classList.contains('selected')) this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'" class="selected">
                        üòà Hard
                    </button>
                </div>
                <span id="ai-difficulty-desc" style="color:#aaa;font-size:0.95em;text-align:center;margin-top:8px;">Hard: AI plays optimally with full strategy.</span>
            </div>
            
            <h2 style="color: #4ecdc4; text-align: center; margin-bottom: 30px; font-size: 28px;">üé≤ Game Variants</h2>
            <div style="display:flex;justify-content:center;align-items:center;margin-bottom:18px;gap:12px;">
                <label for="base-defense-variant-tc" style="color:#ffd700;font-size:1.08em;">Base Defense:</label>
                <select id="base-defense-variant-tc" style="font-size:1em;padding:4px 10px;border-radius:6px;">
                    <option value="original">Original (Only Rhombus)</option>
                    <option value="shape-defense">Shape Defence</option>
                </select>
                <span id="base-defense-variant-tc-desc" style="color:#aaa;font-size:0.95em;margin-left:10px;"></span>
            </div>
            <div style="display:flex;justify-content:center;align-items:center;margin-bottom:18px;gap:12px;">
                <label for="fog-of-war-variant-tc" style="color:#4ecdc4;font-size:1.08em;">Fog of War:</label>
                <input type="checkbox" id="fog-of-war-variant-tc" style="transform:scale(1.3);margin-left:8px;" />
                <span id="fog-of-war-variant-tc-desc" style="color:#aaa;font-size:0.95em;margin-left:10px;">Hide enemy pieces outside vision range.</span>
            </div>
            <script>
            // Set dropdown and fog of war to current value and update desc
            setTimeout(() => {
                const sel = document.getElementById('base-defense-variant-tc');
                const desc = document.getElementById('base-defense-variant-tc-desc');
                const fogCheckbox = document.getElementById('fog-of-war-variant-tc');
                if (sel) {
                    // Initialize dropdown from saved settings, or fallback to runtime value
                    sel.value = (window.gameSettings && window.gameSettings.baseDefenseVariant) || window.baseDefenseVariant || 'original';
                    function updateDesc() {
                        if (sel.value === 'original') desc.textContent = 'Original rules: only the rhombus defends the base (casual mode).';
                        else if (sel.value === 'shape-defense') desc.textContent = "Shape Defence: rhombus can only escape if the opponent's base is not under attack.";
                    }
                    sel.addEventListener('change', function() {
                        if (!window.gameSettings) window.gameSettings = {};
                        window.gameSettings.baseDefenseVariant = sel.value;
                        window.baseDefenseVariant = sel.value;
                        updateBaseDefenceDisplay();
                        updateDesc();
                        saveSettings();
                    });
                    updateDesc();
                }
                if (fogCheckbox) {
                    if (!window.gameSettings) window.gameSettings = {};
                    fogCheckbox.checked = !!(window.gameSettings && window.gameSettings.fogOfWar);
                    fogCheckbox.addEventListener('change', function() {
                        if (!window.gameSettings) window.gameSettings = {};
                        window.gameSettings.fogOfWar = fogCheckbox.checked;
                        fogOfWarEnabled = fogCheckbox.checked;
                        saveSettings();
                    });
                }
            }, 0);
            </script>
            <p style="color: #ccc; text-align: center; margin-bottom: 25px;">Select your preferred game variants:</p>
            <div style="display: grid; gap: 15px; margin-bottom: 20px;">
                <button onclick="startGameWithTime(10)" style="
                    background: linear-gradient(45deg, #4ecdc4, #44a08d);
                    color: white;
                    border: none;
                    padding: 18px;
                    border-radius: 12px;
                    cursor: pointer;
                    font-weight: 600;
                    font-size: 18px;
                    transition: all 0.3s ease;
                " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                    ‚ö° 10 Minutes
                </button>
                
                <button onclick="startGameWithTime(20)" style="
                    background: linear-gradient(45deg, #ffd700, #f0ad4e);
                    color: white;
                    border: none;
                    padding: 18px;
                    border-radius: 12px;
                    cursor: pointer;
                    font-weight: 600;
                    font-size: 18px;
                    transition: all 0.3s ease;
                " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                    üïê 20 Minutes
                </button>
                
                <button onclick="startGameWithTime(30)" style="
                    background: linear-gradient(45deg, #a55eea, #8e44ad);
                    color: white;
                    border: none;
                    padding: 18px;
                    border-radius: 12px;
                    cursor: pointer;
                    font-weight: 600;
                    font-size: 18px;
                    transition: all 0.3s ease;
                " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                    ‚è≥ 30 Minutes
                </button>
                
                <button onclick="startGameWithTime(0)" style="
                    background: linear-gradient(45deg, #95a5a6, #7f8c8d);
                    color: white;
                    border: none;
                    padding: 18px;
                    border-radius: 12px;
                    cursor: pointer;
                    font-weight: 600;
                    font-size: 18px;
                    transition: all 0.3s ease;
                " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                    ‚àû No Time Limit
                </button>
            </div>
            
            <button onclick="closeAIVariantsModal()" style="
                background-color: #555;
                color: white;
                border: none;
                padding: 12px 24px;
                border-radius: 8px;
                cursor: pointer;
                width: 100%;
                font-weight: 600;
                transition: all 0.3s ease;
            " onmouseover="this.style.background='#666'" onmouseout="this.style.background='#555'">
                ‚Üê Back
            </button>
        </div>
    </div>

    <!-- PVP Game Variants Modal -->
    <div id="game-variants-pvp-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.9); z-index: 10000; justify-content: center; align-items: center;">
        <div style="background: #262421; border: 3px solid #4ecdc4; border-radius: 20px; padding: 40px; max-width: 500px; width: 90%; box-shadow: 0 10px 50px rgba(78, 205, 196, 0.3); position:relative;">
            <h2 style="color: #4ecdc4; text-align: center; margin-bottom: 30px; font-size: 28px;">üé≤ Game Variants</h2>
            <div style="display:flex;justify-content:center;align-items:center;margin-bottom:18px;gap:12px;">
                <label for="base-defense-variant-tc-pvp" style="color:#ffd700;font-size:1.08em;">Base Defense:</label>
                <select id="base-defense-variant-tc-pvp" style="font-size:1em;padding:4px 10px;border-radius:6px;">
                    <option value="original">Original (Only Rhombus)</option>
                    <option value="shape-defense">Shape Defence</option>
                </select>
                <span id="base-defense-variant-tc-desc-pvp" style="color:#aaa;font-size:0.95em;margin-left:10px;"></span>
            </div>
            <div style="display:flex;justify-content:center;align-items:center;margin-bottom:18px;gap:12px;">
                <label for="fog-of-war-variant-tc-pvp" style="color:#4ecdc4;font-size:1.08em;">Fog of War:</label>
                <input type="checkbox" id="fog-of-war-variant-tc-pvp" style="transform:scale(1.3);margin-left:8px;" />
                <span id="fog-of-war-variant-tc-desc-pvp" style="color:#aaa;font-size:0.95em;margin-left:10px;">Hide enemy pieces outside vision range.</span>
            </div>
            <script>
            // Set dropdown and fog of war to current value and update desc (PVP modal)
            setTimeout(() => {
                const sel = document.getElementById('base-defense-variant-tc-pvp');
                const desc = document.getElementById('base-defense-variant-tc-desc-pvp');
                const fogCheckbox = document.getElementById('fog-of-war-variant-tc-pvp');
                if (sel) {
                    sel.value = (window.gameSettings && window.gameSettings.baseDefenseVariant) || window.baseDefenseVariant || 'original';
                    function updateDesc() {
                        if (sel.value === 'original') desc.textContent = 'Original rules: only the rhombus defends the base (casual mode).';
                        else if (sel.value === 'shape-defense') desc.textContent = "Shape Defence: rhombus can only escape if the opponent's base is not under attack.";
                    }
                    sel.addEventListener('change', function() {
                        if (!window.gameSettings) window.gameSettings = {};
                        window.gameSettings.baseDefenseVariant = sel.value;
                        window.baseDefenseVariant = sel.value;
                        updateBaseDefenceDisplay();
                        updateDesc();
                        saveSettings();
                    });
                    updateDesc();
                }
                if (fogCheckbox) {
                    if (!window.gameSettings) window.gameSettings = {};
                    fogCheckbox.checked = !!(window.gameSettings && window.gameSettings.fogOfWar);
                    fogCheckbox.addEventListener('change', function() {
                        if (!window.gameSettings) window.gameSettings = {};
                        window.gameSettings.fogOfWar = fogCheckbox.checked;
                        fogOfWarEnabled = fogCheckbox.checked;
                        saveSettings();
                    });
                }
            }, 0);
            </script>
            <p style="color: #ccc; text-align: center; margin-bottom: 25px;">Select your preferred game variants:</p>
            <div style="display: grid; gap: 15px; margin-bottom: 20px;">
                <button onclick="startGameWithTime(10)" style="
                    background: linear-gradient(45deg, #4ecdc4, #44a08d);
                    color: white;
                    border: none;
                    padding: 18px;
                    border-radius: 12px;
                    cursor: pointer;
                    font-weight: 600;
                    font-size: 18px;
                    transition: all 0.3s ease;
                " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                    ‚ö° 10 Minutes
                </button>
                
                <button onclick="startGameWithTime(20)" style="
                    background: linear-gradient(45deg, #ffd700, #f0ad4e);
                    color: white;
                    border: none;
                    padding: 18px;
                    border-radius: 12px;
                    cursor: pointer;
                    font-weight: 600;
                    font-size: 18px;
                    transition: all 0.3s ease;
                " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                    üïê 20 Minutes
                </button>
                
                <button onclick="startGameWithTime(30)" style="
                    background: linear-gradient(45deg, #a55eea, #8e44ad);
                    color: white;
                    border: none;
                    padding: 18px;
                    border-radius: 12px;
                    cursor: pointer;
                    font-weight: 600;
                    font-size: 18px;
                    transition: all 0.3s ease;
                " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                    ‚è≥ 30 Minutes
                </button>
                
                <button onclick="startGameWithTime(0)" style="
                    background: linear-gradient(45deg, #95a5a6, #7f8c8d);
                    color: white;
                    border: none;
                    padding: 18px;
                    border-radius: 12px;
                    cursor: pointer;
                    font-weight: 600;
                    font-size: 18px;
                    transition: all 0.3s ease;
                " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                    ‚àû No Time Limit
                </button>
            </div>
            
            <button onclick="closePVPVariantsModal()" style="
                background-color: #555;
                color: white;
                border: none;
                padding: 12px 24px;
                border-radius: 8px;
                cursor: pointer;
                width: 100%;
                font-weight: 600;
                transition: all 0.3s ease;
            " onmouseover="this.style.background='#666'" onmouseout="this.style.background='#555'">
                ‚Üê Back
            </button>
        </div>
    </div>

    <!-- Learning Modal -->
    <div id="learning-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.9); z-index: 10000; overflow-y: auto;">
        <div style="background: #262421; border: 3px solid #4ecdc4; border-radius: 20px; padding: 40px; max-width: 800px; width: 90%; margin: 50px auto; box-shadow: 0 10px 50px rgba(78, 205, 196, 0.3);">
            <h2 style="color: #4ecdc4; text-align: center; margin-bottom: 30px; font-size: 32px;">üìö Learn ROMGON</h2>
            
            <!-- Objective -->
            <div style="background: rgba(78, 205, 196, 0.1); border-left: 4px solid #4ecdc4; padding: 20px; margin-bottom: 25px; border-radius: 8px;">
                <h3 style="color: #4ecdc4; margin: 0 0 15px 0;">üéØ Objective</h3>
                <p style="color: #ddd; margin: 0; line-height: 1.6;">
                    Move your <strong>Rhombus</strong> to your opponent's base OR trap their rhombus so it cannot move (checkmate).
                </p>
            </div>
            
            <!-- Pieces Guide -->
            <div style="background: rgba(255, 215, 0, 0.1); border-left: 4px solid #ffd700; padding: 20px; margin-bottom: 25px; border-radius: 8px;">
                <h3 style="color: #ffd700; margin: 0 0 15px 0;">‚ôüÔ∏è Pieces & Movement</h3>
                
                <div style="color: #ddd; line-height: 1.8;">
                    <p style="margin: 0 0 12px 0;"><strong style="color: #f57d2d;">üî∂ Rhombus (King):</strong> Moves 1 hex in any direction. Goal piece!</p>
                    
                    <p style="margin: 0 0 12px 0;"><strong style="color: #f57d2d;">‚¨ü Hexagon:</strong> Moves 1-3 hexes in any direction. Can rotate 60¬∞ left/right.</p>
                    
                    <p style="margin: 0 0 12px 0;"><strong style="color: #f57d2d;">‚ñ≤ Triangle:</strong> Moves 1-3 hexes forward (directional). Can rotate and move in same turn. Cannot rotate after attacking!</p>
                    
                    <p style="margin: 0 0 12px 0;"><strong style="color: #f57d2d;">‚ñ† Square:</strong> Moves 1-2 hexes in any direction.</p>
                    
                    <p style="margin: 0;"><strong style="color: #f57d2d;">‚óè Circle:</strong> Moves like a knight - jumps in L-shape pattern.</p>
                </div>
            </div>
            
            <!-- Basic Rules -->
            <div style="background: rgba(255, 107, 107, 0.1); border-left: 4px solid #ff6b6b; padding: 20px; margin-bottom: 25px; border-radius: 8px;">
                <h3 style="color: #ff6b6b; margin: 0 0 15px 0;">‚öñÔ∏è Basic Rules</h3>
                
                <ul style="color: #ddd; line-height: 1.8; padding-left: 20px;">
                    <li><strong>Turn-based:</strong> Players alternate turns (Black starts first)</li>
                    <li><strong>One action per turn:</strong> Move OR attack, then end turn</li>
                    <li><strong>Capturing:</strong> Land on opponent's piece to capture it</li>
                    <li><strong>Base Defence:</strong> Pieces at your base give you strength</li>
                    <li><strong>No Repeating:</strong> Cannot repeat the same position 3 times</li>
                    <li><strong>Escape Race:</strong> When both rhombuses reach opponent bases, first to move wins!</li>
                        </ul>
                    </div>
                    
            <!-- Special Features -->
            <div style="background: rgba(165, 94, 234, 0.1); border-left: 4px solid #a55eea; padding: 20px; margin-bottom: 25px; border-radius: 8px;">
                <h3 style="color: #a55eea; margin: 0 0 15px 0;">‚ú® Special Features</h3>
                
                <ul style="color: #ddd; line-height: 1.8; padding-left: 20px;">
                    <li><strong>Triangle Rotation:</strong> Press LEFT/RIGHT to rotate after moving</li>
                    <li><strong>Threat Highlights:</strong> Red glow shows pieces under attack</li>
                    <li><strong>Move History:</strong> Track all moves in side panels</li>
                    <li><strong>Coordinate Display:</strong> Toggle hex coordinates on/off</li>
                    <li><strong>Help System:</strong> Click ‚ùì HELP in-game for detailed rules</li>
                        </ul>
            </div>
            
            <!-- Tips -->
            <div style="background: rgba(38, 222, 129, 0.1); border-left: 4px solid #26de81; padding: 20px; margin-bottom: 25px; border-radius: 8px;">
                <h3 style="color: #26de81; margin: 0 0 15px 0;">üí° Pro Tips</h3>
                
                <ul style="color: #ddd; line-height: 1.8; padding-left: 20px;">
                    <li>Protect your rhombus - it's your most important piece!</li>
                    <li>Use triangles and hexagons for early game control</li>
                    <li>Circles are great for surprise attacks (knight-like movement)</li>
                    <li>Keep pieces on your base for defence bonus</li>
                    <li>Watch for checkmate opportunities when opponent's rhombus is trapped</li>
                        </ul>
            </div>
            
            <button onclick="closeLearningModal()" style="
                background: linear-gradient(45deg, #4ecdc4, #44a08d);
                color: white;
                border: none;
                padding: 15px 30px;
                border-radius: 8px;
                cursor: pointer;
                width: 100%;
                font-weight: 600;
                font-size: 16px;
                transition: all 0.3s ease;
            " onmouseover="this.style.transform='scale(1.02)'" onmouseout="this.style.transform='scale(1)'">
                ‚úì Got it! Let's Play
            </button>
                    </div>
                </div>
                
    <!-- Leaderboard Modal -->
    <div id="leaderboard-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.9); z-index: 10000; overflow-y: auto;">
        <div style="background: #262421; border: 3px solid #f1c40f; border-radius: 20px; padding: 40px; max-width: 700px; width: 90%; margin: 50px auto; box-shadow: 0 10px 50px rgba(241, 196, 15, 0.3);">
            <h2 style="color: #f1c40f; text-align: center; margin-bottom: 30px; font-size: 32px;">üèÜ Leaderboard</h2>
            
            <!-- Filter Tabs -->
            <div style="display: flex; gap: 10px; justify-content: center; margin-bottom: 25px; flex-wrap: wrap;">
                <button onclick="switchLeaderboardTab('daily')" id="lb-tab-daily" style="
                    background: #f1c40f;
                    color: #262421;
                    border: none;
                    padding: 10px 20px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-weight: 600;
                    transition: all 0.3s ease;
                ">Daily</button>
                <button onclick="switchLeaderboardTab('weekly')" id="lb-tab-weekly" style="
                    background: #444;
                    color: #ccc;
                    border: none;
                    padding: 10px 20px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-weight: 600;
                    transition: all 0.3s ease;
                ">Weekly</button>
                <button onclick="switchLeaderboardTab('alltime')" id="lb-tab-alltime" style="
                    background: #444;
                    color: #ccc;
                    border: none;
                    padding: 10px 20px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-weight: 600;
                    transition: all 0.3s ease;
                ">All Time</button>
                    </div>
                    
            <!-- Leaderboard Content -->
            <div id="leaderboard-content" style="background: rgba(0, 0, 0, 0.3); border-radius: 12px; padding: 20px; margin-bottom: 25px;">
                <!-- Table Header -->
                <div style="display: grid; grid-template-columns: 60px 1fr 100px 100px; gap: 10px; padding: 10px; border-bottom: 2px solid #444; margin-bottom: 15px; font-weight: 600; color: #f1c40f;">
                    <div>Rank</div>
                    <div>Player</div>
                    <div>Wins</div>
                    <div>Rating</div>
                    </div>
                    
                <!-- Top Players List -->
                <div id="leaderboard-list">
                    <!-- Rank 1 -->
                    <div style="display: grid; grid-template-columns: 60px 1fr 100px 100px; gap: 10px; padding: 12px; background: rgba(241, 196, 15, 0.1); border-radius: 8px; margin-bottom: 8px; align-items: center;">
                        <div style="font-size: 1.5em;">ü•á</div>
                        <div style="color: #fff; font-weight: 600;">ChessMaster2000</div>
                        <div style="color: #4ecdc4;">147</div>
                        <div style="color: #f1c40f; font-weight: 700;">2450</div>
                    </div>
                    
                    <!-- Rank 2 -->
                    <div style="display: grid; grid-template-columns: 60px 1fr 100px 100px; gap: 10px; padding: 12px; background: rgba(192, 192, 192, 0.1); border-radius: 8px; margin-bottom: 8px; align-items: center;">
                        <div style="font-size: 1.5em;">ü•à</div>
                        <div style="color: #fff; font-weight: 600;">StrategyKing</div>
                        <div style="color: #4ecdc4;">132</div>
                        <div style="color: #ccc; font-weight: 700;">2380</div>
                </div>
                
                    <!-- Rank 3 -->
                    <div style="display: grid; grid-template-columns: 60px 1fr 100px 100px; gap: 10px; padding: 12px; background: rgba(205, 127, 50, 0.1); border-radius: 8px; margin-bottom: 8px; align-items: center;">
                        <div style="font-size: 1.5em;">ü•â</div>
                        <div style="color: #fff; font-weight: 600;">TacticalGenius</div>
                        <div style="color: #4ecdc4;">128</div>
                        <div style="color: #cd7f32; font-weight: 700;">2310</div>
                    </div>
                    
                    <!-- Rank 4-10 -->
                    <div style="display: grid; grid-template-columns: 60px 1fr 100px 100px; gap: 10px; padding: 10px; border-bottom: 1px solid #333; margin-bottom: 5px; align-items: center;">
                        <div style="color: #888; font-weight: 600;">4</div>
                        <div style="color: #ddd;">HexagonHero</div>
                        <div style="color: #4ecdc4;">115</div>
                        <div style="color: #ddd;">2245</div>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 60px 1fr 100px 100px; gap: 10px; padding: 10px; border-bottom: 1px solid #333; margin-bottom: 5px; align-items: center;">
                        <div style="color: #888; font-weight: 600;">5</div>
                        <div style="color: #ddd;">RhombusMaster</div>
                        <div style="color: #4ecdc4;">108</div>
                        <div style="color: #ddd;">2198</div>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 60px 1fr 100px 100px; gap: 10px; padding: 10px; border-bottom: 1px solid #333; margin-bottom: 5px; align-items: center;">
                        <div style="color: #888; font-weight: 600;">6</div>
                        <div style="color: #ddd;">GameChampion</div>
                        <div style="color: #4ecdc4;">95</div>
                        <div style="color: #ddd;">2145</div>
                </div>
                
                    <div style="display: grid; grid-template-columns: 60px 1fr 100px 100px; gap: 10px; padding: 10px; border-bottom: 1px solid #333; margin-bottom: 5px; align-items: center;">
                        <div style="color: #888; font-weight: 600;">7</div>
                        <div style="color: #ddd;">BoardPro</div>
                        <div style="color: #4ecdc4;">87</div>
                        <div style="color: #ddd;">2089</div>
                        </div>
                    
                    <div style="display: grid; grid-template-columns: 60px 1fr 100px 100px; gap: 10px; padding: 10px; border-bottom: 1px solid #333; margin-bottom: 5px; align-items: center;">
                        <div style="color: #888; font-weight: 600;">8</div>
                        <div style="color: #ddd;">SquareWarrior</div>
                        <div style="color: #4ecdc4;">78</div>
                        <div style="color: #ddd;">2034</div>
                        </div>
                    
                    <div style="display: grid; grid-template-columns: 60px 1fr 100px 100px; gap: 10px; padding: 10px; border-bottom: 1px solid #333; margin-bottom: 5px; align-items: center;">
                        <div style="color: #888; font-weight: 600;">9</div>
                        <div style="color: #ddd;">CircleChaser</div>
                        <div style="color: #4ecdc4;">72</div>
                        <div style="color: #ddd;">1987</div>
                        </div>
                    
                    <div style="display: grid; grid-template-columns: 60px 1fr 100px 100px; gap: 10px; padding: 10px; border-bottom: 1px solid #333; margin-bottom: 5px; align-items: center;">
                        <div style="color: #888; font-weight: 600;">10</div>
                        <div style="color: #ddd;">TriangleTitan</div>
                        <div style="color: #4ecdc4;">65</div>
                        <div style="color: #ddd;">1925</div>
                    </div>
                </div>
                
                <!-- Your Rank (if logged in) -->
                <div style="margin-top: 20px; padding: 15px; background: rgba(78, 205, 196, 0.1); border: 2px solid #4ecdc4; border-radius: 8px;">
                    <div style="display: grid; grid-template-columns: 60px 1fr 100px 100px; gap: 10px; align-items: center;">
                        <div style="color: #4ecdc4; font-weight: 600;">---</div>
                        <div style="color: #fff; font-weight: 600;">LOGGED IN AS GUEST</div>
                        <div style="color: #4ecdc4;">0</div>
                        <div style="color: #4ecdc4; font-weight: 700;">1200</div>
                    </div>
                    <p style="color: #888; font-size: 0.85em; margin: 10px 0 0 0; text-align: center;">
                        üîê Create an account to save your progress and compete!
                    </p>
                </div>
            </div>
            
            <button onclick="closeLeaderboardModal()" style="
                background: linear-gradient(45deg, #f1c40f, #f39c12);
                color: #262421;
                border: none;
                padding: 15px 30px;
                border-radius: 8px;
                cursor: pointer;
                width: 100%;
                font-weight: 600;
                font-size: 16px;
                transition: all 0.3s ease;
            " onmouseover="this.style.transform='scale(1.02)'" onmouseout="this.style.transform='scale(1)'">
                ‚Üê Back to Menu
            </button>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.95); z-index: 10000; overflow-y: auto;">
        <div style="background: #000000; border: none; border-radius: 0; padding: 40px; max-width: 100%; width: 100%; min-height: 100vh; margin: 0; box-shadow: none;">
            <h2 style="color: #95a5a6; text-align: center; margin-bottom: 30px; font-size: 32px;">‚öôÔ∏è Settings</h2>
            
            <!-- Audio Settings -->
            <div style="padding: 20px 0; margin-bottom: 20px;">
                <h3 style="color: #4ecdc4; margin: 0 0 15px 0; font-size: 1.3em;">üîä Audio</h3>
                
                <!-- Sound Effects -->
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <div>
                        <div style="color: #fff; font-weight: 600; margin-bottom: 3px;">Sound Effects</div>
                        <div style="color: #888; font-size: 0.85em;">Piece movement & capture sounds</div>
                    </div>
                    <div onclick="toggleSetting('sound-effects')" style="position: relative; display: inline-block; width: 60px; height: 30px; cursor: pointer;">
                        <input type="checkbox" id="setting-sound-effects" checked style="opacity: 0; width: 0; height: 0; pointer-events: none;">
                        <span style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: #4ecdc4; border-radius: 30px; transition: 0.3s;"></span>
                        <span style="position: absolute; height: 22px; width: 22px; left: 34px; bottom: 4px; background-color: white; border-radius: 50%; transition: 0.3s;"></span>
                    </div>
                </div>
                
                <!-- Music -->
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <div>
                        <div style="color: #fff; font-weight: 600; margin-bottom: 3px;">Background Music</div>
                        <div style="color: #888; font-size: 0.85em;">Ambient game music</div>
                    </div>
                    <div onclick="toggleSetting('music')" style="position: relative; display: inline-block; width: 60px; height: 30px; cursor: pointer;">
                        <input type="checkbox" id="setting-music" style="opacity: 0; width: 0; height: 0; pointer-events: none;">
                        <span style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: #555; border-radius: 30px; transition: 0.3s;"></span>
                        <span style="position: absolute; height: 22px; width: 22px; left: 4px; bottom: 4px; background-color: white; border-radius: 50%; transition: 0.3s;"></span>
                    </div>
                </div>
                
                <!-- Music Track Selector -->
                <div style="margin-bottom: 15px;">
                    <div style="color: #fff; font-weight: 600; margin-bottom: 8px;">Music Track</div>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <button onclick="playBackgroundMusic(1)" style="background: rgba(78, 205, 196, 0.2); border: 1px solid #4ecdc4; color: #4ecdc4; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 0.85em;">Track 1</button>
                        <button onclick="playBackgroundMusic(2)" style="background: rgba(78, 205, 196, 0.2); border: 1px solid #4ecdc4; color: #4ecdc4; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 0.85em;">Track 2</button>
                        <button onclick="playBackgroundMusic(3)" style="background: rgba(78, 205, 196, 0.2); border: 1px solid #4ecdc4; color: #4ecdc4; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 0.85em;">Track 3</button>
                        <button onclick="stopBackgroundMusic()" style="background: rgba(255, 107, 107, 0.2); border: 1px solid #ff6b6b; color: #ff6b6b; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 0.85em;">Stop</button>
                    </div>
                </div>
            </div>
            
            <!-- Display Settings -->
            <div style="padding: 20px 0; margin-bottom: 20px;">
                <h3 style="color: #ffd700; margin: 0 0 15px 0; font-size: 1.3em;">üé® Display</h3>
                
                <!-- Show Coordinates -->
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <div>
                        <div style="color: #fff; font-weight: 600; margin-bottom: 3px;">Show Coordinates</div>
                        <div style="color: #888; font-size: 0.85em;">Display hex coordinates on board</div>
                    </div>
                    <div onclick="toggleSetting('coordinates')" style="position: relative; display: inline-block; width: 60px; height: 30px; cursor: pointer;">
                        <input type="checkbox" id="setting-coordinates" style="opacity: 0; width: 0; height: 0; pointer-events: none;">
                        <span style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: #555; border-radius: 30px; transition: 0.3s;"></span>
                        <span style="position: absolute; height: 22px; width: 22px; left: 4px; bottom: 4px; background-color: white; border-radius: 50%; transition: 0.3s;"></span>
                    </div>
                </div>
                
                <!-- Highlight Valid Moves -->
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <div>
                        <div style="color: #fff; font-weight: 600; margin-bottom: 3px;">Highlight Valid Moves</div>
                        <div style="color: #888; font-size: 0.85em;">Show possible moves when selecting piece</div>
                    </div>
                    <div onclick="toggleSetting('highlight-moves')" style="position: relative; display: inline-block; width: 60px; height: 30px; cursor: pointer;">
                        <input type="checkbox" id="setting-highlight-moves" checked style="opacity: 0; width: 0; height: 0; pointer-events: none;">
                        <span style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: #ffd700; border-radius: 30px; transition: 0.3s;"></span>
                        <span style="position: absolute; height: 22px; width: 22px; left: 34px; bottom: 4px; background-color: white; border-radius: 50%; transition: 0.3s;"></span>
                    </div>
                </div>
                
                <!-- Animation Speed -->
                <div style="margin-bottom: 0;">
                    <div style="color: #fff; font-weight: 600; margin-bottom: 8px;">Animation Speed</div>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <span style="color: #888; font-size: 0.85em;">Slow</span>
                        <input type="range" id="setting-animation-speed" min="1" max="3" value="2" style="flex: 1; height: 6px; background: #555; border-radius: 5px; outline: none;">
                        <span style="color: #888; font-size: 0.85em;">Fast</span>
                    </div>
                </div>
            </div>
            
            <!-- Gameplay Settings -->
            <div style="padding: 20px 0; margin-bottom: 20px;">
                <h3 style="color: #a55eea; margin: 0 0 15px 0; font-size: 1.3em;">üéÆ Gameplay</h3>
                
                <!-- Auto-end Turn -->
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <div>
                        <div style="color: #fff; font-weight: 600; margin-bottom: 3px;">Confirm Moves</div>
                        <div style="color: #888; font-size: 0.85em;">Require confirmation before move</div>
                    </div>
                    <div onclick="toggleSetting('confirm-moves')" style="position: relative; display: inline-block; width: 60px; height: 30px; cursor: pointer;">
                        <input type="checkbox" id="setting-confirm-moves" style="opacity: 0; width: 0; height: 0; pointer-events: none;">
                        <span style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: #555; border-radius: 30px; transition: 0.3s;"></span>
                        <span style="position: absolute; height: 22px; width: 22px; left: 4px; bottom: 4px; background-color: white; border-radius: 50%; transition: 0.3s;"></span>
                    </div>
                </div>
                
                <!-- Show Threats -->
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <div>
                        <div style="color: #fff; font-weight: 600; margin-bottom: 3px;">Show Threats</div>
                        <div style="color: #888; font-size: 0.85em;">Highlight pieces under attack</div>
                    </div>
                    <div onclick="toggleSetting('show-threats')" style="position: relative; display: inline-block; width: 60px; height: 30px; cursor: pointer;">
                        <input type="checkbox" id="setting-show-threats" checked style="opacity: 0; width: 0; height: 0; pointer-events: none;">
                        <span style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: #a55eea; border-radius: 30px; transition: 0.3s;"></span>
                        <span style="position: absolute; height: 22px; width: 22px; left: 34px; bottom: 4px; background-color: white; border-radius: 50%; transition: 0.3s;"></span>
                    </div>
                </div>
                
                <!-- Show Last Move -->
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <div style="color: #fff; font-weight: 600; margin-bottom: 3px;">Show Last Move</div>
                        <div style="color: #888; font-size: 0.85em;">Highlight the previous move</div>
                    </div>
                    <div onclick="toggleSetting('show-last-move')" style="position: relative; display: inline-block; width: 60px; height: 30px; cursor: pointer;">
                        <input type="checkbox" id="setting-show-last-move" checked style="opacity: 0; width: 0; height: 0; pointer-events: none;">
                        <span style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: #a55eea; border-radius: 30px; transition: 0.3s;"></span>
                        <span style="position: absolute; height: 22px; width: 22px; left: 34px; bottom: 4px; background-color: white; border-radius: 50%; transition: 0.3s;"></span>
                    </div>
                </div>
            </div>
            
            <!-- Reset Button -->
            <button onclick="resetSettings()" style="
                background: #ff6b6b;
                color: white;
                border: none;
                padding: 12px 24px;
                border-radius: 8px;
                cursor: pointer;
                width: 100%;
                font-weight: 600;
                margin-bottom: 10px;
                transition: all 0.3s ease;
            " onmouseover="this.style.background='#ff5252'" onmouseout="this.style.background='#ff6b6b'">
                üîÑ Reset to Defaults
            </button>
                
            <button onclick="closeSettingsModal()" style="
                background: linear-gradient(45deg, #95a5a6, #7f8c8d);
                color: white;
                border: none;
                padding: 15px 30px;
                border-radius: 8px;
                cursor: pointer;
                width: 100%;
                font-weight: 600;
                font-size: 16px;
                transition: all 0.3s ease;
            " onmouseover="this.style.transform='scale(1.02)'" onmouseout="this.style.transform='scale(1)'">
                ‚úì Save & Close
            </button>
        </div>
    </div>

    <!-- Game Modes Modal -->
    <div id="game-modes-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.9); z-index: 10000; justify-content: center; align-items: center;">
        <div style="background: #262421; border: 3px solid #ff6b6b; border-radius: 20px; padding: 40px; max-width: 700px; width: 90%; box-shadow: 0 10px 50px rgba(255, 107, 107, 0.3);">
            <h2 style="color: #ff6b6b; text-align: center; margin-bottom: 30px; font-size: 32px;">üéØ Game Modes</h2>
            
            <p style="color: #ccc; text-align: center; margin-bottom: 25px;">Choose an alternative game variant:</p>
            
            <!-- Game Modes Grid -->
            <div style="display: grid; gap: 20px; margin-bottom: 25px;">
                
                <!-- Square Attack Mode -->
                <div style="background: rgba(255, 107, 107, 0.1); border: 2px solid #ff6b6b; border-radius: 12px; padding: 25px; cursor: pointer; transition: all 0.3s ease;" 
                     onclick="startGameMode('square-attack')" 
                     onmouseover="this.style.transform='translateY(-3px)'; this.style.boxShadow='0 8px 25px rgba(255, 107, 107, 0.3)'" 
                     onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                    <div style="display: flex; align-items: center; gap: 20px;">
                        <div style="font-size: 3em;">‚öîÔ∏è</div>
                        <div style="flex: 1;">
                            <h3 style="color: #ff6b6b; margin: 0 0 10px 0; font-size: 1.4em;">Square Attack</h3>
                            <p style="color: #ddd; margin: 0 0 10px 0; line-height: 1.5;">
                                Simplified mode with <strong>squares only</strong> plus rhombus. Fast-paced tactical gameplay.
                            </p>
                            <div style="display: flex; gap: 15px; color: #aaa; font-size: 0.9em;">
                                <span>‚ñ† 4 Squares each</span>
                                <span>üî∂ 1 Rhombus each</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Hexagon Siege Mode -->
                <div style="background: rgba(78, 205, 196, 0.1); border: 2px solid #4ecdc4; border-radius: 12px; padding: 25px; cursor: pointer; transition: all 0.3s ease;" 
                     onclick="startGameMode('hexagon-siege')" 
                     onmouseover="this.style.transform='translateY(-3px)'; this.style.boxShadow='0 8px 25px rgba(78, 205, 196, 0.3)'" 
                     onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                    <div style="display: flex; align-items: center; gap: 20px;">
                        <div style="font-size: 3em;">‚¨°</div>
                        <div style="flex: 1;">
                            <h3 style="color: #4ecdc4; margin: 0 0 10px 0; font-size: 1.4em;">Hexagon Siege</h3>
                            <p style="color: #ddd; margin: 0 0 10px 0; line-height: 1.5;">
                                Rotating powerhouses! <strong>Hexagons only</strong> plus rhombus. Master rotation strategy.
                            </p>
                            <div style="display: flex; gap: 15px; color: #aaa; font-size: 0.9em;">
                                <span>‚¨° 4 Hexagons each</span>
                                <span>üî∂ 1 Rhombus each</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- More modes placeholder -->
                <div style="background: rgba(149, 165, 166, 0.1); border: 2px dashed #95a5a6; border-radius: 12px; padding: 25px; opacity: 0.6;">
                    <div style="display: flex; align-items: center; gap: 20px;">
                        <div style="font-size: 3em;">üîí</div>
                        <div style="flex: 1;">
                            <h3 style="color: #95a5a6; margin: 0 0 10px 0; font-size: 1.4em;">More Modes Coming Soon!</h3>
                            <p style="color: #999; margin: 0; line-height: 1.5;">
                                Triangle Rush, Circle Chaos, and more variants in development...
                            </p>
                        </div>
                    </div>
                </div>
                
            </div>
            
            <button onclick="closeGameModesModal()" style="
                background-color: #555;
                    color: white;
                    border: none;
                padding: 15px 30px;
                border-radius: 8px;
                    cursor: pointer;
                width: 100%;
                font-weight: 600;
                font-size: 16px;
                    transition: all 0.3s ease;
            " onmouseover="this.style.background='#666'" onmouseout="this.style.background='#555'">
                ‚Üê Back to Menu
                </button>
                
            <!-- Debug AI Button -->
            <button onclick="testAI()" style="
                background-color: #ff6b6b;
                    color: white;
                    border: none;
                padding: 10px 20px;
                border-radius: 8px;
                    cursor: pointer;
                width: 100%;
                font-weight: 600;
                font-size: 14px;
                margin-top: 10px;
                    transition: all 0.3s ease;
            " onmouseover="this.style.background='#ff5252'" onmouseout="this.style.background='#ff6b6b'">
                üß™ Test AI Move
            </button>
            
            <!-- Debug Triangle Button -->
            <button onclick="testTriangleRotation()" style="
                background-color: #4ecdc4;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 8px;
                cursor: pointer;
                width: 100%;
                font-weight: 600;
                font-size: 14px;
                margin-top: 10px;
                transition: all 0.3s ease;
            " onmouseover="this.style.background='#26d0ce'" onmouseout="this.style.background='#4ecdc4'">
                üî∫ Test Triangle Rotation
                </button>
        </div>
            </div>
            
    <!-- Game Analysis Modal -->
    <div id="analysis-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.95); z-index: 10000; overflow-y: auto;">
        <div style="background: #262421; border: 3px solid #4ecdc4; border-radius: 20px; padding: 30px; max-width: 1000px; width: 95%; margin: 30px auto; box-shadow: 0 10px 50px rgba(78, 205, 196, 0.3);">
            <h2 style="color: #4ecdc4; text-align: center; margin-bottom: 20px; font-size: 28px;">üìä Game Analysis</h2>
            
            <!-- File Upload Section -->
            <div style="background: rgba(78, 205, 196, 0.1); border: 2px dashed #4ecdc4; border-radius: 12px; padding: 25px; margin-bottom: 25px; text-align: center;">
                <h3 style="color: #4ecdc4; margin: 0 0 15px 0;">üìÅ Load RMN File</h3>
                <p style="color: #ccc; margin-bottom: 15px;">Upload a saved RMN game file to analyze</p>
                <input type="file" id="rmn-file-input" accept=".rmn,.txt" style="display: none;" onchange="loadRMNFile(event)">
                <button onclick="document.getElementById('rmn-file-input').click()" style="
                    background: linear-gradient(135deg, #4ecdc4, #26d0ce);
                    color: #262421;
                    border: none;
                    padding: 12px 30px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-weight: 700;
                    font-size: 16px;
                    transition: all 0.3s ease;
                    margin-right: 10px;
                " onmouseover="this.style.transform='translateY(-2px)'" onmouseout="this.style.transform='translateY(0)'">
                    üìÇ Choose File
                </button>
                <button onclick="loadCurrentGame()" style="
                    background: linear-gradient(135deg, #ffd700, #ffa500);
                    color: #262421;
                    border: none;
                    padding: 12px 30px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-weight: 700;
                    font-size: 16px;
                    transition: all 0.3s ease;
                " onmouseover="this.style.transform='translateY(-2px)'" onmouseout="this.style.transform='translateY(0)'">
                    üéÆ Analyze Current Game
                </button>
                <button onclick="debugCurrentPosition()" style="
                    background: linear-gradient(135deg, #9b59b6, #8e44ad);
                    color: white;
                    border: none;
                    padding: 12px 30px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-weight: 700;
                    font-size: 16px;
                    transition: all 0.3s ease;
                " onmouseover="this.style.transform='translateY(-2px)'" onmouseout="this.style.transform='translateY(0)'">
                    üîç Debug Position
                </button>
            </div>
            
            <!-- Game Info Section -->
            <div id="analysis-info" style="display: none; background: rgba(255, 215, 0, 0.1); border-left: 4px solid #ffd700; padding: 20px; margin-bottom: 20px; border-radius: 8px;">
                <h3 style="color: #ffd700; margin: 0 0 10px 0;">‚ÑπÔ∏è Game Information</h3>
                <div id="analysis-metadata" style="color: #ddd; line-height: 1.8;"></div>
            </div>
            
            <!-- Move Navigator -->
            <div id="analysis-navigator" style="display: none; background: rgba(78, 205, 196, 0.1); padding: 20px; margin-bottom: 20px; border-radius: 8px;">
                <h3 style="color: #4ecdc4; margin: 0 0 15px 0;">üé¨ Move Navigator</h3>
                <div style="display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap;">
                    <button onclick="goToStart()" style="
                        background: #555;
                        color: white;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 6px;
                        cursor: pointer;
                        font-weight: 600;
                    ">‚èÆÔ∏è Start</button>
                    <button onclick="previousMove()" style="
                        background: #555;
                        color: white;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 6px;
                        cursor: pointer;
                        font-weight: 600;
                    ">‚óÄÔ∏è Previous</button>
                    <button onclick="nextMove()" style="
                        background: #555;
                        color: white;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 6px;
                        cursor: pointer;
                        font-weight: 600;
                    ">‚ñ∂Ô∏è Next</button>
                    <button onclick="goToEnd()" style="
                        background: #555;
                        color: white;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 6px;
                        cursor: pointer;
                        font-weight: 600;
                    ">‚è≠Ô∏è End</button>
                    <button onclick="toggleAutoPlay()" id="autoplay-btn" style="
                        background: #4ecdc4;
                        color: #262421;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 6px;
                        cursor: pointer;
                        font-weight: 600;
                    ">‚ñ∂Ô∏è Auto Play</button>
                    <button onclick="annotateCurrentMove()" style="
                        background: #9b59b6;
                        color: white;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 6px;
                        cursor: pointer;
                        font-weight: 600;
                    ">üìù Annotate</button>
                </div>
                <div style="color: #fff; margin-bottom: 10px; font-weight: 600;">
                    Move: <span id="current-move-number">0</span> / <span id="total-moves">0</span>
                </div>
                <input type="range" id="move-slider" min="0" max="0" value="0" style="width: 100%; margin-bottom: 10px;" oninput="jumpToMove(parseInt(this.value))">
                <div id="current-move-info" style="color: #ccc; font-size: 14px;"></div>
            </div>
            
            <!-- Mini Board Display -->
            <div id="analysis-board-container" style="display: none; background: rgba(0, 0, 0, 0.3); padding: 20px; margin-bottom: 20px; border-radius: 8px; overflow: visible;">
                <h3 style="color: #4ecdc4; margin: 0 0 15px 0; text-align: center;">‚ôüÔ∏è Position View</h3>
                <div style="display: flex; justify-content: center; align-items: center; min-height: 500px; width: 100%;">
                    <div id="analysis-mini-board" class="mini-board"></div>
                </div>
            </div>
            
            <!-- Move List -->
            <div id="analysis-moves" style="display: none; background: rgba(255, 255, 255, 0.05); padding: 20px; margin-bottom: 20px; border-radius: 8px; max-height: 300px; overflow-y: auto;">
                <h3 style="color: #ffd700; margin: 0 0 15px 0;">üìú Move List</h3>
                <div id="analysis-move-list" style="color: #ddd; font-family: monospace; line-height: 2;"></div>
            </div>
            
            <!-- Statistics -->
            <div id="analysis-stats" style="display: none; background: rgba(255, 107, 107, 0.1); padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                <h3 style="color: #ff6b6b; margin: 0 0 15px 0;">üìà Game Statistics</h3>
                <div id="analysis-statistics" style="color: #ddd; line-height: 1.8;"></div>
            </div>
            
            <!-- Action Buttons -->
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                <button onclick="closeAnalysisModal()" style="
                    background: linear-gradient(135deg, #4ecdc4, #26d0ce);
                    color: #262421;
                    border: none;
                    padding: 15px 30px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-weight: 700;
                    font-size: 16px;
                    transition: all 0.3s ease;
                " onmouseover="this.style.transform='scale(1.02)'" onmouseout="this.style.transform='scale(1)'">
                    ‚Üê Back to Game
                </button>
                <button onclick="closeAnalysisModal()" style="
                    background: linear-gradient(45deg, #95a5a6, #7f8c8d);
                    color: white;
                    border: none;
                    padding: 15px 30px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-weight: 600;
                    font-size: 16px;
                    transition: all 0.3s ease;
                " onmouseover="this.style.transform='scale(1.02)'" onmouseout="this.style.transform='scale(1)'">
                    ‚úì Close
                </button>
            </div>
        </div>
    </div>
            
    <!--Multiplayer Modal -->
    <div id="multiplayer-modal">
        <div class="multiplayer-container" id="mp-main-menu">
            <h2>üåê Multiplayer Mode</h2>
            <div class="multiplayer-options">
                <button class="mp-button" onclick="startMatchmaking()" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                    üéØ Quick Match (Matchmaking)
                </button>
                <button class="mp-button" onclick="createMultiplayerRoom()">
                    üéÆ Create Private Room
                </button>
                <button class="mp-button secondary" onclick="showJoinRoom()">
                    üîó Join Private Room
                </button>
                <button class="mp-button" onclick="showPublicRooms()" style="background: linear-gradient(135deg, #43cea2 0%, #185a9d 100%);">
                    üìã Browse Public Rooms
                </button>
                <button class="mp-button" onclick="startDevMode()" style="background: linear-gradient(135deg, #ffa502 0%, #ff6348 100%);">
                    üîß Dev Mode (Local Test)
                </button>
                <button class="mp-back-button" onclick="closeMultiplayerModal()">
                    ‚Üê Back to Menu
                </button>
            </div>
        </div>

        <!-- Matchmaking View -->
        <div class="multiplayer-container" id="mp-matchmaking" style="display: none;">
            <h2>üéØ Finding Match</h2>
            <div style="text-align: center; padding: 40px 20px;">
                <div class="loading-spinner" style="
                    border: 4px solid rgba(78, 205, 196, 0.2);
                    border-top: 4px solid #4ecdc4;
                    border-radius: 50%;
                    width: 60px;
                    height: 60px;
                    animation: spin 1s linear infinite;
                    margin: 0 auto 20px;
                "></div>
                <p class="waiting-message">Searching for opponent...</p>
                <p id="matchmaking-queue-info" style="color: #888; font-size: 14px; margin-top: 10px;">
                    Players in queue: <span id="queue-size">0</span>
                </p>
                <p style="color: #888; font-size: 12px; margin-top: 20px;">
                    You'll be matched with players of similar skill level
                </p>
            </div>
            <button class="mp-back-button" onclick="cancelMatchmaking()">
                Cancel Search
            </button>
        </div>

        <!-- Public Rooms View -->
        <div class="multiplayer-container" id="mp-public-rooms" style="display: none;">
            <h2>üìã Public Rooms</h2>
            <div id="public-rooms-list" style="
                max-height: 400px;
                overflow-y: auto;
                margin: 20px 0;
                padding: 10px;
            ">
                <p style="text-align: center; color: #888;">Loading rooms...</p>
            </div>
            <button class="mp-back-button" onclick="backToMultiplayerMenu()">
                ‚Üê Back
            </button>
        </div>

        <!-- Create Room View -->
        <div class="multiplayer-container" id="mp-create-room" style="display: none;">
            <h2>üéÆ Hosting Game Room</h2>
            <div class="room-code-display" id="room-code-display">------</div>
            <div id="room-players-list" style="margin: 20px 0;">
                <div class="room-player">
                    <span class="player-name">Waiting for opponent...</span>
                </div>
            </div>
            <p style="color: #888; font-size: 14px; text-align: center;">
                Share this room code with your opponent
            </p>
            <button class="mp-button" id="ready-button" onclick="toggleReady()" style="display: none;">
                ‚úì Ready
            </button>
            <button class="mp-back-button" onclick="cancelCreateRoom()">
                Cancel
            </button>
        </div>

        <!-- Join Room View -->
        <div class="multiplayer-container" id="mp-join-room" style="display: none;">
            <h2>üîó Join Game Room</h2>
            <input 
                type="text" 
                id="room-code-input" 
                class="mp-input" 
                placeholder="Enter Room Code" 
                maxlength="6"
            />
            <div id="mp-error-message" class="mp-error"></div>
            <button class="mp-button" onclick="joinMultiplayerRoom()">
                Join Game
            </button>
            <button class="mp-back-button" onclick="backToMultiplayerMenu()">
                ‚Üê Back
            </button>
        </div>

        <!-- Waiting Room View (after joining) -->
        <div class="multiplayer-container" id="mp-waiting-room" style="display: none;">
            <h2>üéÆ Game Room</h2>
            <div class="room-code-display" id="waiting-room-code">------</div>
            <div id="waiting-room-players" style="margin: 20px 0;">
                <!-- Players will be populated here -->
            </div>
            <button class="mp-button" id="waiting-ready-button" onclick="toggleReady()">
                ‚úì Ready
            </button>
            <button class="mp-back-button" onclick="leaveWaitingRoom()">
                Leave Room
            </button>
        </div>
    </div>

    <style>
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .room-player {
            background: rgba(78, 205, 196, 0.1);
            border: 2px solid rgba(78, 205, 196, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .room-player.ready {
            border-color: #2ecc71;
            background: rgba(46, 204, 113, 0.1);
        }
        
        .player-name {
            font-weight: bold;
            color: #4ecdc4;
        }
        
        .player-ready-badge {
            background: #2ecc71;
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
        }
        
        .public-room-item {
            background: rgba(78, 205, 196, 0.1);
            border: 2px solid rgba(78, 205, 196, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .public-room-item:hover {
            background: rgba(78, 205, 196, 0.2);
            border-color: #4ecdc4;
            transform: translateX(5px);
        }
        
        .room-code-badge {
            display: inline-block;
            background: #4ecdc4;
            color: white;
            padding: 4px 12px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 14px;
            margin-left: 10px;
        }
    </style>

    <!-- Multiplayer Status Indicator -->
    <div id="multiplayer-status" class="multiplayer-status" style="display: none;">
        <div style="margin-bottom: 10px;">
            <span class="status-indicator" id="connection-indicator"></span>
            <span id="connection-text">Disconnected</span>
        </div>
        <div style="font-size: 12px; color: #ccc;">
            <div id="room-info" style="display: none;">
                Room: <span id="current-room-code" style="color: #4ecdc4; font-weight: bold;">------</span>
            </div>
            <div id="player-role">Role: <span id="player-color-display" style="font-weight: bold;">-</span></div>
        </div>
    </div>

    <!-- AI Reasoning Display Panel - Compact Version -->
    <div id="ai-reasoning-panel" style="
        display: none;
        position: fixed;
        bottom: 20px;
        left: 220px;
        background: rgba(0, 0, 0, 0.9);
        border: 2px solid #00d2ff;
        border-radius: 10px;
        padding: 12px;
        max-width: 320px;
        width: 320px;
        color: white;
        font-family: 'Courier New', monospace;
        z-index: 1500;
        box-shadow: 0 4px 20px rgba(0, 210, 255, 0.4);
        backdrop-filter: blur(10px);
    ">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <div style="display: flex; align-items: center; gap: 8px;">
                <span id="ai-model-icon" style="font-size: 1.2em;">üß†</span>
                <span id="ai-model-name" style="color: #00d2ff; font-size: 0.9em; font-weight: bold;">Claude</span>
            </div>
            <div id="ai-thinking-status" style="color: #ffd93d; font-size: 0.75em;">
                ‚è≥
            </div>
        </div>
        
        <div id="ai-reasoning-content" style="
            background: rgba(0, 210, 255, 0.1);
            border-left: 2px solid #00d2ff;
            padding: 8px;
            border-radius: 5px;
            font-size: 0.75em;
            line-height: 1.4;
            max-height: 120px;
            overflow-y: auto;
        ">
            <div id="ai-reasoning-text" style="color: #e0e0e0;">
                Thinking...
            </div>
        </div>
        
        <div id="ai-move-display" style="
            margin-top: 8px;
            padding: 6px;
            background: linear-gradient(45deg, #00d2ff22, #3a7bd522);
            border-radius: 5px;
            text-align: center;
            font-size: 0.85em;
            font-weight: bold;
            color: #00d2ff;
        ">
            <span id="ai-move-text">‚ö° Calculating...</span>
        </div>
    </div>

    <div id="board-display-container" style="display: none;">
        <!-- Top Left Controls (Quit Button Only) -->
        <div style="position: absolute; top: 18px; left: 18px; z-index: 20; display: flex; gap: 12px;">
            <button id="quit-game-btn" style="background:linear-gradient(135deg,#ff6b6b,#ff5252);color:white;border:none;padding:12px 28px;border-radius:18px;cursor:pointer;font-weight:700;font-size:1.05em;box-shadow:0 2px 8px rgba(255,107,107,0.25);transition:all 0.2s;letter-spacing:1px;white-space:nowrap;min-width:180px;" onclick="quitAndLogout()" onmouseover="this.style.transform='translateY(-2px)';this.style.boxShadow='0 4px 16px rgba(255,107,107,0.4)'" onmouseout="this.style.transform='translateY(0)';this.style.boxShadow='0 2px 8px rgba(255,107,107,0.25)';">Quit & Logout</button>
        </div>
        
        <!-- Player Timers -->
        <div id="player-timers" class="player-timers" style="display: none;">
            <div id="white-timer" class="timer-display">
                <div class="timer-label">White</div>
                <div class="timer-time">10:00</div>
            </div>
            <div id="black-timer" class="timer-display active">
                <div class="timer-label">Black</div>
                <div class="timer-time">10:00</div>
            </div>
        </div>
        
        <!-- Eliminated pieces display -->
        <div id="eliminated-pieces-container">
            <div class="eliminated-section">
                <h3>White Eliminated</h3>
                <div id="white-eliminated" class="eliminated-pieces"></div>
                <!-- Base defence indicator placeholder will be inserted here by updateBaseDefenceDisplay() -->
                <div id="white-base-defence-placeholder"></div>
                <div id="white-variant-indicator" class="variant-indicator" style="margin-top:6px;">BASE: Original</div>
                <div id="white-opening-name" style="margin-top:6px;text-align:center;color:#4ecdc4;font-size:0.95em;font-weight:600;"></div>
                <div class="movement-section">
                    <h3>White Moves</h3>
                    <ul id="white-moves" class="movement-list"></ul>
                </div>
            </div>
            <div class="eliminated-section">
                <h3>Black Eliminated</h3>
                <div id="black-eliminated" class="eliminated-pieces"></div>
                <!-- Base defence indicator placeholder will be inserted here by updateBaseDefenceDisplay() -->
                <div id="black-base-defence-placeholder"></div>
                <div id="black-variant-indicator" class="variant-indicator" style="margin-top:6px;">BASE: Original</div>
                <div id="black-opening-name" style="margin-top:6px;text-align:center;color:#ffd700;font-size:0.95em;font-weight:600;"></div>
                <div class="movement-section">
                    <h3>Black Moves</h3>
                    <ul id="black-moves" class="movement-list"></ul>
                </div>
    
    <!-- Sandbox Mode Tools Panel -->
    <div id="sandbox-tools-panel" style="display: none; position: fixed; top: 80px; left: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 12px; padding: 20px; box-shadow: 0 8px 30px rgba(102, 126, 234, 0.4); z-index: 1000; min-width: 280px; color: #fff;">
        <div style="text-align: center; margin-bottom: 15px;">
            <div style="font-size: 2em;">üõ†Ô∏è</div>
            <h3 style="margin: 8px 0 4px 0; font-size: 1.2em;">Sandbox Mode</h3>
            <p style="margin: 0; font-size: 0.85em; opacity: 0.9;">Position Editor</p>
        </div>
        
        <!-- Edit Mode Toggle -->
        <div style="background: rgba(255, 255, 255, 0.1); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
            <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; font-weight: 600;">
                <input type="checkbox" id="sandbox-edit-mode" onchange="toggleSandboxEditMode()" style="width: 20px; height: 20px; cursor: pointer;">
                <span>‚úèÔ∏è Edit Mode (Place/Remove Pieces)</span>
            </label>
        </div>
        
        <!-- Play Mode Toggle -->
        <div style="background: rgba(78, 205, 196, 0.2); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
            <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; font-weight: 600;">
                <input type="checkbox" id="sandbox-play-mode" onchange="toggleSandboxPlayMode()" style="width: 20px; height: 20px; cursor: pointer;">
                <span>‚ñ∂Ô∏è Play Mode (Test Position)</span>
            </label>
            <div style="font-size: 0.85em; opacity: 0.9; margin-top: 8px; font-style: italic;">Enable to test moves by dragging pieces</div>
        </div>
        
        <!-- Piece Selection -->
        <div id="sandbox-piece-selector" style="display: none; background: rgba(255, 255, 255, 0.1); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
            <label style="display: block; margin-bottom: 8px; font-weight: 600;">Select Piece to Place:</label>
            <select id="sandbox-piece-type" style="width: 100%; padding: 8px; background: rgba(255, 255, 255, 0.9); border: none; border-radius: 6px; font-size: 0.95em; margin-bottom: 8px;">
                <option value="">-- Click to Remove --</option>
                <optgroup label="White Pieces">
                    <option value="white-triangle">‚ñ≥ White Triangle</option>
                    <option value="white-square">‚ñ° White Square</option>
                    <option value="white-circle">‚óã White Circle</option>
                    <option value="white-hexgon">‚¨° White Hexgon</option>
                    <option value="white-rhombus">‚óá White Rhombus</option>
                </optgroup>
                <optgroup label="Black Pieces">
                    <option value="black-triangle">‚ñ≤ Black Triangle</option>
                    <option value="black-square">‚ñ† Black Square</option>
                    <option value="black-circle">‚óè Black Circle</option>
                    <option value="black-hexgon">‚¨¢ Black Hexgon</option>
                    <option value="black-rhombus">‚óÜ Black Rhombus</option>
                </optgroup>
            </select>
            <div style="font-size: 0.85em; opacity: 0.9; font-style: italic;">Click any hex to place/remove</div>
        </div>
        
        <!-- Control Buttons -->
        <div style="display: flex; flex-direction: column; gap: 10px;">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                <button onclick="switchSandboxTurn()" style="background: rgba(255, 255, 255, 0.2); color: #fff; border: 2px solid rgba(255, 255, 255, 0.4); padding: 10px; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s; font-size: 0.9em;" onmouseover="this.style.background='rgba(255, 255, 255, 0.3)'" onmouseout="this.style.background='rgba(255, 255, 255, 0.2)'">
                    üîÑ Turn
                </button>
                <button onclick="toggleSandboxSidePanels()" style="background: rgba(78, 205, 196, 0.3); color: #fff; border: 2px solid rgba(78, 205, 196, 0.5); padding: 10px; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s; font-size: 0.9em;" onmouseover="this.style.background='rgba(78, 205, 196, 0.4)'" onmouseout="this.style.background='rgba(78, 205, 196, 0.3)'">
                    üëÅÔ∏è Panels
                </button>
            </div>
            <button onclick="resetSandboxBoard()" style="background: rgba(255, 255, 255, 0.2); color: #fff; border: 2px solid rgba(255, 255, 255, 0.4); padding: 10px; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s;" onmouseover="this.style.background='rgba(255, 255, 255, 0.3)'" onmouseout="this.style.background='rgba(255, 255, 255, 0.2)'">
                ‚ôªÔ∏è Reset to Start
            </button>
            <button onclick="clearSandboxBoard()" style="background: rgba(255, 107, 107, 0.3); color: #fff; border: 2px solid rgba(255, 107, 107, 0.5); padding: 10px; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s;" onmouseover="this.style.background='rgba(255, 107, 107, 0.4)'" onmouseout="this.style.background='rgba(255, 107, 107, 0.3)'">
                üóëÔ∏è Clear Board
            </button>
            <button onclick="saveSandboxPosition()" style="background: rgba(78, 205, 196, 0.3); color: #fff; border: 2px solid rgba(78, 205, 196, 0.5); padding: 10px; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s;" onmouseover="this.style.background='rgba(78, 205, 196, 0.4)'" onmouseout="this.style.background='rgba(78, 205, 196, 0.3)'">
                üíæ Save Position
            </button>
            <button onclick="loadSandboxPosition()" style="background: rgba(78, 205, 196, 0.3); color: #fff; border: 2px solid rgba(78, 205, 196, 0.5); padding: 10px; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s;" onmouseover="this.style.background='rgba(78, 205, 196, 0.4)'" onmouseout="this.style.background='rgba(78, 205, 196, 0.3)'">
                üìÇ Load Position
            </button>
            <button onclick="openPositionAnalyzer()" style="background: rgba(255, 206, 86, 0.3); color: #fff; border: 2px solid rgba(255, 206, 86, 0.5); padding: 10px; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s;" onmouseover="this.style.background='rgba(255, 206, 86, 0.4)'" onmouseout="this.style.background='rgba(255, 206, 86, 0.3)'">
                üîç Analyze Position
            </button>
            <button onclick="openPuzzleCreator()" style="background: rgba(230, 126, 34, 0.3); color: #fff; border: 2px solid rgba(230, 126, 34, 0.5); padding: 10px; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s;" onmouseover="this.style.background='rgba(230, 126, 34, 0.4)'" onmouseout="this.style.background='rgba(230, 126, 34, 0.3)'">
                üß© Create Puzzle
            </button>
            <button onclick="exitSandboxMode()" style="background: linear-gradient(135deg, #ff6b6b 0%, #ff5252 100%); color: #fff; border: none; padding: 12px; border-radius: 8px; cursor: pointer; font-weight: 700; box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3); transition: all 0.3s;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(255, 107, 107, 0.5)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(255, 107, 107, 0.3)'">
                ‚ùå Exit Sandbox
            </button>
        </div>
        
        <!-- Current Turn Indicator -->
        <div id="sandbox-turn-display" style="margin-top: 15px; text-align: center; padding: 10px; background: rgba(0, 0, 0, 0.2); border-radius: 6px; font-weight: 600;">
            Current Turn: <span id="sandbox-current-turn">Black</span>
        </div>
    </div>
    
    <!-- Position Analyzer Modal -->
    <div id="position-analyzer-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.95); z-index: 100002; overflow-y: auto;">
        <div style="max-width: 800px; margin: 40px auto; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 18px; box-shadow: 0 8px 40px rgba(102, 126, 234, 0.5); padding: 40px; color: #fff; position: relative;">
            <button onclick="closePositionAnalyzer()" style="position: absolute; top: 18px; right: 18px; background: #ff6b6b; color: #fff; border: none; border-radius: 8px; font-size: 1.2em; font-weight: bold; padding: 6px 16px; cursor: pointer; transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.1)'" onmouseout="this.style.transform='scale(1)'">‚úñÔ∏è</button>
            
            <div style="text-align: center; margin-bottom: 30px;">
                <div style="font-size: 3em; margin-bottom: 10px;">üîçüìä</div>
                <h2 style="margin: 0; font-size: 2em;">Position Analyzer</h2>
                <p style="opacity: 0.9; margin: 10px 0 0 0;">Analyze legal moves and position statistics</p>
            </div>
            
            <!-- Analysis Results -->
            <div id="analyzer-results" style="background: rgba(0, 0, 0, 0.3); border-radius: 12px; padding: 25px; margin-bottom: 20px;">
                <h3 style="margin: 0 0 15px 0; font-size: 1.3em; border-bottom: 2px solid rgba(255, 255, 255, 0.3); padding-bottom: 10px;">üìà Position Summary</h3>
                <div id="analyzer-summary" style="font-size: 1.05em; line-height: 1.8;">
                    Click "Analyze" to see position details...
                </div>
            </div>
            
            <!-- Legal Moves Display -->
            <div id="analyzer-moves" style="background: rgba(0, 0, 0, 0.3); border-radius: 12px; padding: 25px; margin-bottom: 20px; display: none;">
                <h3 style="margin: 0 0 15px 0; font-size: 1.3em; border-bottom: 2px solid rgba(255, 255, 255, 0.3); padding-bottom: 10px;">‚ôüÔ∏è Legal Moves</h3>
                <div id="analyzer-moves-list" style="max-height: 300px; overflow-y: auto;"></div>
            </div>
            
            <div style="display: flex; gap: 15px;">
                <button onclick="analyzeCurrentPosition()" style="flex: 1; background: rgba(78, 205, 196, 0.3); color: #fff; border: 2px solid rgba(78, 205, 196, 0.5); padding: 15px; border-radius: 8px; cursor: pointer; font-weight: 700; font-size: 1.1em; transition: all 0.3s;" onmouseover="this.style.background='rgba(78, 205, 196, 0.4)'" onmouseout="this.style.background='rgba(78, 205, 196, 0.3)'">
                    üîÑ Analyze
                </button>
                <button onclick="exportAnalysis()" style="flex: 1; background: rgba(255, 206, 86, 0.3); color: #fff; border: 2px solid rgba(255, 206, 86, 0.5); padding: 15px; border-radius: 8px; cursor: pointer; font-weight: 700; font-size: 1.1em; transition: all 0.3s;" onmouseover="this.style.background='rgba(255, 206, 86, 0.4)'" onmouseout="this.style.background='rgba(255, 206, 86, 0.3)'">
                    üì§ Export
                </button>
            </div>
        </div>
    </div>
    
    <!-- Puzzle Creator Modal -->
    <div id="puzzle-creator-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.95); z-index: 100003; overflow-y: auto;">
        <div style="max-width: 700px; margin: 40px auto; background: linear-gradient(135deg, #e67e22 0%, #d35400 100%); border-radius: 18px; box-shadow: 0 8px 40px rgba(230, 126, 34, 0.5); padding: 40px; color: #fff; position: relative;">
            <button onclick="closePuzzleCreator()" style="position: absolute; top: 18px; right: 18px; background: #ff6b6b; color: #fff; border: none; border-radius: 8px; font-size: 1.2em; font-weight: bold; padding: 6px 16px; cursor: pointer; transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.1)'" onmouseout="this.style.transform='scale(1)'">‚úñÔ∏è</button>
            
            <div style="text-align: center; margin-bottom: 30px;">
                <div style="font-size: 3em; margin-bottom: 10px;">üß©‚ú®</div>
                <h2 style="margin: 0; font-size: 2em;">Puzzle Creator</h2>
                <p style="opacity: 0.9; margin: 10px 0 0 0;">Design custom puzzles from the current position</p>
            </div>
            
            <!-- Puzzle Settings Form -->
            <div style="background: rgba(0, 0, 0, 0.3); border-radius: 12px; padding: 25px; margin-bottom: 20px;">
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 600;">üìù Puzzle Title:</label>
                    <input type="text" id="puzzle-title" placeholder="e.g., Checkmate in 3 Moves" style="width: 100%; padding: 12px; background: rgba(255, 255, 255, 0.9); border: none; border-radius: 6px; font-size: 1em; color: #333;">
                </div>
                
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 600;">üéØ Objective:</label>
                    <select id="puzzle-objective" style="width: 100%; padding: 12px; background: rgba(255, 255, 255, 0.9); border: none; border-radius: 6px; font-size: 1em; color: #333;">
                        <option value="capture">Capture specific piece</option>
                        <option value="checkmate">Achieve checkmate/victory</option>
                        <option value="defense">Defend position</option>
                        <option value="tactical">Find tactical move</option>
                        <option value="custom">Custom objective</option>
                    </select>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 600;">‚≠ê Difficulty:</label>
                    <select id="puzzle-difficulty" style="width: 100%; padding: 12px; background: rgba(255, 255, 255, 0.9); border: none; border-radius: 6px; font-size: 1em; color: #333;">
                        <option value="beginner">üü¢ Beginner</option>
                        <option value="intermediate">üü° Intermediate</option>
                        <option value="advanced">üü† Advanced</option>
                        <option value="expert">üî¥ Expert</option>
                    </select>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 600;">üí° Hint (Optional):</label>
                    <textarea id="puzzle-hint" placeholder="e.g., Look for a forcing move..." style="width: 100%; padding: 12px; background: rgba(255, 255, 255, 0.9); border: none; border-radius: 6px; font-size: 1em; color: #333; min-height: 80px; font-family: inherit;"></textarea>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 600;">üìã Description:</label>
                    <textarea id="puzzle-description" placeholder="Describe the puzzle scenario..." style="width: 100%; padding: 12px; background: rgba(255, 255, 255, 0.9); border: none; border-radius: 6px; font-size: 1em; color: #333; min-height: 100px; font-family: inherit;"></textarea>
                </div>
            </div>
            
            <div style="display: flex; gap: 15px;">
                <button onclick="generatePuzzle()" style="flex: 1; background: rgba(78, 205, 196, 0.3); color: #fff; border: 2px solid rgba(78, 205, 196, 0.5); padding: 15px; border-radius: 8px; cursor: pointer; font-weight: 700; font-size: 1.1em; transition: all 0.3s;" onmouseover="this.style.background='rgba(78, 205, 196, 0.4)'" onmouseout="this.style.background='rgba(78, 205, 196, 0.3)'">
                    ‚ú® Generate Puzzle
                </button>
                <button onclick="exportPuzzle()" style="flex: 1; background: rgba(255, 206, 86, 0.3); color: #fff; border: 2px solid rgba(255, 206, 86, 0.5); padding: 15px; border-radius: 8px; cursor: pointer; font-weight: 700; font-size: 1.1em; transition: all 0.3s;" onmouseover="this.style.background='rgba(255, 206, 86, 0.4)'" onmouseout="this.style.background='rgba(255, 206, 86, 0.3)'">
                    üì§ Export JSON
                </button>
            </div>
            
            <!-- Puzzle Preview -->
            <div id="puzzle-preview" style="display: none; background: rgba(0, 0, 0, 0.3); border-radius: 12px; padding: 20px; margin-top: 20px;">
                <h3 style="margin: 0 0 15px 0; font-size: 1.2em;">üìã Puzzle Preview</h3>
                <pre id="puzzle-json" style="background: rgba(0, 0, 0, 0.5); padding: 15px; border-radius: 6px; overflow-x: auto; font-size: 0.9em; max-height: 300px; overflow-y: auto;"></pre>
            </div>
        </div>
    </div>
    
    <!-- ChatGPT Assistant Modal -->
    <div id="chatgpt-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.95); z-index: 100001; overflow-y: auto;">
        <div style="max-width: 900px; margin: 40px auto; background: linear-gradient(135deg, #1a1e26 0%, #23272e 100%); border-radius: 18px; box-shadow: 0 8px 40px rgba(16, 163, 127, 0.5), 0 0 0 2px rgba(16, 163, 127, 0.3); padding: 40px; color: #fff; position: relative;">
            <button onclick="hideChatGPTModal()" style="position: absolute; top: 18px; right: 18px; background: #ff6b6b; color: #fff; border: none; border-radius: 8px; font-size: 1.2em; font-weight: bold; padding: 6px 16px; cursor: pointer; transition: all 0.3s ease;" onmouseover="this.style.transform='scale(1.1)'" onmouseout="this.style.transform='scale(1)'">‚úñÔ∏è</button>
            <div style="text-align: center; margin-bottom: 30px;">
                <div style="font-size: 3em; margin-bottom: 10px;">ü§ñüí¨</div>
                <h2 style="color: #10a37f; margin: 0; font-size: 2em;">AI Assistant Mode</h2>
                <p style="color: #888; margin: 10px 0 0 0;">Get AI-powered move suggestions while you play</p>
            </div>
            <div id="chatgpt-setup" style="background: rgba(16, 163, 127, 0.1); border: 2px solid rgba(16, 163, 127, 0.3); border-radius: 12px; padding: 25px; margin-bottom: 25px;">
                <h3 style="color: #10a37f; margin: 0 0 15px 0; font-size: 1.2em;">üîë Setup</h3>
                
                <!-- AI Provider Selection -->
                <div style="margin-bottom: 20px;">
                    <label style="display: block; color: #10a37f; font-weight: bold; margin-bottom: 8px;">Choose AI Provider:</label>
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px;">
                        <button id="provider-openai" onclick="selectAIProvider('openai')" style="padding: 12px; background: linear-gradient(135deg, #10a37f 0%, #1a7f64 100%); border: 3px solid #10a37f; border-radius: 8px; color: #fff; cursor: pointer; font-weight: 700; transition: all 0.3s;">
                            <div style="font-size: 1.5em; margin-bottom: 4px;">üü¢</div>
                            OpenAI<br><span style="font-size: 0.8em; opacity: 0.9;">GPT-4o-mini</span>
                        </button>
                        <button id="provider-claude" onclick="selectAIProvider('claude')" style="padding: 12px; background: rgba(165, 94, 234, 0.2); border: 3px solid transparent; border-radius: 8px; color: #ccc; cursor: pointer; font-weight: 700; transition: all 0.3s;">
                            <div style="font-size: 1.5em; margin-bottom: 4px;">üü£</div>
                            Claude<br><span style="font-size: 0.8em; opacity: 0.9;">Haiku</span>
                        </button>
                        <button id="provider-gemini" onclick="selectAIProvider('gemini')" style="padding: 12px; background: rgba(78, 205, 196, 0.2); border: 3px solid transparent; border-radius: 8px; color: #ccc; cursor: pointer; font-weight: 700; transition: all 0.3s;">
                            <div style="font-size: 1.5em; margin-bottom: 4px;">üîµ</div>
                            Gemini<br><span style="font-size: 0.8em; opacity: 0.9;">Flash</span>
                        </button>
                    </div>
                </div>
                
                <!-- API Key Input (Dynamic) -->
                <div id="api-key-help" style="color: #ccc; margin: 0 0 15px 0; font-size: 0.95em;">
                    Get your OpenAI API key from <a href="https://platform.openai.com/api-keys" target="_blank" style="color: #10a37f;">platform.openai.com/api-keys</a>
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; color: #10a37f; font-weight: bold; margin-bottom: 8px;" id="api-key-label">OpenAI API Key:</label>
                    <input type="password" id="chatgpt-api-key" placeholder="sk-proj-..." style="width: 100%; padding: 12px; background: #23272e; border: 2px solid #10a37f; border-radius: 8px; color: #fff; font-size: 0.95em; box-sizing: border-box; font-family: 'Courier New', monospace;" />
                </div>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <label style="color: #ccc; font-size: 0.9em; cursor: pointer;"><input type="checkbox" id="chatgpt-save-key" style="margin-right: 5px;" />Save key in browser (local storage only)</label>
                </div>
                <div id="chatgpt-key-status" style="margin-top: 15px; padding: 12px; border-radius: 8px; display: none;"></div>
            </div>
            <div style="background: rgba(255, 255, 255, 0.05); border-radius: 12px; padding: 20px; margin-bottom: 25px;">
                <h3 style="color: #4ecdc4; margin: 0 0 15px 0; font-size: 1.2em;">üí° How It Works</h3>
                <ol style="color: #ccc; margin: 0; padding-left: 20px; line-height: 1.8;">
                    <li>Start a game (Practice Mode recommended)</li>
                    <li>Click <strong>ASK CHATGPT</strong> button during your turn</li>
                    <li>ChatGPT analyzes the position and suggests the best move</li>
                    <li>You can accept the suggestion or make your own move</li>
                </ol>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 25px;">
                <div style="background: rgba(16, 163, 127, 0.1); padding: 15px; border-radius: 8px;"><div style="font-size: 1.5em; margin-bottom: 8px;">üéØ</div><strong style="color: #10a37f;">Strategic Analysis</strong><p style="color: #999; margin: 8px 0 0 0; font-size: 0.9em;">Get explanations for each suggested move</p></div>
                <div style="background: rgba(78, 205, 196, 0.1); padding: 15px; border-radius: 8px;"><div style="font-size: 1.5em; margin-bottom: 8px;">üìä</div><strong style="color: #4ecdc4;">Position Evaluation</strong><p style="color: #999; margin: 8px 0 0 0; font-size: 0.9em;">Understand who's winning and why</p></div>
                <div style="background: rgba(165, 94, 234, 0.1); padding: 15px; border-radius: 8px;"><div style="font-size: 1.5em; margin-bottom: 8px;">üéì</div><strong style="color: #a55eea;">Learning Mode</strong><p style="color: #999; margin: 8px 0 0 0; font-size: 0.9em;">Improve your skills with AI guidance</p></div>
                <div style="background: rgba(255, 107, 107, 0.1); padding: 15px; border-radius: 8px;"><div style="font-size: 1.5em; margin-bottom: 8px;">‚ö°</div><strong style="color: #ff6b6b;">Fast Responses</strong><p style="color: #999; margin: 8px 0 0 0; font-size: 0.9em;">Get suggestions in 2-3 seconds</p></div>
            </div>
            <div style="background: rgba(255, 215, 0, 0.1); border: 2px solid rgba(255, 215, 0, 0.3); border-radius: 12px; padding: 15px; margin-bottom: 25px;">
                <strong style="color: #ffd700;">üí∞ Cost Comparison</strong>
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-top: 10px; color: #ccc; font-size: 0.9em;">
                    <div>üü¢ <strong>OpenAI:</strong> ~$0.001/move</div>
                    <div>üü£ <strong>Claude:</strong> ~$0.0004/move</div>
                    <div>üîµ <strong>Gemini:</strong> Free tier!</div>
                </div>
                <p style="color: #999; margin: 8px 0 0 0; font-size: 0.85em;">Full 40-move game: OpenAI $0.04, Claude $0.016, Gemini FREE (up to 1500 requests/day)</p>
            </div>
            <div style="display: flex; gap: 15px; justify-content: center;">
                <button onclick="enableChatGPTMode()" style="background: linear-gradient(135deg, #10a37f 0%, #1a7f64 100%); color: #fff; border: none; padding: 15px 40px; border-radius: 50px; cursor: pointer; font-weight: 700; font-size: 1.1em; box-shadow: 0 4px 15px rgba(16, 163, 127, 0.4); transition: all 0.3s ease;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(16, 163, 127, 0.6)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(16, 163, 127, 0.4)'">üöÄ Enable ChatGPT Mode</button>
                <button onclick="testChatGPTConnection()" style="background: rgba(78, 205, 196, 0.2); color: #4ecdc4; border: 2px solid #4ecdc4; padding: 15px 40px; border-radius: 50px; cursor: pointer; font-weight: 700; font-size: 1.1em; transition: all 0.3s ease;" onmouseover="this.style.background='rgba(78, 205, 196, 0.3)'" onmouseout="this.style.background='rgba(78, 205, 196, 0.2)'">üß™ Test Connection</button>
            </div>
        </div>
    </div>
    
    <script>
    console.log('üü¢ ROMGON SCRIPT LOADED - Version 2024-10-20-21:35:27');
    console.log('üü¢ Current URL:', window.location.href);
    console.log('üü¢ Document ready state:', document.readyState);
    
    // ============================================
    // SIGN IN MODAL FUNCTION (Moved to main script block for global access)
    // ============================================
    
    function showSignInModal() {
        try {
            console.log('üîê Opening Sign In modal...');
            
            const modal = document.getElementById('signin-modal');
            const errorDiv = document.getElementById('signin-error');
            const form = document.getElementById('signin-form');
            
            if (!modal) {
                console.error('‚ùå signin-modal element not found!');
                return;
            }
            
            console.log('‚úÖ Modal element found:', modal);
            
            // Reset form
            if (form) {
                form.reset();
                console.log('‚úÖ Form reset');
            }
            
            // Hide error message
            if (errorDiv) {
                errorDiv.style.display = 'none';
                console.log('‚úÖ Error div hidden');
            }
            
            // Show modal
            modal.style.display = 'block';
            console.log('‚úÖ Modal display set to block');
            console.log('‚úÖ Sign In modal opened successfully!');
            
        } catch (error) {
            console.error('‚ùå Error in showSignInModal:', error);
            alert('Error opening Sign In modal. Check console for details.');
        }
    }
    
    // Make it globally accessible
    window.showSignInModal = showSignInModal;
    console.log('‚úÖ window.showSignInModal assigned at startup:', typeof window.showSignInModal);
    
    // ============================================
    // SIGN UP MODAL FUNCTIONS
    // ============================================
    
    function showSignUpModal() {
        console.log('üìù Opening Sign Up modal...');
        document.getElementById('signup-modal').style.display = 'block';
        document.getElementById('signup-error').style.display = 'none';
        document.getElementById('signup-form').reset();
        
        // Enable keyboard navigation for the modal
        if (window.generalNav) {
            console.log('üéπ Enabling keyboard navigation for signup modal');
            window.generalNav.setEnabled(true);
            window.generalNav.updateNavigationElements();
        }
    }
    
    function hideSignUpModal() {
        document.getElementById('signup-modal').style.display = 'none';
        document.getElementById('signup-error').style.display = 'none';
        
        // Disable keyboard navigation when modal closes
        if (window.generalNav) {
            console.log('üéπ Disabling keyboard navigation (signup modal closed)');
            window.generalNav.setEnabled(false);
        }
    }
    
    // Make them globally accessible
    window.showSignUpModal = showSignUpModal;
    window.hideSignUpModal = hideSignUpModal;
    console.log('‚úÖ window.showSignUpModal assigned at startup:', typeof window.showSignUpModal);
    
    // ============================================
    // SIGN UP FORM HANDLER
    // ============================================
    
    async function handleSignUp(event) {
        event.preventDefault();
        
        const username = document.getElementById('signup-username').value.trim();
        const email = document.getElementById('signup-email').value.trim();
        const password = document.getElementById('signup-password').value;
        const confirmPassword = document.getElementById('signup-confirm-password').value;
        
        // Basic validation
        if (username.length < 3) {
            showSignUpError('Username must be at least 3 characters');
            return;
        }
        
        if (!/^[a-zA-Z0-9_-]+$/.test(username)) {
            showSignUpError('Username can only contain letters, numbers, underscores, and dashes');
            return;
        }
        
        if (password !== confirmPassword) {
            showSignUpError('Passwords do not match');
            return;
        }
        
        if (password.length < 6) {
            showSignUpError('Password must be at least 6 characters');
            return;
        }
        
        try {
            showLoadingIndicator('Creating your account...');
            
            // Register with backend
            const response = await romgonAPI.register(username, email, password, confirmPassword);
            
            // Save user info locally
            const user = {
                username: response.user.username,
                name: response.user.username,
                email: response.user.email,
                id: response.user.id,
                type: 'registered',
                token: response.token,
                wins: 0,
                losses: 0
            };
            
            window.currentUser = user;
            localStorage.setItem('romgon-user', JSON.stringify(user));
            
            hideLoadingIndicator();
            hideSignUpModal();
            showUserHome();
            
            console.log('‚úÖ Account created successfully:', user);
            
        } catch (error) {
            hideLoadingIndicator();
            console.error('‚ùå Registration failed:', error);
            showSignUpError(error.message || 'Registration failed. Please try again.');
        }
    }
    
    function showSignUpError(message) {
        const errorDiv = document.getElementById('signup-error');
        errorDiv.textContent = message;
        errorDiv.style.display = 'block';
    }
    
    // ============================================
    // SIGN IN FORM HANDLER
    // ============================================
    
    async function handleSignIn(event) {
        event.preventDefault();
        
        const username = document.getElementById('signin-username').value.trim();
        const password = document.getElementById('signin-password').value;
        const rememberMe = document.getElementById('remember-me').checked;
        
        if (!username || !password) {
            showSignInError('Please enter both username and password');
            return;
        }
        
        try {
            showLoadingIndicator('Signing you in...');
            
            // Login with backend
            const response = await romgonAPI.login(username, password);
            
            // Save user info locally
            const user = {
                username: response.user.username,
                name: response.user.username,
                email: response.user.email || '',
                id: response.user.id,
                type: 'registered',
                token: response.token,
                wins: response.user.wins || 0,
                losses: response.user.losses || 0,
                rating: response.user.rating || 1600
            };
            
            window.currentUser = user;
            localStorage.setItem('romgon-user', JSON.stringify(user));
            
            // Remember me functionality
            if (rememberMe) {
                localStorage.setItem('romgon-remember', 'true');
            }
            
            hideLoadingIndicator();
            hideSignInModal();
            showUserHome();
            
            console.log('‚úÖ Signed in successfully:', user);
            
        } catch (error) {
            hideLoadingIndicator();
            console.error('‚ùå Sign in failed:', error);
            showSignInError(error.message || 'Invalid username or password. Please try again.');
        }
    }
    
    function showSignInError(message) {
        const errorDiv = document.getElementById('signin-error');
        errorDiv.textContent = message;
        errorDiv.style.display = 'block';
    }
    
    function hideSignInModal() {
        document.getElementById('signin-modal').style.display = 'none';
        document.getElementById('signin-error').style.display = 'none';
        
        // Disable keyboard navigation
        if (window.generalNav) {
            window.generalNav.setEnabled(false);
        }
    }
    
    // Make them globally accessible
    window.handleSignUp = handleSignUp;
    window.handleSignIn = handleSignIn;
    window.hideSignInModal = hideSignInModal;
    console.log('‚úÖ Authentication handlers assigned at startup');
    
    // ============================================
    // USER HOME MODAL FUNCTIONS (moved from non-executing script block)
    // ============================================
    
    // OLD FUNCTION COMMENTED OUT - Using backend-integrated version at line 2424
    /*
    function showAccountModal() {
        const currentUser = JSON.parse(localStorage.getItem('romgon-user') || '{}');
        const allUsers = JSON.parse(localStorage.getItem('romgon-users') || '{}');
        
        // Check if guest user
        if (!currentUser.username || currentUser.type === 'guest') {
            // Guest user - show limited profile
            document.getElementById('account-sidebar-name').textContent = 'Guest Player';
            document.getElementById('account-sidebar-email').textContent = 'Session: ' + (currentUser.id || 'Anonymous');
            document.getElementById('account-sidebar-date').textContent = 'Not registered';
            
            // Set guest avatar to emoji
            document.getElementById('account-avatar').textContent = 'üë§';
            document.getElementById('account-avatar').style.background = 'rgba(255, 255, 255, 0.2)';
            
            // Main content
            document.getElementById('account-username').textContent = 'Guest Player';
            document.getElementById('account-email').textContent = 'Session: ' + (currentUser.id || 'Anonymous');
            
            // Show guest stats from localStorage
            const guestStats = JSON.parse(localStorage.getItem('romgon-guest-settings') || '{}');
            document.getElementById('account-wins').textContent = guestStats.gamesWon || 0;
            document.getElementById('account-losses').textContent = guestStats.gamesLost || 0;
            document.getElementById('account-games').textContent = (guestStats.gamesWon || 0) + (guestStats.gamesLost || 0);
            
            // Hide last login and saved games for guests
            const lastLoginEl = document.getElementById('account-last-login');
            const savedGamesEl = document.getElementById('account-saved-games');
            if (lastLoginEl) lastLoginEl.textContent = 'Session only';
            if (savedGamesEl) savedGamesEl.textContent = '0 (session)';
            
            // Hide delete account button for guests
            const deleteBtn = document.querySelector('button[onclick="deleteAccount()"]');
            if (deleteBtn) deleteBtn.style.display = 'none';
            
            document.getElementById('account-modal').style.display = 'block';
            return;
        }
        
        // Registered user
        if (!allUsers[currentUser.username]) {
            // User account not found
            alert('üìù Create an account to access your profile, stats, and settings!\n\nClick "Create Account" on the login screen to get started.');
            return;
        }
        
        const userAccount = allUsers[currentUser.username];
        const regDate = new Date(userAccount.registeredDate);
        
        // Update sidebar with user info
        document.getElementById('account-sidebar-name').textContent = userAccount.username;
        document.getElementById('account-sidebar-email').textContent = userAccount.email;
        document.getElementById('account-sidebar-date').textContent = regDate.toLocaleDateString();
        
        // Set avatar - use Google profile picture if available, or initials
        const avatarEl = document.getElementById('account-avatar');
        if (userAccount.picture) {
            avatarEl.innerHTML = `<img src="${userAccount.picture}" style="width: 100%; height: 100%; object-fit: cover;" />`;
        } else {
            const initials = (userAccount.username || 'U').charAt(0).toUpperCase();
            avatarEl.textContent = initials;
        }
        
        // Populate main content account info
        document.getElementById('account-username').textContent = userAccount.username;
        document.getElementById('account-email').textContent = userAccount.email;
        
        // Populate real stats from getUserStats
        const stats = getUserStats(userAccount.username);
        if (stats) {
            document.getElementById('account-wins').textContent = stats.gamesWon || 0;
            document.getElementById('account-losses').textContent = stats.gamesLost || 0;
            document.getElementById('account-games').textContent = stats.gamesPlayed || 0;
            
            // Add last login
            const lastLoginEl = document.getElementById('account-last-login');
            if (lastLoginEl && stats.lastLogin) {
                const lastLoginDate = new Date(stats.lastLogin);
                lastLoginEl.textContent = lastLoginDate.toLocaleString();
            }
            
            // Add saved games count
            const savedGamesEl = document.getElementById('account-saved-games');
            if (savedGamesEl) {
                savedGamesEl.textContent = (stats.savedGames || []).length;
            }
        } else {
            document.getElementById('account-wins').textContent = 0;
            document.getElementById('account-losses').textContent = 0;
            document.getElementById('account-games').textContent = 0;
        }
        
        // Show delete account button for registered users
        const deleteBtn = document.querySelector('button[onclick="deleteAccount()"]');
        if (deleteBtn) deleteBtn.style.display = 'block';
        
        document.getElementById('account-modal').style.display = 'block';
    }
    */
    
    function showSettingsModal() {
        const currentUser = JSON.parse(localStorage.getItem('romgon-user'));
        const allUsers = JSON.parse(localStorage.getItem('romgon-users') || '{}');
        
        // Allow both registered and guest users to access settings
        let userSettings = {};
        
        if (currentUser && currentUser.username && allUsers[currentUser.username]) {
            // Registered user - load their settings
            userSettings = allUsers[currentUser.username].settings;
        } else {
            // Guest user - use default settings
            userSettings = {
                audioEnabled: true,
                theme: 'dark',
                boardZoom: 1
            };
        }
        
        // Load current settings
        document.getElementById('settings-audio').checked = userSettings.audioEnabled !== false;
        document.getElementById('settings-theme').value = userSettings.theme || 'dark';
        document.getElementById('settings-zoom').value = userSettings.boardZoom || 1;
        updateZoomDisplay();
        
        document.getElementById('settings-modal').style.display = 'block';
    }
    
    function showOpeningBook() {
        document.getElementById('opening-book-modal').style.display = 'block';
        renderOpeningBook();
    }
    
    function hideAccountModal() {
        document.getElementById('account-modal').style.display = 'none';
    }
    
    function hideSettingsModal() {
        document.getElementById('settings-modal').style.display = 'none';
    }
    
    function hideOpeningBook() {
        document.getElementById('opening-book-modal').style.display = 'none';
    }
    
    // ============================================
    // CHATGPT ASSISTANT MODE
    // ============================================
    
    let chatGPTEnabled = false;
    let chatGPTApiKey = null;
    let aiProvider = 'openai'; // Default: openai, claude, gemini
    
    function selectAIProvider(provider) {
        console.log('üîÑ Switching AI provider to:', provider);
        aiProvider = provider;
        
        // Update button styles
        const buttons = {
            'openai': document.getElementById('provider-openai'),
            'claude': document.getElementById('provider-claude'),
            'gemini': document.getElementById('provider-gemini')
        };
        
        const colors = {
            'openai': {active: 'linear-gradient(135deg, #10a37f 0%, #1a7f64 100%)', border: '#10a37f', text: '#fff'},
            'claude': {active: 'linear-gradient(135deg, #a55eea 0%, #8b4bc4 100%)', border: '#a55eea', text: '#fff'},
            'gemini': {active: 'linear-gradient(135deg, #4ecdc4 0%, #3aaa9f 100%)', border: '#4ecdc4', text: '#fff'}
        };
        
        // Reset all buttons
        Object.keys(buttons).forEach(key => {
            const btn = buttons[key];
            if (btn) {
                if (key === provider) {
                    btn.style.background = colors[key].active;
                    btn.style.borderColor = colors[key].border;
                    btn.style.color = colors[key].text;
                } else {
                    btn.style.background = `rgba(${key === 'openai' ? '16, 163, 127' : key === 'claude' ? '165, 94, 234' : '78, 205, 196'}, 0.2)`;
                    btn.style.borderColor = 'transparent';
                    btn.style.color = '#ccc';
                }
            }
        });
        
        // Update help text and placeholder
        const helpDiv = document.getElementById('api-key-help');
        const labelDiv = document.getElementById('api-key-label');
        const inputField = document.getElementById('chatgpt-api-key');
        
        if (provider === 'openai') {
            helpDiv.innerHTML = 'Get your OpenAI API key from <a href="https://platform.openai.com/api-keys" target="_blank" style="color: #10a37f;">platform.openai.com/api-keys</a>';
            labelDiv.textContent = 'OpenAI API Key:';
            inputField.placeholder = 'sk-proj-...';
            inputField.style.borderColor = '#10a37f';
        } else if (provider === 'claude') {
            helpDiv.innerHTML = 'Get your Claude API key from <a href="https://console.anthropic.com/settings/keys" target="_blank" style="color: #a55eea;">console.anthropic.com/settings/keys</a>';
            labelDiv.textContent = 'Claude API Key:';
            inputField.placeholder = 'sk-ant-...';
            inputField.style.borderColor = '#a55eea';
        } else if (provider === 'gemini') {
            helpDiv.innerHTML = 'Get your Gemini API key from <a href="https://makersuite.google.com/app/apikey" target="_blank" style="color: #4ecdc4;">makersuite.google.com/app/apikey</a>';
            labelDiv.textContent = 'Gemini API Key:';
            inputField.placeholder = 'AIza...';
            inputField.style.borderColor = '#4ecdc4';
        }
        
        // Load saved key for this provider
        const savedKey = localStorage.getItem(`ai_api_key_${provider}`);
        if (savedKey && inputField) {
            inputField.value = savedKey;
            console.log(`‚úÖ Loaded saved ${provider} API key`);
        } else if (inputField) {
            inputField.value = '';
        }
        
        console.log(`‚úÖ AI provider switched to: ${provider}`);
    }
    
    function showChatGPTModal() {
        console.log('ü§ñ Opening ChatGPT modal...');
        const modal = document.getElementById('chatgpt-modal');
        
        if (!modal) {
            console.error('‚ùå ChatGPT modal element not found!');
            return;
        }
        
        console.log('‚úÖ Modal element found:', modal);
        
        // Check parent chain
        let parent = modal.parentElement;
        let parentChain = [];
        while (parent) {
            const computed = window.getComputedStyle(parent);
            parentChain.push({
                tag: parent.tagName,
                id: parent.id || '',
                display: computed.display,
                visibility: computed.visibility,
                opacity: computed.opacity,
                position: computed.position
            });
            parent = parent.parentElement;
        }
        console.log('üîç Parent chain:', parentChain);
        
        // NUCLEAR OPTION: Move modal to be direct child of body
        console.log('üî• Moving modal to body...');
        document.body.appendChild(modal);
        console.log('‚úÖ Modal moved to body');
        
        // Force the styles explicitly with !important via setAttribute
        modal.setAttribute('style', `
            display: block !important;
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 100001 !important;
            background: rgba(0, 0, 0, 0.95) !important;
            overflow-y: auto !important;
            visibility: visible !important;
            opacity: 1 !important;
        `);
        
        console.log('‚úÖ Modal styles set with !important');
        
        // Debug: Check computed style
        setTimeout(() => {
            const computed = window.getComputedStyle(modal);
            console.log('üîç Modal computed display:', computed.display);
            console.log('üîç Modal computed visibility:', computed.visibility);
            console.log('üîç Modal computed z-index:', computed.zIndex);
            console.log('üîç Modal computed opacity:', computed.opacity);
            console.log('üîç Modal computed width:', computed.width);
            console.log('üîç Modal computed height:', computed.height);
            console.log('üîç Modal offsetWidth:', modal.offsetWidth);
            console.log('üîç Modal offsetHeight:', modal.offsetHeight);
            console.log('üîç Modal offsetParent:', modal.offsetParent);
            console.log('üîç Modal getBoundingClientRect:', modal.getBoundingClientRect());
            
            // Check inner div
            const inner = modal.querySelector('div');
            if (inner) {
                console.log('üîç Inner div found:', inner);
                console.log('üîç Inner offsetWidth:', inner.offsetWidth);
                console.log('üîç Inner offsetHeight:', inner.offsetHeight);
                const innerComputed = window.getComputedStyle(inner);
                console.log('üîç Inner computed display:', innerComputed.display);
            } else {
                console.error('‚ùå No inner div found in modal!');
            }
        }, 100);
        
        // Load saved AI provider preference
        const savedProvider = localStorage.getItem('ai_provider') || 'openai';
        selectAIProvider(savedProvider);
        
        // Load saved API key if exists
        const savedKey = localStorage.getItem(`ai_api_key_${savedProvider}`);
        if (savedKey) {
            const keyInput = document.getElementById('chatgpt-api-key');
            const saveCheckbox = document.getElementById('chatgpt-save-key');
            if (keyInput) keyInput.value = savedKey;
            if (saveCheckbox) saveCheckbox.checked = true;
            console.log(`‚úÖ Loaded saved ${savedProvider} API key`);
        }
        
        hideUserHome();
        console.log('‚úÖ ChatGPT modal should now be visible');
    }
    
    function hideChatGPTModal() {
        console.log('ü§ñ Closing ChatGPT modal...');
        const modal = document.getElementById('chatgpt-modal');
        if (modal) {
            modal.style.display = 'none';
        }
        
        // Show user home again if we're not in a game
        console.log('üîç gameStarted:', typeof gameStarted !== 'undefined' ? gameStarted : 'undefined');
        if (typeof gameStarted === 'undefined' || !gameStarted) {
            console.log('üì± Calling showUserHome()...');
            if (typeof showUserHome === 'function') {
                showUserHome();
                console.log('‚úÖ showUserHome() called');
            } else {
                console.error('‚ùå showUserHome is not a function!');
                // Fallback: show user-home directly
                const uh = document.getElementById('user-home');
                if (uh) {
                    uh.style.display = 'flex';
                    console.log('‚úÖ Showed user-home via fallback');
                }
            }
        } else {
            console.log('‚ö†Ô∏è Game is running, not showing user home');
        }
    }
    
    async function testChatGPTConnection() {
        const apiKey = document.getElementById('chatgpt-api-key').value.trim();
        const statusDiv = document.getElementById('chatgpt-key-status');
        
        // Validate based on provider
        let validFormat = false;
        if (aiProvider === 'openai' && apiKey.startsWith('sk-')) validFormat = true;
        if (aiProvider === 'claude' && apiKey.startsWith('sk-ant-')) validFormat = true;
        if (aiProvider === 'gemini' && apiKey.startsWith('AIza')) validFormat = true;
        
        if (!validFormat) {
            const formats = {
                'openai': 'sk-proj-...',
                'claude': 'sk-ant-...',
                'gemini': 'AIza...'
            };
            statusDiv.style.display = 'block';
            statusDiv.style.background = 'rgba(255, 107, 107, 0.2)';
            statusDiv.style.border = '2px solid #ff6b6b';
            statusDiv.style.color = '#ff6b6b';
            statusDiv.innerHTML = `‚ùå Invalid ${aiProvider} API key format. Should start with "${formats[aiProvider]}"`;
            return;
        }
        
        statusDiv.style.display = 'block';
        statusDiv.style.background = 'rgba(255, 215, 0, 0.2)';
        statusDiv.style.border = '2px solid #ffd700';
        statusDiv.style.color = '#ffd700';
        statusDiv.innerHTML = '‚è≥ Testing connection...';
        
        try {
            let response;
            
            if (aiProvider === 'openai') {
                response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-mini',
                        messages: [{role: 'user', content: 'test'}],
                        max_tokens: 5
                    })
                });
            } else if (aiProvider === 'claude') {
                response = await fetch('https://api.anthropic.com/v1/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01'
                    },
                    body: JSON.stringify({
                        model: 'claude-3-haiku-20240307',
                        messages: [{role: 'user', content: 'test'}],
                        max_tokens: 10
                    })
                });
            } else if (aiProvider === 'gemini') {
                response = await fetch(`https://generativelanguage.googleapis.com/v1/models/gemini-2.0-flash-exp:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        contents: [{parts: [{text: 'test'}]}]
                    })
                });
            }
            
            if (response.ok) {
                statusDiv.style.background = 'rgba(16, 163, 127, 0.2)';
                statusDiv.style.border = '2px solid #10a37f';
                statusDiv.style.color = '#10a37f';
                statusDiv.innerHTML = `‚úÖ Connection successful! ${aiProvider.toUpperCase()} API key is valid.`;
            } else {
                const error = await response.json();
                statusDiv.style.background = 'rgba(255, 107, 107, 0.2)';
                statusDiv.style.border = '2px solid #ff6b6b';
                statusDiv.style.color = '#ff6b6b';
                statusDiv.innerHTML = `‚ùå Error: ${error.error?.message || error.error?.type || 'Invalid API key'}`;
            }
        } catch (error) {
            statusDiv.style.background = 'rgba(255, 107, 107, 0.2)';
            statusDiv.style.border = '2px solid #ff6b6b';
            statusDiv.style.color = '#ff6b6b';
            statusDiv.innerHTML = `‚ùå Connection failed: ${error.message}`;
        }
    }
    
    function enableChatGPTMode() {
        const apiKeyRaw = document.getElementById('chatgpt-api-key').value;
        const apiKey = apiKeyRaw.trim(); // Remove whitespace
        const saveKey = document.getElementById('chatgpt-save-key').checked;
        const statusDiv = document.getElementById('chatgpt-key-status');
        
        console.log(`üîë ${aiProvider.toUpperCase()} API Key length:`, apiKey.length);
        console.log('üîë API Key starts with:', apiKey.substring(0, 10));
        
        // Validate based on provider
        let validFormat = false;
        let expectedPrefix = '';
        if (aiProvider === 'openai') {
            validFormat = apiKey.startsWith('sk-');
            expectedPrefix = 'sk-';
        } else if (aiProvider === 'claude') {
            validFormat = apiKey.startsWith('sk-ant-');
            expectedPrefix = 'sk-ant-';
        } else if (aiProvider === 'gemini') {
            validFormat = apiKey.startsWith('AIza');
            expectedPrefix = 'AIza';
        }
        
        console.log('üîë Validation result:', validFormat);
        
        if (!apiKey || apiKey.length < 20) {
            statusDiv.style.display = 'block';
            statusDiv.style.background = 'rgba(255, 107, 107, 0.2)';
            statusDiv.style.border = '2px solid #ff6b6b';
            statusDiv.style.color = '#ff6b6b';
            statusDiv.innerHTML = '‚ùå Please enter a valid API key (too short)';
            return;
        }
        
        if (!validFormat) {
            statusDiv.style.display = 'block';
            statusDiv.style.background = 'rgba(255, 107, 107, 0.2)';
            statusDiv.style.border = '2px solid #ff6b6b';
            statusDiv.style.color = '#ff6b6b';
            statusDiv.innerHTML = `‚ùå API key must start with "${expectedPrefix}"`;
            return;
        }
        
        chatGPTApiKey = apiKey;
        chatGPTEnabled = true;
        
        // Save provider preference and API key
        localStorage.setItem('ai_provider', aiProvider);
        if (saveKey) {
            localStorage.setItem(`ai_api_key_${aiProvider}`, apiKey);
        } else {
            localStorage.removeItem(`ai_api_key_${aiProvider}`);
        }
        
        console.log(`‚úÖ ${aiProvider.toUpperCase()} AI mode enabled!`);
        
        statusDiv.style.display = 'block';
        statusDiv.style.background = 'rgba(16, 163, 127, 0.2)';
        statusDiv.style.border = '2px solid #10a37f';
        statusDiv.style.color = '#10a37f';
        statusDiv.innerHTML = `‚úÖ ${aiProvider.toUpperCase()} AI mode enabled! Close this modal and start a game.`;
        
        // Add ChatGPT button to game UI
        addChatGPTButton();
        
        setTimeout(() => {
            hideChatGPTModal();
        }, 2000);
    }
    
    function addChatGPTButton() {
        // Check if button already exists
        if (document.getElementById('chatgpt-ask-btn')) return;
        
        // Create button
        const btn = document.createElement('button');
        btn.id = 'chatgpt-ask-btn';
        btn.innerHTML = 'ü§ñ Ask AI';
        btn.style.cssText = `
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(135deg, #10a37f 0%, #1a7f64 100%);
            color: #fff;
            border: none;
            padding: 15px 25px;
            border-radius: 50px;
            cursor: pointer;
            font-weight: 700;
            font-size: 1em;
            box-shadow: 0 4px 15px rgba(16, 163, 127, 0.4);
            z-index: 999999;
            transition: all 0.3s ease;
            display: none;
        `;
        btn.onmouseover = () => {
            btn.style.transform = 'translateY(-2px)';
            btn.style.boxShadow = '0 6px 20px rgba(16, 163, 127, 0.6)';
        };
        btn.onmouseout = () => {
            btn.style.transform = 'translateY(0)';
            btn.style.boxShadow = '0 4px 15px rgba(16, 163, 127, 0.4)';
        };
        btn.onclick = askChatGPT;
        
        document.body.appendChild(btn);
    }
    
    async function askChatGPT() {
        if (!chatGPTEnabled || !chatGPTApiKey) {
            alert('AI mode not enabled. Click the menu and select "AI Assistant" to configure.');
            return;
        }
        
        if (gameOver) {
            alert('Game is over! Start a new game to use AI assistance.');
            return;
        }
        
        const btn = document.getElementById('chatgpt-ask-btn');
        btn.disabled = true;
        btn.innerHTML = `‚è≥ ${aiProvider === 'openai' ? 'ChatGPT' : aiProvider === 'claude' ? 'Claude' : 'Gemini'} thinking...`;
        
        try {
            // Get current game state
            const state = window.RomgonEngine.getGameState();
            const moves = window.RomgonEngine.getLegalMoves();
            const analysis = window.RomgonEngine.analyzePosition();
            
            console.log('üîç Game state:', state);
            console.log('üîç State pieces type:', typeof state.pieces, Array.isArray(state.pieces));
            
            // Format for ChatGPT
            let prompt = `I'm playing Romgon. Current position:\n\n`;
            prompt += `Turn ${state.turnNumber} - ${state.currentPlayer} to move\n\n`;
            
            // Handle pieces - check if it's an array or object
            let piecesArray = [];
            if (Array.isArray(state.pieces)) {
                piecesArray = state.pieces;
            } else if (state.pieces && typeof state.pieces === 'object') {
                // Convert object to array
                piecesArray = Object.values(state.pieces);
            } else {
                throw new Error('Unable to get pieces from game state');
            }
            
            prompt += `My pieces (${state.currentPlayer}):\n`;
            piecesArray.filter(p => p.color === state.currentPlayer).forEach(p => {
                prompt += `- ${p.type} at ${p.position}\n`;
            });
            
            prompt += `\nOpponent pieces:\n`;
            const opponent = state.currentPlayer === 'white' ? 'black' : 'white';
            piecesArray.filter(p => p.color === opponent).forEach(p => {
                prompt += `- ${p.type} at ${p.position}\n`;
            });
            
            prompt += `\nLegal moves available (${moves.length} total):\n`;
            // Show first 20 moves to avoid token limit
            moves.slice(0, 20).forEach(move => {
                prompt += `- ${move}\n`;
            });
            if (moves.length > 20) {
                prompt += `... and ${moves.length - 20} more moves\n`;
            }
            
            prompt += `\nMaterial evaluation: ${analysis.evaluation > 0 ? '+' : ''}${analysis.evaluation}\n\n`;
            prompt += `What's my best move from the legal moves above? Provide:\n1. The exact move notation from the list (format: "row-col‚Üírow-col")\n2. Why this move is strong (2-3 sentences)\n3. One alternative move to consider`;
            
            const systemPrompt = `You are an expert Romgon player. 

BOARD LAYOUT:
- Hexagonal grid with 7 rows (0-6)
- Row 0: 4 hexes (cols 2-5), Row 1: 5 hexes (1-5), Row 2: 6 hexes (1-6), Row 3: 9 hexes (0-8), Row 4: 6 hexes (1-6), Row 5: 5 hexes (2-6), Row 6: 4 hexes (3-6)
- Black goal (rhombus starting position): 3-0 (row 3, col 0) - leftmost hex in center row
- White goal (rhombus starting position): 3-8 (row 3, col 8) - rightmost hex in center row
- Dead zone (no pieces allowed): 3-3, 3-4, 3-5 (center 3 hexes of row 3)
- Position format: "row-column" (e.g., "3-6" = row 3, column 6)

PIECE VALUES:
- Square: 150 pts, Triangle: 180 pts, Hexagon: 170 pts, Circle: 160 pts
- Rhombus: Win condition (reach opponent's goal at 3-0 or 3-8)

STRATEGY PRIORITIES:
1) Captures (150-180pts) - eliminate opponent pieces
2) Threaten opponent rhombus - force defensive moves
3) Protect your rhombus - avoid exposing to capture
4) Advance rhombus safely toward opponent goal (black‚Üí8, white‚Üí0)
5) Center control - row 3 is critical battleground
6) Forward positioning - advance pieces toward opponent side

MOVE FORMAT: "fromRow-fromCol‚ÜítoRow-toCol" (e.g., "2-3‚Üí3-4")

Analyze positions and suggest the best move with clear reasoning. Be concise (2-3 sentences).`;
            
            // Call AI API based on provider
            let response, data, suggestion;
            
            if (aiProvider === 'openai') {
                response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${chatGPTApiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-mini',
                        messages: [
                            {role: 'system', content: systemPrompt},
                            {role: 'user', content: prompt}
                        ],
                        temperature: 0.7,
                        max_tokens: 300
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error?.message || response.statusText);
                }
                
                data = await response.json();
                suggestion = data.choices[0].message.content;
                
            } else if (aiProvider === 'claude') {
                response = await fetch('https://api.anthropic.com/v1/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': chatGPTApiKey,
                        'anthropic-version': '2023-06-01'
                    },
                    body: JSON.stringify({
                        model: 'claude-3-haiku-20240307',
                        system: systemPrompt,
                        messages: [
                            {role: 'user', content: prompt}
                        ],
                        max_tokens: 300,
                        temperature: 0.7
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error?.message || errorData.error?.type || response.statusText);
                }
                
                data = await response.json();
                suggestion = data.content[0].text;
                
            } else if (aiProvider === 'gemini') {
                const fullPrompt = `${systemPrompt}\n\n${prompt}`;
                response = await fetch(`https://generativelanguage.googleapis.com/v1/models/gemini-2.0-flash-exp:generateContent?key=${chatGPTApiKey}`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        contents: [{
                            parts: [{text: fullPrompt}]
                        }],
                        generationConfig: {
                            temperature: 0.7,
                            maxOutputTokens: 300
                        }
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error?.message || response.statusText);
                }
                
                data = await response.json();
                suggestion = data.candidates[0].content.parts[0].text;
            }
            
            // Show suggestion in a nice modal
            showChatGPTSuggestion(suggestion);
            
        } catch (error) {
            console.error('AI error:', error);
            alert(`‚ùå ${aiProvider.toUpperCase()} Error: ${error.message}\n\nCheck your API key and internet connection.`);
        } finally {
            btn.disabled = false;
            btn.innerHTML = 'ü§ñ Ask AI';
        }
    }
    
    function showChatGPTSuggestion(suggestion) {
        const providerInfo = {
            'openai': {emoji: 'üü¢', name: 'ChatGPT', color: '#10a37f'},
            'claude': {emoji: 'üü£', name: 'Claude', color: '#a55eea'},
            'gemini': {emoji: 'üîµ', name: 'Gemini', color: '#4ecdc4'}
        };
        const info = providerInfo[aiProvider] || providerInfo['openai'];
        
        // Create overlay
        const overlay = document.createElement('div');
        overlay.style.cssText = `
            position: fixed;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            z-index: 100002;
            display: flex;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(4px);
        `;
        
        // Create suggestion box
        const box = document.createElement('div');
        box.style.cssText = `
            background: #1a1e26;
            border-radius: 18px;
            padding: 40px;
            max-width: 600px;
            box-shadow: 0 8px 40px rgba(16, 163, 127, 0.5);
            position: relative;
            color: #fff;
        `;
        
        box.innerHTML = `
            <div style="text-align: center; margin-bottom: 20px;">
                <div style="font-size: 2.5em; margin-bottom: 10px;">${info.emoji}üí°</div>
                <h2 style="color: ${info.color}; margin: 0;">${info.name} Suggests</h2>
            </div>
            <div style="background: rgba(16, 163, 127, 0.1); border-left: 4px solid ${info.color}; padding: 20px; border-radius: 8px; margin-bottom: 20px; white-space: pre-wrap; font-family: 'Courier New', monospace; line-height: 1.6; color: #ccc;">${suggestion}</div>
            <button onclick="this.closest('div[style*=\\'position: fixed\\']').remove()" style="
                width: 100%;
                background: linear-gradient(135deg, ${info.color} 0%, ${info.color}cc 100%);
                color: #fff;
                border: none;
                padding: 15px;
                border-radius: 50px;
                cursor: pointer;
                font-weight: 700;
                font-size: 1.1em;
                box-shadow: 0 4px 15px rgba(16, 163, 127, 0.4);
                transition: all 0.3s ease;
            " onmouseover="this.style.transform='translateY(-2px)'" onmouseout="this.style.transform='translateY(0)'">
                ‚úÖ Got it!
            </button>
        `;
        
        overlay.appendChild(box);
        document.body.appendChild(overlay);
        
        // Close on overlay click
        overlay.onclick = (e) => {
            if (e.target === overlay) {
                overlay.remove();
            }
        };
    }
    
    // Show ChatGPT button when game starts
    function showChatGPTButton() {
        console.log('ü§ñ showChatGPTButton called');
        console.log('üîç chatGPTEnabled:', chatGPTEnabled);
        
        if (chatGPTEnabled) {
            const btn = document.getElementById('chatgpt-ask-btn');
            console.log('üîç Button found:', btn);
            if (btn) {
                btn.style.display = 'block';
                console.log('‚úÖ ChatGPT button is now visible');
            } else {
                console.warn('‚ö†Ô∏è ChatGPT button not found in DOM, creating it...');
                addChatGPTButton();
                // Try again after creating
                setTimeout(() => {
                    const newBtn = document.getElementById('chatgpt-ask-btn');
                    if (newBtn) {
                        newBtn.style.display = 'block';
                        console.log('‚úÖ ChatGPT button created and shown');
                    }
                }, 50);
            }
        } else {
            console.log('‚ö†Ô∏è ChatGPT not enabled, button will not show');
        }
    }
    
    // Hide ChatGPT button when game ends
    function hideChatGPTButton() {
        const btn = document.getElementById('chatgpt-ask-btn');
        if (btn) btn.style.display = 'none';
    }
    
    // Make functions globally accessible
    window.showChatGPTModal = showChatGPTModal;
    window.hideChatGPTModal = hideChatGPTModal;
    window.testChatGPTConnection = testChatGPTConnection;
    window.enableChatGPTMode = enableChatGPTMode;
    window.askChatGPT = askChatGPT;
    
    // ============================================
    // END CHATGPT ASSISTANT MODE
    // ============================================
    
    function switchAccountTab(tabName) {
        // Hide all tabs
        const tabs = document.querySelectorAll('.account-tab-content');
        tabs.forEach(tab => tab.style.display = 'none');
        
        // Show selected tab
        const selectedTab = document.getElementById('account-tab-' + tabName);
        if (selectedTab) {
            selectedTab.style.display = 'block';
            populateTabContent(tabName);
        }
        
        // Update active button
        const buttons = document.querySelectorAll('.account-tab-btn');
        buttons.forEach(btn => {
            if (btn.dataset.tab === tabName) {
                btn.classList.add('active');
                btn.style.borderBottomColor = '#667eea';
                btn.style.color = '#fff';
            } else {
                btn.classList.remove('active');
                btn.style.borderBottomColor = 'transparent';
                btn.style.color = '#999';
            }
        });
    }
    
    function populateTabContent(tabName) {
        const currentUser = JSON.parse(localStorage.getItem('romgon-user') || '{}');
        const allUsers = JSON.parse(localStorage.getItem('romgon-users') || '{}');
        
        if (tabName === 'analytics' && currentUser.username && allUsers[currentUser.username]) {
            populateAnalyticsTab(currentUser.username);
        }
    }
    
    function populateAnalyticsTab(username) {
        const stats = getUserStats(username);
        if (!stats) return;
        
        // Win rate calculation
        const winRate = stats.gamesPlayed > 0 ? Math.round((stats.gamesWon / stats.gamesPlayed) * 100) : 0;
        const avgMoves = stats.gamesPlayed > 0 ? Math.round(stats.totalMoves / stats.gamesPlayed) : 0;
        
        // Update elements
        const avgMovesEl = document.getElementById('account-avg-moves');
        const fastestWinEl = document.getElementById('account-fastest-win');
        const winStreakEl = document.getElementById('account-win-streak');
        const capturesEl = document.getElementById('account-captures');
        
        if (avgMovesEl) avgMovesEl.textContent = avgMoves;
        if (fastestWinEl) fastestWinEl.textContent = stats.fastestWin ? stats.fastestWin + ' moves' : '‚Äî';
        if (winStreakEl) winStreakEl.textContent = stats.longestWinStreak || 0;
        if (capturesEl) capturesEl.textContent = stats.totalCaptures || 0;
        
        // Piece stats (with null checks)
        const pieceSquareCaptures = document.getElementById('piece-square-captures');
        const pieceSquareSurvived = document.getElementById('piece-square-survived');
        const pieceSquareLost = document.getElementById('piece-square-lost');
        if (pieceSquareCaptures) pieceSquareCaptures.textContent = stats.pieceStats.square.captures || 0;
        if (pieceSquareSurvived) pieceSquareSurvived.textContent = stats.pieceStats.square.survived || 0;
        if (pieceSquareLost) pieceSquareLost.textContent = stats.pieceStats.square.lost || 0;
        
        const pieceTriangleCaptures = document.getElementById('piece-triangle-captures');
        const pieceTriangleSurvived = document.getElementById('piece-triangle-survived');
        const pieceTriangleLost = document.getElementById('piece-triangle-lost');
        if (pieceTriangleCaptures) pieceTriangleCaptures.textContent = stats.pieceStats.triangle.captures || 0;
        if (pieceTriangleSurvived) pieceTriangleSurvived.textContent = stats.pieceStats.triangle.survived || 0;
        if (pieceTriangleLost) pieceTriangleLost.textContent = stats.pieceStats.triangle.lost || 0;
        
        const pieceRhombusCaptures = document.getElementById('piece-rhombus-captures');
        const pieceRhombusSurvived = document.getElementById('piece-rhombus-survived');
        const pieceRhombusLost = document.getElementById('piece-rhombus-lost');
        if (pieceRhombusCaptures) pieceRhombusCaptures.textContent = stats.pieceStats.rhombus.captures || 0;
        if (pieceRhombusSurvived) pieceRhombusSurvived.textContent = stats.pieceStats.rhombus.survived || 0;
        if (pieceRhombusLost) pieceRhombusLost.textContent = stats.pieceStats.rhombus.lost || 0;
        
        const pieceCircleCaptures = document.getElementById('piece-circle-captures');
        const pieceCircleSurvived = document.getElementById('piece-circle-survived');
        const pieceCircleLost = document.getElementById('piece-circle-lost');
        if (pieceCircleCaptures) pieceCircleCaptures.textContent = stats.pieceStats.circle.captures || 0;
        if (pieceCircleSurvived) pieceCircleSurvived.textContent = stats.pieceStats.circle.survived || 0;
        if (pieceCircleLost) pieceCircleLost.textContent = stats.pieceStats.circle.lost || 0;
        
        const pieceHexagonCaptures = document.getElementById('piece-hexagon-captures');
        const pieceHexagonSurvived = document.getElementById('piece-hexagon-survived');
        const pieceHexagonLost = document.getElementById('piece-hexagon-lost');
        if (pieceHexagonCaptures) pieceHexagonCaptures.textContent = stats.pieceStats.hexagon.captures || 0;
        if (pieceHexagonSurvived) pieceHexagonSurvived.textContent = stats.pieceStats.hexagon.survived || 0;
        if (pieceHexagonLost) pieceHexagonLost.textContent = stats.pieceStats.hexagon.lost || 0;
    }
    
    function getUserStats(username) {
        const allUsers = JSON.parse(localStorage.getItem('romgon-users') || '{}');
        if (!allUsers[username]) return null;
        
        // Ensure stats object exists and has proper structure
        const user = allUsers[username];
        if (!user.stats) {
            user.stats = {
                gamesPlayed: 0,
                gamesWon: 0,
                gamesLost: 0,
                gamesDrawn: 0
            };
            // Save the updated user back to localStorage
            localStorage.setItem('romgon-users', JSON.stringify(allUsers));
        }
        
        return {
            gamesPlayed: user.stats.gamesPlayed || 0,
            gamesWon: user.stats.gamesWon || 0,
            gamesLost: user.stats.gamesLost || 0,
            gamesDrawn: user.stats.gamesDrawn || 0,
            lastLogin: user.lastLogin || null,
            savedGames: user.savedGames || [],
            pieceStats: user.pieceStats || {
                square: { captures: 0, survived: 0, lost: 0 },
                triangle: { captures: 0, survived: 0, lost: 0 },
                rhombus: { captures: 0, survived: 0, lost: 0 },
                circle: { captures: 0, survived: 0, lost: 0 },
                hexagon: { captures: 0, survived: 0, lost: 0 }
            },
            longestWinStreak: user.longestWinStreak || 0,
            fastestWin: user.fastestWin || null,
            totalCaptures: user.totalCaptures || 0,
            totalMoves: user.totalMoves || 0,
            registeredDate: user.registeredDate
        };
    }
    
    function updateZoomDisplay() {
        const zoomValue = parseFloat(document.getElementById('settings-zoom').value);
        document.getElementById('zoom-value').textContent = Math.round(zoomValue * 100) + '%';
    }
    
    // OPENING_BOOK is defined earlier in the file (line ~3087) with complete rpn data
    // This duplicate declaration has been removed
    
    function renderOpeningBook() {
        const content = document.getElementById('opening-book-content');
        if (!content) {
            console.error('Opening book content element not found');
            return;
        }
        
        // Helper: get side from name
        function getSide(name) {
            if (name.toLowerCase().includes('white')) return 'White';
            if (name.toLowerCase().includes('black')) return 'Black';
            return 'Both';
        }
        
        // Helper: piece icon
        function pieceIcon(move) {
            const p = move[0].toLowerCase();
            if (p === 's') return '‚ñ†';
            if (p === 't') return '‚ñ≤';
            if (p === 'r') return '‚óÜ';
            if (p === 'c') return '‚óè';
            if (p === 'h') return '‚¨°';
            return '';
        }
        
        // Helper: color for side
        function sideColor(side) {
            if (side === 'White') return '#4ecdc4';
            if (side === 'Black') return '#ffd700';
            return '#aaa';
        }
        
        let html = `<table style='width:100%; border-collapse:collapse; margin-top:10px;'>
            <thead>
                <tr style='background:#23272e; color:#4ecdc4;'>
                    <th style='padding:8px 4px; text-align:left;'>Opening Name</th>
                    <th style='padding:8px 4px; text-align:left;'>Side</th>
                    <th style='padding:8px 4px; text-align:left;'>Moves</th>
                    <th style='padding:8px 4px; text-align:left;'>Description</th>
                </tr>
            </thead>
            <tbody>`;
        
        for (const opening of OPENING_BOOK) {
            const side = getSide(opening.name);
            html += `<tr style='border-bottom:1px solid #333;'>
                <td style='padding:8px 4px; font-weight:bold; color:#fff;'>${opening.name.replace(/ \((White|Black)\)/,'')}</td>
                <td style='padding:8px 4px; color:${sideColor(side)}; font-weight:bold;'>${side}</td>
                <td style='padding:8px 4px; color:#fff;'>
                    ${opening.moves.map(m => `<span style='font-family:monospace; margin-right:8px;'>${pieceIcon(m)} <span style='color:#4ecdc4;'>${m}</span></span>`).join('<br>')}
                </td>
                <td style='padding:8px 4px; color:#aaa;'>${opening.description}</td>
            </tr>`;
        }
        html += '</tbody></table>';
        content.innerHTML = html;
    }
    
    // Make modal functions globally accessible
    window.showAccountModal = showAccountModal;
    window.showSettingsModal = showSettingsModal;
    window.showOpeningBook = showOpeningBook;
    window.hideAccountModal = hideAccountModal;
    window.hideSettingsModal = hideSettingsModal;
    window.hideOpeningBook = hideOpeningBook;
    window.switchAccountTab = switchAccountTab;
    window.populateTabContent = populateTabContent;
    window.populateAnalyticsTab = populateAnalyticsTab;
    window.getUserStats = getUserStats;
    window.updateZoomDisplay = updateZoomDisplay;
    window.renderOpeningBook = renderOpeningBook;
    console.log('‚úÖ User home modal functions assigned at startup');
    
    // --- Opening Recognition Logic ---
    // List of all named openings from openings.md
    const ROMGON_OPENINGS = [
        { name: 'Triangle Coop', moves: ['t5-6>5-5','t1-6>2-6'] },
        { name: 'Triangle Coop', moves: ['T1-0>1-1','T5-0>4-1'] },
        { name: 'Rhombus Straw', moves: ['r3-8>3-6','r3-6>3-4'] },
        { name: 'Rhombus Straw', moves: ['R3-0>3-2','R3-2>3-4'] },
        { name: '2 Square Advance', moves: ['s6-5>5-5','s0-5>1-5'] },
        { name: '2 Square Advance', moves: ['S0-0>1-1','S6-0>5-1'] },
        { name: 'Triangle Gateway Attack', moves: ['T2-1-3-2','s5-0-5-1'] },
        { name: 'Central Hexagon Push', moves: ['H3-2-3-3','t4-1-4-2'] },
        { name: 'Rhombus Diagonal Entry', moves: ['R3-0-2-1','s1-0-1-1'] },
        { name: 'Circle Central Jump', moves: ['C0-2-2-3','h3-2-rotR'] },
        { name: 'Square Side Push', moves: ['S1-0-2-0','t4-1-3-2'] },
        { name: 'Triangle Flank Advance', moves: ['T4-1-5-2','s1-0-1-1'] },
        { name: 'Hexagon Diagonal Move', moves: ['H3-2-2-3','c0-2-2-1'] },
        { name: 'Rhombus Central Advance', moves: ['R3-0-3-1','h3-2-3-3'] },
        { name: 'Square Central Advance', moves: ['S5-0-5-1','t2-1-2-2'] },
        { name: 'Circle Zone Jump', moves: ['C0-2-1-3','r3-0-4-1'] },
        { name: 'Hexagon Rotate Left', moves: ['H3-2-rotL','t2-1-3-2'] },
        { name: 'Triangle Central Push', moves: ['T2-1-2-2','s5-0-4-0'] },
        { name: 'Square Flank Push', moves: ['S1-0-2-0','h3-2-2-3'] },
        { name: 'Rhombus Flank Entry', moves: ['R3-0-4-1','t4-1-4-2'] },
        { name: 'Hexagon Rotate Right', moves: ['H3-2-rotR','s1-0-1-1'] },
        { name: 'Black Square Side Push', moves: ['s6-5>5-5'] },
        { name: 'Hexagon Push', moves: ['s6-5>5-5','h2-7>3-6'] },
        { name: 'Hexagon Push', moves: ['S0-0>1-1','H4-0>3-2'] },
        { name: 'Rhombus Roster', moves: ['r3-8>3-6','c4-7>4-6'] },
        { name: 'Rhombus Roster', moves: ['R3-0>3-2','C2-0>2-1'] }
    ];

    // --- Quit Game Handler (old - kept for backward compatibility) ---
    function quitGame() {
        // This function is kept for backward compatibility
        // The new function quitAndLogout() is now used instead
        quitAndLogout();
    }

    // --- Resign Game ---
    function resignGame() {
        console.log('üè≥Ô∏è Player resigned!');
        console.log('üîç Current player:', currentPlayer);
        
        // Confirm resignation
        if (!confirm('Are you sure you want to resign? This will count as a loss.')) {
            console.log('‚ùå Resignation cancelled');
            return;
        }
        
        // Determine the winner (opponent of current player)
        const winner = currentPlayer === 'white' ? 'black' : 'white';
        console.log('üèÜ Winner by resignation:', winner);
        
        // End the game with resignation reason
        showGameOver(winner, 'resignation');
    }

    // --- Quit Game And Logout ---
    function quitAndLogout() {
        // Hide board container and all its children (including buttons)
        const boardDisplayEl = document.getElementById('board-display-container');
        if (boardDisplayEl) {
            boardDisplayEl.style.display = 'none';
            // Also hide all child elements to ensure nothing shows
            const allChildren = boardDisplayEl.querySelectorAll('*');
            allChildren.forEach(child => {
                if (child.style) {
                    // Don't override if already hidden, but ensure visibility
                }
            });
        }
        
        // Hide turn indicator (the circular buttons toolbar at the top)
        const turnIndicatorEl = document.getElementById('turn-indicator');
        if (turnIndicatorEl) {
            turnIndicatorEl.style.display = 'none';
        }
        
        // Hide AI panel if present
        const aiPanelEl = document.getElementById('ai-reasoning-panel');
        if (aiPanelEl) aiPanelEl.style.display = 'none';
        
        // Hide user home 
        const userHomeEl = document.getElementById('user-home');
        if (userHomeEl) userHomeEl.style.display = 'none';
        
        // Hide start menu (important!)
        const startMenuEl = document.getElementById('start-menu');
        if (startMenuEl) startMenuEl.style.display = 'none';
        
        // Clear session and user data
        window.currentUser = null;
        try { localStorage.removeItem('romgon-user'); } catch (e) {}
        try { sessionStorage.clear(); } catch (e) {}
        
        // Note: Google One Tap auto-select disabled (now using OAuth flow)
        
        // Remove logged-in user UI
        try { removeLoggedInUserUI(); } catch (e) {}
        
        // Reset game state flags
        gameInProgress = false;
        aiEnabled = false;
        
        // Show splash page (login screen) LAST so it's on top
        const splashPage = document.getElementById('splash-page');
        if (splashPage) {
            splashPage.style.display = 'flex';
            splashPage.style.zIndex = '3000'; // Ensure it's on top
        }
    }

    // --- Quit Game To User Screen (old - kept for backward compatibility) ---
    function quitGameToUserScreen() {
        // This function is kept for backward compatibility
        // The new function quitAndLogout() is now used instead
        quitAndLogout();
    }

    function normalizeMoveNotation(move) {
        // Normalize move notation for comparison: remove spaces, unify > and -
        if (!move) return '';
        // Remove any trailing capture/rotation/special flags (x, @, d)
        const stripped = move.replace(/[x@d]+$/i, '');
        return stripped.toLowerCase().replace(/\s+/g, '').replace(/>/g, '-');
    }

    function getOpeningNameForPlayer(player) {
        // Check if rpnMoveHistory exists
        if (!window.rpnMoveHistory || !Array.isArray(window.rpnMoveHistory)) {
            return '';
        }

        // Get the first two moves played in the game (regardless of player)
        // Get first two moves by the specified player
        const playerMoves = window.rpnMoveHistory.filter(m => m.player === player).slice(0,2);
        const rawMoves = playerMoves.map(m => m.notation);
        const moves = rawMoves.map(m => normalizeMoveNotation(m));
        // Also get the first two moves in the game (for backward compatibility)
        const firstTwoMoves = window.rpnMoveHistory.slice(0,2).map(m => normalizeMoveNotation(m.notation));
        // Prefer 4-move opening only if all 4 moves match
        for (const opening of ROMGON_OPENINGS) {
            if (opening.moves.length === 4) {
                const firstFourMoves = window.rpnMoveHistory.slice(0,4).map(m => normalizeMoveNotation(m.notation));
                if (firstFourMoves.length === 4 &&
                    firstFourMoves[0] === normalizeMoveNotation(opening.moves[0]) &&
                    firstFourMoves[1] === normalizeMoveNotation(opening.moves[1]) &&
                    firstFourMoves[2] === normalizeMoveNotation(opening.moves[2]) &&
                    firstFourMoves[3] === normalizeMoveNotation(opening.moves[3])) {
                    return opening.name;
                }
            }
        }
        // Otherwise, check for 2-move openings for this player
        for (const opening of ROMGON_OPENINGS) {
            if (opening.moves.length === 2) {
                const o0 = normalizeMoveNotation(opening.moves[0]);
                const o1 = normalizeMoveNotation(opening.moves[1]);
                if (moves[0] && moves[1] && ((moves[0] === o0 && moves[1] === o1) || (moves[0] === o1 && moves[1] === o0))) {
                    return opening.name;
                }
                if (firstTwoMoves[0] && firstTwoMoves[1] && ((firstTwoMoves[0] === o0 && firstTwoMoves[1] === o1) || (firstTwoMoves[0] === o1 && firstTwoMoves[1] === o0))) {
                    return opening.name;
                }
            }
        }
        return '';
    }



    function updateOpeningDisplay() {
    // Opening detection reads from window.rpnMoveHistory (first two moves per player)
        // Show opening name for each player if their first two moves match an opening
        let whiteName = getOpeningNameForPlayer('white');
        let blackName = getOpeningNameForPlayer('black');
        if (!whiteName) whiteName = 'No opening played';
        if (!blackName) blackName = 'No opening played';
        document.getElementById('white-opening-name').textContent = whiteName;
        document.getElementById('black-opening-name').textContent = blackName;

        // ...existing code for debug panel...

        // Remove Opening Recognition debug window if present
        const debugPanel = document.getElementById('opening-debug-panel');
        if (debugPanel) debugPanel.remove();
    }



    // Call updateOpeningDisplay after each move (robust)
    function alwaysUpdateOpeningDisplay() {
        setTimeout(updateOpeningDisplay, 0);
    }
    const origRecordMoveRPN = window.recordMoveRPN;
    window.recordMoveRPN = function(...args) {
        if (origRecordMoveRPN) origRecordMoveRPN.apply(this, args);
        alwaysUpdateOpeningDisplay();
    };
    const origImportPositionRPN = window.importPositionRPN;
    window.importPositionRPN = function(...args) {
        const result = origImportPositionRPN ? origImportPositionRPN.apply(this, args) : null;
        alwaysUpdateOpeningDisplay();
        return result;
    };
    // Also update after any click on the board (in case of missed hooks)
    document.addEventListener('click', alwaysUpdateOpeningDisplay);
    // Initial call
    setTimeout(updateOpeningDisplay, 500);
    // --- Move panels spacing fix ---
    // Move the move panels slightly further down to avoid overlap
    document.addEventListener('DOMContentLoaded', function() {
        var whiteMoves = document.getElementById('white-moves');
        var blackMoves = document.getElementById('black-moves');
        if (whiteMoves) whiteMoves.parentElement.style.marginTop = '80px';
        if (blackMoves) blackMoves.parentElement.style.marginTop = '80px';
    });
    </script>
            </div>
        </div>
        
        <!-- Movement tracking display removed (moves lists are embedded into each side panel) -->
        
        <!-- Mobile Bottom Controls -->
        <div class="mobile-game-controls" style="
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.95);
            border-top: 2px solid rgba(78, 205, 196, 0.5);
            padding: 6px 4px;
            z-index: 2000;
        ">
            <!-- Main Controls -->
            <div style="display: flex; justify-content: center; align-items: center; max-width: 100%; margin: 0 auto; gap: 3px; flex-wrap: nowrap; overflow-x: auto;">
                <button onclick="undoMove()" style="
                    background: rgba(78, 205, 196, 0.2);
                    border: 2px solid #4ecdc4;
                    border-radius: 4px;
                    padding: 5px 8px;
                    color: white;
                    font-size: 0.65em;
                    font-weight: bold;
                    cursor: pointer;
                    flex: 0 0 auto;
                    white-space: nowrap;
                ">‚Ü∂ Undo</button>
                
                <button onclick="toggleMobileInfo()" style="
                    background: rgba(255, 121, 198, 0.2);
                    border: 2px solid #ff79c6;
                    border-radius: 4px;
                    padding: 5px 8px;
                    color: white;
                    font-size: 0.65em;
                    font-weight: bold;
                    cursor: pointer;
                    flex: 0 0 auto;
                    white-space: nowrap;
                ">‚ÑπÔ∏è Info</button>
                
                <button onclick="toggleBoardFlip()" style="
                    background: rgba(100, 100, 255, 0.2);
                    border: 2px solid #6464ff;
                    border-radius: 4px;
                    padding: 5px 8px;
                    color: white;
                    font-size: 0.65em;
                    font-weight: bold;
                    cursor: pointer;
                    flex: 0 0 auto;
                    white-space: nowrap;
                ">üîÑ Flip</button>
                
                <button onclick="toggleMobileDefense()" style="
                    background: rgba(255, 193, 7, 0.2);
                    border: 2px solid #ffc107;
                    border-radius: 4px;
                    padding: 5px 8px;
                    color: white;
                    font-size: 0.65em;
                    font-weight: bold;
                    cursor: pointer;
                    flex: 0 0 auto;
                    white-space: nowrap;
                ">üõ°Ô∏è Def</button>
                
                <button onclick="toggleWoodenBoard()" style="
                    background: rgba(139, 90, 43, 0.3);
                    border: 2px solid #8b5a2b;
                    border-radius: 4px;
                    padding: 5px 8px;
                    color: white;
                    font-size: 0.65em;
                    font-weight: bold;
                    cursor: pointer;
                    flex: 0 0 auto;
                    white-space: nowrap;
                ">ü™µ Wood</button>
                
                <button onclick="resignGame()" style="
                    background: rgba(231, 76, 60, 0.2);
                    border: 2px solid #e74c3c;
                    border-radius: 4px;
                    padding: 5px 8px;
                    color: white;
                    font-size: 0.65em;
                    font-weight: bold;
                    cursor: pointer;
                    flex: 0 0 auto;
                    white-space: nowrap;
                ">üè≥Ô∏è Resign</button>
                
                <!-- Rotation controls inline -->
                <div id="mobile-rotation-controls" style="display: none; flex-direction: row; gap: 3px; align-items: center;">
                    <button id="mobile-rotate-left" style="
                        background: rgba(155, 89, 182, 0.2);
                        border: 2px solid #9b59b6;
                        border-radius: 4px;
                        padding: 5px 8px;
                        color: white;
                        font-size: 0.65em;
                        font-weight: bold;
                        cursor: pointer;
                        white-space: nowrap;
                    ">‚Üª R</button>
                    
                    <button id="mobile-rotate-right" style="
                        background: rgba(155, 89, 182, 0.2);
                        border: 2px solid #9b59b6;
                        border-radius: 4px;
                        padding: 5px 8px;
                        color: white;
                        font-size: 0.65em;
                        font-weight: bold;
                        cursor: pointer;
                        white-space: nowrap;
                    ">‚Ü∫ L</button>
                    
                    <button id="mobile-keep" style="
                        background: rgba(39, 174, 96, 0.2);
                        border: 2px solid #27ae60;
                        border-radius: 4px;
                        padding: 5px 8px;
                        color: white;
                        font-size: 0.65em;
                        font-weight: bold;
                        cursor: pointer;
                        white-space: nowrap;
                    ">‚úì Keep</button>
                    
                    <button id="mobile-release" style="
                        background: rgba(231, 76, 60, 0.2);
                        border: 2px solid #e74c3c;
                        border-radius: 4px;
                        padding: 5px 8px;
                        color: white;
                        font-size: 0.65em;
                        font-weight: bold;
                        cursor: pointer;
                        white-space: nowrap;
                    ">‚úï Release</button>
                </div>
                
                <button onclick="quitAndLogout()" style="
                    background: rgba(255, 107, 107, 0.2);
                    border: 2px solid #ff6b6b;
                    border-radius: 4px;
                    padding: 5px 8px;
                    color: white;
                    font-size: 0.65em;
                    font-weight: bold;
                    cursor: pointer;
                    flex: 0 0 auto;
                    white-space: nowrap;
                ">‚úï Quit</button>
            </div>
        </div>
        
        <style>
            @media (max-width: 768px) {
                .mobile-game-controls {
                    display: block !important;
                }
                
                /* Hide desktop rotation controls on mobile */
                #rotation-controls {
                    display: none !important;
                }
            }
        </style>
        
        <script>
            // Mobile rotation button handlers
            document.addEventListener('DOMContentLoaded', function() {
                const mobileRotateLeft = document.getElementById('mobile-rotate-left');
                const mobileRotateRight = document.getElementById('mobile-rotate-right');
                const mobileKeep = document.getElementById('mobile-keep');
                const mobileRelease = document.getElementById('mobile-release');
                
                if (mobileRotateLeft) {
                    mobileRotateLeft.onclick = function() {
                        console.log('Mobile rotate left clicked');
                        if (selectedPiece) {
                            const [, row, col] = selectedPiece.id.match(/hex-(\d+)-(\d+)/);
                            const piece = selectedPiece.querySelector('.triangle-piece, .hexgon-piece');
                            if (piece && piece.classList.contains('triangle-piece')) {
                                rotateTriangleLeft(`hex-${row}-${col}`);
                            } else if (piece && piece.classList.contains('hexgon-piece')) {
                                rotateHexgonLeft(`hex-${row}-${col}`);
                            }
                        }
                    };
                }
                
                if (mobileRotateRight) {
                    mobileRotateRight.onclick = function() {
                        console.log('Mobile rotate right clicked');
                        if (selectedPiece) {
                            const [, row, col] = selectedPiece.id.match(/hex-(\d+)-(\d+)/);
                            const piece = selectedPiece.querySelector('.triangle-piece, .hexgon-piece');
                            if (piece && piece.classList.contains('triangle-piece')) {
                                rotateTriangleRight(`hex-${row}-${col}`);
                            } else if (piece && piece.classList.contains('hexgon-piece')) {
                                rotateHexgonRight(`hex-${row}-${col}`);
                            }
                        }
                    };
                }
                
                if (mobileKeep) {
                    mobileKeep.onclick = function() {
                        console.log('Mobile keep clicked');
                        if (selectedPiece) {
                            const hexId = selectedPiece.id;
                            const actions = pieceActions.get(hexId) || {moved: false, attacked: false, rotated: false};
                            const hasPerformedAction = actions.moved || actions.attacked || actions.rotated;
                            
                            if (!hasPerformedAction) {
                                const confirmed = confirm('‚ö†Ô∏è WARNING: You haven\'t made any move, rotation, or attack!\n\nAre you sure you want to end your turn without doing anything?');
                                if (!confirmed) {
                                    return;
                                }
                            }
                            
                            actions.rotated = true;
                            pieceActions.set(hexId, actions);
                            
                            if (!gameOver) {
                                switchTurn();
                                updateBaseDefenceDisplay();
                                highlightAllPiecesUnderAttack();
                            }
                        }
                    };
                }
                
                if (mobileRelease) {
                    mobileRelease.onclick = function() {
                        console.log('Mobile release clicked');
                        if (selectedPiece) {
                            clearAllHighlights();
                            const hexId = selectedPiece.id;
                            currentTurnPiece = null;
                            selectedPiece = null;
                            
                            const mobileRotationControls = document.getElementById('mobile-rotation-controls');
                            if (mobileRotationControls) {
                                mobileRotationControls.style.display = 'none';
                            }
                        }
                    };
                }
            });
            
            function toggleMobileInfo() {
                const whiteElim = document.querySelectorAll('.eliminated-section')[0];
                const blackElim = document.querySelectorAll('.eliminated-section')[1];
                
                if (whiteElim && blackElim) {
                    const isVisible = whiteElim.style.display !== 'none';
                    whiteElim.style.display = isVisible ? 'none' : 'block';
                    blackElim.style.display = isVisible ? 'none' : 'block';
                    
                    // Position panels for mobile
                    if (!isVisible) {
                        whiteElim.style.position = 'fixed';
                        whiteElim.style.left = '10px';
                        whiteElim.style.top = '80px';
                        whiteElim.style.maxHeight = '60vh';
                        whiteElim.style.overflow = 'auto';
                        whiteElim.style.zIndex = '3000';
                        
                        blackElim.style.position = 'fixed';
                        blackElim.style.right = '10px';
                        blackElim.style.top = '80px';
                        blackElim.style.maxHeight = '60vh';
                        blackElim.style.overflow = 'auto';
                        blackElim.style.zIndex = '3000';
                    }
                }
            }
            
            function toggleMobileDefense() {
                const whiteDefense = document.getElementById('white-base-defence-placeholder');
                const blackDefense = document.getElementById('black-base-defence-placeholder');
                
                if (whiteDefense && blackDefense) {
                    // Check if currently visible (not empty)
                    const isVisible = whiteDefense.innerHTML.trim() !== '' && whiteDefense.style.display !== 'none';
                    
                    if (isVisible) {
                        // Hide defense displays
                        whiteDefense.style.display = 'none';
                        blackDefense.style.display = 'none';
                    } else {
                        // Show defense displays
                        whiteDefense.style.display = 'block';
                        blackDefense.style.display = 'block';
                        // Make sure they have content
                        if (typeof updateBaseDefenceDisplay === 'function') {
                            updateBaseDefenceDisplay();
                        }
                    }
                }
            }
            
            function toggleWoodenBoard() {
                const board = document.getElementById('board-display-container');
                if (board) {
                    if (board.style.backgroundImage && board.style.backgroundImage.includes('wooden')) {
                        board.style.backgroundImage = '';
                        board.style.backgroundColor = '';
                    } else {
                        board.style.backgroundImage = "url('ASSETS/backgrounds/wooden background.png')";
                        board.style.backgroundSize = 'cover';
                        board.style.backgroundPosition = 'center';
                        board.style.backgroundRepeat = 'no-repeat';
                    }
                }
            }
        </script>
        
        <!-- 3D Camera Controls -->
        <div class="camera-controls-panel" style="
            position: fixed;
            bottom: 20px;
            right: 100px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid rgba(78, 205, 196, 0.5);
            border-radius: 15px;
            padding: 15px;
            z-index: 1000;
            display: none;
            min-width: 200px;
        " id="camera-panel">
            <!-- Header with close button -->
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <div style="color: #4ecdc4; font-weight: bold;">üé• 3D Camera</div>
                <button onclick="closeCameraPanel()" style="
                    background: rgba(255, 121, 198, 0.2);
                    border: 1px solid #ff79c6;
                    border-radius: 50%;
                    width: 24px;
                    height: 24px;
                    color: #ff79c6;
                    cursor: pointer;
                    font-size: 14px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    padding: 0;
                " title="Close panel (camera stays on)">‚úï</button>
            </div>
            <!-- Drag Area for Camera Control -->
            <div id="camera-drag-area" style="
                background: rgba(78, 205, 196, 0.1);
                border: 2px dashed rgba(78, 205, 196, 0.3);
                border-radius: 10px;
                padding: 40px 20px;
                text-align: center;
                margin-bottom: 15px;
                cursor: move;
                user-select: none;
            ">
                <div style="color: #4ecdc4; font-weight: bold; margin-bottom: 5px;">üñ±Ô∏è DRAG HERE</div>
                <div style="color: #888; font-size: 10px;">Drag ‚¨ÖÔ∏è ‚û°Ô∏è ‚¨ÜÔ∏è ‚¨áÔ∏è to pan camera view</div>
            </div>
            
            <!-- Preset Views -->
            <div style="display: flex; gap: 8px; margin-bottom: 10px; flex-wrap: wrap;">
                <button onclick="setCamera3DView('default')" style="flex: 1; min-width: 80px; padding: 8px; background: rgba(78, 205, 196, 0.2); border: 1px solid #4ecdc4; border-radius: 8px; color: white; cursor: pointer; font-size: 12px;">ü¶Ö Top</button>
                <button onclick="setCamera3DView('tilt')" style="flex: 1; min-width: 80px; padding: 8px; background: rgba(78, 205, 196, 0.2); border: 1px solid #4ecdc4; border-radius: 8px; color: white; cursor: pointer; font-size: 12px;">üìê Tilt</button>
            </div>
            
            <!-- Rotation Control -->
            <div style="margin-bottom: 10px;">
                <label style="color: #4ecdc4; font-size: 11px; display: block; margin-bottom: 5px;">Rotate: <span id="rotate-value">0</span>¬∞</label>
                <input type="range" id="rotate-slider" min="0" max="360" value="0" step="1" 
                       oninput="rotateCamera3D(this.value)" 
                       style="width: 100%; cursor: pointer;">
            </div>
            
            <!-- Tilt Control -->
            <div style="margin-bottom: 10px;">
                <label style="color: #4ecdc4; font-size: 11px; display: block; margin-bottom: 5px;">Tilt: <span id="tilt-value">0</span>¬∞</label>
                <input type="range" id="tilt-slider" min="0" max="75" value="0" step="1"
                       oninput="tiltCamera3D(this.value)"
                       style="width: 100%; cursor: pointer;">
            </div>
            
            <!-- Zoom Control -->
            <div style="margin-bottom: 10px;">
                <label style="color: #4ecdc4; font-size: 11px; display: block; margin-bottom: 5px;">Zoom: <span id="zoom-value">1.0</span>x</label>
                <input type="range" id="zoom-slider" min="0.6" max="1.5" value="1" step="0.05"
                       oninput="zoomCamera3D(this.value)"
                       style="width: 100%; cursor: pointer;">
            </div>
            
            <!-- Action Buttons -->
            <div style="display: flex; gap: 8px; margin-top: 10px;">
                <button onclick="resetCamera3D()" style="flex: 1; padding: 10px; background: rgba(255, 121, 198, 0.3); border: 1px solid #ff79c6; border-radius: 8px; color: white; cursor: pointer; font-weight: bold; font-size: 12px;">‚Üª Reset</button>
                <button onclick="disableCamera3D()" style="flex: 1; padding: 10px; background: rgba(255, 79, 79, 0.3); border: 1px solid #ff4f4f; border-radius: 8px; color: white; cursor: pointer; font-weight: bold; font-size: 12px;">‚èª OFF</button>
            </div>
        </div>
        
        <!-- 3D Camera Toggle Button -->
        <button onclick="toggleCamera3D()" id="camera-toggle-btn" style="
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            background: rgba(78, 205, 196, 0.9);
            border: 2px solid #4ecdc4;
            border-radius: 50%;
            color: white;
            font-size: 24px;
            cursor: pointer;
            z-index: 999;
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.4);
            transition: all 0.3s ease;
        " title="Toggle 3D Camera">
            üé•
        </button>
        
        <!-- 3D Camera Wrapper -->
        <div id="board-3d-container" style="
            perspective: 1200px;
            perspective-origin: center center;
            width: 100%;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            position: fixed;
            top: 0;
            left: 0;
            pointer-events: none;
        ">
            <div id="board-3d-wrapper" style="
                transform-style: preserve-3d;
                transition: transform 0.5s ease;
                transform: rotateX(0deg) rotateZ(0deg) scale(1);
                pointer-events: all;
            ">
        
        <div class="board" id="game-board">
             <!-- Board Rows 0-6 with coordinates and classes -->
             <div class="row" id="row-0">
                 <div class="hexagon shift-down color-orange-med" id="hex-0-0">
                     <span class="hex-coords">0-0</span>
                     <div class="square-piece white-piece"></div>
                 </div>
                 <div class="hexagon shift-down color-orange-med" id="hex-0-1"><span class="hex-coords">0-1</span></div>
                 <div class="hexagon shift-down color-orange-med" id="hex-0-2"><span class="hex-coords">0-2</span></div>
                 <div class="hexagon shift-down color-orange-med" id="hex-0-3"><span class="hex-coords">0-3</span></div>
                 <div class="hexagon shift-down color-orange-med" id="hex-0-4"><span class="hex-coords">0-4</span></div>
                 <div class="hexagon shift-down color-orange-med" id="hex-0-5">
                     <span class="hex-coords">0-5</span>
                     <div class="square-piece"></div>
                 </div>
             </div>
             <div class="row" id="row-1">
                 <div class="hexagon color-orange-med" id="hex-1-0">
                     <span class="hex-coords">1-0</span>
                     <div class="triangle-piece white-triangle"></div>
                 </div>
                 <div class="hexagon color-orange-light" id="hex-1-1"><span class="hex-coords">1-1</span></div>
                 <div class="hexagon color-orange-light" id="hex-1-2"><span class="hex-coords">1-2</span></div>
                 <div class="hexagon color-orange-light" id="hex-1-3"><span class="hex-coords">1-3</span></div>
                 <div class="hexagon color-orange-light" id="hex-1-4"><span class="hex-coords">1-4</span></div>
                 <div class="hexagon color-orange-light" id="hex-1-5"><span class="hex-coords">1-5</span></div>
                 <div class="hexagon color-orange-med" id="hex-1-6">
                     <span class="hex-coords">1-6</span>
                     <div class="triangle-piece"></div>
                 </div>
             </div>
             <div class="row" id="row-2">
                 <div class="hexagon shift-down color-orange-med" id="hex-2-0">
                     <span class="hex-coords">2-0</span>
                     <div class="circle-piece white-circle" draggable="true"></div>
                 </div>
                 <div class="hexagon shift-down color-orange-light" id="hex-2-1"><span class="hex-coords">2-1</span></div>
                 <div class="hexagon shift-down color-orange-med" id="hex-2-2"><span class="hex-coords">2-2</span></div>
                 <div class="hexagon shift-down color-orange-med" id="hex-2-3"><span class="hex-coords">2-3</span></div>
                 <div class="hexagon shift-down color-orange-med" id="hex-2-4"><span class="hex-coords">2-4</span></div>
                 <div class="hexagon shift-down color-orange-med" id="hex-2-5"><span class="hex-coords">2-5</span></div>
                 <div class="hexagon shift-down color-orange-light" id="hex-2-6"><span class="hex-coords">2-6</span></div>
                  <div class="hexagon shift-down color-orange-med" id="hex-2-7">
                      <span class="hex-coords">2-7</span>
                      <div class="hexgon-piece" draggable="true"></div>
                  </div>
             </div>
             <div class="row" id="row-3">
                 <div class="hexagon color-dark-brown" id="hex-3-0">
                     <span class="hex-coords">3-0</span>
                     <div class="rhombus-piece white-rhombus"></div>
                 </div>
                 <div class="hexagon color-orange-light" id="hex-3-1"><span class="hex-coords">3-1</span></div>
                 <div class="hexagon color-orange-med" id="hex-3-2"><span class="hex-coords">3-2</span></div>
                 <div class="hexagon color-dark-brown" id="hex-3-3"><span class="hex-coords">3-3</span></div>
                 <div class="hexagon color-dark-brown" id="hex-3-4">
                     <span class="hex-coords">3-4</span>
                 </div>
                 <div class="hexagon color-dark-brown" id="hex-3-5"><span class="hex-coords">3-5</span></div>
                 <div class="hexagon color-orange-med" id="hex-3-6"><span class="hex-coords">3-6</span></div>
                 <div class="hexagon color-orange-light" id="hex-3-7"><span class="hex-coords">3-7</span></div>
                 <div class="hexagon color-dark-brown" id="hex-3-8">
                     <span class="hex-coords">3-8</span>
                     <div class="rhombus-piece"></div>
                 </div>
             </div>
             <div class="row" id="row-4">
                 <div class="hexagon shift-down color-orange-med" id="hex-4-0">
                     <span class="hex-coords">4-0</span>
                     <div class="hexgon-piece white-hexgon" draggable="true"></div>
                 </div>
                 <div class="hexagon shift-down color-orange-light" id="hex-4-1"><span class="hex-coords">4-1</span></div>
                 <div class="hexagon shift-down color-orange-med" id="hex-4-2"><span class="hex-coords">4-2</span></div>
                 <div class="hexagon shift-down color-orange-med" id="hex-4-3"><span class="hex-coords">4-3</span></div>
                 <div class="hexagon shift-down color-orange-med" id="hex-4-4"><span class="hex-coords">4-4</span></div>
                 <div class="hexagon shift-down color-orange-med" id="hex-4-5"><span class="hex-coords">4-5</span></div>
                 <div class="hexagon shift-down color-orange-light" id="hex-4-6"><span class="hex-coords">4-6</span></div>
                <div class="hexagon shift-down color-orange-med" id="hex-4-7">
                    <span class="hex-coords">4-7</span>
                    <div class="circle-piece" draggable="true"></div>
                </div>
             </div>
             <div class="row" id="row-5">
                 <div class="hexagon color-orange-med" id="hex-5-0">
                     <span class="hex-coords">5-0</span>
                     <div class="triangle-piece white-triangle"></div>
                 </div>
                 <div class="hexagon color-orange-light" id="hex-5-1"><span class="hex-coords">5-1</span></div>
                 <div class="hexagon color-orange-light" id="hex-5-2"><span class="hex-coords">5-2</span></div>
                 <div class="hexagon color-orange-light" id="hex-5-3"><span class="hex-coords">5-3</span></div>
                 <div class="hexagon color-orange-light" id="hex-5-4"><span class="hex-coords">5-4</span></div>
                 <div class="hexagon color-orange-light" id="hex-5-5"><span class="hex-coords">5-5</span></div>
                 <div class="hexagon color-orange-med" id="hex-5-6">
                     <span class="hex-coords">5-6</span>
                     <div class="triangle-piece"></div>
                 </div>
             </div>
             <div class="row" id="row-6">
                 <div class="hexagon shift-down color-orange-med" id="hex-6-0">
                     <span class="hex-coords">6-0</span>
                     <div class="square-piece white-piece"></div>
                 </div>
                 <div class="hexagon shift-down color-orange-med" id="hex-6-1"><span class="hex-coords">6-1</span></div>
                 <div class="hexagon shift-down color-orange-med" id="hex-6-2"><span class="hex-coords">6-2</span></div>
                 <div class="hexagon shift-down color-orange-med" id="hex-6-3"><span class="hex-coords">6-3</span></div>
                 <div class="hexagon shift-down color-orange-med" id="hex-6-4"><span class="hex-coords">6-4</span></div>
                 <div class="hexagon shift-down color-orange-med" id="hex-6-5">
                     <span class="hex-coords">6-5</span>
                     <div class="square-piece"></div>
                 </div>
            </div>
        </div>
        
            </div> <!-- Close board-3d-wrapper -->
        </div> <!-- Close board-3d-container -->
    </div>

    <script>
        // ============================================
        // 3D CAMERA SYSTEM
        // ============================================
        
        let camera3DEnabled = false;
        let cameraPanelVisible = false;
        let currentRotation = 0;
        let currentTilt = 0;
        let currentZoom = 1;
        let currentPanX = 0; // Camera horizontal position
        let currentPanY = 0; // Camera vertical position
        
        function toggleCamera3D() {
            const panel = document.getElementById('camera-panel');
            const toggleBtn = document.getElementById('camera-toggle-btn');
            const container = document.getElementById('board-3d-container');
            
            if (camera3DEnabled) {
                // Camera is ON, clicking button toggles panel visibility
                cameraPanelVisible = !cameraPanelVisible;
                panel.style.display = cameraPanelVisible ? 'block' : 'none';
            } else {
                // Camera is OFF, turn it ON and show panel
                camera3DEnabled = true;
                cameraPanelVisible = true;
                panel.style.display = 'block';
                toggleBtn.style.background = 'rgba(255, 121, 198, 0.9)';
                toggleBtn.style.borderColor = '#ff79c6';
                toggleBtn.title = 'Camera ON - Click to toggle panel';
                container.style.pointerEvents = 'all';
            }
        }
        
        function closeCameraPanel() {
            // Close panel but keep camera active
            const panel = document.getElementById('camera-panel');
            cameraPanelVisible = false;
            panel.style.display = 'none';
            // Camera stays enabled, view persists
        }
        
        function disableCamera3D() {
            // Completely turn off camera (resets to 2D)
            camera3DEnabled = false;
            cameraPanelVisible = false;
            const panel = document.getElementById('camera-panel');
            const toggleBtn = document.getElementById('camera-toggle-btn');
            const container = document.getElementById('board-3d-container');
            
            panel.style.display = 'none';
            toggleBtn.style.background = 'rgba(78, 205, 196, 0.9)';
            toggleBtn.style.borderColor = '#4ecdc4';
            toggleBtn.title = 'Toggle 3D Camera';
            resetCamera3D();
            container.style.pointerEvents = 'none';
        }
        
        function rotateCamera3D(angle) {
            currentRotation = angle;
            document.getElementById('rotate-value').textContent = angle;
            updateCamera3DTransform();
        }
        
        function tiltCamera3D(angle) {
            currentTilt = angle;
            document.getElementById('tilt-value').textContent = angle;
            updateCamera3DTransform();
        }
        
        function zoomCamera3D(scale) {
            currentZoom = scale;
            document.getElementById('zoom-value').textContent = parseFloat(scale).toFixed(2);
            updateCamera3DTransform();
        }
        
        function updateCamera3DTransform() {
            const wrapper = document.getElementById('board-3d-wrapper');
            if (wrapper && camera3DEnabled) {
                wrapper.style.transform = `translate(${currentPanX}px, ${currentPanY}px) rotateX(${currentTilt}deg) rotateZ(${currentRotation}deg) scale(${currentZoom})`;
                wrapper.style.transformStyle = 'preserve-3d';
                wrapper.style.transition = 'transform 0.5s ease';
            }
        }
        
        // Ensure camera persists through DOM changes
        setInterval(() => {
            if (camera3DEnabled) {
                updateCamera3DTransform();
            }
        }, 100);
        
        function setCamera3DView(viewType) {
            switch(viewType) {
                case 'default':
                    currentRotation = 0;
                    currentTilt = 0;
                    currentZoom = 1;
                    currentPanX = 0;
                    currentPanY = 0;
                    break;
                case 'tilt':
                    currentRotation = 0;
                    currentTilt = 45;
                    currentZoom = 0.9;
                    currentPanX = 0;
                    currentPanY = 0;
                    break;
            }
            
            // Update sliders
            document.getElementById('rotate-slider').value = currentRotation;
            document.getElementById('tilt-slider').value = currentTilt;
            document.getElementById('zoom-slider').value = currentZoom;
            document.getElementById('rotate-value').textContent = currentRotation;
            document.getElementById('tilt-value').textContent = currentTilt;
            document.getElementById('zoom-value').textContent = currentZoom.toFixed(2);
            
            updateCamera3DTransform();
        }
        
        function resetCamera3D() {
            setCamera3DView('default');
        }
        
        // Keyboard shortcuts for camera
        document.addEventListener('keydown', (e) => {
            if (!camera3DEnabled) return;
            
            switch(e.key) {
                case 'ArrowLeft':
                    e.preventDefault();
                    currentRotation = Math.max(0, currentRotation - 5);
                    document.getElementById('rotate-slider').value = currentRotation;
                    rotateCamera3D(currentRotation);
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    currentRotation = Math.min(360, parseInt(currentRotation) + 5);
                    document.getElementById('rotate-slider').value = currentRotation;
                    rotateCamera3D(currentRotation);
                    break;
                case 'ArrowUp':
                    e.preventDefault();
                    currentTilt = Math.max(0, currentTilt - 5);
                    document.getElementById('tilt-slider').value = currentTilt;
                    tiltCamera3D(currentTilt);
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    currentTilt = Math.min(75, parseInt(currentTilt) + 5);
                    document.getElementById('tilt-slider').value = currentTilt;
                    tiltCamera3D(currentTilt);
                    break;
                case '=':
                case '+':
                    e.preventDefault();
                    currentZoom = Math.min(1.5, currentZoom + 0.05);
                    document.getElementById('zoom-slider').value = currentZoom;
                    zoomCamera3D(currentZoom);
                    break;
                case '-':
                    e.preventDefault();
                    currentZoom = Math.max(0.6, currentZoom - 0.05);
                    document.getElementById('zoom-slider').value = currentZoom;
                    zoomCamera3D(currentZoom);
                    break;
                case ' ':
                    e.preventDefault();
                    resetCamera3D();
                    break;
            }
        });
        
        // ============================================
        // LEFT-CLICK DRAG CONTROLS ON CAMERA PANEL DRAG AREA
        // ============================================
        
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let dragStartPanX = 0;
        let dragStartPanY = 0;
        
        // Get drag area element (wait for DOM to load)
        window.addEventListener('DOMContentLoaded', () => {
            const dragArea = document.getElementById('camera-drag-area');
            
            if (!dragArea) return;
            
            // Mouse down (left-click on drag area)
            dragArea.addEventListener('mousedown', (e) => {
                if (e.button === 0 && camera3DEnabled) { // Left click (button 0)
                    e.preventDefault();
                    isDragging = true;
                    dragStartX = e.clientX;
                    dragStartY = e.clientY;
                    dragStartPanX = currentPanX;
                    dragStartPanY = currentPanY;
                    dragArea.style.cursor = 'grabbing';
                    dragArea.style.background = 'rgba(78, 205, 196, 0.2)';
                }
            });
            
            // Mouse move (drag) - global to allow dragging outside area
            document.addEventListener('mousemove', (e) => {
                if (!isDragging || !camera3DEnabled) return;
                
                e.preventDefault();
                
                // Calculate drag distance
                const deltaX = e.clientX - dragStartX;
                const deltaY = e.clientY - dragStartY;
                
                // Pan camera view (move what the player sees)
                // Left/Right drag = move camera horizontally
                // Up/Down drag = move camera vertically
                currentPanX = dragStartPanX + deltaX;
                currentPanY = dragStartPanY + deltaY;
                
                updateCamera3DTransform();
            });
            
            // Mouse up (release) - global
            document.addEventListener('mouseup', (e) => {
                if (isDragging) {
                    isDragging = false;
                    dragArea.style.cursor = 'move';
                    dragArea.style.background = 'rgba(78, 205, 196, 0.1)';
                }
            });
            
            // Mouse leave window (cancel drag)
            document.addEventListener('mouseleave', () => {
                if (isDragging) {
                    isDragging = false;
                    dragArea.style.cursor = 'move';
                    dragArea.style.background = 'rgba(78, 205, 196, 0.1)';
                }
            });
        });
        
        // Mouse wheel zoom (only when camera active)
        document.addEventListener('wheel', (e) => {
            if (!camera3DEnabled) return;
            
            e.preventDefault();
            
            // Zoom in/out based on wheel direction
            const delta = e.deltaY > 0 ? -0.05 : 0.05;
            currentZoom = Math.max(0.6, Math.min(1.5, currentZoom + delta));
            
            document.getElementById('zoom-slider').value = currentZoom;
            zoomCamera3D(currentZoom);
        }, { passive: false });
        
        // ============================================
        // END LEFT-CLICK DRAG CONTROLS
        // ============================================
        
        // ============================================
        // END 3D CAMERA SYSTEM
        // ============================================
    
    </script>

    <script>
        // Audio setup
        let clickSound = null;
        let capturedSound = null;
        let winSound = null;
        let lockRhombusSound = null;
        let flipboardSound = null;
        
        // Background music
        let backgroundMusic1 = null;
        let backgroundMusic2 = null;
        let backgroundMusic3 = null;
        let currentMusicTrack = 0; // 0 = none, 1 = track1, 2 = track2, 3 = track3
        let backgroundMusicTracks = [];
        
        // Track move history for RPN game export (separate from undo moveHistory)
        window.rpnMoveHistory = [];
        
        // Initialize audio when page loads
        function initAudio() {
            try {
                clickSound = new Audio('ASSETS/click.mp3');
                clickSound.volume = 0.3; // Set volume to 30%
                clickSound.preload = 'auto';
                
                capturedSound = new Audio('ASSETS/captured.mp3');
                capturedSound.volume = 0.4; // Set volume to 40% for capture sound
                capturedSound.preload = 'auto';
                
                winSound = new Audio('ASSETS/win.mp3');
                winSound.volume = 0.5; // Set volume to 50% for win sound
                winSound.preload = 'auto';
                
                lockRhombusSound = new Audio('ASSETS/lock rhombus.mp3');
                lockRhombusSound.volume = 0.5; // Set volume to 50% for check/lock sound
                lockRhombusSound.preload = 'auto';
                
                flipboardSound = new Audio('ASSETS/flipboard.mp3');
                flipboardSound.volume = 0.4; // Set volume to 40% for board flip sound
                flipboardSound.preload = 'auto';
                
                // Background music tracks
                backgroundMusic1 = new Audio('ASSETS/background1.mp3');
                backgroundMusic1.volume = 0.2; // Set volume to 20%
                backgroundMusic1.preload = 'auto';
                backgroundMusic1.loop = true; // Loop the music
                
                backgroundMusic2 = new Audio('ASSETS/background2.mp3');
                backgroundMusic2.volume = 0.2;
                backgroundMusic2.preload = 'auto';
                backgroundMusic2.loop = true;
                
                backgroundMusic3 = new Audio('ASSETS/background3.mp3');
                backgroundMusic3.volume = 0.2;
                backgroundMusic3.preload = 'auto';
                backgroundMusic3.loop = true;
                
                backgroundMusicTracks = [backgroundMusic1, backgroundMusic2, backgroundMusic3];
            } catch (error) {
                console.log('Audio not available:', error);
            }
        }
        
        // Play click sound
        function playClickSound() {
            if (clickSound) {
                try {
                    clickSound.currentTime = 0; // Reset to beginning
                    clickSound.play().catch(error => {
                        console.log('Could not play click sound:', error);
                    });
                } catch (error) {
                    console.log('Click audio play error:', error);
                }
            }
        }
        
        // Play captured sound
        function playCapturedSound() {
            if (capturedSound) {
                try {
                    capturedSound.currentTime = 0; // Reset to beginning
                    capturedSound.play().catch(error => {
                        console.log('Could not play captured sound:', error);
                    });
                } catch (error) {
                    console.log('Captured audio play error:', error);
                }
            }
        }
        
        // Play win sound
        function playWinSound() {
            if (winSound) {
                try {
                    winSound.currentTime = 0; // Reset to beginning
                    winSound.play().catch(error => {
                        console.log('Win audio play error:', error);
                    });
                } catch (error) {
                    console.log('Win audio play error:', error);
                }
            }
        }
        
        // Play lock rhombus sound (when rhombus is under attack/check)
        function playLockRhombusSound() {
            if (lockRhombusSound) {
                try {
                    lockRhombusSound.currentTime = 0; // Reset to beginning
                    lockRhombusSound.play().catch(error => {
                        console.log('Lock rhombus audio play error:', error);
                    });
                } catch (error) {
                    console.log('Lock rhombus audio play error:', error);
                }
            }
        }
        
        // Play flipboard sound (when board flips)
        function playFlipboardSound() {
            if (flipboardSound) {
                try {
                    flipboardSound.currentTime = 0; // Reset to beginning
                    flipboardSound.play().catch(error => {
                        console.log('Flipboard audio play error:', error);
                    });
                } catch (error) {
                    console.log('Flipboard audio play error:', error);
                }
            }
        }
        
        // Background music functions
        function playBackgroundMusic(trackNumber) {
            if (!backgroundMusicTracks[trackNumber - 1]) return;
            
            // Stop current music
            stopBackgroundMusic();
            
            // Play new track
            const track = backgroundMusicTracks[trackNumber - 1];
            track.play().catch(error => {
                console.log('Background music play error:', error);
            });
            currentMusicTrack = trackNumber;
            window.gameSettings.currentMusicTrack = trackNumber;
            updateMusicButtonDisplay();
        }
        
        function stopBackgroundMusic() {
            backgroundMusicTracks.forEach(track => {
                if (track) {
                    track.pause();
                    track.currentTime = 0;
                }
            });
            currentMusicTrack = 0;
            window.gameSettings.currentMusicTrack = 0;
            updateMusicButtonDisplay();
        }
        
        function toggleBackgroundMusic() {
            if (currentMusicTrack === 0) {
                // Start with track 1
                playBackgroundMusic(1);
            } else {
                stopBackgroundMusic();
            }
        }
        
        function nextBackgroundTrack() {
            if (currentMusicTrack === 0) {
                playBackgroundMusic(1);
            } else {
                const nextTrack = (currentMusicTrack % 3) + 1;
                playBackgroundMusic(nextTrack);
            }
        }
        
        // Function to update music button display
        function updateMusicButtonDisplay() {
            const turnIndicator = document.getElementById('turn-indicator');
            if (!turnIndicator) return;
            
            const buttons = turnIndicator.querySelectorAll('button');
            for (const button of buttons) {
                if (button.innerHTML.includes('MUSIC')) {
                    const isMusicOn = window.gameSettings.music && currentMusicTrack > 0;
                    button.innerHTML = isMusicOn ? 'üîä MUSIC' : 'üîá MUSIC';
                    button.style.backgroundColor = isMusicOn ? '#8B4513' : '#654321';
                    button.style.boxShadow = isMusicOn ? '0 2px 8px rgba(139, 69, 19, 0.4)' : '0 2px 8px rgba(101, 67, 33, 0.3)';
                    break;
                }
            }
        }
        
        // Track movement history
        let moveCount = 0;
        
        // Track move repetitions for three-fold repetition loss rule
        // Structure: { "pieceId-fromPos-toPos": count }
        // Example: { "hex-3-4-to-3-5": 2 } means this move happened 2 times consecutively
        const moveRepetitions = new Map();
        
        // Track position repetitions for threefold repetition rule
        // Structure: { "positionHash": count }
        const positionHistory = new Map();
        
        // Track last move for each player to detect when pattern breaks
        let lastWhiteMove = null;
        let lastBlackMove = null;
        
        function recordMove(fromRow, fromCol, toRow, toCol, pieceType, isWhite, isCapture = false, repetitionCount = 0) {
            moveCount++;
            const moveList = isWhite ? document.getElementById('white-moves') : document.getElementById('black-moves');
            const moveItem = document.createElement('li');
            moveItem.className = `movement-item ${isWhite ? 'white-move' : 'black-move'}`;
            
            const pieceSymbol = pieceType === 'square' ? '‚ñ†' : 
                               pieceType === 'triangle' ? '‚ñ≤' : 
                               pieceType === 'rhombus' ? '‚óÜ' : 
                               pieceType === 'circle' ? '‚óè' : '‚¨°';
            const captureSymbol = isCapture ? ' (capture)' : '';
            
            // Color-code based on repetition count (shuttle limit: 5)
            let repetitionDisplay = '';
            let backgroundColor = '';
            let textColor = 'white';
            
            if (repetitionCount === 3) {
                repetitionDisplay = ' ‚ö†Ô∏è (3/5 Warning)';
                backgroundColor = '#f39c12'; // Orange warning
                textColor = 'black';
            } else if (repetitionCount === 4) {
                repetitionDisplay = ' üî• (4/5 DANGER!)';
                backgroundColor = '#e67e22'; // Dark orange danger
                textColor = 'white';
            } else if (repetitionCount >= 5) {
                repetitionDisplay = ' üíÄ (5/5 LOSS!)';
                backgroundColor = '#e74c3c'; // Red loss
                textColor = 'white';
            }
            
            moveItem.textContent = `${moveCount}. ${pieceSymbol} ${fromRow}-${fromCol} ‚Üí ${toRow}-${toCol}${captureSymbol}${repetitionDisplay}`;
            
            if (backgroundColor) {
                moveItem.style.backgroundColor = backgroundColor;
                moveItem.style.color = textColor;
                moveItem.style.fontWeight = 'bold';
                moveItem.style.padding = '5px';
                moveItem.style.borderRadius = '3px';
                moveItem.style.marginTop = '3px';
            }
            
            moveList.appendChild(moveItem);
            
            // Auto-scroll to bottom of movement list
            moveList.scrollTop = moveList.scrollHeight;
            
            // Return the repetition count so caller can use it
            return repetitionCount;
        }
        
        // Function to check and track repetition (called BEFORE recordMove)
        function checkRepetition(fromRow, fromCol, toRow, toCol, pieceType, isWhite, isCapture) {
            // Don't track captures
            if (isCapture) return 0;
            
            const playerPrefix = isWhite ? 'white' : 'black';
            
            // Create shuttle key - treats A‚ÜíB and B‚ÜíA as the same pattern
            const fromPos = `${fromRow}${fromCol}`;
            const toPos = `${toRow}${toCol}`;
            const sortedPositions = [fromPos, toPos].sort();
            const shuttleKey = `${playerPrefix}-${pieceType}-shuttle-${sortedPositions[0]}-${sortedPositions[1]}`;
            
            console.log(`Repetition Check: ${playerPrefix} ${pieceType} shuttle ${fromPos}‚Üî${toPos}`);
            
            // Count how many times THIS SHUTTLE PATTERN has been made (never resets!)
            const currentCount = moveRepetitions.get(shuttleKey) || 0;
            const repetitionCount = currentCount + 1;
            moveRepetitions.set(shuttleKey, repetitionCount);
            
            console.log(`Total shuttles for ${shuttleKey}: ${repetitionCount}/5`);
            
            // Check for five-fold repetition
            if (repetitionCount >= 5) {
                // Fifth shuttle - player loses!
                const losingPlayer = isWhite ? 'White' : 'Black';
                const winningPlayer = isWhite ? 'Black' : 'White';
                console.log(`FIVE-FOLD SHUTTLE REPETITION! ${losingPlayer} loses!`);
                // Delay game over slightly so move appears in list first
                setTimeout(() => {
                    showGameOver(winningPlayer, `${losingPlayer} lost by shuttling 5 times between ${sortedPositions[0]} and ${sortedPositions[1]}!`);
                }, 100);
            }
            
            // Update last move for this player (for tracking)
            const moveKey = `${playerPrefix}-${pieceType}-${fromPos}-${toPos}`;
            if (isWhite) {
                lastWhiteMove = moveKey;
            } else {
                lastBlackMove = moveKey;
            }
            
            console.log(`Updated last${playerPrefix === 'white' ? 'White' : 'Black'}Move to: ${moveKey}`);
            
            return repetitionCount;
        }
        
        // Function to generate a hash of the current board position
        function generatePositionHash() {
            const pieces = [];
            
            // Collect all pieces on the board with their positions and orientations
            document.querySelectorAll('.hexagon').forEach(hex => {
                const piece = hex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                if (piece) {
                    const hexId = hex.id; // e.g., "hex-3-4"
                    const [, row, col] = hexId.match(/hex-(\d+)-(\d+)/);
                    
                    // Determine piece type and color
                    let pieceType = '';
                    let pieceColor = '';
                    
                    if (piece.classList.contains('square-piece')) {
                        pieceType = 'square';
                        pieceColor = piece.classList.contains('white-piece') ? 'W' : 'B';
                    } else if (piece.classList.contains('triangle-piece')) {
                        pieceType = 'triangle';
                        pieceColor = piece.classList.contains('white-triangle') ? 'W' : 'B';
                    } else if (piece.classList.contains('rhombus-piece')) {
                        pieceType = 'rhombus';
                        pieceColor = piece.classList.contains('white-rhombus') ? 'W' : 'B';
                    } else if (piece.classList.contains('circle-piece')) {
                        pieceType = 'circle';
                        pieceColor = piece.classList.contains('white-circle') ? 'W' : 'B';
                    } else if (piece.classList.contains('hexgon-piece')) {
                        pieceType = 'hexagon';
                        pieceColor = piece.classList.contains('white-hexgon') ? 'W' : 'B';
                    }
                    
                    // Get orientation for pieces that have it
                    let orientation = 0;
                    if (pieceType === 'triangle' || pieceType === 'hexagon') {
                        const orientAttr = piece.getAttribute('data-orientation');
                        orientation = orientAttr ? parseInt(orientAttr) : 0;
                    }
                    
                    // Format: "row-col-type-color-orientation"
                    pieces.push(`${row}-${col}-${pieceType}-${pieceColor}-${orientation}`);
                }
            });
            
            // Sort to ensure consistent hash regardless of DOM order
            pieces.sort();
            
            // Join into a single string hash
            return pieces.join('|');
        }
        
        // Function to check and track position repetition (for threefold repetition rule)
        function checkPositionRepetition(isWhite) {
            const positionHash = generatePositionHash();
            const currentCount = positionHistory.get(positionHash) || 0;
            const newCount = currentCount + 1;
            positionHistory.set(positionHash, newCount);
            
            console.log(`Position repetition check: Count = ${newCount}/3`);
            
            // Check for threefold repetition
            if (newCount >= 3) {
                const losingPlayer = isWhite ? 'White' : 'Black';
                const winningPlayer = isWhite ? 'Black' : 'White';
                console.log(`THREEFOLD REPETITION! ${losingPlayer} loses by repeating position!`);
                
                // Delay game over slightly so move appears first
                setTimeout(() => {
                    showGameOver(winningPlayer, `${losingPlayer} lost by threefold repetition (same position occurred 3 times)!`);
                }, 100);
            }
            
            return newCount;
        }
        
        // Function to clear move repetition tracking (for new games)
        function clearMoveRepetitions() {
            moveRepetitions.clear();
            positionHistory.clear();
            lastWhiteMove = null;
            lastBlackMove = null;
            // Also remove any existing warning panels
            const existingWarning = document.getElementById('repetition-warning-panel');
            if (existingWarning) {
                existingWarning.remove();
            }
        }
        
        // Function to show repetition warning panel
        function showRepetitionWarning(isWhite, pieceType, fromRow, fromCol, toRow, toCol) {
            // Remove any existing warning first
            const existingWarning = document.getElementById('repetition-warning-panel');
            if (existingWarning) {
                existingWarning.remove();
            }
            
            const playerColor = isWhite ? 'WHITE' : 'BLACK';
            const playerColorHex = isWhite ? '#fff' : '#333';
            const pieceSymbol = pieceType === 'square' ? '‚ñ†' : 
                               pieceType === 'triangle' ? '‚ñ≤' : 
                               pieceType === 'rhombus' ? '‚óÜ' : 
                               pieceType === 'circle' ? '‚óè' : '‚¨°';
            
            // Create warning panel
            const warningPanel = document.createElement('div');
            warningPanel.id = 'repetition-warning-panel';
            warningPanel.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: linear-gradient(135deg, #e74c3c, #c0392b);
                color: white;
                padding: 20px 40px;
                border-radius: 15px;
                border: 3px solid #fff;
                box-shadow: 0 8px 30px rgba(231, 76, 60, 0.6);
                z-index: 1500;
                text-align: center;
                font-family: Arial, sans-serif;
                animation: warningPulse 1s ease-in-out infinite;
                min-width: 300px;
            `;
            
            warningPanel.innerHTML = `
                <div style="display: flex; align-items: center; gap: 15px;">
                    <div style="font-size: 3em;">‚ö†Ô∏è</div>
                    <div style="text-align: left;">
                        <div style="font-size: 1.4em; font-weight: bold; margin-bottom: 5px;">
                            REPETITION WARNING!
                        </div>
                        <div style="font-size: 1em; opacity: 0.95;">
                            <strong style="color: ${playerColorHex}; text-shadow: 1px 1px 2px rgba(0,0,0,0.5);">${playerColor}</strong> repeated:<br>
                            <strong>${pieceSymbol} ${fromRow}-${fromCol} ‚Üí ${toRow}-${toCol}</strong><br>
                            <span style="font-size: 1.2em; font-weight: bold;">ONE MORE TIME = LOSS!</span>
                        </div>
                    </div>
                    <div style="font-size: 3em;">‚ö†Ô∏è</div>
                </div>
            `;
            
            // Add pulsing animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes warningPulse {
                    0%, 100% { 
                        box-shadow: 0 8px 30px rgba(231, 76, 60, 0.6);
                        transform: translateX(-50%) scale(1);
                    }
                    50% { 
                        box-shadow: 0 8px 40px rgba(231, 76, 60, 0.9);
                        transform: translateX(-50%) scale(1.02);
                    }
                }
            `;
            document.head.appendChild(style);
            
            document.body.appendChild(warningPanel);
            
            // Auto-remove after 5 seconds with fade out
            setTimeout(() => {
                warningPanel.style.transition = 'opacity 1s, transform 1s';
                warningPanel.style.opacity = '0';
                warningPanel.style.transform = 'translateX(-50%) translateY(-20px)';
                setTimeout(() => {
                    if (warningPanel.parentElement) {
                        warningPanel.remove();
                    }
                }, 1000);
            }, 5000);
        }
        
        function clearMovementHistory() {
            moveCount = 0;
            document.getElementById('white-moves').innerHTML = '';
            document.getElementById('black-moves').innerHTML = '';
        }
        
        function clearCoordinateLabels() {
            // Hide the existing hex-coords spans without modifying their styling
            const existingCoords = document.querySelectorAll('.hex-coords');
            existingCoords.forEach(coord => {
                coord.style.display = 'none';
            });
            
            // Also remove any dynamically created coordinate labels
            const allCoordLabels = document.querySelectorAll('.coordinate-label');
            allCoordLabels.forEach(label => label.remove());
            
            coordinatesVisible = false;
        }
        
        // Coordinate visibility toggle
        let coordinatesVisible = false;
        
        function toggleCoordinates() {
            coordinatesVisible = !coordinatesVisible;
            
            // Toggle the existing hex-coords spans - show/hide without modifying their styling
            const existingCoords = document.querySelectorAll('.hex-coords');
            
            existingCoords.forEach(coord => {
                if (coordinatesVisible) {
                    coord.style.display = 'block';
                } else {
                    coord.style.display = 'none';
                }
            });
        }
        
        // Check and highlight pieces under threat
        function highlightThreatenedPieces() {
            // DISABLED - We only want to show attack highlights based on actual piece movement patterns
            // when dragging pieces, not a separate threat detection system
            return;
            
            /* ORIGINAL CODE COMMENTED OUT
            // Clear existing threat highlights
            document.querySelectorAll('.hexagon').forEach(hex => {
                hex.classList.remove('highlight-threat');
            });
            
            // Get all pieces on the board (including circles and hexgons)
            const allPieces = document.querySelectorAll('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
            
            allPieces.forEach(piece => {
                const pieceHex = piece.closest('.hexagon');
                if (!pieceHex) return;
                
                const pieceId = pieceHex.id;
                const [, pieceRow, pieceCol] = pieceId.match(/hex-(\d+)-(\d+)/);
                const isWhite = piece.classList.contains('white-piece') || 
                               piece.classList.contains('white-triangle') || 
                               piece.classList.contains('white-rhombus') ||
                               piece.classList.contains('white-circle') ||
                               piece.classList.contains('white-hexgon');
                
                // Check if this piece is under threat
                if (isPieceUnderThreat(parseInt(pieceRow), parseInt(pieceCol), isWhite)) {
                    // Only apply threat highlighting if the piece is not in a valid attack position
                    // (i.e., not already highlighted as red for attack)
                    if (!pieceHex.classList.contains('highlight-red')) {
                        pieceHex.classList.add('highlight-threat');
                    }
                }
            });
            */
        }
        
        // NEW: Highlight ALL pieces that are under attack on the board
        function highlightAllPiecesUnderAttack() {
            // Track which rhombuses were under attack before
            const previousRhombusesUnderAttack = new Set();
            document.querySelectorAll('.hexagon.highlight-rhombus-check').forEach(hex => {
                previousRhombusesUnderAttack.add(hex.id);
            });
            
            // Clear any previous "under attack" highlights (both regular and rhombus-check)
            document.querySelectorAll('.hexagon').forEach(hex => {
                hex.classList.remove('highlight-under-attack', 'highlight-rhombus-check');
            });
            
            // Track if any NEW rhombus comes under attack this turn
            let newRhombusUnderAttack = false;
            
            // Get all pieces on the board
            const allPieces = document.querySelectorAll('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
            
            allPieces.forEach(piece => {
                const pieceHex = piece.closest('.hexagon');
                if (!pieceHex) return;
                
                const pieceId = pieceHex.id;
                const [, row, col] = pieceId.match(/hex-(\d+)-(\d+)/);
                const isWhite = piece.classList.contains('white-piece') || 
                               piece.classList.contains('white-triangle') || 
                               piece.classList.contains('white-rhombus') ||
                               piece.classList.contains('white-circle') ||
                               piece.classList.contains('white-hexgon');
                
                // Check if this piece is under threat
                const underThreat = isPieceUnderThreat(parseInt(row), parseInt(col), isWhite);
                if (underThreat) {
                    // Special yellow highlight for RHOMBUS under attack (CHECK/DEADLOCK warning)
                    if (piece.classList.contains('rhombus-piece')) {
                        pieceHex.classList.add('highlight-rhombus-check');
                        // Check if this is a NEW rhombus under attack (wasn't before)
                        if (!previousRhombusesUnderAttack.has(pieceId)) {
                            newRhombusUnderAttack = true;
                        }
                    } else {
                        // Regular red highlight for other pieces
                        pieceHex.classList.add('highlight-under-attack');
                    }
                }
            });
            
            // Play lock sound if a rhombus just came under attack
            if (newRhombusUnderAttack) {
                playLockRhombusSound();
            }
        }
        
        // Clear previous last move highlights
        function clearLastMoveHighlight() {
            document.querySelectorAll('.hexagon').forEach(hex => {
                hex.classList.remove('highlight-last-move-from', 'highlight-last-move-to');
                // Note: We do NOT clear under-attack highlights here anymore
                // They persist across turns until pieces move or are captured
            });
        }
        
        // Highlight the last move (from and to hexagons)
        function highlightLastMove(fromHexId, toHexId) {
            // Clear any previous last move highlights
            clearLastMoveHighlight();
            
            // Only apply highlights if setting is enabled
            if (!window.gameSettings.showLastMove) {
                lastMoveFrom = fromHexId;
                lastMoveTo = toHexId;
                return;
            }
            
            // Apply new highlights
            const fromHex = document.getElementById(fromHexId);
            const toHex = document.getElementById(toHexId);
            
            if (fromHex) {
                fromHex.classList.add('highlight-last-move-from');
            }
            
            if (toHex) {
                toHex.classList.add('highlight-last-move-to');
            }
            
            // Store the last move for reference
            lastMoveFrom = fromHexId;
            lastMoveTo = toHexId;
        }
        
        // Check if a specific piece is under threat
        function isPieceUnderThreat(pieceRow, pieceCol, isWhite) {
            const targetId = `hex-${pieceRow}-${pieceCol}`;
            console.log(`üîç Checking if ${isWhite ? 'WHITE' : 'BLACK'} piece at ${targetId} is under threat...`);
            
            // Get all opponent pieces (including circles and hexgons)
            const opponentPieceTypes = isWhite ? 
                ['.square-piece:not(.white-piece)', '.triangle-piece:not(.white-triangle)', '.rhombus-piece:not(.white-rhombus)', '.circle-piece:not(.white-circle)', '.hexgon-piece:not(.white-hexgon)'] :
                ['.square-piece.white-piece', '.triangle-piece.white-triangle', '.rhombus-piece.white-rhombus', '.circle-piece.white-circle', '.hexgon-piece.white-hexgon'];
            
            // Check each opponent piece to see if it can attack this position
            for (let pieceType of opponentPieceTypes) {
                const opponentPieces = document.querySelectorAll(pieceType);
                for (let piece of opponentPieces) {
                    // Skip hidden pieces (used during simulation) and temp simulation pieces
                    if (piece.style.display === 'none' || piece.hasAttribute('data-temp-simulation')) {
                        continue;
                    }
                    
                    const pieceHex = piece.closest('.hexagon');
                    if (!pieceHex) continue;
                    
                    const pieceId = pieceHex.id;
                    const [, oppRow, oppCol] = pieceId.match(/hex-(\d+)-(\d+)/);
                    
                    // Use the actual movement pattern functions to check if this piece can attack
                    if (canPieceActuallyAttack(parseInt(oppRow), parseInt(oppCol), pieceRow, pieceCol, piece)) {
                        console.log(`‚ö†Ô∏è THREAT FOUND! Piece at ${targetId} IS under threat`);
                        return true;
                    }
                }
            }
            console.log(`‚úì No threat found for piece at ${targetId}`);
            return false;
        }
        
        // Check if a piece can actually attack using the real movement patterns
        function canPieceActuallyAttack(pieceRow, pieceCol, targetRow, targetCol, piece) {
            // Get the piece type and determine which movement function to use
            if (piece.classList.contains('square-piece')) {
                const canAttack = canSquareAttack(pieceRow, pieceCol, targetRow, targetCol);
                if (canAttack) {
                    console.log(`‚úÖ SQUARE at ${pieceRow}-${pieceCol} CAN attack ${targetRow}-${targetCol}`);
                }
                return canAttack;
            } else if (piece.classList.contains('triangle-piece')) {
                let canAttack;
                if (piece.classList.contains('white-triangle')) {
                    canAttack = canWhiteTriangleAttack(pieceRow, pieceCol, targetRow, targetCol, piece);
                } else {
                    canAttack = canBlackTriangleAttack(pieceRow, pieceCol, targetRow, targetCol, piece);
                }
                if (canAttack) {
                    const color = piece.classList.contains('white-triangle') ? 'WHITE' : 'BLACK';
                    console.log(`‚úÖ ${color} TRIANGLE at ${pieceRow}-${pieceCol} CAN attack ${targetRow}-${targetCol}`);
                }
                return canAttack;
            } else if (piece.classList.contains('rhombus-piece')) {
                const canAttack = canRhombusAttack(pieceRow, pieceCol, targetRow, targetCol);
                if (canAttack) {
                    console.log(`‚úÖ RHOMBUS at ${pieceRow}-${pieceCol} CAN attack ${targetRow}-${targetCol}`);
                }
                return canAttack;
            } else if (piece.classList.contains('circle-piece')) {
                const canAttack = canCircleAttack(pieceRow, pieceCol, targetRow, targetCol, piece);
                if (canAttack) {
                    console.log(`‚úÖ CIRCLE at ${pieceRow}-${pieceCol} CAN attack ${targetRow}-${targetCol}`);
                }
                return canAttack;
            } else if (piece.classList.contains('hexgon-piece')) {
                const canAttack = canHexgonAttack(pieceRow, pieceCol, targetRow, targetCol, piece);
                if (canAttack) {
                    const color = piece.classList.contains('white-hexgon') ? 'WHITE' : 'BLACK';
                    console.log(`‚úÖ ${color} HEXAGON at ${pieceRow}-${pieceCol} CAN attack ${targetRow}-${targetCol}`);
                }
                return canAttack;
            }
            return false;
        }
        
        // Check if a square can attack a position
        function canSquareAttack(pieceRow, pieceCol, targetRow, targetCol) {
            let offsets = [];
            
            if (pieceRow === 0) {
                // Row 0 (even, shift-down): down-left, down-right, up-right, up-left
                offsets = [[1, 0], [1, 1], [-1, 1], [-1, 0]];
            } else if (pieceRow === 1) {
                // Row 1 (odd, no shift): down-left, down-right, up-left, up-right
                offsets = [[1, 0], [1, 1], [-1, -1], [-1, 0]];
            } else if (pieceRow === 2) {
                // Row 2 (even, shift-down): down-left, down-right, up-left, up-right
                offsets = [[1, 0], [1, 1], [-1, -1], [-1, 0]];
            } else if (pieceRow === 3) {
                // Row 3 (odd, no shift): down-left, down-right, up-right, up-left
                offsets = [[1, -1], [1, 0], [-1, 0], [-1, -1]];
            } else if (pieceRow === 4) {
                // Row 4 (even, shift-down): up-left, up-right, down-left, down-right
                offsets = [[-1, 0], [-1, 1], [1, -1], [1, 0]];
            } else if (pieceRow === 5) {
                // Row 5 (odd, no shift): down-left, down-right, up-left, up-right
                offsets = [[1, 0], [1, 1], [-1, -1], [-1, 0]];
            } else if (pieceRow === 6) {
                // Row 6 (even, shift-down): down-left, down-right, up-right, up-left
                offsets = [[1, 0], [1, 1], [-1, 1], [-1, 0]];
            }
            
            for (let [rowOffset, colOffset] of offsets) {
                if (pieceRow + rowOffset === targetRow && pieceCol + colOffset === targetCol) {
                    return true;
                }
            }
            return false;
        }
        
        // Check if a white triangle can attack a position (accounts for rotation)
        function canWhiteTriangleAttack(pieceRow, pieceCol, targetRow, targetCol, piece) {
            // Get the triangle's current orientation from triangleOrientations
            const triangleHex = piece ? piece.closest('.hexagon') : document.getElementById(`hex-${pieceRow}-${pieceCol}`);
            const hexId = triangleHex ? triangleHex.id : `hex-${pieceRow}-${pieceCol}`;
            const orientation = triangleOrientations.get(hexId) || 0;
            
            // Use the rotation-aware function to get attack OFFSETS (relative coordinates)
            const offsets = getRotatedTriangleTargets(pieceRow, pieceCol, orientation, true);
            
            // Check if target position is in the attack pattern (convert offsets to absolute coordinates)
            for (let [dr, dc] of offsets) {
                if (pieceRow + dr === targetRow && pieceCol + dc === targetCol) {
                    return true;
                }
            }
            return false;
        }
        
        // Check if a black triangle can attack a position (accounts for rotation)
        // Check if a black triangle can attack a position (accounts for rotation)
        function canBlackTriangleAttack(pieceRow, pieceCol, targetRow, targetCol, piece) {
            // Get the triangle's current orientation from triangleOrientations
            const triangleHex = piece ? piece.closest('.hexagon') : document.getElementById(`hex-${pieceRow}-${pieceCol}`);
            const hexId = triangleHex ? triangleHex.id : `hex-${pieceRow}-${pieceCol}`;
            const orientation = triangleOrientations.get(hexId) || 0;
            
            // Use the rotation-aware function to get attack OFFSETS (relative coordinates)
            const offsets = getRotatedTriangleTargets(pieceRow, pieceCol, orientation, false);
            
            // Check if target position is in the attack pattern (convert offsets to absolute coordinates)
            for (let [dr, dc] of offsets) {
                if (pieceRow + dr === targetRow && pieceCol + dc === targetCol) {
                    return true;
                }
            }
            return false;
        }
        
        // Helper function to rotate offsets by angle (in degrees, 60-degree increments for hex grid)
        function rotateOffsets(offsets, angleDegrees) {
            // For now, return original offsets (triangle rotation is visual only for threat detection)
            // This is a simplified version - full hex rotation logic would be complex
            return offsets;
        }
        
        // Check if a circle can attack a position (zone-based perimetric attack)
        function canCircleAttack(pieceRow, pieceCol, targetRow, targetCol, piece) {
            // Circles attack ANY opponent on their perimeter ring (not just adjacent hexes)
            const coord = `${pieceRow}-${pieceCol}`;
            const targetCoord = `${targetRow}-${targetCol}`;
            
            // Check if circle is in dead zone - cannot attack from dead zone
            if (circleDeadZone.has(coord)) {
                return false;
            }
            
            // Determine which zone the circle is in
            let zoneSet = null;
            let zoneOrder = null;
            
            if (circleInnerZone.has(coord)) {
                zoneSet = circleInnerZone;
                zoneOrder = circleInnerOrder;
            } else if (circleMiddleZone.has(coord)) {
                zoneSet = circleMiddleZone;
                zoneOrder = circleMiddleOrder;
            } else if (circleOuterZone.has(coord)) {
                zoneSet = circleOuterZone;
                zoneOrder = circleOuterOrder;
            } else {
                return false; // Not in any valid zone
            }
            
            // Check if target is in the same zone (perimeter ring)
            if (!zoneSet.has(targetCoord)) {
                return false; // Target not on same perimeter ring
            }
            
            // Circle can attack ANY position on its perimeter ring
            // Need to check if there's a clear path (no pieces blocking between circle and target)
            const startIdx = zoneOrder.indexOf(coord);
            const targetIdx = zoneOrder.indexOf(targetCoord);
            
            if (startIdx === -1 || targetIdx === -1) {
                return false;
            }
            
            const len = zoneOrder.length;
            // circle attack tracing removed
            
            // Check clockwise direction
            let clockwiseBlocked = false;
            let clockwiseSteps = (targetIdx - startIdx + len) % len;
            const clockwiseBlockedHexes = [];
            for (let step = 1; step < clockwiseSteps; step++) {
                const idx = (startIdx + step) % len;
                const [r, c] = zoneOrder[idx].split('-');
                const hex = document.getElementById(`hex-${r}-${c}`);
                if (hex && hex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece')) {
                    clockwiseBlocked = true;
                    clockwiseBlockedHexes.push(`${r}-${c}`);
                    break;
                }
            }
            // circle attack tracing removed
            
            // Check counter-clockwise direction
            let counterClockwiseBlocked = false;
            let counterClockwiseSteps = (startIdx - targetIdx + len) % len;
            const counterBlockedHexes = [];
            for (let step = 1; step < counterClockwiseSteps; step++) {
                const idx = (startIdx - step + len) % len;
                const [r, c] = zoneOrder[idx].split('-');
                const hex = document.getElementById(`hex-${r}-${c}`);
                if (hex && hex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece')) {
                    counterClockwiseBlocked = true;
                    counterBlockedHexes.push(`${r}-${c}`);
                    break;
                }
            }
            // circle attack tracing removed
            
            // Can attack if at least one direction is clear
            return !clockwiseBlocked || !counterClockwiseBlocked;
        }
        
        // Check if a hexgon can attack a position (accounts for rotation)
        function canHexgonAttack(pieceRow, pieceCol, targetRow, targetCol, piece) {
            // Get the hexgon's current orientation from hexgonOrientations
            const hexgonHex = piece ? piece.closest('.hexagon') : document.getElementById(`hex-${pieceRow}-${pieceCol}`);
            const hexId = hexgonHex ? hexgonHex.id : `hex-${pieceRow}-${pieceCol}`;
            const orientation = hexgonOrientations.get(hexId) || 0;
            
            // Determine if white or black (needed for getRotatedHexgonTargets)
            const isWhite = piece ? 
                (piece.classList.contains('white-hexgon')) : 
                (hexgonHex && hexgonHex.querySelector('.white-hexgon') !== null);
            
            // Use the rotation-aware function to get attack targets
            const targets = getRotatedHexgonTargets(pieceRow, pieceCol, orientation, isWhite);
            
            // Check if target is in the attack list
            for (const [moveRow, moveCol] of targets) {
                if (moveRow === targetRow && moveCol === targetCol) {
                    console.log(`‚úÖ HEXAGON at ${pieceRow}-${pieceCol} CAN attack ${targetRow}-${targetCol} (orientation ${orientation})`);
                    return true;
                }
            }
            return false;
        }
        
        // Check if a rhombus can attack a position (uses hardcoded patterns)
        function canRhombusAttack(pieceRow, pieceCol, targetRow, targetCol) {
            // RULE: Rhombuses cannot attack other rhombuses (cannot check/lock each other)
            const targetHex = document.getElementById(`hex-${targetRow}-${targetCol}`);
            if (targetHex) {
                const targetPiece = targetHex.querySelector('.rhombus-piece');
                if (targetPiece) {
                    // Target is a rhombus - cannot attack
                    return false;
                }
            }
            
            // Use the actual hardcoded rhombus movement patterns
            const moves = getRhombusMoves(pieceRow, pieceCol);
            
            // Define zones for diagonal ability detection
            const deadZone = new Set(["3-3", "3-4", "3-5"]);
            const innerPerimeter = new Set(["4-2", "4-3", "4-4", "4-5", "2-2", "2-3", "2-4", "2-5"]);
            const currentPos = `${pieceRow}-${pieceCol}`;
            const targetPos = `${targetRow}-${targetCol}`;
            
            // Check if target is in the move list
            for (const [moveRow, moveCol] of moves) {
                if (moveRow === targetRow && moveCol === targetCol) {
                    // RULE: Diagonal moves can only be used for MOVEMENT, not ATTACK
                    const isDiagonalMove = (deadZone.has(currentPos) && innerPerimeter.has(targetPos)) || 
                                          (innerPerimeter.has(currentPos) && deadZone.has(targetPos));
                    
                    // If it's a diagonal move, it cannot be used for attack
                    if (isDiagonalMove) {
                        return false;
                    }
                    
                    return true;
                }
            }
            return false;
        }

        // Helper function to check if a position is vulnerable to attack
        function isPositionVulnerable(row, col, isWhite, movingPieceType = null) {
            // Get all opponent pieces (INCLUDING CIRCLES AND HEXAGONS!)
            const opponentPieceTypes = isWhite ? 
                ['.square-piece:not(.white-piece)', '.triangle-piece:not(.white-triangle)', '.rhombus-piece:not(.white-rhombus)', '.circle-piece:not(.white-circle)', '.hexgon-piece:not(.white-hexgon)'] :
                ['.square-piece.white-piece', '.triangle-piece.white-triangle', '.rhombus-piece.white-rhombus', '.circle-piece.white-circle', '.hexgon-piece.white-hexgon'];
            
            // Check each opponent piece to see if it can attack this position
            for (let pieceType of opponentPieceTypes) {
                const opponentPieces = document.querySelectorAll(pieceType);
                for (let piece of opponentPieces) {
                    // SPECIAL CASE: If we're checking for a rhombus moving to this position,
                    // and the opponent piece is also a rhombus, skip it (rhombuses can't attack each other)
                    if (movingPieceType === 'rhombus' && piece.classList.contains('rhombus-piece')) {
                        continue; // Skip rhombus-on-rhombus check
                    }
                    
                    const pieceHex = piece.closest('.hexagon');
                    if (!pieceHex) continue;
                    
                    const pieceId = pieceHex.id;
                    const [, pieceRow, pieceCol] = pieceId.match(/hex-(\d+)-(\d+)/);
                    
                    // Check if this opponent piece can attack the target position
                    if (canPieceActuallyAttack(parseInt(pieceRow), parseInt(pieceCol), row, col, piece)) {
                        return true;
                    }
                }
            }
            return false;
        }
        

        // Helper function to highlight movement patterns
        function highlightMovement(targetHex, isWhite) {
            if (!targetHex) return;
            
            // Check if target hex has a friendly piece
            const friendlyPieceTypes = isWhite 
                ? ['.square-piece.white-piece', '.triangle-piece.white-triangle', '.rhombus-piece.white-rhombus', '.circle-piece.white-circle', '.hexgon-piece.white-hexgon'] 
                : ['.square-piece:not(.white-piece)', '.triangle-piece:not(.white-triangle)', '.rhombus-piece:not(.white-rhombus)', '.circle-piece:not(.white-circle)', '.hexgon-piece:not(.white-hexgon)'];
            let hasFriendlyPiece = false;
            friendlyPieceTypes.forEach(selector => {
                if (targetHex.querySelector(selector)) {
                    hasFriendlyPiece = true;
                }
            });
            
            // Check if target hex has an opponent piece
            const opponentPieceTypes = isWhite 
                ? ['.square-piece:not(.white-piece)', '.triangle-piece:not(.white-triangle)', '.rhombus-piece:not(.white-rhombus)', '.circle-piece:not(.white-circle)', '.hexgon-piece:not(.white-hexgon)'] 
                : ['.square-piece.white-piece', '.triangle-piece.white-triangle', '.rhombus-piece.white-rhombus', '.circle-piece.white-circle', '.hexgon-piece.white-hexgon'];
            let hasOpponentPiece = false;
            opponentPieceTypes.forEach(selector => {
                if (targetHex.querySelector(selector)) {
                    hasOpponentPiece = true;
                }
            });
            
            // Highlight in red if opponent piece, green if empty
            if (hasOpponentPiece) {
                targetHex.classList.add('highlight-red');
            } else if (!hasFriendlyPiece) {
                targetHex.classList.add('highlight-green');
            }
        }

        // Function to show movement pattern for white triangles (opposite of black triangles)
        function showWhiteTriangleMovementPattern(centerRow, centerCol) {
            // Clear any existing highlights (but keep threat highlights)
            document.querySelectorAll('.hexagon').forEach(hex => {
                hex.classList.remove('highlight-green', 'highlight-red', 'highlight-danger', 'highlight-diagonal', 'highlight-gray');
            });

            // White triangle movement pattern - opposite diagonal from black triangles
            let offsets;
            
            if (centerRow === 0) {
                // Row 0 - white triangle movement pattern
                offsets = [
                    [1, 1],  // down-right
                    [-1, 1], // up-right (off-board)
                    [0, 1]   // right
                ];
            } else if (centerRow === 1) {
                // Row 1 - white triangle movement pattern
                offsets = [
                    [1, 1],  // down-right
                    [-1, 0], // up-right
                    [0, 1]   // right
                ];
            } else if (centerRow === 2) {
                // Row 2 - white triangle movement pattern
                offsets = [
                    [1, 1],  // down-right
                    [-1, 0], // up-right
                    [0, 1]   // right
                ];
            } else if (centerRow === 3) {
                // Row 3 - white triangle movement pattern
                offsets = [
                    [1, 0],  // down: 3-2 + [1,0] = 4-2
                    [0, 1],  // right: 3-2 + [0,1] = 3-3
                    [-1, 0]  // up-left: 3-2 + [-1,0] = 2-2
                ];
            } else if (centerRow === 4) {
                // Row 4 - white triangle movement pattern
                offsets = [
                    [1, 0],  // down-right
                    [0, 1],  // right
                    [-1, 1]  // up-right
                ];
            } else if (centerRow === 5) {
                // Row 5 - white triangle movement pattern
                // For 5-0 ‚Üí 6-0, 5-1, 4-1
                offsets = [
                    [1, 0],  // down-right: 5-0 + [1,0] = 6-0
                    [0, 1],  // right: 5-0 + [0,1] = 5-1
                    [-1, 1]  // up-right: 5-0 + [-1,1] = 4-1
                ];
            } else if (centerRow === 6) {
                // Row 6 - white triangle movement pattern
                offsets = [
                    [1, 1],  // down-right (off-board)
                    [0, 1],  // right
                    [-1, 1]  // up-right
                ];
            }

            // Highlight the hexes in the white triangle pattern
            offsets.forEach(([rowOffset, colOffset]) => {
                const targetRow = centerRow + rowOffset;
                const targetCol = centerCol + colOffset;
                const targetHex = document.getElementById(`hex-${targetRow}-${targetCol}`);
                
                // Skip if target hex doesn't exist (off the board)
                if (!targetHex) return;
                
                    // Check if target hex has a friendly piece
                const friendlyPieceTypes = ['.square-piece.white-piece', '.triangle-piece.white-triangle', '.rhombus-piece.white-rhombus', '.circle-piece.white-circle', '.hexgon-piece.white-hexgon'];
                    let hasFriendlyPiece = false;
                    friendlyPieceTypes.forEach(selector => {
                        if (targetHex.querySelector(selector)) {
                            hasFriendlyPiece = true;
                        }
                    });
                    
                // Check if target hex has an opponent piece
                const opponentPieceTypes = ['.square-piece:not(.white-piece)', '.triangle-piece:not(.white-triangle)', '.rhombus-piece:not(.white-rhombus)', '.circle-piece:not(.white-circle)', '.hexgon-piece:not(.white-hexgon)'];
                let hasOpponentPiece = false;
                opponentPieceTypes.forEach(selector => {
                    if (targetHex.querySelector(selector)) {
                        hasOpponentPiece = true;
                    }
                });
                
                // Highlight in red if opponent piece, green if empty, danger if vulnerable
                if (hasOpponentPiece) {
                        targetHex.classList.add('highlight-red');
                } else if (!hasFriendlyPiece) {
                    // Check if this position would be vulnerable to attack
                    if (isPositionVulnerable(targetRow, targetCol, true)) {
                        targetHex.classList.add('highlight-danger');
                    } else {
                        targetHex.classList.add('highlight-green');
                    }
                }
            });
        }
        function showTriangleMovementPattern(centerRow, centerCol) {
            console.log(`üéØ showTriangleMovementPattern called: centerRow=${centerRow}, centerCol=${centerCol}`);
            
            // Clear any existing highlights (but keep threat highlights)
            document.querySelectorAll('.hexagon').forEach(hex => {
                hex.classList.remove('highlight-green', 'highlight-red', 'highlight-danger', 'highlight-diagonal', 'highlight-gray');
            });

            // Get triangle orientation for rotation-aware movement
            const hexId = `hex-${centerRow}-${centerCol}`;
            
            // DEFENSIVE CHECK: Ensure this is actually a triangle
            const triangle = document.querySelector(`#${hexId} .triangle-piece`);
            if (!triangle) {
                console.error(`‚ùå showTriangleMovementPattern called but no triangle found at ${hexId}!`);
                return;
            }
            
            const orientation = getTriangleOrientation(hexId);
            console.log(`üéØ Triangle orientation: ${orientation}`);
            
            // Determine if it's white or black triangle
            const isWhite = triangle && (triangle.classList.contains('white-triangle') || triangle.classList.contains('white-piece'));
            console.log(`üéØ Triangle isWhite: ${isWhite}`);
            
            // Get rotation-aware movement pattern
            const offsets = getRotatedTriangleTargets(centerRow, centerCol, orientation, isWhite);
            console.log(`üéØ Rotated offsets:`, offsets);

            // Get friendly piece types based on triangle color
            let friendlyPieceTypes;
            const centerHex = document.getElementById(`hex-${centerRow}-${centerCol}`);
            const centerPiece = centerHex.querySelector('.triangle-piece');
            
            if (centerPiece && centerPiece.classList.contains('white-triangle')) {
                // White triangle - friendly with white squares and other white triangles
                friendlyPieceTypes = ['.square-piece.white-piece', '.triangle-piece.white-triangle', '.rhombus-piece.white-rhombus', '.circle-piece.white-circle', '.hexgon-piece.white-hexgon'];
            } else {
                // Black triangle - friendly with black squares and other black triangles
                friendlyPieceTypes = ['.square-piece:not(.white-piece)', '.triangle-piece:not(.white-triangle)', '.rhombus-piece:not(.white-rhombus)', '.circle-piece:not(.white-circle)', '.hexgon-piece:not(.white-hexgon)'];
            }

            // Highlight the hexes in the triangle pattern
            console.log(`üéØ Highlighting ${offsets.length} movement targets:`, offsets);
            offsets.forEach(([rowOffset, colOffset]) => {
                // Apply offsets to get target coordinates
                const targetRow = centerRow + rowOffset;
                const targetCol = centerCol + colOffset;
                const targetHexId = `hex-${targetRow}-${targetCol}`;
                const targetHex = document.getElementById(targetHexId);
                
                console.log(`üéØ Processing target: ${targetHexId} (from ${centerRow}-${centerCol} + [${rowOffset},${colOffset}]), element found:`, !!targetHex);
                
                if (targetHex) {
                    // Check if target hex has a friendly piece
                    let hasFriendlyPiece = false;
                    friendlyPieceTypes.forEach(selector => {
                        if (targetHex.querySelector(selector)) {
                            hasFriendlyPiece = true;
                        }
                    });
                    
                    // Check if target hex has an opponent piece
                    const isWhite = centerPiece && centerPiece.classList.contains('white-triangle');
                    const opponentPieceTypes = isWhite ? 
                        ['.square-piece:not(.white-piece)', '.triangle-piece:not(.white-triangle)', '.rhombus-piece:not(.white-rhombus)'] :
                        ['.square-piece.white-piece', '.triangle-piece.white-triangle', '.rhombus-piece.white-rhombus'];
                    let hasOpponentPiece = false;
                    opponentPieceTypes.forEach(selector => {
                        if (targetHex.querySelector(selector)) {
                            hasOpponentPiece = true;
                        }
                    });
                    
                    console.log(`üéØ Target ${targetHexId}: hasFriendly=${hasFriendlyPiece}, hasOpponent=${hasOpponentPiece}`);
                    
                    // Highlight in red if opponent piece, green if empty (skip friendly pieces)
                    if (hasOpponentPiece) {
                        targetHex.classList.add('highlight-red');
                        console.log(`üéØ Added highlight-red to ${targetHexId}`);
                    } else if (!hasFriendlyPiece) {
                        targetHex.classList.add('highlight-green');
                        console.log(`üéØ Added highlight-green to ${targetHexId}`);
                    }
                } else {
                    console.log(`‚ö†Ô∏è Target hex not found: ${targetHexId}`);
                }
            });
        }
        
        // Triangle rotation pattern functions
        function getTriangleOrientation(hexId) {
            return triangleOrientations.get(hexId) || 0; // Default to 0 (0¬∞)
        }
        
        function setTriangleOrientation(hexId, orientation) {
            triangleOrientations.set(hexId, orientation % 6); // Keep within 0-5
        }
        
        // Hexgon rotation pattern functions
        function getHexgonOrientation(hexId) {
            return hexgonOrientations.get(hexId) || 0; // Default to 0 (0¬∞)
        }
        
        function setHexgonOrientation(hexId, orientation) {
            hexgonOrientations.set(hexId, orientation % 6); // Keep within 0-5
        }
        
        function rotateTriangleLeft(hexId) {
            console.log('Rotating triangle left:', hexId);
            
            // Check if this piece is the active piece for this turn
            console.log('Rotation check - currentTurnPiece:', currentTurnPiece);
            console.log('Rotation check - currentTurnPiece.id:', currentTurnPiece ? currentTurnPiece.id : 'null');
            console.log('Rotation check - hexId:', hexId);
            if (currentTurnPiece && currentTurnPiece.id !== hexId) {
                alert('You can only move or rotate one piece per turn!');
                return;
            }
            
            // Check if piece has already attacked this turn
            const actions = pieceActions.get(hexId) || {moved: false, attacked: false, rotated: false};
            if (actions.attacked) {
                alert('Cannot rotate after attacking!');
                return;
            }
            
            const current = getTriangleOrientation(hexId);
            console.log('Current orientation:', current);
            
            // Handle orientation cycling properly for 6-angle cycle
            let newOrientation = current + 1;
            if (newOrientation >= 6) {
                newOrientation = 0; // Wrap to first angle (30¬∞)
            }
            setTriangleOrientation(hexId, newOrientation);
            updateTriangleVisual(hexId);
            
            console.log('New orientation:', newOrientation);
            const angleMap = [270, 330, 30, 90, 150, 210];
            const rotation = angleMap[newOrientation % 6];
            console.log('Rotation degrees:', rotation);
            
            // Mark as rotated (but don't end turn)
            actions.rotated = true;
            pieceActions.set(hexId, actions);
            
            // Update movement pattern display to show new rotated pattern
            const [, fromRow, fromCol] = hexId.match(/hex-(\d+)-(\d+)/);
            console.log('üîÑ Updating movement pattern for rotated triangle at:', fromRow, fromCol);
            showTriangleMovementPattern(parseInt(fromRow), parseInt(fromCol));
            
            // Check for rhombus deadlock after rotation (rotation might create checkmate)
            if (!gameOver) {
                checkRhombusDeadlock();
            }
            
            // Don't end turn - allow free rotation
            console.log('Rotation complete, turn continues');
        }
        
        function rotateTriangleRight(hexId) {
            console.log('Rotating triangle right:', hexId);
            
            // Check if this piece is the active piece for this turn
            console.log('Rotation check - currentTurnPiece:', currentTurnPiece);
            console.log('Rotation check - currentTurnPiece.id:', currentTurnPiece ? currentTurnPiece.id : 'null');
            console.log('Rotation check - hexId:', hexId);
            if (currentTurnPiece && currentTurnPiece.id !== hexId) {
                alert('You can only move or rotate one piece per turn!');
                return;
            }
            
            // Check if piece has already attacked this turn
            const actions = pieceActions.get(hexId) || {moved: false, attacked: false, rotated: false};
            if (actions.attacked) {
                alert('Cannot rotate after attacking!');
                return;
            }
            
            const current = getTriangleOrientation(hexId);
            console.log('Current orientation:', current);
            
            // Handle negative orientation properly for 6-angle cycle
            let newOrientation = current - 1;
            if (newOrientation < 0) {
                newOrientation = 5; // Wrap to last angle (330¬∞)
            }
            setTriangleOrientation(hexId, newOrientation);
            updateTriangleVisual(hexId);
            
            console.log('New orientation:', newOrientation);
            const angleMap = [270, 330, 30, 90, 150, 210];
            const rotation = angleMap[newOrientation % 6];
            console.log('Rotation degrees:', rotation);
            
            // Mark as rotated (but don't end turn)
            actions.rotated = true;
            pieceActions.set(hexId, actions);
            
            // Update movement pattern display to show new rotated pattern
            const [, fromRow, fromCol] = hexId.match(/hex-(\d+)-(\d+)/);
            console.log('üîÑ Updating movement pattern for rotated triangle at:', fromRow, fromCol);
            showTriangleMovementPattern(parseInt(fromRow), parseInt(fromCol));
            
            // Check for rhombus deadlock after rotation (rotation might create checkmate)
            if (!gameOver) {
                checkRhombusDeadlock();
            }
            
            // Don't end turn - allow free rotation
            console.log('Rotation complete, turn continues');
        }
        
        function updateTriangleVisual(hexId) {
            console.log('Updating triangle visual for:', hexId);
            const triangle = document.querySelector(`#${hexId} .triangle-piece`);
            console.log('Triangle element found:', triangle);
            if (triangle) {
                const orientation = getTriangleOrientation(hexId);
                // Map orientations to specific angles: 270¬∞, 330¬∞, 30¬∞, 90¬∞, 150¬∞, 210¬∞
                // Shifted by 2 positions to match visual appearance
                const angleMap = [270, 330, 30, 90, 150, 210];
                const rotation = angleMap[orientation % 6]; // Cycle through the 6 angles
                console.log('üî∫ Triangle rotation:', {
                    hexId,
                    orientation,
                    rotation,
                    angleMap
                });
                triangle.style.transform = `translate(-50%, -50%) rotate(${rotation}deg)`;
                console.log('Triangle transform set to:', triangle.style.transform);
            } else {
                console.log('No triangle element found for:', hexId);
            }
        }
        
        function rotateHexgonLeft(hexId) {
            console.log('Rotating hexgon left:', hexId);
            
            // Check if this piece is the active piece for this turn
            console.log('Rotation check - currentTurnPiece:', currentTurnPiece);
            console.log('Rotation check - currentTurnPiece.id:', currentTurnPiece ? currentTurnPiece.id : 'null');
            console.log('Rotation check - hexId:', hexId);
            if (currentTurnPiece && currentTurnPiece.id !== hexId) {
                alert('You can only move or rotate one piece per turn!');
                return;
            }
            
            // Check if piece has already attacked this turn
            const actions = pieceActions.get(hexId) || {moved: false, attacked: false, rotated: false};
            if (actions.attacked) {
                alert('Cannot rotate after attacking!');
                return;
            }
            
            const current = getHexgonOrientation(hexId);
            console.log('Current orientation:', current);
            
            // Hexagons only use orientations 0, 2, 4 (120-degree rotations)
            let newOrientation;
            if (current === 0) newOrientation = 2;
            else if (current === 2) newOrientation = 4;
            else newOrientation = 0; // 4 -> 0 or any other -> 0
            
            setHexgonOrientation(hexId, newOrientation);
            updateHexgonVisual(hexId);
            
            // Mark as rotated to track turn actions
            const actions2 = pieceActions.get(hexId) || {moved: false, attacked: false, rotated: false};
            actions2.rotated = true;
            pieceActions.set(hexId, actions2);
            
            // Update movement pattern to show new rotation
            const [, row, col] = hexId.match(/hex-(\d+)-(\d+)/);
            showHexgonMovementPattern(parseInt(row), parseInt(col));
            
            console.log('New orientation:', newOrientation);
            const angleMap = [0, 60, 120, 180, 240, 300];
            const rotation = angleMap[newOrientation % 6];
            console.log('Rotation degrees:', rotation);
            
            // Check for rhombus deadlock after rotation (rotation might create checkmate)
            if (!gameOver) {
                checkRhombusDeadlock();
            }
            
            // Don't end turn - allow free rotation
            console.log('Rotation complete, turn continues');
        }
        
        function rotateHexgonRight(hexId) {
            console.log('Rotating hexgon right:', hexId);
            
            // Check if this piece is the active piece for this turn
            console.log('Rotation check - currentTurnPiece:', currentTurnPiece);
            console.log('Rotation check - currentTurnPiece.id:', currentTurnPiece ? currentTurnPiece.id : 'null');
            console.log('Rotation check - hexId:', hexId);
            if (currentTurnPiece && currentTurnPiece.id !== hexId) {
                alert('You can only move or rotate one piece per turn!');
                return;
            }
            
            // Check if piece has already attacked this turn
            const actions = pieceActions.get(hexId) || {moved: false, attacked: false, rotated: false};
            if (actions.attacked) {
                alert('Cannot rotate after attacking!');
                return;
            }
            
            const current = getHexgonOrientation(hexId);
            console.log('Current orientation:', current);
            
            // Hexagons only use orientations 0, 2, 4 (120-degree rotations)
            let newOrientation;
            if (current === 0) newOrientation = 4;
            else if (current === 4) newOrientation = 2;
            else newOrientation = 0; // 2 -> 0 or any other -> 0
            
            setHexgonOrientation(hexId, newOrientation);
            updateHexgonVisual(hexId);
            
            // Mark as rotated to track turn actions
            const actions2 = pieceActions.get(hexId) || {moved: false, attacked: false, rotated: false};
            actions2.rotated = true;
            pieceActions.set(hexId, actions2);
            
            // Update movement pattern to show new rotation
            const [, row, col] = hexId.match(/hex-(\d+)-(\d+)/);
            showHexgonMovementPattern(parseInt(row), parseInt(col));
            
            console.log('New orientation:', newOrientation);
            const angleMap = [0, 60, 120, 180, 240, 300];
            const rotation = angleMap[newOrientation % 6];
            console.log('Rotation degrees:', rotation);
            
            // Check for rhombus deadlock after rotation (rotation might create checkmate)
            if (!gameOver) {
                checkRhombusDeadlock();
            }
            
            // Don't end turn - allow free rotation
            console.log('Rotation complete, turn continues');
        }
        
        function updateHexgonVisual(hexId) {
            console.log('Updating hexgon visual for:', hexId);
            const hexgon = document.querySelector(`#${hexId} .hexgon-piece`);
            console.log('Hexgon element found:', hexgon);
            if (hexgon) {
                const orientation = getHexgonOrientation(hexId);
                // Map orientations to specific angles: 0¬∞, 60¬∞, 120¬∞, 180¬∞, 240¬∞, 300¬∞
                // Add base 90¬∞ rotation to match other pieces
                const angleMap = [90, 150, 210, 270, 330, 30];
                const rotation = angleMap[orientation % 6]; // Cycle through the 6 angles
                console.log('‚¨° Hexgon rotation:', {
                    hexId,
                    orientation,
                    rotation,
                    angleMap
                });
                hexgon.style.transform = `translate(-50%, -50%) rotate(${rotation}deg)`;
                console.log('Hexgon transform set to:', hexgon.style.transform);
            } else {
                console.log('No hexgon element found for:', hexId);
            }
        }
        
        function getRotatedTrianglePattern(centerRow, centerCol, orientation) {
            // Get base pattern for the position
            const basePattern = getBaseTrianglePattern(centerRow, centerCol);
            if (!basePattern) return [];
            
            // Rotate each offset by orientation * 60 degrees
            return basePattern.map(offset => rotateOffset(offset, orientation));
        }
        
        function rotateOffset(offset, orientation) {
            const [row, col] = offset;
            const angle = orientation * 60 * Math.PI / 180; // Convert to radians
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            
            // Rotate the offset vector
            const newRow = Math.round(row * cos - col * sin);
            const newCol = Math.round(row * sin + col * cos);
            
            return [newRow, newCol];
        }
        
        function getBaseTrianglePattern(centerRow, centerCol) {
            // This will contain the base movement patterns for each position
            // We'll populate this with the existing triangle patterns
            const patterns = {
                // Row 0 patterns
                '0-0': [[1, 0], [0, 1]],
                '0-1': [[1, 0], [1, 1], [0, 1]],
                '0-2': [[1, 0], [1, 1], [0, 1], [0, 2]],
                '0-3': [[1, 1], [1, 2], [0, 1], [0, 2]],
                '0-4': [[1, 1], [1, 2], [0, 2]],
                '0-5': [[1, 2], [0, 2]],
                '0-6': [[1, 2]],
                
                // Row 1 patterns
                '1-0': [[1, 0], [0, 1], [-1, 0]],
                '1-1': [[1, 0], [1, 1], [0, 1], [-1, 0]],
                '1-2': [[1, 0], [1, 1], [0, 1], [0, 2], [-1, 0]],
                '1-3': [[1, 1], [1, 2], [0, 1], [0, 2], [-1, 1]],
                '1-4': [[1, 1], [1, 2], [0, 2], [-1, 1]],
                '1-5': [[1, 2], [0, 2], [-1, 1]],
                '1-6': [[1, 2], [-1, 1]],
                
                // Row 2 patterns
                '2-0': [[1, 0], [0, 1], [-1, 0], [-1, 1]],
                '2-1': [[1, 0], [1, 1], [0, 1], [-1, 0], [-1, 1]],
                '2-2': [[1, 0], [1, 1], [0, 1], [0, 2], [-1, 0], [-1, 1]],
                '2-3': [[1, 1], [1, 2], [0, 1], [0, 2], [-1, 1], [-1, 2]],
                '2-4': [[1, 1], [1, 2], [0, 2], [-1, 1], [-1, 2]],
                '2-5': [[1, 2], [0, 2], [-1, 1], [-1, 2]],
                '2-6': [[1, 2], [-1, 1], [-1, 2]],
                
                // Row 3 patterns
                '3-0': [[1, 0], [0, 1], [-1, 0], [-1, 1]],
                '3-1': [[1, 0], [1, 1], [0, 1], [-1, 0], [-1, 1]],
                '3-2': [[1, 0], [1, 1], [0, 1], [0, 2], [-1, 0], [-1, 1]],
                '3-3': [[1, 1], [1, 2], [0, 1], [0, 2], [-1, 1], [-1, 2]],
                '3-4': [[1, 1], [1, 2], [0, 2], [-1, 1], [-1, 2]],
                '3-5': [[1, 2], [0, 2], [-1, 1], [-1, 2]],
                '3-6': [[1, 2], [-1, 1], [-1, 2]],
                '3-7': [[1, 2], [-1, 2]],
                '3-8': [[-1, 2]],
                
                // Row 4 patterns
                '4-0': [[0, 1], [-1, 0], [-1, 1]],
                '4-1': [[1, 1], [0, 1], [-1, 0], [-1, 1]],
                '4-2': [[1, 1], [0, 1], [0, 2], [-1, 0], [-1, 1]],
                '4-3': [[1, 1], [1, 2], [0, 1], [0, 2], [-1, 1], [-1, 2]],
                '4-4': [[1, 1], [1, 2], [0, 2], [-1, 1], [-1, 2]],
                '4-5': [[1, 2], [0, 2], [-1, 1], [-1, 2]],
                '4-6': [[1, 2], [-1, 1], [-1, 2]],
                '4-7': [[1, 2], [-1, 2]],
                '4-8': [[-1, 2]],
                
                // Row 5 patterns
                '5-0': [[0, 1], [-1, 0], [-1, 1]],
                '5-1': [[1, 1], [0, 1], [-1, 0], [-1, 1]],
                '5-2': [[1, 1], [0, 1], [0, 2], [-1, 0], [-1, 1]],
                '5-3': [[1, 1], [1, 2], [0, 1], [0, 2], [-1, 1], [-1, 2]],
                '5-4': [[1, 1], [1, 2], [0, 2], [-1, 1], [-1, 2]],
                '5-5': [[1, 2], [0, 2], [-1, 1], [-1, 2]],
                '5-6': [[1, 2], [-1, 1], [-1, 2]],
                '5-7': [[1, 2], [-1, 2]],
                '5-8': [[-1, 2]],
                
                // Row 6 patterns
                '6-0': [[0, 1], [-1, 0], [-1, 1]],
                '6-1': [[1, 1], [0, 1], [-1, 0], [-1, 1]],
                '6-2': [[1, 1], [0, 1], [0, 2], [-1, 0], [-1, 1]],
                '6-3': [[1, 1], [1, 2], [0, 1], [0, 2], [-1, 1], [-1, 2]],
                '6-4': [[1, 1], [1, 2], [0, 2], [-1, 1], [-1, 2]],
                '6-5': [[1, 2], [0, 2], [-1, 1], [-1, 2]],
                '6-6': [[1, 2], [-1, 1], [-1, 2]],
                '6-7': [[1, 2], [-1, 2]],
                '6-8': [[-1, 2]]
            };
            
            return patterns[`${centerRow}-${centerCol}`] || [];
        }

        // Function to show movement pattern accounting for hexagonal grid structure
        function showSquareMovementPattern(centerRow, centerCol) {
            console.log(`üéØ showSquareMovementPattern called for ${centerRow}-${centerCol}`);
            // Clear any existing highlights (but keep threat highlights)
            document.querySelectorAll('.hexagon').forEach(hex => {
                hex.classList.remove('highlight-green', 'highlight-red', 'highlight-danger', 'highlight-diagonal', 'highlight-gray');
            });

            // Different offset patterns for each row due to hexagonal grid structure
            let offsets;
            
            if (centerRow === 0) {
                // Row 0 (even, shift-down)
                offsets = [
                    [1, 0],  // down-left
                    [1, 1],  // down-right
                    [-1, 1], // up-right (off-board)
                    [-1, 0]  // up-left (off-board)
                ];
            } else if (centerRow === 1) {
                // Row 1 (odd, no shift)
                // For 1-3 ‚Üí 2-3, 2-4, 0-2, 0-3
                offsets = [
                    [1, 0],  // down-left: 1-3 + [1,0] = 2-3
                    [1, 1],  // down-right: 1-3 + [1,1] = 2-4
                    [-1, -1], // up-left: 1-3 + [-1,-1] = 0-2
                    [-1, 0]  // up-right: 1-3 + [-1,0] = 0-3
                ];
            } else if (centerRow === 2) {
                // Row 2 (even, shift-down)
                // For 2-3 ‚Üí 3-3, 3-4, 1-2, 1-3
                offsets = [
                    [1, 0],  // down-left: 2-3 + [1,0] = 3-3
                    [1, 1],  // down-right: 2-3 + [1,1] = 3-4
                    [-1, -1], // up-left: 2-3 + [-1,-1] = 1-2
                    [-1, 0]  // up-right: 2-3 + [-1,0] = 1-3
                ];
            } else if (centerRow === 3) {
                // Row 3 (odd, no shift) - KEEP ORIGINAL WORKING PATTERN
                // For 3-4 ‚Üí 4-3, 4-4, 2-4, 2-3
                offsets = [
                    [1, -1], // down-left
                    [1, 0],  // down-right
                    [-1, 0], // up-right
                    [-1, -1] // up-left
                ];
            } else if (centerRow === 4) {
                // Row 4 (even, shift-down)
                // For 4-3 ‚Üí 3-3, 3-4, 5-2, 5-3
                offsets = [
                    [-1, 0], // up-left
                    [-1, 1], // up-right
                    [1, -1], // down-left
                    [1, 0]   // down-right
                ];
            } else if (centerRow === 5) {
                // Row 5 (odd, no shift)
                // For 5-1 ‚Üí 6-0, 6-1, 4-1, 4-2
                offsets = [
                    [1, -1], // down-left
                    [1, 0],  // down-right
                    [-1, 0], // up-left  
                    [-1, 1]  // up-right
                ];
            } else if (centerRow === 6) {
                // Row 6 (even, shift-down)
                // For 6-0 ‚Üí should go to 5-0, 5-1 (and two off-board)
                offsets = [
                    [1, 0],  // down-left (off-board)
                    [1, 1],  // down-right (off-board)
                    [-1, 1], // up-right
                    [-1, 0]  // up-left
                ];
            }

            // Get the piece type that's showing movement pattern
            const centerHex = document.getElementById(`hex-${centerRow}-${centerCol}`);
            const centerPiece = centerHex.querySelector('.square-piece, .triangle-piece');
            let friendlyPieceTypes = [];
            
            if (centerPiece) {
                if (centerPiece.classList.contains('square-piece')) {
                    if (centerPiece.classList.contains('white-piece')) {
                            // White square - friendly with other white pieces (squares, triangles, rhombuses, circles, hexgons)
                            friendlyPieceTypes = ['.square-piece.white-piece', '.triangle-piece.white-triangle', '.rhombus-piece.white-rhombus', '.circle-piece.white-circle', '.hexgon-piece.white-hexgon'];
                    } else {
                        // Black square - friendly with other black pieces and triangles
                            friendlyPieceTypes = ['.square-piece:not(.white-piece)', '.triangle-piece:not(.white-triangle)', '.rhombus-piece:not(.white-rhombus)', '.circle-piece:not(.white-circle)', '.hexgon-piece:not(.white-hexgon)'];
                    }
                } else if (centerPiece.classList.contains('triangle-piece')) {
                    if (centerPiece.classList.contains('white-triangle')) {
                        // White triangle - friendly with white squares and other white triangles
                            friendlyPieceTypes = ['.square-piece.white-piece', '.triangle-piece.white-triangle', '.rhombus-piece.white-rhombus', '.circle-piece.white-circle', '.hexgon-piece.white-hexgon'];
                    } else {
                        // Black triangle - friendly with black squares and other black triangles
                            friendlyPieceTypes = ['.square-piece:not(.white-piece)', '.triangle-piece:not(.white-triangle)', '.rhombus-piece:not(.white-rhombus)', '.circle-piece:not(.white-circle)', '.hexgon-piece:not(.white-hexgon)'];
                    }
                }
            }

            // Highlight the hexes in the cross pattern
            offsets.forEach(([rowOffset, colOffset]) => {
                const targetRow = centerRow + rowOffset;
                const targetCol = centerCol + colOffset;
                const targetHex = document.getElementById(`hex-${targetRow}-${targetCol}`);
                
                if (targetHex) {
                    // Check if target hex has a friendly piece
                    let hasFriendlyPiece = false;
                    friendlyPieceTypes.forEach(selector => {
                        if (targetHex.querySelector(selector)) {
                            hasFriendlyPiece = true;
                        }
                    });
                    
                    // Check if target hex has an opponent piece
                    const isWhite = centerPiece && (centerPiece.classList.contains('white-piece') || centerPiece.classList.contains('white-triangle'));
                    const opponentPieceTypes = isWhite ? 
                        ['.square-piece:not(.white-piece)', '.triangle-piece:not(.white-triangle)', '.rhombus-piece:not(.white-rhombus)', '.circle-piece:not(.white-circle)', '.hexgon-piece:not(.white-hexgon)'] :
                        ['.square-piece.white-piece', '.triangle-piece.white-triangle', '.rhombus-piece.white-rhombus', '.circle-piece.white-circle', '.hexgon-piece.white-hexgon'];
                    let hasOpponentPiece = false;
                    opponentPieceTypes.forEach(selector => {
                        if (targetHex.querySelector(selector)) {
                            hasOpponentPiece = true;
                        }
                    });
                    
                    // Highlight in red if opponent piece, green if empty (skip friendly pieces)
                    if (hasOpponentPiece) {
                        console.log(`üî¥ SQUARE: Adding red highlight to ${targetRow}-${targetCol} for opponent piece`);
                        targetHex.classList.add('highlight-red');
                    } else if (!hasFriendlyPiece) {
                        // Check if this position would be vulnerable to attack
                        if (isPositionVulnerable(targetRow, targetCol, isWhite)) {
                            targetHex.classList.add('highlight-danger');
                        } else {
                            targetHex.classList.add('highlight-green');
                        }
                    }
                }
            });
        }

        // Function to show movement pattern for rhombus pieces
        function showRhombusMovementPattern(centerRow, centerCol) {
            console.log(`üéØ showRhombusMovementPattern called for ${centerRow}-${centerCol}`);
            // Clear any existing highlights (but keep threat highlights)
            document.querySelectorAll('.hexagon').forEach(hex => {
                hex.classList.remove('highlight-green', 'highlight-red', 'highlight-danger', 'highlight-diagonal', 'highlight-gray');
            });

            // Get friendly piece types based on rhombus color
            let friendlyPieceTypes;
            const centerHex = document.getElementById(`hex-${centerRow}-${centerCol}`);
            const centerPiece = centerHex.querySelector('.rhombus-piece');
            
            if (centerPiece && centerPiece.classList.contains('white-rhombus')) {
                // White rhombus - friendly with white pieces (squares, triangles, rhombuses, circles, hexgons)
                friendlyPieceTypes = ['.square-piece.white-piece', '.triangle-piece.white-triangle', '.rhombus-piece.white-rhombus', '.circle-piece.white-circle', '.hexgon-piece.white-hexgon'];
            } else {
                // Black rhombus - friendly with black pieces
                friendlyPieceTypes = ['.square-piece:not(.white-piece)', '.triangle-piece:not(.white-triangle)', '.rhombus-piece:not(.white-rhombus)', '.circle-piece:not(.white-circle)', '.hexgon-piece:not(.white-hexgon)'];
            }

            // Define zones for diagonal ability detection
            const deadZone = new Set(["3-3", "3-4", "3-5"]);
            const innerPerimeter = new Set(["4-2", "4-3", "4-4", "4-5", "2-2", "2-3", "2-4", "2-5"]);
            const currentPos = `${centerRow}-${centerCol}`;

            // Use getRhombusMoves to get all possible moves (including diagonal abilities)
            const targets = getRhombusMoves(centerRow, centerCol);

            // Highlight the hexes in the rhombus pattern
            targets.forEach(([targetRow, targetCol]) => {
                const targetHex = document.getElementById(`hex-${targetRow}-${targetCol}`);
                const targetPos = `${targetRow}-${targetCol}`;
                
                if (targetHex) {
                    // Check if target hex has a friendly piece
                    let hasFriendlyPiece = false;
                    friendlyPieceTypes.forEach(selector => {
                        if (targetHex.querySelector(selector)) {
                            hasFriendlyPiece = true;
                        }
                    });
                    
                    // Check if target hex has an opponent piece
                    // NOTE: Rhombuses CANNOT attack other rhombuses, so exclude them from opponent list
                    const isWhite = centerPiece && centerPiece.classList.contains('white-rhombus');
                    const opponentPieceTypes = isWhite ? 
                        ['.square-piece:not(.white-piece)', '.triangle-piece:not(.white-triangle)', '.circle-piece:not(.white-circle)', '.hexgon-piece:not(.white-hexgon)'] :
                        ['.square-piece.white-piece', '.triangle-piece.white-triangle', '.circle-piece.white-circle', '.hexgon-piece.white-hexgon'];
                    let hasOpponentPiece = false;
                    opponentPieceTypes.forEach(selector => {
                        if (targetHex.querySelector(selector)) {
                            hasOpponentPiece = true;
                        }
                    });
                    
                    // Check if this is a diagonal move (from dead zone to inner perimeter or vice versa)
                    const isDiagonalMove = (deadZone.has(currentPos) && innerPerimeter.has(targetPos)) || 
                                          (innerPerimeter.has(currentPos) && deadZone.has(targetPos));
                    
                    // Highlight in red if opponent piece (but NOT for diagonal moves - diagonal is movement only)
                    if (hasOpponentPiece && !isDiagonalMove) {
                        targetHex.classList.add('highlight-red');
                    } else if (!hasFriendlyPiece) {
                        // Check if this position would be vulnerable to attack
                        // Pass 'rhombus' as the moving piece type so we exclude rhombus-on-rhombus threats
                        if (isPositionVulnerable(targetRow, targetCol, isWhite, 'rhombus')) {
                            targetHex.classList.add('highlight-danger');
                        } else {
                            // Use purple highlight for ALL diagonal moves (both directions)
                            if (isDiagonalMove) {
                                targetHex.classList.add('highlight-diagonal');
                            } else {
                                targetHex.classList.add('highlight-green');
                            }
                        }
                    }
                }
            });
        }

        // Function to show movement for circle pieces by zone
        function showCircleMovementPattern(centerRow, centerCol) {
            console.log(`üéØ showCircleMovementPattern called for ${centerRow}-${centerCol}`);
            const centerHex = document.getElementById(`hex-${centerRow}-${centerCol}`);
            if (!centerHex) {
                console.log(`‚ùå centerHex not found!`);
                return;
            }
            const piece = centerHex.querySelector('.circle-piece');
            if (!piece) {
                console.log(`‚ùå circle piece not found!`);
                return;
            }
            
            console.log(`‚úÖ Circle piece found, proceeding...`);

            // Clear previous highlights but keep threat
            document.querySelectorAll('.hexagon').forEach(hex => {
                hex.classList.remove('highlight-green', 'highlight-red', 'highlight-danger', 'highlight-diagonal', 'highlight-gray');
            });

            const coord = `${centerRow}-${centerCol}`;
            console.log(`üìç Current position: ${coord}`);
            
            let zoneSet = null;
            let zoneOrder = null;
            let currentZone = null;
            
            if (circleDeadZone.has(coord)) {
                currentZone = 'dead';
                console.log(`‚ùå Circle is in DEAD ZONE - cannot move`);
                return; // cannot move in dead zone
            } else if (circleInnerZone.has(coord)) {
                zoneSet = circleInnerZone;
                zoneOrder = circleInnerOrder;
                currentZone = 'inner';
                console.log(`‚úÖ Circle is in INNER zone`);
            } else if (circleMiddleZone.has(coord)) {
                zoneSet = circleMiddleZone;
                zoneOrder = circleMiddleOrder;
                currentZone = 'middle';
                console.log(`‚úÖ Circle is in MIDDLE zone`);
            } else if (circleOuterZone.has(coord)) {
                zoneSet = circleOuterZone;
                zoneOrder = circleOuterOrder;
                currentZone = 'outer';
                console.log(`‚úÖ Circle is in OUTER zone`);
            } else {
                console.log(`‚ùå Circle is NOT in any zone!`);
                return;
            }

            const isWhite = piece.classList.contains('white-circle');
            const friendlySelectors = isWhite 
                ? ['.square-piece.white-piece', '.triangle-piece.white-triangle', '.rhombus-piece.white-rhombus', '.circle-piece.white-circle', '.hexgon-piece.white-hexgon']
                : ['.square-piece:not(.white-piece)', '.triangle-piece:not(.white-triangle)', '.rhombus-piece:not(.white-rhombus)', '.circle-piece:not(.white-circle)', '.hexgon-piece:not(.white-hexgon)'];

            const opponentSelectors = isWhite 
                ? ['.square-piece:not(.white-piece)', '.triangle-piece:not(.white-triangle)', '.rhombus-piece:not(.white-rhombus)', '.circle-piece:not(.white-circle)', '.hexgon-piece:not(.white-hexgon)']
                : ['.square-piece.white-piece', '.triangle-piece.white-triangle', '.rhombus-piece.white-rhombus', '.circle-piece.white-circle', '.hexgon-piece.white-hexgon'];

            // ===== PART 1: FULL ZONE PERIMETRIC MOVEMENT (original system) =====
            // Helper function to check if a position is adjacent to the center
            function isAdjacent(targetRow, targetCol) {
                let offsets;
                if (centerRow % 2 === 0) {
                    offsets = [[1, 0], [1, 1], [0, 1], [-1, 0], [-1, 1], [0, -1]];
                } else {
                    offsets = [[1, -1], [1, 0], [0, 1], [-1, -1], [-1, 0], [0, -1]];
                }
                for (const [rowOff, colOff] of offsets) {
                    if (centerRow + rowOff === targetRow && centerCol + colOff === targetCol) {
                        return true;
                    }
                }
                return false;
            }
            
            // Perimetric sweep clockwise until first friendly/opponent
            const startIdx = zoneOrder.indexOf(coord);
            const len = zoneOrder.length;
            console.log(`üîÑ Starting clockwise perimetric sweep. startIdx: ${startIdx}, len: ${len}`);
            
            let clockwiseCount = 0;
            for (let step = 1; step < len; step++) {
                const idx = (startIdx + step) % len;
                const [r,c] = zoneOrder[idx].split('-');
                const hex = document.getElementById(`hex-${r}-${c}`);
                if (!hex) continue;
                
                clockwiseCount++;
                const targetRow = parseInt(r);
                const targetCol = parseInt(c);
                
                // Friendly: stop without highlighting
                let hasFriendly = false;
                for (const sel of friendlySelectors) { if (hex.querySelector(sel)) { hasFriendly = true; break; } }
                if (hasFriendly) {
                    console.log(`  üîÑ CW Step ${step}: ${r}-${c} has friendly piece, stopping`);
                    break;
                }
                // Opponent: ALWAYS highlight red (can attack any opponent on perimeter), then stop
                let hasOpponent = false;
                for (const sel of opponentSelectors) { if (hex.querySelector(sel)) { hasOpponent = true; break; } }
                if (hasOpponent) {
                    console.log(`  üîÑ CW Step ${step}: ${r}-${c} has opponent, adding red and stopping`);
                    hex.classList.add('highlight-red');
                    break;
                }
                // Empty: highlight green and continue
                if (hex !== centerHex) {
                    hex.classList.add('highlight-green');
                    console.log(`  üîÑ CW Step ${step}: ${r}-${c} is empty, added green`);
                }
            }
            console.log(`‚úÖ Clockwise sweep complete. Processed ${clockwiseCount} hexes`);

            // Perimetric sweep counter-clockwise until first friendly/opponent
            console.log(`üîÑ Starting counter-clockwise perimetric sweep`);
            let counterClockwiseCount = 0;
            for (let step = 1; step < len; step++) {
                const idx = (startIdx - step + len) % len;
                const [r,c] = zoneOrder[idx].split('-');
                const hex = document.getElementById(`hex-${r}-${c}`);
                if (!hex) continue;
                
                counterClockwiseCount++;
                const targetRow = parseInt(r);
                const targetCol = parseInt(c);
                
                // Friendly: stop without highlighting
                let hasFriendly = false;
                for (const sel of friendlySelectors) { if (hex.querySelector(sel)) { hasFriendly = true; break; } }
                if (hasFriendly) {
                    console.log(`  üîÑ CCW Step ${step}: ${r}-${c} has friendly piece, stopping`);
                    break;
                }
                // Opponent: ALWAYS highlight red (can attack any opponent on perimeter), then stop
                let hasOpponent = false;
                for (const sel of opponentSelectors) { if (hex.querySelector(sel)) { hasOpponent = true; break; } }
                if (hasOpponent) {
                    console.log(`  üîÑ CCW Step ${step}: ${r}-${c} has opponent, adding red and stopping`);
                    hex.classList.add('highlight-red');
                    break;
                }
                if (hex !== centerHex) {
                    hex.classList.add('highlight-green');
                    console.log(`  üîÑ CCW Step ${step}: ${r}-${c} is empty, added green`);
                }
            }
            console.log(`‚úÖ Counter-clockwise sweep complete. Processed ${counterClockwiseCount} hexes`);

            // ===== PART 2: ADJACENT HEX ZONE TRANSITIONS (hardcoded valid transitions) =====
            console.log(`üî∑ Starting zone transition checks (Part 2)`);
            
            const currentPos = `${centerRow}-${centerCol}`;
            const validTransitions = circleZoneTransitions.get(currentPos);
            
            if (!validTransitions || validTransitions.length === 0) {
                console.log(`üî∑ No valid zone transitions from ${currentPos}`);
            } else {
                console.log(`üî∑ Valid transitions from ${currentPos}:`, validTransitions);
                
                // Check each valid transition target
                validTransitions.forEach(targetPos => {
                    const [targetRow, targetCol] = targetPos.split('-').map(Number);
                    const targetHex = document.getElementById(`hex-${targetRow}-${targetCol}`);
                    
                    console.log(`  üî∑ Checking transition target ${targetPos}`);
                    
                    if (!targetHex) {
                        console.log(`    ‚ö†Ô∏è Hex not found`);
                        return;
                    }
                    
                    // Check if already highlighted from perimetric sweep
                    const alreadyHighlighted = targetHex.classList.contains('highlight-green') || 
                                              targetHex.classList.contains('highlight-red') || 
                                              targetHex.classList.contains('highlight-gray');
                    
                    if (alreadyHighlighted) {
                        console.log(`    ‚è≠Ô∏è Already highlighted, skipping`);
                        return;
                    }
                    
                    // Check if target hex has any piece
                    let hasFriendly = false;
                    for (const sel of friendlySelectors) {
                        if (targetHex.querySelector(sel)) {
                            hasFriendly = true;
                            break;
                        }
                    }
                    
                    let hasOpponent = false;
                    for (const sel of opponentSelectors) {
                        if (targetHex.querySelector(sel)) {
                            hasOpponent = true;
                            break;
                        }
                    }
                    
                    // If has any piece, skip (not attackable via transition)
                    if (hasOpponent || hasFriendly) {
                        console.log(`    ‚¨ú Has piece, not attackable via zone transition`);
                        return;
                    }
                    
                    // Empty hex - valid zone transition move (purple highlight)
                    console.log(`    üíú Adding purple highlight for valid zone transition`);
                    targetHex.classList.add('highlight-diagonal');
                });
            }
        }

        // Show persistent attack highlights for all circles on the board
        function showCircleAttackHighlights() {
            // Get all circle pieces on the board
            const allCircles = document.querySelectorAll('.circle-piece');
            
            allCircles.forEach(circle => {
                const circleHex = circle.closest('.hexagon');
                if (!circleHex) return;
                
                const [, row, col] = circleHex.id.match(/hex-(\d+)-(\d+)/);
                const centerRow = parseInt(row);
                const centerCol = parseInt(col);
                const coord = `${centerRow}-${centerCol}`;
                
                // Skip if in dead zone
                if (circleDeadZone.has(coord)) return;
                
                // Determine zone
                let zoneOrder = null;
                if (circleInnerZone.has(coord)) {
                    zoneOrder = circleInnerOrder;
                } else if (circleMiddleZone.has(coord)) {
                    zoneOrder = circleMiddleOrder;
                } else if (circleOuterZone.has(coord)) {
                    zoneOrder = circleOuterOrder;
                } else {
                    return; // Not in valid zone
                }
                
                const isWhite = circle.classList.contains('white-circle');
                const opponentSelectors = isWhite 
                    ? ['.square-piece:not(.white-piece)', '.triangle-piece:not(.white-triangle)', '.rhombus-piece:not(.white-rhombus)', '.circle-piece:not(.white-circle)', '.hexgon-piece:not(.white-hexgon)']
                    : ['.square-piece.white-piece', '.triangle-piece.white-triangle', '.rhombus-piece.white-rhombus', '.circle-piece.white-circle', '.hexgon-piece.white-hexgon'];
                
                const startIdx = zoneOrder.indexOf(coord);
                const len = zoneOrder.length;
                
                // Check clockwise for first opponent
                for (let step = 1; step < len; step++) {
                    const idx = (startIdx + step) % len;
                    const [r, c] = zoneOrder[idx].split('-');
                    const hex = document.getElementById(`hex-${r}-${c}`);
                    if (!hex) continue;
                    
                    let hasOpponent = false;
                    for (const sel of opponentSelectors) {
                        if (hex.querySelector(sel)) {
                            hasOpponent = true;
                            break;
                        }
                    }
                    
                    if (hasOpponent) {
                        // Add red highlight for attackable opponent
                        hex.classList.add('highlight-red');
                        break; // Stop at first piece
                    } else if (hex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece')) {
                        break; // Stop at friendly piece
                    }
                }
                
                // Check counter-clockwise for first opponent
                for (let step = 1; step < len; step++) {
                    const idx = (startIdx - step + len) % len;
                    const [r, c] = zoneOrder[idx].split('-');
                    const hex = document.getElementById(`hex-${r}-${c}`);
                    if (!hex) continue;
                    
                    let hasOpponent = false;
                    for (const sel of opponentSelectors) {
                        if (hex.querySelector(sel)) {
                            hasOpponent = true;
                            break;
                        }
                    }
                    
                    if (hasOpponent) {
                        // Add red highlight for attackable opponent
                        hex.classList.add('highlight-red');
                        break; // Stop at first piece
                    } else if (hex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece')) {
                        break; // Stop at friendly piece
                    }
                }
            });
        }

        // ===== FOG OF WAR SYSTEM =====
        
        // Calculate distance between two hexagon positions
        function getHexDistance(hex1Id, hex2Id) {
            const [, row1, col1] = hex1Id.match(/hex-(\d+)-(\d+)/).map(Number);
            const [, row2, col2] = hex2Id.match(/hex-(\d+)-(\d+)/).map(Number);
            
            // Convert offset coordinates to cube coordinates for hex distance
            const x1 = col1 - Math.floor(row1 / 2);
            const z1 = row1;
            const y1 = -x1 - z1;
            
            const x2 = col2 - Math.floor(row2 / 2);
            const z2 = row2;
            const y2 = -x2 - z2;
            
            // Manhattan distance in cube coordinates
            return (Math.abs(x1 - x2) + Math.abs(y1 - y2) + Math.abs(z1 - z2)) / 2;
        }
        
        // Get all visible hexes for the current player under Fog of War
        function getVisibleHexes(forPlayer) {
            if (!fogOfWarEnabled) {
                // Return all hexes if fog is disabled
                return Array.from(document.querySelectorAll('.hexagon')).map(h => h.id);
            }
            
            const visibleHexIds = new Set();
            
            // Get all pieces belonging to the player
            const playerPieceSelector = forPlayer === 'white' 
                ? '.white-piece, .white-triangle, .white-rhombus, .white-circle, .white-hexgon'
                : '.square-piece:not(.white-piece), .triangle-piece:not(.white-triangle), .rhombus-piece:not(.white-rhombus), .circle-piece:not(.white-circle), .hexgon-piece:not(.white-hexgon)';
            
            const playerPieces = document.querySelectorAll(playerPieceSelector);
            
            // For each player piece, reveal hexes within radius
            playerPieces.forEach(piece => {
                const pieceHex = piece.closest('.hexagon');
                if (!pieceHex) return;
                
                const pieceHexId = pieceHex.id;
                visibleHexIds.add(pieceHexId); // Always see your own piece
                
                // Check all hexes on board
                document.querySelectorAll('.hexagon').forEach(hex => {
                    const distance = getHexDistance(pieceHexId, hex.id);
                    if (distance <= fogOfWarRadius) {
                        visibleHexIds.add(hex.id);
                    }
                });
            });
            
            return Array.from(visibleHexIds);
        }
        
        // Apply fog of war visual effects to the board
        function updateFogOfWar() {
            if (!fogOfWarEnabled) {
                // Remove all fog effects
                document.querySelectorAll('.hexagon').forEach(hex => {
                    hex.classList.remove('fog-hidden', 'fog-dimmed');
                    const pieces = hex.querySelectorAll('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                    pieces.forEach(p => p.style.visibility = 'visible');
                });
                return;
            }
            
            const visibleHexIds = getVisibleHexes(currentPlayer);
            const visibleSet = new Set(visibleHexIds);
            
            // Apply fog to all hexes
            document.querySelectorAll('.hexagon').forEach(hex => {
                if (visibleSet.has(hex.id)) {
                    // Visible hex - remove fog
                    hex.classList.remove('fog-hidden', 'fog-dimmed');
                    const pieces = hex.querySelectorAll('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                    pieces.forEach(p => p.style.visibility = 'visible');
                } else {
                    // Hidden hex - apply fog
                    hex.classList.add('fog-hidden');
                    // Hide opponent pieces in fog
                    const opponentPieceSelector = currentPlayer === 'white'
                        ? '.square-piece:not(.white-piece), .triangle-piece:not(.white-triangle), .rhombus-piece:not(.white-rhombus), .circle-piece:not(.white-circle), .hexgon-piece:not(.white-hexgon)'
                        : '.white-piece, .white-triangle, .white-rhombus, .white-circle, .white-hexgon';
                    
                    const opponentPieces = hex.querySelectorAll(opponentPieceSelector);
                    opponentPieces.forEach(p => p.style.visibility = 'hidden');
                }
            });
        }
        
        // Reveal hexes briefly when a piece attacks (if enabled)
        function revealAttackArea(attackerHexId, targetHexId) {
            if (!fogOfWarEnabled || !fogOfWarRevealOnAttack) return;
            
            // Temporarily reveal the attack path
            const revealedHexes = [attackerHexId, targetHexId];
            
            revealedHexes.forEach(hexId => {
                const hex = document.getElementById(hexId);
                if (hex) {
                    hex.classList.remove('fog-hidden');
                    hex.classList.add('fog-revealed-temp');
                    const pieces = hex.querySelectorAll('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                    pieces.forEach(p => {
                        p.style.visibility = 'visible';
                        p.style.animation = 'fogRevealPulse 0.5s ease-out';
                    });
                }
            });
            
            // Reapply fog after 2 seconds
            setTimeout(() => {
                revealedHexes.forEach(hexId => {
                    const hex = document.getElementById(hexId);
                    if (hex) {
                        hex.classList.remove('fog-revealed-temp');
                    }
                });
                updateFogOfWar();
            }, 2000);
        }

        // Show the movement pattern for the square at position 3-4
        // showSquareMovementPattern(3, 4); // Removed auto-highlight on load

        // Track which piece is currently selected
        let _selectedPiece = null;
        Object.defineProperty(window, 'selectedPiece', {
            get: function() {
                return _selectedPiece;
            },
            set: function(value) {
                console.log('selectedPiece changed from', _selectedPiece, 'to', value);
                _selectedPiece = value;
            }
        });

        // Turn-based logic
        let currentPlayer = 'black'; // Black starts first
        let gameOver = false;
        let gameInProgress = false; // Track if we're currently in an active game
        let gameMode = 'full'; // 'full', 'square-attack', or 'ai'
        let aiEnabled = false; // AI opponent enabled
        let boardFlipped = false; // Track if board is flipped for white player perspective
        let aiDifficulty = 'hard'; // 'easy', 'medium', or 'hard'
        window.aiDifficulty = aiDifficulty; // Make it globally accessible
        let aiThinking = false; // Lock player input while AI is thinking
        let llmMode = false; // LLM AI mode (mockup)
        let currentAIModel = 'claude-sonnet'; // 'claude-sonnet', 'gpt4', 'grok', 'gemini'
        let showAllMoves = false; // Track if "show all moves" mode is active
        
        // Fog of War variant settings
        let fogOfWarEnabled = false; // Enable/disable Fog of War mode
        let fogOfWarRadius = 2; // Visibility radius (number of hexes)
        let fogOfWarRevealOnAttack = true; // Reveal pieces when they attack
        
        // Last move tracking for highlighting
        let lastMoveFrom = null; // Hex ID of last move source
        let lastMoveTo = null; // Hex ID of last move destination
        
        // Triangle orientation tracking (0-5 for 6 orientations, 60¬∞ each)
        let triangleOrientations = new Map(); // hexId -> orientation (0-5)
        
        // Hexgon orientation tracking (0-5 for 6 orientations, 60¬∞ each)
        let hexgonOrientations = new Map(); // hexId -> orientation (0-5)
        
        // Track piece actions for move+rotate vs attack rules
        let pieceActions = new Map(); // hexId -> {moved: boolean, attacked: boolean, rotated: boolean}
        let currentTurnPiece = null; // Track which piece is active this turn

        // Circle zones (by board coordinates as strings "r-c")
        const circleDeadZone = new Set(["3-3","3-4","3-5"]);
        // Zone membership (Set) and ordered rings (Array) for perimetric sweep
        const circleInnerOrder = ["3-2","4-2","4-3","4-4","4-5","3-6","2-5","2-4","2-3","2-2"]; // clockwise ring
        const circleMiddleOrder = ["2-1","1-1","1-2","1-3","1-4","1-5","2-6","3-7","4-6","5-5","5-4","5-3","5-2","5-1","4-1","3-1"]; // clockwise ring
        const circleOuterOrder = ["3-0","2-0","1-0","0-0","0-1","0-2","0-3","0-4","0-5","1-6","2-7","3-8","4-7","5-6","6-5","6-4","6-3","6-2","6-1","6-0","5-0","4-0"]; // clockwise ring
        const circleInnerZone = new Set(circleInnerOrder);
        const circleMiddleZone = new Set(circleMiddleOrder);
        const circleOuterZone = new Set(circleOuterOrder);
        
        // Circle zone-change gateways (entry/exit hexes)
        // Radials: [0-5 ‚áÑ 1-5 ‚áÑ 2-5], [6-5 ‚áÑ 5-5 ‚áÑ 4-5], [6-0 ‚áÑ 5-1 ‚áÑ 4-2], [0-0 ‚áÑ 1-1 ‚áÑ 2-3]
        const circleGateways = new Map([
            ["0-5", ["1-5"]],
            ["1-5", ["0-5", "2-5"]],
            ["2-5", ["1-5"]],
            ["6-5", ["5-5"]],
            ["5-5", ["6-5", "4-5"]],
            ["4-5", ["5-5"]],
            ["6-0", ["5-1"]],
            ["5-1", ["6-0", "4-2"]],
            ["4-2", ["5-1"]],
            ["0-0", ["1-1"]],
            ["1-1", ["0-0", "2-2"]],
            ["2-2", ["1-1"]]
        ]);

        // Circle zone transition map - defines which adjacent hexes allow zone transitions for each position
        // Format: "position" -> [list of valid zone-transition target positions]
        const circleZoneTransitions = new Map([
            // OUTER ZONE to MIDDLE ZONE transitions (hardcoded by user)
            ["3-8", ["3-7"]], // outer to middle
            ["4-7", ["4-6", "3-7"]], // outer to middle
            ["5-6", ["5-5", "4-6"]], // outer to middle
            ["6-5", ["5-5"]], // outer to middle
            ["6-4", ["5-4", "5-5"]], // outer to middle
            ["6-3", ["5-3", "5-4"]], // outer to middle
            ["6-2", ["5-2", "5-3"]], // outer to middle
            ["6-1", ["5-1", "5-2"]], // outer to middle
            ["6-0", ["5-1"]], // outer to middle
            ["5-0", ["5-1", "4-1"]], // outer to middle
            ["4-0", ["4-1", "3-1"]], // outer to middle
            ["3-0", ["3-1"]], // outer to middle
            ["2-0", ["3-1", "2-1"]], // outer to middle
            ["1-0", ["2-1", "1-1"]], // outer to middle
            ["0-0", ["1-1"]], // outer to middle
            ["0-1", ["1-1", "1-2"]], // outer to middle
            ["0-2", ["1-2", "1-3"]], // outer to middle
            ["0-3", ["1-3", "1-4"]], // outer to middle
            ["0-4", ["1-4", "1-5"]], // outer to middle
            ["0-5", ["1-5"]], // outer to middle
            ["1-6", ["1-5", "2-6"]], // outer to middle
            ["2-7", ["2-6", "3-7"]], // outer to middle
            
            // MIDDLE ZONE to OUTER ZONE and INNER ZONE transitions (hardcoded by user)
            ["3-1", ["4-0", "3-0", "2-0", "3-2"]], // middle to outer + inner
            ["2-1", ["2-0", "1-0", "3-2", "2-2"]], // middle to outer + inner
            ["1-1", ["1-0", "0-0", "0-1", "2-2"]], // middle to outer + inner
            ["1-2", ["0-1", "0-2", "2-2", "2-3"]], // middle to outer + inner
            ["1-3", ["0-2", "0-3", "2-3", "2-4"]], // middle to outer + inner
            ["1-4", ["0-3", "0-4", "2-4", "2-5"]], // middle to outer + inner
            ["1-5", ["0-4", "0-5", "1-6", "2-5"]], // middle to outer + inner
            ["2-6", ["3-6", "2-5", "1-6", "2-7"]], // middle to outer + inner
            ["3-7", ["4-7", "3-8", "2-7", "3-6"]], // middle to outer + inner
            ["4-6", ["4-5", "3-6", "5-6", "4-7"]], // middle to outer + inner
            ["5-5", ["6-4", "6-5", "5-6", "4-5"]], // middle to outer + inner
            ["5-4", ["6-4", "6-3", "4-5", "4-4"]], // middle to outer + inner
            ["5-3", ["6-3", "6-2", "4-4", "4-3"]], // middle to outer + inner
            ["5-2", ["6-2", "6-1", "4-3", "4-2"]], // middle to outer + inner
            ["5-1", ["6-1", "6-0", "5-0", "4-2"]], // middle to outer + inner
            ["4-1", ["5-0", "4-0", "4-2", "3-2"]], // middle to outer + inner
            
            // INNER ZONE to MIDDLE ZONE transitions (hardcoded by user)
            ["3-6", ["2-6", "3-7", "4-6"]], // inner to middle
            ["4-5", ["4-6", "5-5", "5-4"]], // inner to middle
            ["4-4", ["5-4", "5-3"]], // inner to middle
            ["4-3", ["5-3", "5-2"]], // inner to middle
            ["4-2", ["5-2", "5-1", "4-1"]], // inner to middle
            ["3-2", ["4-1", "3-1", "2-1"]], // inner to middle
            ["2-2", ["1-2", "1-1", "2-1"]], // inner to middle
            ["2-3", ["1-2", "1-3"]], // inner to middle
            ["2-4", ["1-3", "1-4"]], // inner to middle
            ["2-5", ["1-4", "1-5", "2-6"]], // inner to middle
            
            // NO DEAD ZONE transitions - circles cannot move or attack in dead zone
            // NO INNER to DEAD transitions - circles cannot enter dead zone
        ]);

        // Settings state - must be defined before updateTurnDisplay() is called
        window.gameSettings = {
            soundEffects: true,
            music: false,
            coordinates: false,
            highlightMoves: true,
            animationSpeed: 2,
            confirmMoves: false,
            showThreats: true,
            showLastMove: false,
            fogOfWar: false,
            fogRadius: 2,
            currentMusicTrack: 0
        };
        // Ensure base defense variant is tracked in settings
        if (typeof window.gameSettings.baseDefenseVariant === 'undefined') {
            window.gameSettings.baseDefenseVariant = window.baseDefenseVariant || 'original';
        }

        // Simple move history for undo (stack of last actions)
        const moveHistory = []; // entries: {fromId,toId,pieceClass,capturedHTML,endedTurn,isTriangle}
        
        // Captured pieces tracking
        const capturedWhitePieces = []; // Array of piece characters: 'S', 'T', 'R', 'C', 'H'
        const capturedBlackPieces = []; // Array of piece characters: 's', 't', 'r', 'c', 'h'
        
        // Initialize turn display
        updateTurnDisplay();
        
        // Initialize base defence display
        updateBaseDefenceDisplay();

        // ===== BASE DEFENSE VARIANT LOGIC =====
    // Variant: 'original' (only rhombus can defend base), 'shape-defense' (shapes defend base)
    window.baseDefenseVariant = 'original'; // Default, will be set by UI

        // Helper: Check if a piece is defending the base
        function isDefendingBase(pieceType, isWhite) {
            // 'original' : only rhombus defends the base
            // 'shape-defense' : any attacking shape can defend the base
            if (window.baseDefenseVariant === 'original') {
                return pieceType === 'rhombus';
            } else if (window.baseDefenseVariant === 'shape-defense') {
                return true;
            }
            return false;
        }

        // Helper: Get base hex for each player
        function getBaseHex(isWhite) {
            // Standard base hexes (updated to match win conditions)
            return isWhite ? '3-0' : '3-8';
        }

        // Helper: Is a piece currently defending its base?
        function isBaseDefended(isWhite) {
            const baseHex = getBaseHex(isWhite);
            const piece = document.querySelector(`.hexagon[data-coords='${baseHex}'] .piece`);
            if (!piece) return false;
            const pieceType = getPieceTypeFromClass(piece.className);
            return isDefendingBase(pieceType, isWhite);
        }

        // Helper: Get piece type from className
        function getPieceTypeFromClass(className) {
            if (className.includes('rhombus')) return 'rhombus';
            if (className.includes('square')) return 'square';
            if (className.includes('triangle')) return 'triangle';
            if (className.includes('circle')) return 'circle';
            if (className.includes('hexgon')) return 'hexgon';
            return null;
        }

        // Enforce base defense rule on move
        function enforceBaseDefenseRule(fromHexId, toHexId, piece, isWhite) {
            // If moving from base hex, check if move is legal under current variant
            const baseHexCoords = getBaseHex(isWhite); // e.g., '3-1'
            const baseHex = 'hex-' + baseHexCoords; // canonical 'hex-3-1'
            const oppBaseHex = 'hex-' + getBaseHex(!isWhite); // Opponent's base hex (for win)
            const pieceType = getPieceTypeFromClass(piece.className);

            // Normalize fromHexId in case callers pass '3-1' vs 'hex-3-1'
            const normalize = id => (id && id.startsWith('hex-')) ? id : ('hex-' + id);
            const fromIdCanonical = normalize(fromHexId);

            if (fromIdCanonical === baseHex) {
                    if (window.baseDefenseVariant === 'original') {
                    // Only rhombus can leave the base
                    if (pieceType !== 'rhombus') {
                        showBaseDefenseWarning();
                        return false;
                    }
                    // If rhombus, allow move to any hex (including opponent's base)
                } else if (window.baseDefenseVariant === 'shape-defense') {
                    // Shape defense: rhombus cannot move to opponent's base if that destination base is under attack
                    if (pieceType === 'rhombus' && toHexId === oppBaseHex) {
                        // Check if the opponent's base hex (the destination) is under threat by the opponent
                        const [, destRow, destCol] = oppBaseHex.match(/hex-(\d+)-(\d+)/);
                        // Simulate placing the rhombus at the destination and check if the opponent
                        // would be able to attack that square (captures the rhombus). This avoids
                        // false negatives caused by path blockers that would be removed/changed
                        // in the post-move position.
                        try {
                            const destHexEl = document.getElementById('hex-' + destRow + '-' + destCol);
                            let temp = null;
                            if (destHexEl) {
                                temp = document.createElement('div');
                                // Use appropriate color for the simulated rhombus so piece checkers behave
                                temp.className = isWhite ? 'rhombus-piece white-rhombus' : 'rhombus-piece';
                                temp.setAttribute('data-temp-simulation', 'true');
                                destHexEl.appendChild(temp);
                            }
                            const attackable = isPieceUnderThreat(parseInt(destRow), parseInt(destCol), !isWhite);
                            // enforcement simulation log removed
                            if (temp) temp.remove();
                            if (attackable) {
                                showShapeDefenseWarning(pieceType);
                                return false;
                            }
                        } catch (e) {
                            // simulation error logging removed
                        }
                    }
                }
            }
            return true;
        }

        // Show popup/warning for illegal base defense move
        function showBaseDefenseWarning() {
            alert('‚ùå Illegal move: Only the allowed piece(s) can leave the base in this variant!');
        }

        // Check if a piece can leave base under shape defense rules
        function canLeaveBaseUnderShapeDefense(pieceType, isWhite) {
            // Shape defense only applies to rhombus - other pieces can always leave
            if (pieceType !== 'rhombus') return true;

            // This function is no longer used for rhombus - rhombus movement to opponent's base
            // is now checked separately in enforceBaseDefenseRule
            return true;
        }

    // Debug tracing removed

        // Helper: check if a square (row,col) is attackable by pieces of a given color
        function isSquareAttackableByColor(row, col, attackerIsWhite) {
            // isSquareAttackableByColor tracing removed
            const attackerSelectors = attackerIsWhite ?
                ['.square-piece.white-piece', '.triangle-piece.white-triangle', '.rhombus-piece.white-rhombus', '.circle-piece.white-circle', '.hexgon-piece.white-hexgon'] :
                ['.square-piece:not(.white-piece)', '.triangle-piece:not(.white-triangle)', '.rhombus-piece:not(.white-rhombus)', '.circle-piece:not(.white-circle)', '.hexgon-piece:not(.white-hexgon)'];

            for (let sel of attackerSelectors) {
                const attackers = document.querySelectorAll(sel);
                for (let attacker of attackers) {
                    try {
                        if (attacker.style.display === 'none' || attacker.hasAttribute('data-temp-simulation')) continue;
                        const attackerHex = attacker.closest('.hexagon');
                        if (!attackerHex) continue;
                        const [, aRow, aCol] = attackerHex.id.match(/hex-(\d+)-(\d+)/);
                        const canAttack = canPieceActuallyAttack(parseInt(aRow), parseInt(aCol), row, col, attacker);
                        // per-attacker tracing removed
                        if (canAttack) {
                            // per-attacker positive trace removed
                            return true;
                        }
                    } catch (e) {
                        // per-attacker error logging removed
                        continue;
                    }
                }
            }
            // Fallback: use existing isPieceUnderThreat helper which enumerates opponent pieces
            // and may catch cases missed by the selector-based scan (especially complex circle
            // perimeter checks). Note: isPieceUnderThreat expects the 'isWhite' parameter
            // indicating the color of the piece being checked; here we invert attackerIsWhite
            // to pass the correct side.
            try {
                const fallback = isPieceUnderThreat(row, col, !attackerIsWhite);
                // fallback tracing removed
                if (fallback) {
                    // fallback positive trace removed
                    return true;
                }
            } catch (e) {
                // fallback error logging removed
            }
            return false;
        }

        // Show popup/warning for shape defense violation
        function showShapeDefenseWarning(pieceType) {
            if (pieceType === 'rhombus') {
                alert('Shape Defense: Cannot escape - your base is not under threat. Position your shapes to defend the base first.');
            } else {
                alert(`‚ùå Illegal move: ${pieceType} cannot leave base under shape defense rules!`);
            }
        }

        // Patch into move logic: before allowing a move from base, enforce rule
        // Find the main move handler (drag/drop or click move)
        // Example: in handlePieceMove or similar, add:
        // if (!enforceBaseDefenseRule(fromHexId, toHexId, piece, isWhite)) return;

        // --- PATCH DRAG/DROP LOGIC ---
        // Find setupDragAndDrop and patch drop handler:
        // (This is a comment for the next patch step)
        
        // Initialize threat highlighting
        highlightThreatenedPieces();

        function setGatewayHighlight(active) {
            const hexes = document.querySelectorAll('.gateway-highlight');
            hexes.forEach(hex => hex.classList.remove('gateway-highlight'));
            if (!active) return;
            try {
                const all = new Set([].concat(
                    ...Array.from(circleGateways.entries()).map(([k, v]) => [k, ...v])
                ));
                all.forEach(id => {
                    const [r,c] = id.split('-');
                    const hex = document.getElementById(`hex-${r}-${c}`);
                    if (hex) hex.classList.add('gateway-highlight');
                });
            } catch (e) { /* ignore */ }
        }
        
        // Test function - add to window for debugging
        window.testThreats = function() {
            console.log('Testing threat detection...');
            highlightThreatenedPieces();
        };
        
        // Test function to manually apply threat highlighting
        window.testThreatHighlight = function() {
            console.log('Testing threat highlight CSS...');
            const hex = document.getElementById('hex-5-4');
            if (hex) {
                hex.classList.add('highlight-threat');
                console.log('Applied highlight-threat to hex-5-4');
                console.log('Element classes:', hex.className);
            } else {
                console.log('hex-5-4 not found');
            }
        };
        
        // Undo last move
        function undoLastMove() {
            setGatewayHighlight(false);
            if (moveHistory.length === 0) return;
            const last = moveHistory.pop();
            const toHex = document.getElementById(last.toId);
            const fromHex = document.getElementById(last.fromId);
            if (!toHex || !fromHex) return;

            // Remove piece from destination (including hexgon-piece!)
            const movedPiece = toHex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
            if (movedPiece) movedPiece.remove();

            // Restore piece back to origin
            const piece = document.createElement('div');
            piece.className = last.pieceClass;
            piece.draggable = true;
            fromHex.appendChild(piece);

            // Restore captured piece if any and remove one eliminated-panel entry
            if (last.capturedHTML) {
                try {
                    const payload = JSON.parse(last.capturedHTML);
                    toHex.insertAdjacentHTML('beforeend', payload.html);
                    const elimId = payload.elimId;
                    if (elimId) {
                        const elimEntry = document.querySelector(`.eliminated-piece[data-eliminated-id="${elimId}"]`);
                        if (elimEntry) elimEntry.remove();
                    }
                } catch(e) {
                    // Fallback to old format if any
                    toHex.insertAdjacentHTML('beforeend', last.capturedHTML);
                }
            }

            // Rebind drag for restored piece (same logic as for new pieces)
            piece.addEventListener('dragstart', function(e) {
                console.log('üé¨ DRAGSTART event triggered for piece at:', this.parentElement.id);
                console.log('  Piece classes:', this.className);
                
                if (gameOver || !isCurrentPlayerPiece(this)) {
                    console.log('‚ùå DRAGSTART blocked: gameOver or not current player piece');
                    e.preventDefault();
                    return;
                }
                if (currentTurnPiece && currentTurnPiece !== this.parentElement) {
                    console.log('‚ùå DRAGSTART blocked: already moved a piece this turn');
                    e.preventDefault();
                    alert('You can only move or rotate one piece per turn!');
                    return;
                }
                console.log('‚úÖ DRAGSTART proceeding...');
                
                draggedPiece = this;
                draggedFromHex = this.parentElement;
                selectedPiece = this.parentElement;
                currentTurnPiece = this.parentElement;
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/html', this.outerHTML);

                const hexId = this.parentElement.id;
                const [, row, col] = hexId.match(/hex-(\d+)-(\d+)/);
                console.log('üìç Piece position:', row, col);
                
                const rotationControls = document.getElementById('rotation-controls');
                if (rotationControls) {
                    if (this.classList.contains('triangle-piece') || this.classList.contains('hexgon-piece')) {
                        rotationControls.style.display = 'block';
                    } else {
                        rotationControls.style.display = 'none';
                    }
                }
                
                console.log('üé¨ [UNDO HANDLER] Showing movement pattern for:', this.className);
                console.log('Is circle?', this.classList.contains('circle-piece'));
                console.log('Is hexgon?', this.classList.contains('hexgon-piece'));
                console.log('Is triangle?', this.classList.contains('triangle-piece'));
                console.log('Is rhombus?', this.classList.contains('rhombus-piece'));
                
                if (this.classList.contains('circle-piece')) {
                    console.log('üìû Calling showCircleMovementPattern');
                    showCircleMovementPattern(parseInt(row), parseInt(col));
                } else if (this.classList.contains('triangle-piece')) {
                    console.log('üìû Calling showTriangleMovementPattern');
                    // Both white and black triangles use the same rotation-aware movement system
                    showTriangleMovementPattern(parseInt(row), parseInt(col));
                } else if (this.classList.contains('hexgon-piece')) {
                    console.log('üìû Calling showHexgonMovementPattern');
                    showHexgonMovementPattern(parseInt(row), parseInt(col));
                } else if (this.classList.contains('rhombus-piece')) {
                    console.log('üìû Calling showRhombusMovementPattern');
                    showRhombusMovementPattern(parseInt(row), parseInt(col));
                } else {
                    console.log('üìû Calling showSquareMovementPattern');
                    showSquareMovementPattern(parseInt(row), parseInt(col));
                }
            });
            piece.addEventListener('dragend', function(e) {
        document.querySelectorAll('.hexagon').forEach(hex => {
                    hex.classList.remove('highlight-green', 'highlight-red', 'highlight-danger', 'highlight-diagonal', 'highlight-gray');
                });
                draggedPiece = null;
                draggedFromHex = null;
                // Keep selection for triangles and hexagons so rotation buttons remain available
                if (!this.classList.contains('triangle-piece') && !this.classList.contains('hexgon-piece')) {
                    selectedPiece = null;
                    currentTurnPiece = null;
                    const rotationControls = document.getElementById('rotation-controls');
                    if (rotationControls) rotationControls.style.display = 'none';
                    
                    // Also hide mobile rotation controls
                    const mobileRotationControls = document.getElementById('mobile-rotation-controls');
                    if (mobileRotationControls) {
                        mobileRotationControls.style.display = 'none';
                    }
                }
                if (!this.classList.contains('circle-piece')) {
                    setGatewayHighlight(false);
                }
            });

            // If the move ended the turn, revert the turn
            if (last.endedTurn && !gameOver) {
                switchTurn();
            }

            // Reset selection/controls to avoid blocking
            selectedPiece = null;
            currentTurnPiece = null;
            const rotationControls = document.getElementById('rotation-controls');
            if (rotationControls) rotationControls.style.display = 'none';
            
            // Also hide mobile rotation controls
            const mobileRotationControls = document.getElementById('mobile-rotation-controls');
            if (mobileRotationControls) {
                mobileRotationControls.style.display = 'none';
            }

            // Update all pieces under attack after undo
            highlightAllPiecesUnderAttack();
        }
        
        // Test function to check movement patterns
        window.testMovement = function(row, col) {
            console.log(`Testing movement pattern for ${row}-${col}`);
            const hex = document.getElementById(`hex-${row}-${col}`);
            if (hex) {
                const piece = hex.querySelector('.square-piece, .triangle-piece, .rhombus-piece');
                if (piece) {
                    if (piece.classList.contains('square-piece')) {
                        showSquareMovementPattern(row, col);
                    } else if (piece.classList.contains('triangle-piece')) {
                        // Both white and black triangles use the same rotation-aware movement system
                        showTriangleMovementPattern(row, col);
                    } else if (piece.classList.contains('rhombus-piece')) {
                        showRhombusMovementPattern(row, col);
                    }
                } else {
                    console.log('No piece found at this position');
                }
            } else {
                console.log('Hex not found');
            }
        };
        
        // Test function to check if a specific position is highlighted
        window.checkHighlight = function(row, col) {
            const hex = document.getElementById(`hex-${row}-${col}`);
            if (hex) {
                console.log(`Hex ${row}-${col} classes:`, hex.className);
                console.log(`Has highlight-green:`, hex.classList.contains('highlight-green'));
                console.log(`Has highlight-red:`, hex.classList.contains('highlight-red'));
                console.log(`Has highlight-danger:`, hex.classList.contains('highlight-danger'));
                console.log(`Has highlight-threat:`, hex.classList.contains('highlight-threat'));
            } else {
                console.log('Hex not found');
            }
        };
        

        // Start menu functionality
        // Function to initialize board for game mode
        function initializeBoard(mode) {
            gameMode = mode;
            
            // If Square Attack mode, replace triangles, circles, and hexgons with squares
            if (mode === 'square-attack') {
                // Replace white triangle at 1-0 with square
                const hex10 = document.getElementById('hex-1-0');
                const triangle10 = hex10.querySelector('.triangle-piece');
                if (triangle10) {
                    triangle10.remove();
                    const square = document.createElement('div');
                    square.className = 'square-piece white-piece';
                    square.draggable = true;
                    hex10.appendChild(square);
                }
                
                // Replace black triangle at 1-6 with square
                const hex16 = document.getElementById('hex-1-6');
                const triangle16 = hex16.querySelector('.triangle-piece');
                if (triangle16) {
                    triangle16.remove();
                    const square = document.createElement('div');
                    square.className = 'square-piece';
                    square.draggable = true;
                    hex16.appendChild(square);
                }
                
                // Replace white circle at 2-0 with square
                const hex20 = document.getElementById('hex-2-0');
                const circle20 = hex20.querySelector('.circle-piece');
                if (circle20) {
                    circle20.remove();
                    const square = document.createElement('div');
                    square.className = 'square-piece white-piece';
                    square.draggable = true;
                    hex20.appendChild(square);
                }
                
                // Replace black hexgon at 2-7 with square
                const hex27 = document.getElementById('hex-2-7');
                const hexgon27 = hex27.querySelector('.hexgon-piece');
                if (hexgon27) {
                    hexgon27.remove();
                    const square = document.createElement('div');
                    square.className = 'square-piece';
                    square.draggable = true;
                    hex27.appendChild(square);
                }
                
                // Replace white hexgon at 4-0 with square
                const hex40 = document.getElementById('hex-4-0');
                const hexgon40 = hex40.querySelector('.hexgon-piece');
                if (hexgon40) {
                    hexgon40.remove();
                    const square = document.createElement('div');
                    square.className = 'square-piece white-piece';
                    square.draggable = true;
                    hex40.appendChild(square);
                }
                
                // Replace black circle at 4-7 with square
                const hex47 = document.getElementById('hex-4-7');
                const circle47 = hex47.querySelector('.circle-piece');
                if (circle47) {
                    circle47.remove();
                    const square = document.createElement('div');
                    square.className = 'square-piece';
                    square.draggable = true;
                    hex47.appendChild(square);
                }
                
                // Replace white triangle at 5-0 with square
                const hex50 = document.getElementById('hex-5-0');
                const triangle50 = hex50.querySelector('.triangle-piece');
                if (triangle50) {
                    triangle50.remove();
                    const square = document.createElement('div');
                    square.className = 'square-piece white-piece';
                    square.draggable = true;
                    hex50.appendChild(square);
                }
                
                // Replace black triangle at 5-6 with square
                const hex56 = document.getElementById('hex-5-6');
                const triangle56 = hex56.querySelector('.triangle-piece');
                if (triangle56) {
                    triangle56.remove();
                    const square = document.createElement('div');
                    square.className = 'square-piece';
                    square.draggable = true;
                    hex56.appendChild(square);
                }
            }
            
            // If Hexagon Siege mode, replace triangles, circles, and squares with hexagons
            if (mode === 'hexagon-siege') {
                // Replace white triangle at 1-0 with hexagon
                const hex10 = document.getElementById('hex-1-0');
                const triangle10 = hex10.querySelector('.triangle-piece');
                if (triangle10) {
                    triangle10.remove();
                    const hexagon = document.createElement('div');
                    hexagon.className = 'hexgon-piece white-hexgon';
                    hexagon.draggable = true;
                    hex10.appendChild(hexagon);
                }
                
                // Replace black triangle at 1-6 with hexagon
                const hex16 = document.getElementById('hex-1-6');
                const triangle16 = hex16.querySelector('.triangle-piece');
                if (triangle16) {
                    triangle16.remove();
                    const hexagon = document.createElement('div');
                    hexagon.className = 'hexgon-piece';
                    hexagon.draggable = true;
                    hex16.appendChild(hexagon);
                }
                
                // Replace white circle at 2-0 with hexagon
                const hex20 = document.getElementById('hex-2-0');
                const circle20 = hex20.querySelector('.circle-piece');
                if (circle20) {
                    circle20.remove();
                    const hexagon = document.createElement('div');
                    hexagon.className = 'hexgon-piece white-hexgon';
                    hexagon.draggable = true;
                    hex20.appendChild(hexagon);
                }
                
                // Replace white square at 3-0 with hexagon
                const hex30 = document.getElementById('hex-3-0');
                const square30 = hex30.querySelector('.square-piece');
                if (square30) {
                    square30.remove();
                    const hexagon = document.createElement('div');
                    hexagon.className = 'hexgon-piece white-hexgon';
                    hexagon.draggable = true;
                    hex30.appendChild(hexagon);
                }
                
                // Replace black square at 3-7 with hexagon
                const hex37 = document.getElementById('hex-3-7');
                const square37 = hex37.querySelector('.square-piece');
                if (square37) {
                    square37.remove();
                    const hexagon = document.createElement('div');
                    hexagon.className = 'hexgon-piece';
                    hexagon.draggable = true;
                    hex37.appendChild(hexagon);
                }
                
                // Replace black circle at 4-7 with hexagon
                const hex47 = document.getElementById('hex-4-7');
                const circle47 = hex47.querySelector('.circle-piece');
                if (circle47) {
                    circle47.remove();
                    const hexagon = document.createElement('div');
                    hexagon.className = 'hexgon-piece';
                    hexagon.draggable = true;
                    hex47.appendChild(hexagon);
                }
                
                // Replace white triangle at 5-0 with hexagon
                const hex50 = document.getElementById('hex-5-0');
                const triangle50 = hex50.querySelector('.triangle-piece');
                if (triangle50) {
                    triangle50.remove();
                    const hexagon = document.createElement('div');
                    hexagon.className = 'hexgon-piece white-hexgon';
                    hexagon.draggable = true;
                    hex50.appendChild(hexagon);
                }
                
                // Replace black triangle at 5-6 with hexagon
                const hex56 = document.getElementById('hex-5-6');
                const triangle56 = hex56.querySelector('.triangle-piece');
                if (triangle56) {
                    triangle56.remove();
                    const hexagon = document.createElement('div');
                    hexagon.className = 'hexgon-piece';
                    hexagon.draggable = true;
                    hex56.appendChild(hexagon);
                }
            }
            
            // Re-setup drag and drop for all pieces
            setupDragAndDrop();
        }

        // Setup menu event listeners with null checks
        const gameBtn = document.getElementById('start-game-btn');
        if (gameBtn) {
            gameBtn.addEventListener('click', function() {
                // Show game variants modal for PVP mode
                openGameVariantsModal('pvp');
            });
        }
        
        const aiModeBtn = document.getElementById('start-ai-mode-btn');
        if (aiModeBtn) {
            aiModeBtn.addEventListener('click', function() {
                // Show game variants modal for AI mode
                openGameVariantsModal('ai');
            });
        }
        
        const llmModeBtn = document.getElementById('start-llm-mode-btn');
        if (llmModeBtn) {
            llmModeBtn.addEventListener('click', function() {
                // Show game variants modal for LLM mode
                openGameVariantsModal('llm');
            });
        }
        
        const gameModesBtn = document.getElementById('start-game-modes-btn');
        if (gameModesBtn) {
            gameModesBtn.addEventListener('click', function() {
                // Show game modes modal
                openGameModesModal();
            });
        }
        
        const multiplayerBtn = document.getElementById('start-multiplayer-btn');
        if (multiplayerBtn) {
            multiplayerBtn.addEventListener('click', function() {
                // Show multiplayer modal
                openMultiplayerModal();
            });
        }

        const puzzlesBtn = document.getElementById('start-puzzles-btn');
        if (puzzlesBtn) {
            puzzlesBtn.addEventListener('click', function() {
                // Show puzzles modal
                openPuzzlesModal();
            });
        }

        // ========== PUZZLE FUNCTIONALITY ==========
        
        let puzzleMode = false;
        let currentPuzzle = null;
        let puzzleMoves = 0;
        let puzzleMaxMoves = 0;
        
        // Puzzle definitions
        const puzzles = {
            'escape-easy-1': {
                name: 'Escape Easy #1',
                type: 'escape',
                maxMoves: 2,
                startPlayer: 'white',
                description: 'Move the white rhombus to position 3-8 in 2 moves',
                goalPosition: '3-8',
                goalPiece: 'white-rhombus',
                initialBoard: {
                    '3-6': { piece: 'rhombus-piece white-rhombus', draggable: true }
                }
            },
            'checkmate-1': {
                name: 'Tactical Checkmate #1',
                type: 'checkmate',
                maxMoves: 3,
                startPlayer: 'white',
                description: 'White to move and win. Can you find the winning sequence?',
                goalPiece: 'capture-black-rhombus',
                initialBoard: {
                    '4-6': { piece: 'triangle-piece', draggable: true },
                    '2-6': { piece: 'triangle-piece', draggable: true },
                    '3-5': { piece: 'rhombus-piece white-rhombus', draggable: true },
                    '3-3': { piece: 'rhombus-piece', draggable: true },
                    '4-0': { piece: 'triangle-piece white-triangle', draggable: true }
                }
            }
        };
        
        function openPuzzlesModal() {
            document.getElementById('puzzles-modal').style.display = 'flex';
        }
        
        function closePuzzlesModal() {
            document.getElementById('puzzles-modal').style.display = 'none';
        }
        
        function startPuzzle(puzzleId) {
            const puzzle = puzzles[puzzleId];
            if (!puzzle) {
                alert('Puzzle not found!');
                return;
            }
            
            currentPuzzle = puzzle;
            puzzleMode = true;
            puzzleMoves = 0;
            puzzleMaxMoves = puzzle.maxMoves;
            
            // Close modals
            closePuzzlesModal();
            document.getElementById('start-menu').style.display = 'none';
            
            // Show game board
            document.getElementById('board-display-container').style.display = 'block';
            
            // Clear the board
            clearBoard();
            
            // Set up puzzle board
            setupPuzzleBoard(puzzle);
            
            // Set current player
            currentPlayer = puzzle.startPlayer;
            gameOver = false;
            aiEnabled = false;
            
            // Update UI
            updateTurnDisplay();
            highlightThreatenedPieces();
            
            // Show puzzle info
            showPuzzleInfo();
        }
        
        function clearBoard() {
            // Remove all pieces from board
            document.querySelectorAll('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece').forEach(piece => {
                piece.remove();
            });
        }
        
        function setupPuzzleBoard(puzzle) {
            // Place pieces according to puzzle configuration
            for (const [hexId, config] of Object.entries(puzzle.initialBoard)) {
                const hex = document.getElementById(`hex-${hexId}`);
                if (hex) {
                    const piece = document.createElement('div');
                    piece.className = config.piece;
                    piece.draggable = config.draggable;
                    hex.appendChild(piece);
                }
            }
            
            // Re-setup drag and drop
            setupDragAndDrop();
        }
        
        function showPuzzleInfo() {
            // Create puzzle info panel
            let infoPanel = document.getElementById('puzzle-info-panel');
            if (!infoPanel) {
                infoPanel = document.createElement('div');
                infoPanel.id = 'puzzle-info-panel';
                infoPanel.style.cssText = `
                    position: fixed;
                    top: 100px;
                    left: 20px;
                    background: #262421;
                    border: 1px solid #ffd700;
                    border-radius: 8px;
                    padding: 15px;
                    color: white;
                    z-index: 9999;
                    text-align: center;
                    width: 200px;
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
                `;
                document.body.appendChild(infoPanel);
            }
            
            infoPanel.innerHTML = `
                <h3 style="color: #ffd700; margin: 0 0 8px 0; font-size: 0.95em;">üß© ${currentPuzzle.name}</h3>
                <p style="margin: 0 0 10px 0; color: #ccc; font-size: 0.85em; line-height: 1.3;">${currentPuzzle.description}</p>
                <div style="font-size: 0.95em; color: #4ecdc4; margin-bottom: 10px;">
                    <strong>Moves:</strong><br/>
                    <span id="puzzle-move-counter" style="font-size: 1.3em;">${puzzleMoves}</span> / ${puzzleMaxMoves}
                </div>
                <button onclick="resetPuzzle()" style="
                    background: #ff6b6b;
                    color: white;
                    border: none;
                    padding: 6px 12px;
                    border-radius: 5px;
                    cursor: pointer;
                    margin: 3px;
                    font-size: 0.9em;
                    width: calc(50% - 6px);
                ">üîÑ Reset</button>
                <button onclick="exitPuzzle()" style="
                    background: #555;
                    color: white;
                    border: none;
                    padding: 6px 12px;
                    border-radius: 5px;
                    cursor: pointer;
                    margin: 3px;
                    font-size: 0.9em;
                    width: calc(50% - 6px);
                ">‚Üê Exit</button>
            `;
        }
        
        function updatePuzzleMoves() {
            puzzleMoves++;
            const counter = document.getElementById('puzzle-move-counter');
            if (counter) {
                counter.textContent = puzzleMoves;
            }
            
            // Check if puzzle is solved
            checkPuzzleSolution();
            
            // Check if out of moves
            if (puzzleMoves >= puzzleMaxMoves && !gameOver) {
                setTimeout(() => {
                    if (!checkPuzzleSolution()) {
                        alert('‚ùå Out of moves! Try again.');
                        resetPuzzle();
                    }
                }, 500);
            }
        }
        
        function checkPuzzleSolution() {
            if (!currentPuzzle) return false;
            
            if (currentPuzzle.type === 'escape') {
                // Check if the goal piece is at the goal position
                const goalHex = document.getElementById(`hex-${currentPuzzle.goalPosition}`);
                if (goalHex) {
                    const piece = goalHex.querySelector(`.${currentPuzzle.goalPiece.replace(' ', '.')}`);
                    if (piece) {
                        // Puzzle solved!
                        setTimeout(() => {
                            playWinSound();
                            alert(`üéâ Puzzle Solved! You completed it in ${puzzleMoves} moves!`);
                            exitPuzzle();
                        }, 500);
                        return true;
                    }
                }
            }
            return false;
        }
        
        function resetPuzzle() {
            if (currentPuzzle) {
                puzzleMoves = 0;
                clearBoard();
                setupPuzzleBoard(currentPuzzle);
                currentPlayer = currentPuzzle.startPlayer;
                updateTurnDisplay();
                showPuzzleInfo();
            }
        }
        
        function exitPuzzle() {
            puzzleMode = false;
            currentPuzzle = null;
            puzzleMoves = 0;
            
            // Remove puzzle info panel
            const infoPanel = document.getElementById('puzzle-info-panel');
            if (infoPanel) {
                infoPanel.remove();
            }
            
            // Show start menu
            showStartMenu();
        }

        // ========== TIMER FUNCTIONALITY ==========
        
        let timerEnabled = false;
        let whiteTimeLeft = 600; // seconds (10 minutes)
        let blackTimeLeft = 600;
        let timerInterval = null;
        let selectedGameMode = null; // To store which game mode was selected
        // Renamed for Game Variants Modal
        window.openGameVariantsModal = function(gameMode) {
            selectedGameMode = gameMode;
            // Show appropriate modal based on game mode
            if (gameMode === 'ai' || gameMode === 'llm') {
                document.getElementById('game-variants-ai-modal').style.display = 'flex';
            } else {
                document.getElementById('game-variants-pvp-modal').style.display = 'flex';
            }
        }

        function closeAIVariantsModal() {
            document.getElementById('game-variants-ai-modal').style.display = 'none';
            // Don't reset selectedGameMode here - it's needed for startGameWithTime()
        }

        function closePVPVariantsModal() {
            document.getElementById('game-variants-pvp-modal').style.display = 'none';
            // Don't reset selectedGameMode here - it's needed for startGameWithTime()
        }
        
        // Legacy support - keep old function name working
        function closeGameVariantsModal() {
            closeAIVariantsModal();
            closePVPVariantsModal();
        }
        
        // AI Difficulty Selection
        window.selectAIDifficulty = function(difficulty) {
            window.aiDifficulty = difficulty;
            
            // Update visual selection
            const buttons = ['ai-diff-easy', 'ai-diff-medium', 'ai-diff-hard'];
            buttons.forEach(btnId => {
                const btn = document.getElementById(btnId);
                if (btn) {
                    btn.classList.remove('selected');
                    btn.style.border = '3px solid transparent';
                }
            });
            
            const selectedBtn = document.getElementById('ai-diff-' + difficulty);
            if (selectedBtn) {
                selectedBtn.classList.add('selected');
                selectedBtn.style.border = '3px solid #ffd700';
            }
            
            // Update description
            const desc = document.getElementById('ai-difficulty-desc');
            if (desc) {
                if (difficulty === 'easy') {
                    desc.textContent = 'Easy: AI makes random moves from weaker options.';
                } else if (difficulty === 'medium') {
                    desc.textContent = 'Medium: AI considers good moves but not perfect.';
                } else if (difficulty === 'hard') {
                    desc.textContent = 'Hard: AI plays optimally with full strategy.';
                }
            }
        }
        
        function startGameWithTime(minutes) {
            closeGameVariantsModal();
            
            // Hide splash page and start menu
            const splashPage = document.getElementById('splash-page');
            if (splashPage) splashPage.style.display = 'none';
            
            // Set timer
            if (minutes > 0) {
                timerEnabled = true;
                whiteTimeLeft = minutes * 60;
                blackTimeLeft = minutes * 60;
                updateTimerDisplay();
                document.getElementById('player-timers').style.display = 'flex';
            } else {
                timerEnabled = false;
                document.getElementById('player-timers').style.display = 'none';
            }
            
            // Hide start menu
            document.getElementById('start-menu').style.display = 'none';
            // Show game board
            document.getElementById('board-display-container').style.display = 'block';
            
            // Mark that we're now in an active game
            gameInProgress = true;
            
            // Initialize game based on selected mode
            if (selectedGameMode === 'pvp') {
            initializeBoard('full');
                aiEnabled = false;
            } else if (selectedGameMode === 'ai') {
                initializeBoard('full');
                aiEnabled = true;
                llmMode = false;
            } else if (selectedGameMode === 'llm') {
                document.getElementById('ai-reasoning-panel').style.display = 'block';
                initializeBoard('full');
                aiEnabled = true;
                llmMode = true;
                currentAIModel = 'claude-sonnet';
            }
            
            // Reset game state
            currentTurnPiece = null;
            escapeRaceNotificationShown = false;
            clearMovementHistory();
            clearMoveRepetitions();
            clearCoordinateLabels();
            highlightThreatenedPieces();
            updateAIModelDisplay();
            
            // Update turn display
            updateTurnDisplay();
            
            // Start timer if enabled
            if (timerEnabled) {
                startTimer();
            }
            
            // Debug: Log AI state after initialization
            const buildTime = '2025-10-21 11:15:00';
            console.log('üèóÔ∏è Build time:', buildTime);
            console.log('üéÆ Game initialized:', {
                mode: selectedGameMode,
                aiEnabled,
                currentPlayer,
                gameOver
            });
            
            console.log('üéÆ Initial board state check:');
            console.log('  White rhombuses:', document.querySelectorAll('.rhombus-piece.white-rhombus').length);
            console.log('  Black rhombuses:', document.querySelectorAll('.rhombus-piece:not(.white-rhombus)').length);
            
            // Check if AI should move immediately (which would be wrong!)
            if (aiEnabled && currentPlayer === 'white') {
                console.error('‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è BUG DETECTED: currentPlayer is WHITE at game start! AI will move immediately!');
            } else if (aiEnabled && currentPlayer === 'black') {
                console.log('‚úÖ Correct: currentPlayer is BLACK at start. Player should move first.');
            }
            
            // Show ChatGPT button if enabled
            console.log('üéØ About to call showChatGPTButton()...');
            showChatGPTButton();
            console.log('üéØ Finished calling showChatGPTButton()');
            
            // Notify keyboard systems that game has started
            const gameStartEvent = new CustomEvent('gameStarted', {
                detail: {
                    mode: selectedGameMode,
                    isPVP: selectedGameMode === 'pvp',
                    currentPlayer,
                    gameOver
                }
            });
            console.log('üì° Dispatching gameStarted event:', gameStartEvent.detail);
            document.dispatchEvent(gameStartEvent);
            
            // DIRECT ACTIVATION: Don't rely on event listeners - call router directly
            if (window.keyboardRouter) {
                console.log('üéÆ DIRECT: Activating keyboard for mode:', selectedGameMode === 'pvp' ? 'PVP' : 'GENERAL');
                if (selectedGameMode === 'pvp') {
                    window.keyboardRouter.activatePVPSystem();
                } else {
                    window.keyboardRouter.activateGeneralSystem();
                }
            }
            
            // Reset selectedGameMode after game starts
            selectedGameMode = null;
            
            // Note: AI will trigger automatically when it becomes White's turn
        }
        
        // ============================================
        // SANDBOX MODE FUNCTIONS
        // ============================================
        
        let sandboxMode = false;
        let sandboxEditMode = false;
        
        function startSandboxMode() {
            console.log('üõ†Ô∏è Starting Sandbox Mode...');
            
            // Hide user home
            hideUserHome();
            
            // Hide splash page and start menu
            const splashPage = document.getElementById('splash-page');
            if (splashPage) splashPage.style.display = 'none';
            document.getElementById('start-menu').style.display = 'none';
            
            // Show game board
            document.getElementById('board-display-container').style.display = 'block';
            
            // Show sandbox tools panel
            document.getElementById('sandbox-tools-panel').style.display = 'block';
            
            // Initialize board with standard starting position
            initializeBoard('full');
            
            // Disable AI
            aiEnabled = false;
            llmMode = false;
            
            // Disable timers
            timerEnabled = false;
            document.getElementById('player-timers').style.display = 'none';
            
            // Mark sandbox mode as active
            sandboxMode = true;
            gameInProgress = true;
            
            // Reset game state
            currentTurnPiece = null;
            clearMovementHistory();
            clearMoveRepetitions();
            clearCoordinateLabels();
            
            // Update turn display
            updateTurnDisplay();
            updateSandboxTurnDisplay();
            
            console.log('‚úÖ Sandbox Mode started');
        }
        
        function toggleSandboxEditMode() {
            const checkbox = document.getElementById('sandbox-edit-mode');
            const pieceSelectorDiv = document.getElementById('sandbox-piece-selector');
            const playCheckbox = document.getElementById('sandbox-play-mode');
            
            sandboxEditMode = checkbox.checked;
            
            if (sandboxEditMode) {
                console.log('‚úèÔ∏è Sandbox Edit Mode ENABLED');
                pieceSelectorDiv.style.display = 'block';
                
                // Disable play mode if it's active
                if (sandboxPlayMode) {
                    playCheckbox.checked = false;
                    toggleSandboxPlayMode();
                }
                
                // Add click listeners to all hexagons
                document.querySelectorAll('.hexagon').forEach(hex => {
                    if (!hex.hasAttribute('data-sandbox-listener')) {
                        hex.addEventListener('click', handleSandboxHexClick);
                        hex.setAttribute('data-sandbox-listener', 'true');
                        hex.style.cursor = 'pointer';
                    }
                });
            } else {
                console.log('‚úèÔ∏è Sandbox Edit Mode DISABLED');
                pieceSelectorDiv.style.display = 'none';
            }
        }
        
        let sandboxPlayMode = false;
        
        function toggleSandboxPlayMode() {
            const checkbox = document.getElementById('sandbox-play-mode');
            const editCheckbox = document.getElementById('sandbox-edit-mode');
            
            sandboxPlayMode = checkbox.checked;
            
            if (sandboxPlayMode) {
                console.log('‚ñ∂Ô∏è Sandbox Play Mode ENABLED - pieces can be moved');
                
                // Disable edit mode if it's active
                if (sandboxEditMode) {
                    editCheckbox.checked = false;
                    toggleSandboxEditMode();
                }
                
                // Make all pieces draggable
                document.querySelectorAll('[class*="-piece"]').forEach(piece => {
                    piece.draggable = true;
                });
                
                // Enable normal game interactions
                gameInProgress = true;
                
            } else {
                console.log('‚ñ∂Ô∏è Sandbox Play Mode DISABLED');
                
                // Disable dragging
                document.querySelectorAll('[class*="-piece"]').forEach(piece => {
                    piece.draggable = false;
                });
            }
        }
        
        function handleSandboxHexClick(event) {
            if (!sandboxEditMode) return;
            
            const hex = event.currentTarget;
            // Parse hex ID like "hex-0-0" to get row and col
            const hexId = hex.id;
            const parts = hexId.split('-');
            const row = parseInt(parts[1]);
            const col = parseInt(parts[2]);
            const selectedPieceType = document.getElementById('sandbox-piece-type').value;
            
            console.log(`üñ±Ô∏è Sandbox hex clicked: [${row}, ${col}], piece: ${selectedPieceType}`);
            
            // Remove existing piece from hex (DOM manipulation)
            const existingPieceDiv = hex.querySelector('[class*="-piece"]');
            if (existingPieceDiv) {
                existingPieceDiv.remove();
                console.log(`üóëÔ∏è Removed piece from [${row}, ${col}]`);
            }
            
            // Place new piece if one was selected
            if (selectedPieceType && selectedPieceType !== '') {
                const [color, shape] = selectedPieceType.split('-');
                
                // Create piece div with correct classes
                const pieceDiv = document.createElement('div');
                
                // Determine the correct class names based on piece type
                if (shape === 'square') {
                    pieceDiv.className = 'square-piece';
                    if (color === 'white') pieceDiv.classList.add('white-piece');
                } else if (shape === 'triangle') {
                    pieceDiv.className = 'triangle-piece';
                    if (color === 'white') {
                        pieceDiv.classList.add('white-triangle');
                    }
                } else if (shape === 'rhombus') {
                    pieceDiv.className = 'rhombus-piece';
                    if (color === 'white') {
                        pieceDiv.classList.add('white-rhombus');
                    }
                } else if (shape === 'circle') {
                    pieceDiv.className = 'circle-piece';
                    if (color === 'white') {
                        pieceDiv.classList.add('white-circle');
                    }
                } else if (shape === 'hexgon') {
                    pieceDiv.className = 'hexgon-piece';
                    if (color === 'white') {
                        pieceDiv.classList.add('white-hexgon');
                    }
                }
                
                // Make piece draggable
                pieceDiv.draggable = true;
                
                // Add to hex
                hex.appendChild(pieceDiv);
                console.log(`‚ûï Placed ${color} ${shape} at [${row}, ${col}]`);
            }
            
            // Update the game state to match the DOM
            syncStateFromDOM();
        }
        
        function syncStateFromDOM() {
            // This function scans the board DOM and updates the state.pieces array
            // Useful after manually placing/removing pieces in sandbox mode
            console.log('üîÑ Syncing state from DOM...');
            
            // We'll keep this simple for now - the drag-and-drop system
            // handles state updates, so we just need to ensure visual consistency
        }
        
        function switchSandboxTurn() {
            currentPlayer = currentPlayer === 'black' ? 'white' : 'black';
            console.log(`üîÑ Switched turn to: ${currentPlayer}`);
            updateTurnDisplay();
            updateSandboxTurnDisplay();
        }
        
        function updateSandboxTurnDisplay() {
            const display = document.getElementById('sandbox-current-turn');
            if (display) {
                display.textContent = currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1);
                display.style.color = currentPlayer === 'white' ? '#fff' : '#333';
                display.style.background = currentPlayer === 'white' ? '#333' : '#fff';
                display.style.padding = '4px 12px';
                display.style.borderRadius = '6px';
                display.style.fontWeight = '700';
            }
        }
        
        function resetSandboxBoard() {
            if (confirm('Reset board to starting position?')) {
                console.log('‚ôªÔ∏è Resetting Sandbox board...');
                initializeBoard('full');
                currentPlayer = 'black';
                clearMovementHistory();
                clearMoveRepetitions();
                renderBoard();
                updateTurnDisplay();
                updateSandboxTurnDisplay();
                console.log('‚úÖ Board reset');
            }
        }
        
        function clearSandboxBoard() {
            if (confirm('Clear all pieces from the board?')) {
                console.log('üóëÔ∏è Clearing Sandbox board...');
                
                // Clear all pieces from DOM
                document.querySelectorAll('.hexagon [class*="-piece"]').forEach(piece => {
                    piece.remove();
                });
                
                // Clear state
                if (typeof state !== 'undefined' && state.pieces) {
                    state.pieces = [];
                }
                
                console.log('‚úÖ Board cleared');
            }
        }
        
        function saveSandboxPosition() {
            const position = {
                pieces: JSON.parse(JSON.stringify(state.pieces)),
                currentPlayer: currentPlayer,
                timestamp: new Date().toISOString()
            };
            
            localStorage.setItem('romgon-sandbox-position', JSON.stringify(position));
            
            alert('‚úÖ Position saved to browser storage!');
            console.log('üíæ Position saved:', position);
        }
        
        function loadSandboxPosition() {
            const savedPosition = localStorage.getItem('romgon-sandbox-position');
            
            if (!savedPosition) {
                alert('‚ùå No saved position found!');
                return;
            }
            
            if (!confirm('Load saved position? (Current position will be lost)')) {
                return;
            }
            
            try {
                const position = JSON.parse(savedPosition);
                state.pieces = position.pieces;
                currentPlayer = position.currentPlayer;
                
                clearMovementHistory();
                clearMoveRepetitions();
                renderBoard();
                updateTurnDisplay();
                updateSandboxTurnDisplay();
                highlightThreatenedPieces();
                
                alert(`‚úÖ Position loaded!\n\nSaved: ${new Date(position.timestamp).toLocaleString()}`);
                console.log('üìÇ Position loaded:', position);
            } catch (error) {
                console.error('‚ùå Error loading position:', error);
                alert('‚ùå Error loading position!');
            }
        }
        
        function exitSandboxMode() {
            if (!confirm('Exit Sandbox Mode?')) {
                return;
            }
            
            console.log('‚ùå Exiting Sandbox Mode...');
            
            // Hide sandbox tools panel
            document.getElementById('sandbox-tools-panel').style.display = 'none';
            
            // Hide board
            document.getElementById('board-display-container').style.display = 'none';
            
            // Reset flags
            sandboxMode = false;
            sandboxEditMode = false;
            gameInProgress = false;
            
            // Uncheck edit mode
            document.getElementById('sandbox-edit-mode').checked = false;
            document.getElementById('sandbox-piece-selector').style.display = 'none';
            
            // Remove sandbox click listeners
            document.querySelectorAll('.hex-cell').forEach(hex => {
                if (hex.hasAttribute('data-sandbox-listener')) {
                    hex.removeEventListener('click', handleSandboxHexClick);
                    hex.removeAttribute('data-sandbox-listener');
                    hex.style.cursor = '';
                }
            });
            
            // Show user home
            showUserHome();
            
            console.log('‚úÖ Exited Sandbox Mode');
        }
        
        // Position Analyzer Functions
        function openPositionAnalyzer() {
            console.log('üîç Opening Position Analyzer...');
            document.getElementById('position-analyzer-modal').style.display = 'block';
            // Auto-analyze on open
            analyzeCurrentPosition();
        }
        
        function closePositionAnalyzer() {
            document.getElementById('position-analyzer-modal').style.display = 'none';
        }
        
        function analyzeCurrentPosition() {
            console.log('üìä Analyzing current position...');
            
            // Count pieces
            const whitePieces = document.querySelectorAll('.hexagon [class*="white-"]').length;
            const blackPieces = document.querySelectorAll('.hexagon [class*="-piece"]:not([class*="white-"])').length;
            
            // Get all pieces on board with their positions
            const pieces = [];
            document.querySelectorAll('.hexagon').forEach(hex => {
                const piece = hex.querySelector('[class*="-piece"]');
                if (piece) {
                    const hexId = hex.id;
                    const parts = hexId.split('-');
                    const row = parseInt(parts[1]);
                    const col = parseInt(parts[2]);
                    
                    const isWhite = piece.classList.contains('white-piece') || 
                                    piece.classList.contains('white-triangle') ||
                                    piece.classList.contains('white-rhombus') ||
                                    piece.classList.contains('white-circle') ||
                                    piece.classList.contains('white-hexgon');
                    
                    let shape = 'square';
                    if (piece.classList.contains('triangle-piece')) shape = 'triangle';
                    else if (piece.classList.contains('rhombus-piece')) shape = 'rhombus';
                    else if (piece.classList.contains('circle-piece')) shape = 'circle';
                    else if (piece.classList.contains('hexgon-piece')) shape = 'hexgon';
                    
                    pieces.push({
                        row, col,
                        color: isWhite ? 'white' : 'black',
                        shape,
                        hexId
                    });
                }
            });
            
            // Calculate legal moves for current player
            const currentPlayerPieces = pieces.filter(p => p.color === currentPlayer);
            let totalMoves = 0;
            
            // Build summary
            const summaryHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                    <div style="text-align: center; padding: 15px; background: rgba(255, 255, 255, 0.1); border-radius: 8px;">
                        <div style="font-size: 2em; margin-bottom: 5px;">‚¨ú</div>
                        <div style="font-size: 1.5em; font-weight: 700;">${whitePieces}</div>
                        <div style="opacity: 0.8;">White Pieces</div>
                    </div>
                    <div style="text-align: center; padding: 15px; background: rgba(255, 255, 255, 0.1); border-radius: 8px;">
                        <div style="font-size: 2em; margin-bottom: 5px;">‚¨õ</div>
                        <div style="font-size: 1.5em; font-weight: 700;">${blackPieces}</div>
                        <div style="opacity: 0.8;">Black Pieces</div>
                    </div>
                </div>
                <div style="padding: 15px; background: rgba(78, 205, 196, 0.2); border-radius: 8px; margin-bottom: 10px;">
                    <strong>Current Turn:</strong> <span style="font-size: 1.2em;">${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)}</span>
                </div>
                <div style="padding: 15px; background: rgba(255, 206, 86, 0.2); border-radius: 8px;">
                    <strong>Active Pieces:</strong> ${currentPlayerPieces.length} pieces can potentially move
                </div>
            `;
            
            document.getElementById('analyzer-summary').innerHTML = summaryHTML;
            document.getElementById('analyzer-moves').style.display = 'block';
            
            // Show piece details
            let movesHTML = '<div style="display: flex; flex-direction: column; gap: 8px;">';
            currentPlayerPieces.forEach((piece, index) => {
                const shapeEmoji = {
                    'square': '‚ñ°',
                    'triangle': '‚ñ≥',
                    'rhombus': '‚óá',
                    'circle': '‚óã',
                    'hexagon': '‚¨°'
                };
                
                movesHTML += `
                    <div style="padding: 10px; background: rgba(255, 255, 255, 0.1); border-radius: 6px; border-left: 4px solid rgba(78, 205, 196, 0.8);">
                        <strong>${shapeEmoji[piece.shape] || '‚óè'} ${piece.shape.charAt(0).toUpperCase() + piece.shape.slice(1)}</strong>
                        at [${piece.row}, ${piece.col}]
                    </div>
                `;
            });
            movesHTML += '</div>';
            
            document.getElementById('analyzer-moves-list').innerHTML = movesHTML;
            
            console.log('‚úÖ Analysis complete');
        }
        
        function exportAnalysis() {
            const summary = document.getElementById('analyzer-summary').innerText;
            const moves = document.getElementById('analyzer-moves-list').innerText;
            
            const exportData = `ROMGON POSITION ANALYSIS\n${'='.repeat(40)}\n\n${summary}\n\n${'='.repeat(40)}\n${moves}`;
            
            // Copy to clipboard
            navigator.clipboard.writeText(exportData).then(() => {
                alert('‚úÖ Analysis exported to clipboard!');
            }).catch(err => {
                console.error('Export failed:', err);
                alert('‚ùå Export failed');
            });
        }
        
        // Puzzle Creator Functions
        function openPuzzleCreator() {
            console.log('üß© Opening Puzzle Creator...');
            document.getElementById('puzzle-creator-modal').style.display = 'block';
            document.getElementById('puzzle-preview').style.display = 'none';
        }
        
        function closePuzzleCreator() {
            document.getElementById('puzzle-creator-modal').style.display = 'none';
        }
        
        function generatePuzzle() {
            const title = document.getElementById('puzzle-title').value || 'Untitled Puzzle';
            const objective = document.getElementById('puzzle-objective').value;
            const difficulty = document.getElementById('puzzle-difficulty').value;
            const hint = document.getElementById('puzzle-hint').value;
            const description = document.getElementById('puzzle-description').value;
            
            // Get current board position
            const pieces = [];
            document.querySelectorAll('.hexagon').forEach(hex => {
                const piece = hex.querySelector('[class*="-piece"]');
                if (piece) {
                    const hexId = hex.id;
                    const parts = hexId.split('-');
                    const row = parseInt(parts[1]);
                    const col = parseInt(parts[2]);
                    
                    const isWhite = piece.classList.contains('white-piece') || 
                                    piece.classList.contains('white-triangle') ||
                                    piece.classList.contains('white-rhombus') ||
                                    piece.classList.contains('white-circle') ||
                                    piece.classList.contains('white-hexgon');
                    
                    let shape = 'square';
                    if (piece.classList.contains('triangle-piece')) shape = 'triangle';
                    else if (piece.classList.contains('rhombus-piece')) shape = 'rhombus';
                    else if (piece.classList.contains('circle-piece')) shape = 'circle';
                    else if (piece.classList.contains('hexgon-piece')) shape = 'hexgon';
                    
                    pieces.push({
                        row, col,
                        color: isWhite ? 'white' : 'black',
                        shape
                    });
                }
            });
            
            const puzzle = {
                title,
                objective,
                difficulty,
                hint: hint || null,
                description: description || null,
                currentTurn: currentPlayer,
                position: {
                    pieces
                },
                created: new Date().toISOString(),
                creator: 'Sandbox Mode'
            };
            
            // Display preview
            document.getElementById('puzzle-preview').style.display = 'block';
            document.getElementById('puzzle-json').textContent = JSON.stringify(puzzle, null, 2);
            
            console.log('‚ú® Puzzle generated:', puzzle);
            alert(`‚úÖ Puzzle "${title}" generated!\n\nDifficulty: ${difficulty}\nPieces: ${pieces.length}`);
        }
        
        function exportPuzzle() {
            const previewDiv = document.getElementById('puzzle-preview');
            const jsonText = document.getElementById('puzzle-json').textContent;
            
            if (!jsonText || previewDiv.style.display === 'none') {
                alert('‚ö†Ô∏è Please generate a puzzle first!');
                return;
            }
            
            // Copy to clipboard
            navigator.clipboard.writeText(jsonText).then(() => {
                alert('‚úÖ Puzzle JSON exported to clipboard!\n\nYou can save this to share or load later.');
            }).catch(err => {
                console.error('Export failed:', err);
                
                // Fallback: Download as file
                const blob = new Blob([jsonText], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'romgon-puzzle.json';
                a.click();
                URL.revokeObjectURL(url);
                
                alert('‚úÖ Puzzle JSON downloaded as file!');
            });
        }
        
        function toggleSandboxSidePanels() {
            const container = document.getElementById('eliminated-pieces-container');
            
            if (!container) {
                console.error('‚ùå eliminated-pieces-container not found');
                return;
            }
            
            if (container.style.display === 'none') {
                container.style.display = 'flex';
                console.log('üëÅÔ∏è Side panels SHOWN');
            } else {
                container.style.display = 'none';
                console.log('üëÅÔ∏è Side panels HIDDEN');
            }
        }

        // ============================================
        // CHAT & MESSAGING FUNCTIONS (Backend Integrated)
        // ============================================

        let chatConnected = false;
        let typingTimeout = null;

        // Initialize chat when user logs in
        function initializeChat() {
            const user = JSON.parse(localStorage.getItem('romgon-user') || '{}');
            
            if (!user.userId && !user.uid && !user.id) {
                console.warn('üí¨ No user found, cannot connect to chat');
                return;
            }

            const userId = user.userId || user.uid || user.id;
            const displayName = user.displayName || user.name || user.email?.split('@')[0] || 'Guest';
            const avatar = displayName.charAt(0).toUpperCase();

            console.log('üí¨ Initializing chat for', displayName, 'ID:', userId);

            // Connect to chat server
            romgonChat.connect(userId, displayName, avatar);

            // Setup event handlers
            setupChatEventHandlers();

            // Load initial data
            romgonChat.loadGlobalHistory();

            chatConnected = true;
        }

        function setupChatEventHandlers() {
            // Online count updates
            romgonChat.on('onlineCount', (data) => {
                const countElement = document.getElementById('online-users-count');
                if (countElement) {
                    countElement.textContent = data.count;
                }
            });

            // Global chat messages
            romgonChat.on('globalMessage', (data) => {
                addGlobalMessageToUI(data);
            });

            romgonChat.on('globalHistory', (data) => {
                const chatContainer = document.getElementById('global-chat-messages');
                if (!chatContainer) return;

                // Clear existing messages
                chatContainer.innerHTML = '';

                // Add history messages
                data.messages.forEach(msg => {
                    addGlobalMessageToUI(msg, false);
                });

                // Scroll to bottom
                chatContainer.scrollTop = chatContainer.scrollHeight;
            });

            // Direct messages
            romgonChat.on('directMessage', (data) => {
                addDirectMessageToUI(data);
                playMessageSound();
            });

            romgonChat.on('directMessagesHistory', (data) => {
                renderDirectMessagesHistory(data);
            });

            // Friend management
            romgonChat.on('friendsList', (data) => {
                updateFriendsList(data.friends);
            });

            romgonChat.on('friendRequestReceived', (data) => {
                showFriendRequestNotification(data);
            });

            romgonChat.on('friendRequestSent', (data) => {
                showNotification('Friend request sent! üë•', 'success');
            });

            romgonChat.on('friendAdded', (data) => {
                showNotification('Friend added! üéâ', 'success');
                romgonChat.loadGlobalHistory(); // Refresh to update friend list
            });

            romgonChat.on('friendRemoved', (data) => {
                showNotification('Friend removed', 'info');
            });

            // User status changes
            romgonChat.on('userOnline', (data) => {
                updateUserOnlineStatus(data.userId, true);
            });

            romgonChat.on('userOffline', (data) => {
                updateUserOnlineStatus(data.userId, false);
            });

            // Typing indicators
            romgonChat.on('userTyping', (data) => {
                showTypingIndicator(data);
            });

            romgonChat.on('userStoppedTyping', (data) => {
                hideTypingIndicator(data.userId);
            });

            // Errors
            romgonChat.on('error', (data) => {
                showNotification(data.error, 'error');
            });
        }

        function showTypingIndicator(data) {
            const { userId, username, chatType, targetUserId } = data;
            
            if (chatType === 'global') {
                // Show typing indicator in global chat
                const chatContainer = document.getElementById('global-chat-messages');
                if (!chatContainer) return;
                
                // Remove existing typing indicator for this user
                const existingIndicator = document.getElementById(`typing-${userId}`);
                if (existingIndicator) return; // Already showing
                
                // Create typing indicator
                const indicator = document.createElement('div');
                indicator.id = `typing-${userId}`;
                indicator.style.cssText = 'padding: 8px; color: #8be9fd; font-style: italic; opacity: 0.8;';
                indicator.textContent = `${username} is typing...`;
                
                chatContainer.appendChild(indicator);
                chatContainer.scrollTop = chatContainer.scrollHeight;
            } else if (chatType === 'direct') {
                // Show typing indicator in direct messages (if viewing that conversation)
                if (romgonChat.currentChatWith === userId) {
                    const dmContainer = document.getElementById('direct-messages-container');
                    if (!dmContainer) return;
                    
                    const existingIndicator = document.getElementById(`typing-dm-${userId}`);
                    if (existingIndicator) return;
                    
                    const indicator = document.createElement('div');
                    indicator.id = `typing-dm-${userId}`;
                    indicator.style.cssText = 'padding: 8px; color: #8be9fd; font-style: italic; opacity: 0.8;';
                    indicator.textContent = `${username} is typing...`;
                    
                    dmContainer.appendChild(indicator);
                    dmContainer.scrollTop = dmContainer.scrollHeight;
                }
            }
        }

        function hideTypingIndicator(userId) {
            // Remove typing indicator from global chat
            const globalIndicator = document.getElementById(`typing-${userId}`);
            if (globalIndicator) {
                globalIndicator.remove();
            }
            
            // Remove typing indicator from direct messages
            const dmIndicator = document.getElementById(`typing-dm-${userId}`);
            if (dmIndicator) {
                dmIndicator.remove();
            }
        }

        function switchChatTab(tab) {
            const globalTab = document.getElementById('global-chat-tab');
            const friendsTab = document.getElementById('friends-chat-tab');
            const globalPanel = document.getElementById('global-chat-panel');
            const friendsPanel = document.getElementById('friends-chat-panel');

            if (tab === 'global') {
                globalTab.style.background = 'linear-gradient(135deg, #ff79c6, #bd93f9)';
                globalTab.style.color = 'white';
                globalTab.style.border = 'none';
                
                friendsTab.style.background = 'rgba(78, 205, 196, 0.2)';
                friendsTab.style.color = '#4ecdc4';
                friendsTab.style.border = '1px solid rgba(78, 205, 196, 0.3)';
                
                globalPanel.style.display = 'block';
                friendsPanel.style.display = 'none';
                
                romgonChat.stopTyping('direct', romgonChat.currentChatWith);
                
                console.log('üí¨ Switched to Global Chat');
            } else if (tab === 'friends') {
                friendsTab.style.background = 'linear-gradient(135deg, #4ecdc4, #45b7aa)';
                friendsTab.style.color = 'white';
                friendsTab.style.border = 'none';
                
                globalTab.style.background = 'rgba(255, 121, 198, 0.2)';
                globalTab.style.color = '#ff79c6';
                globalTab.style.border = '1px solid rgba(255, 121, 198, 0.3)';
                
                globalPanel.style.display = 'none';
                friendsPanel.style.display = 'block';
                
                console.log('üë• Switched to Friends Chat');
            }
        }

        function sendGlobalMessage() {
            const input = document.getElementById('global-chat-input');
            const message = input.value.trim();
            
            if (!message) {
                return;
            }

            // Send via backend
            if (chatConnected && romgonChat.isConnected) {
                romgonChat.sendGlobalMessage(message);
                input.value = '';
                romgonChat.stopTyping('global');
            } else {
                // Fallback to local-only
                const user = JSON.parse(localStorage.getItem('romgon-user') || '{}');
                const userName = user.displayName || user.email?.split('@')[0] || 'Guest';
                const userInitial = userName.charAt(0).toUpperCase();
                
                addGlobalMessageToUI({
                    userId: user.userId || 'local',
                    displayName: userName,
                    avatar: userInitial,
                    message: message,
                    timestamp: new Date().toISOString()
                });
                
                input.value = '';
                showNotification('üí¨ Offline mode - message not sent to server', 'warning');
            }
        }

        function addGlobalMessageToUI(data, scrollToBottom = true) {
            const chatContainer = document.getElementById('global-chat-messages');
            if (!chatContainer) return;

            // Remove "coming soon" message if exists
            const comingSoonMsg = chatContainer.querySelector('[style*="Real-time chat coming soon"]');
            if (comingSoonMsg && comingSoonMsg.parentElement) {
                comingSoonMsg.parentElement.remove();
            }

            const messageDiv = document.createElement('div');
            messageDiv.style.marginBottom = '12px';
            messageDiv.setAttribute('data-message-id', data.id);
            
            const timeAgo = getTimeAgo(new Date(data.timestamp));
            
            messageDiv.innerHTML = `
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                    <div style="
                        width: 24px;
                        height: 24px;
                        border-radius: 50%;
                        background: linear-gradient(135deg, #f57d2d, #fcc49c);
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 12px;
                        font-weight: bold;
                        color: #fff;
                    ">${data.avatar || data.displayName.charAt(0)}</div>
                    <span style="color: #f57d2d; font-weight: 600; font-size: 0.9em;">${escapeHtml(data.displayName)}</span>
                    <span style="color: #666; font-size: 0.75em;">${timeAgo}</span>
                </div>
                <div style="color: #ccc; font-size: 0.9em; padding-left: 32px;">
                    ${escapeHtml(data.message)}
                </div>
            `;
            
            chatContainer.appendChild(messageDiv);
            
            if (scrollToBottom) {
                chatContainer.scrollTop = chatContainer.scrollHeight;
            }
        }

        function addFriend() {
            const input = document.getElementById('add-friend-input');
            const username = input.value.trim();
            
            if (!username) {
                showNotification('Please enter a username', 'warning');
                return;
            }

            if (chatConnected && romgonChat.isConnected) {
                romgonChat.sendFriendRequest(username);
                input.value = '';
            } else {
                showNotification('üí¨ Chat offline - cannot send friend request', 'warning');
            }
        }

        function openFriendChat(friendId) {
            if (!chatConnected || !romgonChat.isConnected) {
                showNotification('üí¨ Chat offline - cannot open conversation', 'warning');
                return;
            }

            // Load DM history
            romgonChat.loadDirectMessages(friendId);
            
            // Mark as read
            romgonChat.markMessagesRead(friendId);
            
            // TODO: Open DM modal/panel
            showNotification(`Opening chat with ${friendId}... üí¨`, 'info');
        }

        function updateFriendsList(friends) {
            const friendsList = document.getElementById('friends-list');
            if (!friendsList) return;

            // Clear current list
            friendsList.innerHTML = '';

            if (friends.length === 0) {
                friendsList.innerHTML = `
                    <div style="text-align: center; color: #666; font-size: 0.85em; padding: 20px; font-style: italic;">
                        Add friends to chat privately and challenge them to games!
                    </div>
                `;
                return;
            }

            // Render each friend
            friends.forEach(friend => {
                const unreadCount = romgonChat.getUnreadCount(friend.userId);
                const isOnline = friend.isOnline || romgonChat.isUserOnline(friend.userId);
                
                const friendDiv = document.createElement('div');
                friendDiv.style.cssText = `
                    background: rgba(78, 205, 196, ${isOnline ? '0.1' : '0.05'});
                    border-left: 3px solid ${isOnline ? '#4ecdc4' : 'rgba(78, 205, 196, 0.3)'};
                    padding: 12px;
                    border-radius: 8px;
                    margin-bottom: 10px;
                    cursor: pointer;
                    transition: all 0.3s;
                `;
                friendDiv.onmouseover = () => friendDiv.style.background = 'rgba(78, 205, 196, 0.2)';
                friendDiv.onmouseout = () => friendDiv.style.background = `rgba(78, 205, 196, ${isOnline ? '0.1' : '0.05'})`;
                friendDiv.onclick = () => openFriendChat(friend.userId);
                
                friendDiv.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <div style="
                            width: 32px;
                            height: 32px;
                            border-radius: 50%;
                            background: linear-gradient(135deg, #4ecdc4, #a55eea);
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-size: 14px;
                            font-weight: bold;
                            color: #fff;
                            position: relative;
                        ">
                            ${friend.userId.charAt(0).toUpperCase()}
                            <div style="
                                position: absolute;
                                bottom: 0;
                                right: 0;
                                width: 10px;
                                height: 10px;
                                background: ${isOnline ? '#26de81' : '#888'};
                                border-radius: 50%;
                                border: 2px solid #23272e;
                            "></div>
                        </div>
                        <div style="flex: 1;">
                            <div style="color: ${isOnline ? '#4ecdc4' : '#888'}; font-weight: 600; font-size: 0.95em;">${friend.userId}</div>
                            <div style="color: #888; font-size: 0.8em;">${isOnline ? 'Online ‚Ä¢ Last seen now' : 'Offline'}</div>
                        </div>
                        ${unreadCount > 0 ? `<div style="background: #ff79c6; color: white; font-size: 0.75em; padding: 3px 8px; border-radius: 12px; font-weight: 600;">${unreadCount}</div>` : ''}
                    </div>
                `;
                
                friendsList.appendChild(friendDiv);
            });

            // Update friend count
            const friendCountElement = document.getElementById('friends-count');
            if (friendCountElement) {
                friendCountElement.textContent = friends.length;
            }
        }

        function handleGlobalChatTyping() {
            if (!chatConnected || !romgonChat.isConnected) return;

            romgonChat.startTyping('global');
            
            // Clear previous timeout
            if (typingTimeout) {
                clearTimeout(typingTimeout);
            }
            
            // Stop typing after 2 seconds of inactivity
            typingTimeout = setTimeout(() => {
                romgonChat.stopTyping('global');
            }, 2000);
        }

        function getTimeAgo(date) {
            const seconds = Math.floor((new Date() - date) / 1000);
            
            if (seconds < 60) return 'Just now';
            if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
            if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
            return `${Math.floor(seconds / 86400)}d ago`;
        }

        function playMessageSound() {
            // Optional: play notification sound
            try {
                const audio = new Audio('captured.mp3'); // Reuse existing sound
                audio.volume = 0.3;
                audio.play().catch(() => {});
            } catch (e) {}
        }

        function showNotification(message, type = 'info') {
            // Simple notification (can be enhanced with a toast library)
            console.log(`[${type.toUpperCase()}] ${message}`);
            
            // Optional: use browser notification if available
            if (type === 'info' || type === 'success') {
                // You could implement a toast notification here
            }
        }

        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, m => map[m]);
        }
        
        // ============================================
        // ACTIVE GAMES INTEGRATION
        // ============================================
        
        let gameSocket = null;
        const BACKEND_API_URL = 'https://api.romgon.net'; // Production backend URL
        
        // ============================================
        // BACKEND API INTEGRATION FUNCTIONS
        // ============================================
        
        /**
         * Get authorization headers with JWT token
         */
        function getAuthHeaders() {
            const user = JSON.parse(localStorage.getItem('romgon-user') || '{}');
            const token = user.token;
            
            if (token) {
                return {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${token}`
                };
            }
            return {
                'Content-Type': 'application/json'
            };
        }
        
        /**
         * Fetch user profile from backend
         */
        async function fetchUserProfile() {
            try {
                const user = JSON.parse(localStorage.getItem('romgon-user') || '{}');
                if (!user.id) {
                    console.warn('No user ID found');
                    return null;
                }
                
                const response = await fetch(`${BACKEND_API_URL}/api/users/profile`, {
                    headers: getAuthHeaders()
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('‚úÖ User profile fetched:', data);
                return data;
            } catch (error) {
                console.error('‚ùå Failed to fetch user profile:', error);
                return null;
            }
        }
        
        /**
         * Fetch user statistics from backend
         */
        async function fetchUserStats() {
            try {
                const response = await fetch(`${BACKEND_API_URL}/api/users/stats`, {
                    method: 'GET',
                    headers: getAuthHeaders()
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
                    console.error('‚ùå Failed to fetch user stats from backend:', {
                        status: response.status,
                        statusText: response.statusText,
                        error: errorData
                    });
                    
                    // If user not found (404), clear session and force re-login
                    if (response.status === 404 && errorData.error === 'User not found') {
                        console.warn('‚ö†Ô∏è User not found in backend database. Clearing session...');
                        localStorage.removeItem('romgon-session');
                        localStorage.removeItem('romgon-jwt');
                        localStorage.removeItem('romgon-user');
                        
                        // Show user-friendly message
                        alert('Your session is out of sync with the server. Please log in again.');
                        
                        // Reload page to show login screen
                        window.location.reload();
                        return null;
                    }
                    
                    return null;
                }
                
                const data = await response.json();
                console.log('‚úÖ Fetched user stats from backend:', data);
                return data;
            } catch (error) {
                console.error('‚ùå Error fetching user stats from backend:', error);
                return null;
            }
        }
        
        /**
         * Fetch user game history from backend
         */
        async function fetchUserGames(limit = 10) {
            try {
                const response = await fetch(`${BACKEND_API_URL}/api/games/history?limit=${limit}`, {
                    method: 'GET',
                    headers: getAuthHeaders()
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('‚ùå Failed to fetch game history from backend:', {
                        status: response.status,
                        statusText: response.statusText,
                        error: errorText
                    });
                    return [];
                }
                
                const data = await response.json();
                console.log('‚úÖ Fetched game history from backend:', data);
                return data;
            } catch (error) {
                console.error('‚ùå Error fetching game history from backend:', error);
                return [];
            }
        }
        
        /**
         * Update user profile on backend
         */
        async function updateUserProfile(updates) {
            try {
                const response = await fetch(`${BACKEND_API_URL}/api/users/profile`, {
                    method: 'PUT',
                    headers: getAuthHeaders(),
                    body: JSON.stringify(updates)
                });
                
                if (!response.ok) {
                    // Backend endpoint may not exist yet
                    console.warn('‚ö†Ô∏è Profile update endpoint not available');
                    return null;
                }
                
                const data = await response.json();
                console.log('‚úÖ User profile updated:', data);
                return data;
            } catch (error) {
                console.warn('‚ö†Ô∏è Failed to update user profile on backend (using local only):', error.message);
                return null;
            }
        }
        
        /**
         * Initialize lobby - load active games, stats, and match history
         */
        function initializeLobby() {
            console.log('üè† Initializing lobby...');
            
            // Initialize game WebSocket for real-time updates
            initializeGameSocket();
            
            // Initialize online players tracking
            initializeOnlinePlayers();
            
            // Load initial data
            loadActiveGames();
            loadMatchHistory();
            loadUserStats();
            
            console.log('‚úÖ Lobby initialized');
        }
        
        /**
         * Initialize game WebSocket connection
         */
        function initializeGameSocket() {
            if (gameSocket && gameSocket.connected) {
                console.log('‚úÖ Game socket already connected');
                return;
            }
            
            try {
                // Get user info for WebSocket authentication
                const userId = localStorage.getItem('userId');
                const userStr = localStorage.getItem('romgon-user');
                let username = 'Guest';
                let rating = 1600;
                
                console.log('üîç Initializing game socket...');
                console.log('üîç userId from localStorage:', userId);
                console.log('üîç romgon-user from localStorage:', userStr);
                
                if (userStr) {
                    try {
                        const user = JSON.parse(userStr);
                        username = user.username || user.name || 'Guest';
                        rating = user.rating || 1600;
                        console.log('üîç Parsed user:', { username, rating });
                    } catch (e) {
                        console.error('‚ùå Failed to parse user:', e);
                    }
                }
                
                if (!userId) {
                    console.error('‚ùå No userId found - cannot connect to game socket');
                    return;
                }
                
                const socketUrl = `${BACKEND_API_URL}/game`;
                console.log('üîå Connecting to:', socketUrl);
                console.log('üîë Auth data:', { userId, username, rating });
                
                gameSocket = io(socketUrl, {
                    auth: {
                        token: localStorage.getItem('token'),
                        userId: userId,
                        username: username,
                        rating: rating
                    },
                    transports: ['websocket', 'polling']
                });
                
                gameSocket.on('connect', () => {
                    console.log('‚úÖ Game WebSocket connected');
                    console.log('üîå Socket ID:', gameSocket.id);
                    console.log('üîë Auth data sent:', gameSocket.auth);
                    
                    // Initialize online players tracking AFTER connection
                    initializeOnlinePlayersListeners();
                });
                
                gameSocket.on('connect_error', (error) => {
                    console.error('‚ùå Game socket connection error:', error);
                });
                
                gameSocket.on('disconnect', () => {
                    console.log('‚ùå Game WebSocket disconnected');
                });
                
                // Listen for move updates
                gameSocket.on('game:moveUpdate', (data) => {
                    console.log('üéØ Move update received:', data);
                    loadActiveGames(); // Refresh active games list
                    playMessageSound(); // Notify user
                });
                
                // Listen for lobby updates
                gameSocket.on('lobby:gameUpdate', (data) => {
                    console.log('üîÑ Lobby game update:', data);
                    loadActiveGames(); // Refresh active games list
                });
                
                // Listen for game ended
                gameSocket.on('game:ended', (data) => {
                    console.log('üèÅ Game ended:', data);
                    loadActiveGames(); // Remove from active games
                    loadMatchHistory(); // Add to history
                    loadUserStats(); // Update rating
                });
                
                console.log('‚úÖ Game socket initialized');
            } catch (error) {
                console.error('‚ùå Failed to initialize game socket:', error);
            }
        }
        
        /**
         * Initialize online players tracking
         */
        let onlinePlayers = new Map(); // Store online players: userId -> {username, rating, status}
        
        function initializeOnlinePlayers() {
            console.log('üë• Initializing online players tracking...');
            
            if (!gameSocket) {
                console.error('‚ùå Game socket not initialized');
                return;
            }
            
            // Setup listeners first
            initializeOnlinePlayersListeners();
        }
        
        function initializeOnlinePlayersListeners() {
            console.log('üéß Setting up online players listeners...');
            
            // Listen for online players list
            gameSocket.on('lobby:onlinePlayers', (players) => {
                console.log('üìã Online players list received:', players);
                console.log('üìã Players count:', players.length);
                updateOnlinePlayersList(players);
            });
            
            // Listen for player joined
            gameSocket.on('lobby:playerJoined', (player) => {
                console.log('‚úÖ Player joined:', player);
                onlinePlayers.set(player.userId, player);
                renderOnlinePlayers();
            });
            
            // Listen for player left
            gameSocket.on('lobby:playerLeft', (userId) => {
                console.log('üëã Player left:', userId);
                onlinePlayers.delete(userId);
                renderOnlinePlayers();
            });
            
            // Request initial online players list (wait for connection)
            setTimeout(() => {
                console.log('üì° Requesting online players list...');
                gameSocket.emit('lobby:getOnlinePlayers');
            }, 500);
        }
        
        function updateUserOnlineStatus(userId, isOnline) {
            if (isOnline) {
                // User came online - they should already be in the list from playerJoined event
                console.log(`üë§ User ${userId} is now online`);
            } else {
                // User went offline - remove from list
                console.log(`üëã User ${userId} went offline`);
                onlinePlayers.delete(userId);
                renderOnlinePlayers();
            }
        }
        
        function updateOnlinePlayersList(players) {
            onlinePlayers.clear();
            players.forEach(player => {
                onlinePlayers.set(player.userId, player);
            });
            renderOnlinePlayers();
        }
        
        function renderOnlinePlayers() {
            const countEl = document.getElementById('online-players-count');
            const listEl = document.getElementById('online-players-list');
            
            if (!countEl || !listEl) return;
            
            const count = onlinePlayers.size;
            countEl.textContent = count;
            
            if (count === 0) {
                listEl.innerHTML = '<span style="color: #888; font-size: 0.9em;">No other players online</span>';
                return;
            }
            
            // Get current user ID to exclude from list
            const currentUserId = localStorage.getItem('userId');
            
            // Convert to array and filter out current user
            const playersArray = Array.from(onlinePlayers.values())
                .filter(p => p.userId !== currentUserId)
                .slice(0, 10); // Show max 10 players
            
            if (playersArray.length === 0) {
                listEl.innerHTML = '<span style="color: #888; font-size: 0.9em;">You\'re the only one online</span>';
                return;
            }
            
            listEl.innerHTML = playersArray.map(player => {
                const isGuest = player.username.toLowerCase().startsWith('guest');
                const guestBadge = isGuest ? '<span style="font-size: 0.7em; background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 10px; margin-left: 4px;">üë§ Guest</span>' : '';
                const borderColor = isGuest ? 'rgba(156, 136, 255, 0.3)' : 'rgba(78, 205, 196, 0.3)';
                const bgColor = isGuest ? 'rgba(156, 136, 255, 0.15)' : 'rgba(78, 205, 196, 0.15)';
                const bgColorHover = isGuest ? 'rgba(156, 136, 255, 0.25)' : 'rgba(78, 205, 196, 0.25)';
                const statusColor = player.status === 'in-game' ? '#ffd700' : (isGuest ? '#9c88ff' : '#4ecdc4');
                
                return `
                <div onclick="challengePlayer('${player.userId}')" title="${escapeHtml(player.username)} - Rating: ${player.rating || 'Unrated'}${isGuest ? ' (Guest)' : ''}" style="
                    display: flex;
                    align-items: center;
                    gap: 6px;
                    background: ${bgColor};
                    border: 1px solid ${borderColor};
                    border-radius: 20px;
                    padding: 6px 12px;
                    cursor: pointer;
                    transition: all 0.2s;
                " onmouseover="this.style.background='${bgColorHover}'; this.style.transform='scale(1.05)'" onmouseout="this.style.background='${bgColor}'; this.style.transform='scale(1)'">
                    <div style="
                        width: 8px;
                        height: 8px;
                        border-radius: 50%;
                        background: ${statusColor};
                    "></div>
                    <span style="color: white; font-size: 0.9em; font-weight: 500;">${escapeHtml(player.username)}</span>
                    <span style="color: #888; font-size: 0.8em;">(${player.rating || '?'})</span>
                    ${guestBadge}
                </div>
            `;
            }).join('');
            
            // If there are more players, show count
            if (onlinePlayers.size - 1 > playersArray.length) {
                listEl.innerHTML += `
                    <span style="color: #888; font-size: 0.85em;">
                        +${onlinePlayers.size - 1 - playersArray.length} more
                    </span>
                `;
            }
        }
        
        function challengePlayer(userId) {
            alert(`Challenge player feature coming soon! Player ID: ${userId}`);
            // TODO: Implement challenge system
            // gameSocket.emit('challenge:send', { opponentId: userId });
        }
        
        /**
         * Load active games from backend
         */
        async function loadActiveGames() {
            const userId = localStorage.getItem('userId');
            const token = localStorage.getItem('token');
            
            if (!userId) {
                console.log('‚ö†Ô∏è No userId, skipping active games load');
                renderActiveGames([]); // Show empty state
                return;
            }
            
            // Check if offline guest
            if (userId.startsWith('guest_') && token === 'guest-offline-mode') {
                console.log('üë§ Guest in offline mode - no backend games');
                renderActiveGames([]); // Show empty state for offline guests
                return;
            }
            
            try {
                const response = await fetch(`${BACKEND_API_URL}/api/games/active/${userId}`, {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('‚úÖ Active games loaded:', data.games.length);
                    renderActiveGames(data.games || []);
                } else {
                    console.error('Failed to load active games:', response.status);
                    renderActiveGames([]); // Show empty state
                }
            } catch (error) {
                console.error('Error loading active games:', error);
                renderActiveGames([]); // Show empty state
            }
        }
        
        /**
         * Render active games list
         */
        function renderActiveGames(games) {
            const container = document.getElementById('active-games-list');
            if (!container) return;
            
            if (games.length === 0) {
                container.innerHTML = `
                    <div style="
                        background: rgba(78, 205, 196, 0.1);
                        border: 1px solid rgba(78, 205, 196, 0.3);
                        border-radius: 10px;
                        padding: 15px;
                        text-align: center;
                        color: #888;
                    ">
                        No active games. Start a new game to get started!
                    </div>
                `;
                return;
            }
            
            container.innerHTML = games.map(game => `
                <div onclick="resumeGame('${game.gameId}')" style="
                    background: linear-gradient(135deg, rgba(78, 205, 196, 0.15), rgba(108, 92, 231, 0.15));
                    border: 1px solid ${game.turn === 'yourTurn' ? '#4ecdc4' : 'rgba(78, 205, 196, 0.3)'};
                    border-radius: 12px;
                    padding: 15px;
                    cursor: pointer;
                    transition: all 0.2s;
                    ${game.turn === 'yourTurn' ? 'box-shadow: 0 0 15px rgba(78, 205, 196, 0.3);' : ''}
                " onmouseover="this.style.transform='translateX(5px)'; this.style.boxShadow='0 4px 20px rgba(78, 205, 196, 0.2)'" onmouseout="this.style.transform='translateX(0)'; this.style.boxShadow='${game.turn === 'yourTurn' ? '0 0 15px rgba(78, 205, 196, 0.3)' : 'none'}'">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <div style="
                                width: 40px;
                                height: 40px;
                                border-radius: 50%;
                                background: linear-gradient(135deg, #667eea, #764ba2);
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                font-size: 1.2em;
                            ">${game.opponent.avatar || 'üë§'}</div>
                            <div>
                                <div style="color: white; font-weight: 600; font-size: 1.05em;">${escapeHtml(game.opponent.name)}</div>
                                <div style="color: #888; font-size: 0.85em;">Rating: ${game.opponent.rating || 'Unrated'}</div>
                            </div>
                        </div>
                        <div style="text-align: right;">
                            <div style="
                                color: ${game.turn === 'yourTurn' ? '#4ecdc4' : '#888'};
                                font-weight: ${game.turn === 'yourTurn' ? '700' : '600'};
                                font-size: 0.95em;
                                margin-bottom: 4px;
                            ">
                                ${game.turn === 'yourTurn' ? 'üü¢ YOUR TURN' : '‚è≥ Waiting...'}
                            </div>
                            <div style="color: #888; font-size: 0.8em;">${game.lastMove}</div>
                        </div>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1);">
                        <div style="color: #aaa; font-size: 0.85em;">
                            Playing as ${game.yourColor === 'white' ? '‚ö™ White' : '‚ö´ Black'}
                        </div>
                        <div style="color: #aaa; font-size: 0.85em;">
                            Move ${game.moveCount}
                        </div>
                    </div>
                </div>
            `).join('');
        }
        
        /**
         * Resume a game
         */
        function resumeGame(gameId) {
            console.log('üéÆ Resuming game:', gameId);
            
            // TODO: Implement game resume logic
            // 1. Fetch game state from backend
            // 2. Load game board
            // 3. Join game WebSocket room
            // 4. Hide lobby, show game board
            
            alert(`Resuming game ${gameId}...\n\nGame resume functionality coming soon!`);
        }
        
        /**
         * Load match history from backend
         */
        async function loadMatchHistory(limit = 10, offset = 0) {
            const userId = localStorage.getItem('userId');
            const token = localStorage.getItem('token');
            
            if (!userId) {
                console.log('‚ö†Ô∏è No userId, skipping match history load');
                renderMatchHistory([], false);
                return;
            }
            
            // Check if offline guest
            if (userId.startsWith('guest_') && token === 'guest-offline-mode') {
                console.log('üë§ Guest in offline mode - no backend history');
                renderMatchHistory([], false);
                return;
            }
            
            try {
                const response = await fetch(`${BACKEND_API_URL}/api/games/history/${userId}?limit=${limit}&offset=${offset}`, {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('‚úÖ Match history loaded:', data.games.length);
                    renderMatchHistory(data.games || [], data.hasMore);
                } else {
                    console.error('Failed to load match history:', response.status);
                    renderMatchHistory([], false);
                }
            } catch (error) {
                console.error('Error loading match history:', error);
                renderMatchHistory([], false);
            }
        }
        
        /**
         * Render match history
         */
        function renderMatchHistory(games, hasMore) {
            const container = document.getElementById('match-history-list');
            if (!container) return;
            
            if (games.length === 0) {
                container.innerHTML = `
                    <div style="padding: 20px; text-align: center; color: #888;">
                        No match history yet. Play some games!
                    </div>
                `;
                return;
            }
            
            container.innerHTML = games.map(game => {
                const isWin = game.result === 'win';
                const resultColor = isWin ? '#26de81' : '#ff6b6b';
                const resultIcon = isWin ? 'üèÜ' : '‚ùå';
                const resultText = isWin ? 'Victory' : 'Defeat';
                
                return `
                    <div style="
                        background: rgba(35, 39, 46, 0.5);
                        border: 1px solid rgba(255,255,255,0.1);
                        border-radius: 10px;
                        padding: 15px;
                        margin-bottom: 10px;
                    ">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div style="display: flex; align-items: center; gap: 12px;">
                                <div style="font-size: 1.5em;">${resultIcon}</div>
                                <div>
                                    <div style="color: white; font-weight: 600;">vs ${escapeHtml(game.opponent.name)}</div>
                                    <div style="color: #888; font-size: 0.85em;">${game.duration} ‚Ä¢ ${game.moveCount} moves</div>
                                </div>
                            </div>
                            <div style="text-align: right;">
                                <div style="color: ${resultColor}; font-weight: 700; font-size: 1.1em;">${resultText}</div>
                                <div style="color: ${game.ratingChange > 0 ? '#26de81' : '#ff6b6b'}; font-size: 0.9em; font-weight: 600;">
                                    ${game.ratingChange > 0 ? '+' : ''}${game.ratingChange}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
            
            if (hasMore) {
                container.innerHTML += `
                    <button onclick="loadMoreHistory()" style="
                        width: 100%;
                        padding: 12px;
                        background: rgba(78, 205, 196, 0.2);
                        border: 1px solid rgba(78, 205, 196, 0.5);
                        border-radius: 10px;
                        color: #4ecdc4;
                        font-weight: 600;
                        cursor: pointer;
                        transition: all 0.2s;
                    " onmouseover="this.style.background='rgba(78, 205, 196, 0.3)'" onmouseout="this.style.background='rgba(78, 205, 196, 0.2)'">
                        Load More
                    </button>
                `;
            }
        }
        
        let historyOffset = 0;
        function loadMoreHistory() {
            historyOffset += 10;
            loadMatchHistory(10, historyOffset);
        }
        
        /**
         * Load user stats from backend
         */
        async function loadUserStats() {
            const userId = localStorage.getItem('userId');
            const token = localStorage.getItem('token');
            
            if (!userId) {
                console.log('‚ö†Ô∏è No userId, skipping stats load');
                return;
            }
            
            // Check if offline guest - use localStorage stats
            if (userId.startsWith('guest_') && token === 'guest-offline-mode') {
                console.log('üë§ Guest in offline mode - using localStorage stats');
                const localWins = parseInt(localStorage.getItem('wins') || '0');
                const localLosses = parseInt(localStorage.getItem('losses') || '0');
                const localRating = parseInt(localStorage.getItem('rating') || '1420');
                const total = localWins + localLosses;
                const winRate = total > 0 ? Math.round((localWins / total) * 100) : 0;
                
                updateStatsDisplay({
                    rating: localRating,
                    wins: localWins,
                    losses: localLosses,
                    winRate: winRate
                });
                return;
            }
            
            try {
                const response = await fetch(`${BACKEND_API_URL}/api/stats/player/${userId}`, {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });
                
                if (response.ok) {
                    const stats = await response.json();
                    console.log('‚úÖ Stats loaded from backend:', stats);
                    updateStatsDisplay(stats);
                } else {
                    console.error('Failed to load user stats:', response.status);
                    // Fallback to localStorage
                    const localWins = parseInt(localStorage.getItem('wins') || '0');
                    const localLosses = parseInt(localStorage.getItem('losses') || '0');
                    updateStatsDisplay({
                        rating: 1420,
                        wins: localWins,
                        losses: localLosses,
                        winRate: localWins + localLosses > 0 ? Math.round((localWins / (localWins + localLosses)) * 100) : 0
                    });
                }
            } catch (error) {
                console.error('Error loading user stats:', error);
            }
        }
        
        /**
         * Update stats display on lobby
         */
        function updateStatsDisplay(stats) {
            const ratingEl = document.getElementById('user-rating');
            const winsEl = document.getElementById('user-home-wins');
            const lossesEl = document.getElementById('user-home-losses');
            const winrateEl = document.getElementById('user-home-winrate');
            
            if (ratingEl && stats.rating !== undefined) {
                ratingEl.textContent = Math.round(stats.rating);
            }
            
            if (winsEl && stats.wins !== undefined) {
                winsEl.textContent = stats.wins;
            }
            
            if (lossesEl && stats.losses !== undefined) {
                lossesEl.textContent = stats.losses;
            }
            
            if (winrateEl && stats.winRate !== undefined) {
                winrateEl.textContent = Math.round(stats.winRate) + '%';
            }
        }
        
        // ============================================
        // END ACTIVE GAMES INTEGRATION
        // ============================================
        
        // Make Sandbox functions globally accessible
        window.startSandboxMode = startSandboxMode;
        window.toggleSandboxEditMode = toggleSandboxEditMode;
        window.switchSandboxTurn = switchSandboxTurn;
        window.resetSandboxBoard = resetSandboxBoard;
        window.clearSandboxBoard = clearSandboxBoard;
        window.saveSandboxPosition = saveSandboxPosition;
        window.loadSandboxPosition = loadSandboxPosition;
        window.exitSandboxMode = exitSandboxMode;
        window.toggleSandboxSidePanels = toggleSandboxSidePanels;
        
        console.log('‚úÖ Sandbox Mode functions registered');
        
        // ============================================
        // END SANDBOX MODE
        // ============================================
        
        function startTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
            }
            
            timerInterval = setInterval(() => {
                if (gameOver || puzzleMode) {
                    stopTimer();
                    return;
                }
                
                // Decrease time for current player
                if (currentPlayer === 'white') {
                    whiteTimeLeft--;
                    if (whiteTimeLeft <= 0) {
                        whiteTimeLeft = 0;
                        stopTimer();
                        showGameOver('Black', 'Black wins on time!');
                    }
                } else {
                    blackTimeLeft--;
                    if (blackTimeLeft <= 0) {
                        blackTimeLeft = 0;
                        stopTimer();
                        showGameOver('White', 'White wins on time!');
                    }
                }
                
                updateTimerDisplay();
            }, 1000);
        }
        
        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }
        
        function updateTimerDisplay() {
            const whiteTimer = document.getElementById('white-timer');
            const blackTimer = document.getElementById('black-timer');
            
            // Format time as MM:SS
            const whiteMinutes = Math.floor(whiteTimeLeft / 60);
            const whiteSeconds = whiteTimeLeft % 60;
            const blackMinutes = Math.floor(blackTimeLeft / 60);
            const blackSeconds = blackTimeLeft % 60;
            
            whiteTimer.querySelector('.timer-time').textContent = 
                `${whiteMinutes}:${whiteSeconds.toString().padStart(2, '0')}`;
            blackTimer.querySelector('.timer-time').textContent = 
                `${blackMinutes}:${blackSeconds.toString().padStart(2, '0')}`;
            
            // Update active state
            whiteTimer.classList.toggle('active', currentPlayer === 'white');
            blackTimer.classList.toggle('active', currentPlayer === 'black');
            
            // Add low time warning (under 1 minute)
            whiteTimer.classList.toggle('low-time', whiteTimeLeft < 60);
            blackTimer.classList.toggle('low-time', blackTimeLeft < 60);
        }
        
        // ========== LEARNING MODAL ==========
        
        function openLearningModal() {
            document.getElementById('learning-modal').style.display = 'flex';
        }
        
        function closeLearningModal() {
            document.getElementById('learning-modal').style.display = 'none';
        }
        
        // Add event listener for Learn button
        // Fix: Only add event listener if element exists
        var learnBtn = document.getElementById('start-learn-btn');
        if (learnBtn) {
            learnBtn.addEventListener('click', openLearningModal);
        }

        // ========== GAME ANALYSIS MODAL ==========
        
        let analysisData = null;
        let currentMoveIndex = 0;
        let autoPlayInterval = null;
        let moveAnnotations = new Map(); // moveIndex -> {symbol: '!', comment: 'Good move', evaluation: +0.5}
        let positionEvaluations = new Map(); // position RPN -> evaluation score
        
        function openAnalysisModal() {
            document.getElementById('analysis-modal').style.display = 'block';
        }
        
        function closeAnalysisModal() {
            document.getElementById('analysis-modal').style.display = 'none';
            stopAutoPlay();
            
            // If there's an active game, restore it
            // (Hide start menu and show board if we have moves or are in a game)
            if (moveCount > 0 || window.rpnMoveHistory.length > 0 || !gameOver) {
                const startMenu = document.getElementById('start-menu');
                if (startMenu) {
                    startMenu.style.display = 'none';
                }
                
                // Show the game board and side panels
                const boardContainer = document.getElementById('board-display-container');
                if (boardContainer) {
                    boardContainer.style.display = 'block';
                }
            }
        }
        
        // Load RMN file
        function loadRMNFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const content = e.target.result;
                parseRMNContent(content);
            };
            reader.readAsText(file);
        }
        
        // Load current game
        function loadCurrentGame() {
            console.log('üìä Loading current game for analysis...');
            console.log(`   rpnMoveHistory.length: ${window.rpnMoveHistory.length}`);
            
            if (window.rpnMoveHistory.length === 0) {
                // Allow analyzing starting position even with no moves
                const confirm = window.confirm('No moves have been made yet. Analyze starting position?');
                if (!confirm) return;
            }
            
            // Get current board position (full RPN string)
            const fullRPN = exportPositionRPN();
            console.log('üìä Full RPN:', fullRPN);
            
            // Extract just the board part (before the first space)
            const currentPosition = fullRPN.split(' ')[0];
            console.log('üìä Current board position RPN (extracted):', currentPosition);
            
            // Create RMN content from current game
            const rmnContent = exportGameRMN();
            console.log('üìÑ Generated RMN content:', rmnContent);
            
            // Parse the RMN and add current position
            parseRMNContent(rmnContent, currentPosition);
        }
        
        // Debug function to show current position
        function debugCurrentPosition() {
            console.log('üîç === DEBUG CURRENT POSITION ===');
            
            // Check specific problematic hexes
            const testHexes = ['hex-0-0', 'hex-0-5', 'hex-6-0', 'hex-6-5'];
            testHexes.forEach(hexId => {
                const hex = document.getElementById(hexId);
                if (hex) {
                    console.log(`üîç Checking ${hexId}:`);
                    console.log('   - innerHTML:', hex.innerHTML.substring(0, 200));
                    console.log('   - children count:', hex.children.length);
                    console.log('   - querySelector for piece:', hex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece'));
                    
                    // Check all children
                    for (let i = 0; i < hex.children.length; i++) {
                        const child = hex.children[i];
                        console.log(`   - Child ${i}:`, child.className, child.tagName);
                    }
                } else {
                    console.log(`üîç ${hexId} NOT FOUND`);
                }
            });
            
            const fullRPN = exportPositionRPN();
            console.log('üîç Full RPN:', fullRPN);
            const boardOnly = fullRPN.split(' ')[0];
            console.log('üîç Board only:', boardOnly);
            alert('Current board RPN (check console for details):\n\n' + boardOnly);
        }
        
        // Parse RMN content
        function parseRMNContent(content, currentPosition = null) {
            try {
                const lines = content.split('\n').filter(line => line.trim());
                
                // Parse metadata
                const metadata = {};
                const moves = [];
                
                for (const line of lines) {
                    if (line.startsWith('[')) {
                        // Metadata line: [Key "Value"]
                        const match = line.match(/\[(\w+) "(.+)"\]/);
                        if (match) {
                            metadata[match[1].toLowerCase()] = match[2];
                        }
                    } else if (line.match(/^\d+\./)) {
                        // Move line: 1. C2-0>3-1 r3-8>3-6
                        const moveMatch = line.match(/^\d+\.\s+(\S+)(?:\s+(\S+))?/);
                        if (moveMatch) {
                            moves.push({
                                number: moves.length + 1,
                                white: moveMatch[1] || '',
                                black: moveMatch[2] || '',
                                combined: moveMatch[1] + (moveMatch[2] ? ' ' + moveMatch[2] : '')
                            });
                        }
                    }
                }
                
                const startPos = metadata.startposition || 'S4s/T05t0/C6h0/R7r/H06c/t05T0/s4S';
                
                console.log('üìä parseRMNContent - startPos:', startPos);
                console.log('üìä parseRMNContent - currentPosition parameter:', currentPosition);
                
                analysisData = {
                    metadata,
                    moves,
                    totalMoves: moves.reduce((sum, m) => sum + (m.white ? 1 : 0) + (m.black ? 1 : 0), 0),
                    startPosition: startPos,
                    // Store current position if provided (for analyzing current game)
                    currentBoardPosition: currentPosition || startPos
                };
                
                console.log('üìä analysisData.currentBoardPosition:', analysisData.currentBoardPosition);
                console.log('üìä analysisData.totalMoves:', analysisData.totalMoves);
                
                displayAnalysis();
                
            } catch (error) {
                console.error('Error parsing RMN:', error);
                alert('Error loading RMN file: ' + error.message);
            }
        }
        
        // Display analysis
        function displayAnalysis() {
            if (!analysisData) return;
            
            // Show all sections
            document.getElementById('analysis-info').style.display = 'block';
            document.getElementById('analysis-navigator').style.display = 'block';
            document.getElementById('analysis-board-container').style.display = 'block';
            document.getElementById('analysis-moves').style.display = 'block';
            document.getElementById('analysis-stats').style.display = 'block';
            
            // Display metadata
            const metadataDiv = document.getElementById('analysis-metadata');
                        metadataDiv.innerHTML = `
                                <p><strong>White:</strong> ${analysisData.metadata.white || 'Unknown'}</p>
                                <p><strong>Black:</strong> ${analysisData.metadata.black || 'Unknown'}</p>
                                <p><strong>Date:</strong> ${analysisData.metadata.date || 'Unknown'}</p>
                                <p><strong>Result:</strong> ${analysisData.metadata.result || 'Unknown'}</p>
                                <p><strong>Starting Position:</strong> ${analysisData.startPosition === 'S4s/T05t0/C6h0/R7r/H06c/t05T0/s4S' ? 'Standard PvP' : 'Custom'}</p>
                                <hr style='border:0; border-top:1px solid #444; margin:10px 0;'>
                                <div style='margin-top:10px;'>
                                    <span style='color:#ffd700; font-weight:bold; font-size:1.08em;'>‚ö° Advanced Features</span>
                                    <ul style='color:#ccc; margin:8px 0 0 18px; font-size:0.98em; line-height:1.7;'>
                                        <li><b>Repetition Detection</b>: Three-fold repetition rule, draw offers, and visual warnings.</li>
                                        <li><b>Base Defense System</b>: Prevents early base captures, toggleable in settings.</li>
                                        <li><b>Threat Analysis</b>: Real-time threat and checkmate detection, highlights threatened pieces.</li>
                                        <li><b>Show All Moves</b>: Toggle to display all legal moves and rotations for current player.</li>
                                        <li><b>Defense Highlights</b>: Highlights pieces defended by others, optional toggle.</li>
                                        <li><b>Dark Mode</b>: Switch between light/dark themes, remembers your preference.</li>
                                        <li><b>Game Variants</b>: Blitz, Fog of War, King of the Hill (see Quick Reference for more).</li>
                                    </ul>
                                </div>
                        `;
            

            // Recognize opening by RPN (first position)
            let openingNameHtml = '';
            if (analysisData && analysisData.startPosition) {
                const found = OPENING_BOOK.find(o => o.rpn === analysisData.startPosition);
                if (found) {
                    openingNameHtml = `<div style='background:#23272e; color:#4ecdc4; padding:10px 16px; border-radius:8px; margin-bottom:10px; font-size:1.1em; font-weight:600;'>
                        üìñ Opening: <span style='color:#fff;'>${found.name}</span>
                        <span style='font-size:0.9em; color:#aaa; font-weight:400; margin-left:10px;'>(${found.moves.join(', ')})</span>
                    </div>`;
                }
            }

            // Display move list with annotations, with opening name above
            const moveListDiv = document.getElementById('analysis-move-list');
            moveListDiv.innerHTML = openingNameHtml;
            displayMoveListWithAnnotations();
            
            // Display statistics
            const statsDiv = document.getElementById('analysis-statistics');
            const captures = analysisData.moves.filter(m => 
                (m.white && m.white.includes('x')) || (m.black && m.black.includes('x'))
            ).length;
            const rotations = analysisData.moves.filter(m =>
                (m.white && m.white.includes('@')) || (m.black && m.black.includes('@'))
            ).length;
            
            if (analysisData.totalMoves === 0) {
                statsDiv.innerHTML = `
                    <p><strong>Total Moves:</strong> 0</p>
                    <p style="color: #888; font-style: italic;">Play some moves to see game statistics!</p>
                `;
            } else {
                statsDiv.innerHTML = `
                    <p><strong>Total Moves:</strong> ${analysisData.totalMoves}</p>
                    <p><strong>Captures:</strong> ${captures}</p>
                    <p><strong>Rotations:</strong> ${rotations}</p>
                    <p><strong>Average Move Length:</strong> ${(analysisData.totalMoves / analysisData.moves.length).toFixed(1)} per turn</p>
                `;
            }
            
            // Update navigator
            document.getElementById('total-moves').textContent = analysisData.totalMoves;
            document.getElementById('move-slider').max = analysisData.totalMoves;
            currentMoveIndex = 0;
            updateNavigator();
        }
        
        // Navigator functions
        function goToStart() {
            currentMoveIndex = 0;
            updateNavigator();
        }
        
        function previousMove() {
            if (currentMoveIndex > 0) {
                currentMoveIndex--;
                updateNavigator();
            }
        }
        
        function nextMove() {
            if (currentMoveIndex < analysisData.totalMoves) {
                currentMoveIndex++;
                updateNavigator();
            }
        }
        
        function goToEnd() {
            currentMoveIndex = analysisData.totalMoves;
            updateNavigator();
        }
        
        function jumpToMove(index) {
            currentMoveIndex = index;
            updateNavigator();
        }
        
        function updateNavigator() {
            document.getElementById('current-move-number').textContent = currentMoveIndex;
            document.getElementById('move-slider').value = currentMoveIndex;
            
            // Display current move info
            const moveInfoDiv = document.getElementById('current-move-info');
            if (currentMoveIndex === 0) {
                moveInfoDiv.textContent = 'Starting position';
            } else if (currentMoveIndex === analysisData.totalMoves) {
                moveInfoDiv.textContent = `Current position (after ${analysisData.totalMoves} moves)`;
            } else {
                const moveNumber = Math.ceil(currentMoveIndex / 2);
                const isWhite = currentMoveIndex % 2 === 1;
                const move = analysisData.moves[moveNumber - 1];
                const notation = isWhite ? move.white : move.black;
                
                // Note: For current game analysis, intermediate positions not available
                const positionNote = analysisData.currentBoardPosition && !analysisData.positions ? 
                    ' (showing start position - intermediate positions not stored)' : '';
                moveInfoDiv.textContent = `Move ${currentMoveIndex}: ${isWhite ? 'White' : 'Black'} - ${notation}${positionNote}`;
            }
            
            // Update move list highlighting only
            updateMoveListHighlight();
            
            // Update mini board display
            updateAnalysisMiniBoard();
            
            // Update position evaluation
            displayEvaluation();
        }
        
        // Update move list highlighting without re-rendering everything
        function updateMoveListHighlight() {
            if (!analysisData) return;
            
            // Use the annotation display system
            displayMoveListWithAnnotations();
        }
        
        function toggleAutoPlay() {
            if (autoPlayInterval) {
                stopAutoPlay();
            } else {
                startAutoPlay();
            }
        }
        
        function startAutoPlay() {
            const btn = document.getElementById('autoplay-btn');
            btn.textContent = '‚è∏Ô∏è Pause';
            btn.style.backgroundColor = '#ff6b6b';
            
            autoPlayInterval = setInterval(() => {
                if (currentMoveIndex < analysisData.totalMoves) {
                    nextMove();
                } else {
                    stopAutoPlay();
                }
            }, 1500); // 1.5 seconds per move
        }
        
        function stopAutoPlay() {
            if (autoPlayInterval) {
                clearInterval(autoPlayInterval);
                autoPlayInterval = null;
                const btn = document.getElementById('autoplay-btn');
                btn.textContent = '‚ñ∂Ô∏è Auto Play';
                btn.style.backgroundColor = '#4ecdc4';
            }
        }

        // ========== MOVE ANNOTATION SYSTEM ==========
        
        // Annotation symbols and their meanings
        const ANNOTATIONS = {
            '!': { name: 'Good move', color: '#4ecdc4', description: 'Strong, effective move' },
            '!!': { name: 'Brilliant move', color: '#00ff00', description: 'Exceptional, game-changing move' },
            '?': { name: 'Mistake', color: '#ffa500', description: 'Questionable move, likely not best' },
            '??': { name: 'Blunder', color: '#ff0000', description: 'Serious error, significant disadvantage' },
            '!?': { name: 'Interesting move', color: '#9b59b6', description: 'Unclear but interesting' },
            '?!': { name: 'Dubious move', color: '#e67e22', description: 'Likely inferior but worth considering' }
        };
        
        // Add or update annotation for a move
        function annotateMo(moveIndex, symbol, comment = '') {
            if (!analysisData) return;
            
            const annotation = {
                symbol: symbol,
                comment: comment,
                timestamp: new Date().toISOString()
            };
            
            moveAnnotations.set(moveIndex, annotation);
            console.log(`üìù Annotated move ${moveIndex} with ${symbol}:`, comment);
            
            // Refresh the move list display
            displayMoveListWithAnnotations();
        }
        
        // Remove annotation from a move
        function removeAnnotation(moveIndex) {
            moveAnnotations.delete(moveIndex);
            displayMoveListWithAnnotations();
        }
        
        // Display move list with annotations
        function displayMoveListWithAnnotations() {
            if (!analysisData) return;
            
            const moveListDiv = document.getElementById('analysis-move-list');
            let moveHtml = '';
            
            if (analysisData.moves.length === 0) {
                moveHtml = '<p style="color: #888; font-style: italic;">No moves played yet.</p>';
            } else {
                analysisData.moves.forEach((move, index) => {
                    const isHighlighted = index === Math.floor(currentMoveIndex / 2);
                    
                    // Check for annotations on white and black moves
                    const whiteMoveIndex = index * 2;
                    const blackMoveIndex = index * 2 + 1;
                    const whiteAnnotation = moveAnnotations.get(whiteMoveIndex);
                    const blackAnnotation = moveAnnotations.get(blackMoveIndex);
                    
                    moveHtml += `<div style="padding: 8px; background: ${isHighlighted ? 'rgba(78, 205, 196, 0.2)' : 'transparent'}; border-radius: 4px; margin-bottom: 4px; border-left: 3px solid ${isHighlighted ? '#4ecdc4' : 'transparent'};">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span>
                                ${move.number}. 
                                ${move.white}
                                ${whiteAnnotation ? `<span style="color: ${ANNOTATIONS[whiteAnnotation.symbol].color}; font-weight: bold; margin-left: 4px;" title="${whiteAnnotation.comment || ANNOTATIONS[whiteAnnotation.symbol].description}">${whiteAnnotation.symbol}</span>` : ''}
                                ${move.black ? (' ' + move.black) : ''}
                                ${blackAnnotation ? `<span style="color: ${ANNOTATIONS[blackAnnotation.symbol].color}; font-weight: bold; margin-left: 4px;" title="${blackAnnotation.comment || ANNOTATIONS[blackAnnotation.symbol].description}">${blackAnnotation.symbol}</span>` : ''}
                            </span>
                            <button onclick="showAnnotationMenu(${whiteMoveIndex})" style="background: #555; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 11px;">‚úèÔ∏è</button>
                        </div>
                        ${whiteAnnotation && whiteAnnotation.comment ? `<div style="font-size: 12px; color: #ccc; margin-top: 4px; font-style: italic;">${whiteAnnotation.comment}</div>` : ''}
                        ${blackAnnotation && blackAnnotation.comment ? `<div style="font-size: 12px; color: #ccc; margin-top: 4px; font-style: italic;">${blackAnnotation.comment}</div>` : ''}
                    </div>`;
                });
            }
            
            moveListDiv.innerHTML = moveHtml;
        }
        
        // Show annotation menu popup
        function showAnnotationMenu(moveIndex) {
            const existing = moveAnnotations.get(moveIndex);
            
            const menu = document.createElement('div');
            menu.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: #262421;
                border: 2px solid #4ecdc4;
                border-radius: 12px;
                padding: 20px;
                z-index: 10001;
                min-width: 350px;
                box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            `;
            
            menu.innerHTML = `
                <h3 style="color: #4ecdc4; margin: 0 0 15px 0;">üìù Annotate Move ${Math.floor(moveIndex/2) + 1}${moveIndex % 2 === 0 ? ' (White)' : ' (Black)'}</h3>
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 15px;">
                    ${Object.entries(ANNOTATIONS).map(([symbol, data]) => `
                        <button onclick="selectAnnotation('${symbol}', ${moveIndex})" style="
                            background: ${data.color};
                            color: ${symbol === '!!' ? '#000' : '#fff'};
                            border: none;
                            padding: 10px;
                            border-radius: 6px;
                            cursor: pointer;
                            font-weight: bold;
                            font-size: 18px;
                        " title="${data.description}">${symbol}</button>
                    `).join('')}
                </div>
                <textarea id="annotation-comment" placeholder="Add a comment (optional)..." style="
                    width: 100%;
                    height: 80px;
                    background: #1a1a1a;
                    color: white;
                    border: 1px solid #555;
                    border-radius: 6px;
                    padding: 10px;
                    font-family: inherit;
                    resize: vertical;
                    margin-bottom: 15px;
                ">${existing && existing.comment ? existing.comment : ''}</textarea>
                <div style="display: flex; gap: 10px;">
                    <button onclick="saveAnnotation(${moveIndex})" style="
                        background: #4ecdc4;
                        color: #262421;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 6px;
                        cursor: pointer;
                        font-weight: bold;
                        flex: 1;
                    ">üíæ Save</button>
                    ${existing ? `<button onclick="removeAnnotation(${moveIndex}); closeAnnotationMenu()" style="
                        background: #ff6b6b;
                        color: white;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 6px;
                        cursor: pointer;
                        font-weight: bold;
                    ">üóëÔ∏è Remove</button>` : ''}
                    <button onclick="closeAnnotationMenu()" style="
                        background: #555;
                        color: white;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 6px;
                        cursor: pointer;
                        font-weight: bold;
                    ">‚úñÔ∏è Cancel</button>
                </div>
            `;
            
            menu.id = 'annotation-menu';
            document.body.appendChild(menu);
            
            // Store current move index for symbol selection
            window.currentAnnotationMoveIndex = moveIndex;
        }
        
        // Select annotation symbol
        function selectAnnotation(symbol, moveIndex) {
            window.currentAnnotationSymbol = symbol;
            // Highlight selected button
            document.querySelectorAll('#annotation-menu button').forEach(btn => {
                if (btn.textContent.trim() === symbol) {
                    btn.style.outline = '3px solid white';
                } else if (Object.keys(ANNOTATIONS).includes(btn.textContent.trim())) {
                    btn.style.outline = 'none';
                }
            });
        }
        
        // Save annotation
        function saveAnnotation(moveIndex) {
            const symbol = window.currentAnnotationSymbol || '!';
            const comment = document.getElementById('annotation-comment').value;
            annotateMo(moveIndex, symbol, comment);
            closeAnnotationMenu();
        }
        
        // Close annotation menu
        function closeAnnotationMenu() {
            const menu = document.getElementById('annotation-menu');
            if (menu) menu.remove();
            window.currentAnnotationSymbol = null;
            window.currentAnnotationMoveIndex = null;
        }
        
        // Annotate the current move being viewed in navigator
        function annotateCurrentMove() {
            if (!analysisData || currentMoveIndex === 0) {
                alert('‚ö†Ô∏è Please navigate to a move first. Cannot annotate the starting position.');
                return;
            }
            
            // Open annotation menu for current move
            showAnnotationMenu(currentMoveIndex);
        }

        // ========== POSITION EVALUATION SYSTEM ==========
        
        // Piece values for material evaluation
        const PIECE_VALUES = {
            'S': 5,  // Square - most powerful
            'T': 4,  // Triangle
            'C': 3,  // Circle
            'R': 3,  // Rhombus
            'H': 4,  // Hexagon
        };
        
        // Position bonuses (center control, advancement)
        function evaluatePosition(rpnPosition) {
            if (positionEvaluations.has(rpnPosition)) {
                return positionEvaluations.get(rpnPosition);
            }
            
            let whiteScore = 0;
            let blackScore = 0;
            
            // Parse RPN and evaluate pieces
            const pieces = rpnPosition.split('/');
            
            pieces.forEach(piece => {
                if (!piece) return;
                
                // Extract piece type and position
                const isWhite = piece[0] === piece[0].toUpperCase();
                const pieceType = piece[0].toUpperCase();
                const position = piece.slice(1);
                
                // Material value
                const materialValue = PIECE_VALUES[pieceType] || 3;
                
                // Position bonus (pieces closer to enemy base are more valuable)
                let positionBonus = 0;
                if (position.length >= 2) {
                    const col = parseInt(position[0]);
                    const row = parseInt(position[1]);
                    
                    if (!isNaN(col) && !isNaN(row)) {
                        // White pieces get bonus for advancing (higher row numbers)
                        // Black pieces get bonus for advancing (lower row numbers)
                        if (isWhite) {
                            positionBonus = row * 0.5; // Bonus for advancing towards black base
                        } else {
                            positionBonus = (6 - row) * 0.5; // Bonus for advancing towards white base
                        }
                        
                        // Center control bonus (columns 2-4 are center)
                        if (col >= 2 && col <= 4) {
                            positionBonus += 0.5;
                        }
                    }
                }
                
                const totalValue = materialValue + positionBonus;
                
                if (isWhite) {
                    whiteScore += totalValue;
                } else {
                    blackScore += totalValue;
                }
            });
            
            // Calculate advantage (positive = white advantage, negative = black advantage)
            const evaluation = whiteScore - blackScore;
            
            // Store in cache
            positionEvaluations.set(rpnPosition, evaluation);
            
            return evaluation;
        }
        
        // Get evaluation description
        function getEvaluationDescription(score) {
            if (score > 10) return { text: 'White is winning', color: '#00ff00', icon: '++' };
            if (score > 5) return { text: 'White is better', color: '#90ee90', icon: '+' };
            if (score > 2) return { text: 'White has slight advantage', color: '#b0e0b0', icon: '+/=' };
            if (score > -2) return { text: 'Equal position', color: '#ffff99', icon: '=' };
            if (score > -5) return { text: 'Black has slight advantage', color: '#ffb0b0', icon: '=/+' };
            if (score > -10) return { text: 'Black is better', color: '#ff9999', icon: '+' };
            return { text: 'Black is winning', color: '#ff0000', icon: '++' };
        }
        
        // Display evaluation for current position
        function displayEvaluation() {
            const currentRPN = getCurrentPositionRPN();
            if (!currentRPN) return;
            
            const evaluation = evaluatePosition(currentRPN);
            const evalDesc = getEvaluationDescription(evaluation);
            
            // Find or create evaluation display
            let evalDiv = document.getElementById('evaluation-display');
            if (!evalDiv) {
                evalDiv = document.createElement('div');
                evalDiv.id = 'evaluation-display';
                const boardContainer = document.getElementById('analysis-board-container');
                if (boardContainer) {
                    boardContainer.appendChild(evalDiv);
                }
            }
            
            evalDiv.innerHTML = `
                <div style="
                    margin-top: 20px;
                    padding: 15px;
                    background: rgba(0,0,0,0.3);
                    border-radius: 8px;
                    text-align: center;
                ">
                    <div style="
                        font-size: 24px;
                        font-weight: bold;
                        color: ${evalDesc.color};
                        margin-bottom: 10px;
                    ">${evalDesc.icon} ${evaluation > 0 ? '+' : ''}${evaluation.toFixed(1)}</div>
                    <div style="
                        font-size: 14px;
                        color: #ccc;
                    ">${evalDesc.text}</div>
                    <div style="
                        margin-top: 10px;
                        height: 20px;
                        background: linear-gradient(to right, #ff0000, #ffff00, #00ff00);
                        border-radius: 10px;
                        position: relative;
                        overflow: hidden;
                    ">
                        <div style="
                            position: absolute;
                            top: 0;
                            left: 50%;
                            width: 3px;
                            height: 100%;
                            background: #fff;
                            box-shadow: 0 0 10px rgba(255,255,255,0.5);
                            transform: translateX(${(evaluation / 20) * 50}%);
                        "></div>
                    </div>
                </div>
            `;
        }
        
        // Get current position RPN from mini board or analysis data
        function getCurrentPositionRPN() {
            // For now, return the starting position or current board position
            if (analysisData && analysisData.currentBoardPosition) {
                return analysisData.currentBoardPosition;
            }
            return analysisData?.startPosition || null;
        }

        // ========== MINI BOARD FOR ANALYSIS ==========
        
        // Create mini board HTML structure
        function createMiniBoard() {
            const container = document.getElementById('analysis-mini-board');
            container.innerHTML = ''; // Clear existing
            
            // Create 7 rows with appropriate hex counts (correct sizes for the actual board)
            const rowSizes = [6, 7, 8, 9, 8, 7, 6];
            
            for (let r = 0; r < 7; r++) {
                const row = document.createElement('div');
                row.className = 'row';
                
                for (let i = 0; i < rowSizes[r]; i++) {
                    const hex = document.createElement('div');
                    hex.className = 'hexagon';
                    hex.id = `mini-hex-${r}-${i}`;
                    
                    // Add color classes based on position
                    if (r === 0 || r === 6) hex.classList.add('color-dark-brown');
                    else if (r === 1 || r === 5) hex.classList.add('color-orange-med');
                    else hex.classList.add('color-orange-light');
                    
                    row.appendChild(hex);
                }
                
                container.appendChild(row);
            }
        }
        
        // Update mini board with current position
        function updateAnalysisMiniBoard() {
            if (!analysisData) return;
            
            // Create board if it doesn't exist
            if (!document.getElementById('analysis-mini-board').hasChildNodes()) {
                createMiniBoard();
            }
            
            console.log('üé® === UPDATE MINI BOARD START ===');
            console.log('üé® Current move index:', currentMoveIndex);
            console.log('üé® Total moves:', analysisData.totalMoves);
            console.log('üé® Has currentBoardPosition?', !!analysisData.currentBoardPosition);
            console.log('üé® Has positions array?', !!analysisData.positions);
            
            // Get the RPN for current move
            let rpn = analysisData.startPosition;
            let source = 'starting position (default)';
            
            // If we're at the end (latest move), show the current board position
            if (currentMoveIndex === analysisData.totalMoves && analysisData.currentBoardPosition) {
                rpn = analysisData.currentBoardPosition;
                source = 'current board position (end of game)';
                console.log('üé® Using current board position (end of game)');
            }
            // If positions array exists (from a loaded RMN with position data), use it
            else if (analysisData.positions && analysisData.positions[currentMoveIndex]) {
                rpn = analysisData.positions[currentMoveIndex];
                source = `stored position for move ${currentMoveIndex}`;
                console.log('üé® Using stored position for move', currentMoveIndex);
            }
            // Otherwise show starting position
            else if (currentMoveIndex === 0) {
                source = 'starting position (move 0)';
                console.log('üé® Showing starting position');
            }
            
            console.log('üé® RPN Source:', source);
            console.log('üé® Mini board updating with RPN:', rpn);
            console.log('üé® Current move index:', currentMoveIndex, '/ Total moves:', analysisData.totalMoves);
            
            // Clear all pieces first
            const allHexes = document.querySelectorAll('#analysis-mini-board .hexagon');
            allHexes.forEach(hex => {
                hex.innerHTML = '';
            });
            
            // Parse RPN and place pieces
            if (rpn) {
                const rows = rpn.split('/');
                console.log('üé® RPN rows:', rows);
                
                for (let r = 0; r < rows.length && r < 7; r++) {
                    const rowData = rows[r];
                    let colIndex = 0;
                    console.log(`üé® Processing row ${r}: "${rowData}"`);
                    
                    for (let i = 0; i < rowData.length; i++) {
                        const char = rowData[i];
                        
                        if (char >= '0' && char <= '9') {
                            // Check if this is a rotation number (follows T, t, H, or h)
                            const prevChar = i > 0 ? rowData[i - 1] : '';
                            const isRotation = (prevChar === 'T' || prevChar === 't' || 
                                              prevChar === 'H' || prevChar === 'h');
                            
                            if (isRotation) {
                                // This is a rotation number, skip it (already handled when placing the piece)
                                continue;
                            } else {
                                // Number means empty hexes
                                colIndex += parseInt(char);
                            }
                        } else {
                            // Letter means piece
                            const hex = document.getElementById(`mini-hex-${r}-${colIndex}`);
                            if (hex) {
                                const piece = document.createElement('img');
                                piece.className = 'piece';
                                
                                const isWhite = char === char.toUpperCase();
                                const color = isWhite ? 'white' : 'black';
                                
                                // Check if next character is a rotation number
                                let rotation = 0;
                                if (i + 1 < rowData.length && rowData[i + 1] >= '0' && rowData[i + 1] <= '5') {
                                    const charLower = char.toLowerCase();
                                    if (charLower === 't' || charLower === 'h') {
                                        rotation = parseInt(rowData[i + 1]);
                                    }
                                }
                                
                                // Map piece letters to shapes (matching actual filenames)
                                const shapeMap = {
                                    's': 'square', 
                                    't': 'Triangle', 
                                    'r': 'Rhombus', 
                                    'c': 'circle', 
                                    'h': 'hexagon'
                                };
                                const shape = shapeMap[char.toLowerCase()];
                                
                                if (shape) {
                                    // Handle inconsistent capitalization in filenames
                                    // white square uses "Front" (capital F), others use "front"
                                    const frontWord = (shape === 'square' && isWhite) ? 'Front' : 'front';
                                    piece.src = `ASSETS/${shape} ${color} ${frontWord}.png`;
                                    piece.alt = `${color} ${shape}`;
                                    
                                    // Apply rotation if this is a triangle or hexagon
                                    if (rotation > 0) {
                                        const rotationDegrees = rotation * 60;
                                        piece.style.transform = `rotate(-90deg) rotate(${rotationDegrees}deg)`;
                                        console.log(`üé® Placing ${color} ${shape} at row ${r}, col ${colIndex} with rotation ${rotation} (${rotationDegrees}¬∞)`);
                                    } else {
                                        console.log(`üé® Placing ${color} ${shape} at row ${r}, col ${colIndex} (hex mini-hex-${r}-${colIndex})`);
                                    }
                                    
                                    hex.appendChild(piece);
                                } else {
                                    console.warn(`üé® Unknown piece type: ${char}`);
                                }
                            } else {
                                console.warn(`üé® Hex not found: mini-hex-${r}-${colIndex}`);
                            }
                            colIndex++;
                        }
                    }
                }
            }
        }

        // ========== LEADERBOARD FUNCTIONALITY ==========
        
        let currentLeaderboardTab = 'daily';
        
        function openLeaderboardModal() {
            document.getElementById('leaderboard-modal').style.display = 'flex';
        }
        
        function closeLeaderboardModal() {
            document.getElementById('leaderboard-modal').style.display = 'none';
        }
        
        function switchLeaderboardTab(tab) {
            currentLeaderboardTab = tab;
            
            // Update tab button styles
            const tabs = ['daily', 'weekly', 'alltime'];
            tabs.forEach(t => {
                const btn = document.getElementById(`lb-tab-${t}`);
                if (btn) {
                    if (t === tab) {
                        btn.style.background = '#f1c40f';
                        btn.style.color = '#262421';
                    } else {
                        btn.style.background = '#444';
                        btn.style.color = '#ccc';
                    }
                }
            });
            
            // Note: In a real implementation, you would fetch different data here
            // For now, we're just showing the same static data
            console.log('Switched to', tab, 'leaderboard');
        }
        
        // Add event listener for Leaderboard button
        const leaderboardBtn = document.getElementById('start-leaderboard-btn');
        if (leaderboardBtn) {
            leaderboardBtn.addEventListener('click', openLeaderboardModal);
        }

        // ========== SETTINGS FUNCTIONALITY ==========
        
        // Settings state - now defined earlier in the file before updateTurnDisplay()
        
        function openSettingsModal() {
            document.getElementById('settings-modal').style.display = 'flex';
            loadSettings();
        }
        
        function closeSettingsModal() {
            document.getElementById('settings-modal').style.display = 'none';
            saveSettings();
            applySettings(); // Apply the settings after closing
        }
        
        function toggleSetting(settingName) {
            const checkbox = document.getElementById(`setting-${settingName}`);
            const isChecked = checkbox.checked;
            
            // Update the visual toggle
            const toggleContainer = checkbox.nextElementSibling;
            const toggleButton = toggleContainer.nextElementSibling;
            
            if (isChecked) {
                // Turn off
                checkbox.checked = false;
                toggleContainer.style.backgroundColor = '#555';
                toggleButton.style.left = '4px';
                
                // Map setting names to gameSettings keys
                const settingMap = {
                    'sound-effects': 'soundEffects',
                    'music': 'music',
                    'coordinates': 'coordinates',
                    'highlight-moves': 'highlightMoves',
                    'confirm-moves': 'confirmMoves',
                    'show-threats': 'showThreats',
                    'show-last-move': 'showLastMove'
                };
                
                if (settingMap[settingName]) {
                    gameSettings[settingMap[settingName]] = false;
                }
            } else {
                // Turn on
                checkbox.checked = true;
                const colors = {
                    'sound-effects': '#4ecdc4',
                    'music': '#4ecdc4',
                    'coordinates': '#ffd700',
                    'highlight-moves': '#ffd700',
                    'confirm-moves': '#a55eea',
                    'show-threats': '#a55eea',
                    'show-last-move': '#a55eea'
                };
                toggleContainer.style.backgroundColor = colors[settingName] || '#4ecdc4';
                toggleButton.style.left = '34px';
                
                // Map setting names to gameSettings keys
                const settingMap = {
                    'sound-effects': 'soundEffects',
                    'music': 'music',
                    'coordinates': 'coordinates',
                    'highlight-moves': 'highlightMoves',
                    'confirm-moves': 'confirmMoves',
                    'show-threats': 'showThreats',
                    'show-last-move': 'showLastMove'
                };
                
                if (settingMap[settingName]) {
                    gameSettings[settingMap[settingName]] = true;
                }
            }
            
            applySettings();
        }
        
        function loadSettings() {
            // Load from localStorage if available
            const saved = localStorage.getItem('romgonSettings');
            if (saved) {
                Object.assign(gameSettings, JSON.parse(saved));
            }
            
            // Update UI to match settings
            updateSettingsUI();
        }
        
        function saveSettings() {
            // Save to localStorage
            localStorage.setItem('romgonSettings', JSON.stringify(gameSettings));
            applySettings();
        }
        
        function updateSettingsUI() {
            // Update all toggle switches to match current settings
            const settingElements = {
                'sound-effects': window.gameSettings.soundEffects,
                'music': window.gameSettings.music,
                'coordinates': window.gameSettings.coordinates,
                'highlight-moves': window.gameSettings.highlightMoves,
                'confirm-moves': window.gameSettings.confirmMoves,
                'show-threats': window.gameSettings.showThreats,
                'show-last-move': window.gameSettings.showLastMove
            };
            
            for (const [key, value] of Object.entries(settingElements)) {
                const checkbox = document.getElementById(`setting-${key}`);
                const toggleContainer = checkbox.nextElementSibling;
                const toggleButton = toggleContainer.nextElementSibling;
                
                checkbox.checked = value;
                if (value) {
                    const colors = {
                        'sound-effects': '#4ecdc4',
                        'music': '#4ecdc4',
                        'coordinates': '#ffd700',
                        'highlight-moves': '#ffd700',
                        'confirm-moves': '#a55eea',
                        'show-threats': '#a55eea',
                        'show-last-move': '#a55eea'
                    };
                    toggleContainer.style.backgroundColor = colors[key];
                    toggleButton.style.left = '34px';
                } else {
                    toggleContainer.style.backgroundColor = '#555';
                    toggleButton.style.left = '4px';
                }
            }
            
            // Update animation speed slider
            document.getElementById('setting-animation-speed').value = window.gameSettings.animationSpeed;
        }
        
        function applySettings() {
            // Apply settings to the game
            console.log('Settings applied:', window.gameSettings);

            // Ensure base defense runtime variant matches saved settings
            if (typeof window.gameSettings.baseDefenseVariant !== 'undefined') {
                window.baseDefenseVariant = window.gameSettings.baseDefenseVariant;
                // applySettings runtime sync log removed
            }
            // No floating badge: side-panel indicators are the single source of truth
            // Update side-panel indicators if present
            try {
                updateVariantIndicators();
            } catch (e) {
                // ignore if not yet defined or DOM not ready
            }
            
            // Apply music setting
            if (window.gameSettings.music) {
                if (currentMusicTrack === 0 && window.gameSettings.currentMusicTrack > 0) {
                    playBackgroundMusic(window.gameSettings.currentMusicTrack); // Resume last track
                } else if (currentMusicTrack === 0) {
                    playBackgroundMusic(1); // Start with track 1 if music is enabled
                }
            } else {
                stopBackgroundMusic();
            }
            
            // Update music button display
            updateMusicButtonDisplay();
            
            // Example: Apply coordinate display setting
            if (window.gameSettings.coordinates) {
                // Show coordinates (you can integrate with existing coordinate toggle)
                console.log('Coordinates enabled');
            }
        }
        
        function resetSettings() {
            // Reset to defaults
            window.gameSettings.soundEffects = true;
            window.gameSettings.music = false;
            window.gameSettings.coordinates = false;
            window.gameSettings.highlightMoves = true;
            window.gameSettings.animationSpeed = 2;
            window.gameSettings.confirmMoves = false;
            window.gameSettings.showThreats = true;
            window.gameSettings.showLastMove = true;
            window.gameSettings.currentMusicTrack = 0;
            
            // Stop any playing music
            stopBackgroundMusic();
            
            updateSettingsUI();
            saveSettings();
            
            showNotification('‚öôÔ∏è Settings reset to defaults', 'info');
        }
        
        // Add event listener for Settings button
        const settingsBtn = document.getElementById('start-settings-btn');
        if (settingsBtn) {
            settingsBtn.addEventListener('click', openSettingsModal);
        }

        // ========== GAME MODES FUNCTIONALITY ==========
        
        function openGameModesModal() {
            document.getElementById('game-modes-modal').style.display = 'flex';
        }
        
        function closeGameModesModal() {
            document.getElementById('game-modes-modal').style.display = 'none';
        }
        
        function startGameMode(mode) {
            // Close game modes modal
            closeGameModesModal();
            
            // Hide start menu
            document.getElementById('start-menu').style.display = 'none';
            
            // Hide global account bar during gameplay
            hideGlobalAccountBar();
            
            // Show game board
            document.getElementById('board-display-container').style.display = 'block';
            
            // Mark that we're now in an active game
            gameInProgress = true;
            
            // Initialize board with the selected mode
            initializeBoard(mode);
            
            // Reset game state for new game
            currentTurnPiece = null;
            escapeRaceNotificationShown = false;
            clearMovementHistory();
            clearMoveRepetitions();
            clearCoordinateLabels();
            highlightThreatenedPieces();
            
            console.log(`Started game mode: ${mode}`);
        }
        
        function testAI() {
            console.log('üß™ Testing AI...');
            console.log('Current state:', {
                aiEnabled,
                currentPlayer,
                gameOver,
                aiThinking
            });
            
            if (aiEnabled && currentPlayer === 'white' && !gameOver && !aiThinking) {
                makeAIMove();
            } else {
                console.log('‚ùå AI test failed - conditions not met');
                if (!aiEnabled) console.log('‚ùå AI not enabled');
                if (currentPlayer !== 'white') console.log('‚ùå Not white turn, current:', currentPlayer);
                if (gameOver) console.log('‚ùå Game is over');
                if (aiThinking) console.log('‚ùå AI is already thinking');
            }
        }
        
        function testTriangleRotation() {
            console.log('üî∫ Testing Triangle Rotation...');
            
            // Test all orientations
            for (let i = 0; i < 6; i++) {
                console.log(`\nüî∫ Testing orientation ${i}:`);
                const angleMap = [270, 330, 30, 90, 150, 210];
                const rotation = angleMap[i];
                console.log(`  Should point to: ${rotation}¬∞ (position ${i} on hex)`);
            }
            
            // Test a specific triangle
            const testHex = document.getElementById('hex-5-6');
            if (testHex) {
                const triangle = testHex.querySelector('.triangle-piece');
                if (triangle) {
                    console.log('\nüî∫ Testing triangle at 5-6:');
                    const currentOrientation = getTriangleOrientation('hex-5-6');
                    console.log('Current orientation:', currentOrientation);
                    
                    // Test right rotation
                    console.log('Testing right rotation...');
                    rotateTriangleRight('hex-5-6');
                    
                    // Test left rotation
                    console.log('Testing left rotation...');
                    rotateTriangleLeft('hex-5-6');
                } else {
                    console.log('‚ùå No triangle found at 5-6');
                }
            } else {
                console.log('‚ùå Hex 5-6 not found');
            }
        }

        // ========== MULTIPLAYER FUNCTIONALITY ==========
        
        let socket = null;
        let multiplayerMode = false;
        let myPlayerColor = null;
        let currentRoomCode = null;
        let opponentConnected = false;

        // Initialize Socket.IO connection
        function initializeMultiplayerConnection() {
            // Use BACKEND_API_URL for multiplayer connection
            let serverURL;
            if (window.location.protocol === 'file:' || 
                window.location.hostname === '' || 
                window.location.hostname === 'localhost' || 
                window.location.hostname === '127.0.0.1') {
                serverURL = 'http://localhost:3000';
            } else {
                serverURL = typeof BACKEND_API_URL !== 'undefined' ? BACKEND_API_URL : 'https://api.romgon.net';
            }
            
            console.log('üîå Connecting to multiplayer server:', serverURL);
            socket = io(serverURL);
            
            // Connection events
            socket.on('connect', () => {
                console.log('‚úÖ Connected to multiplayer server');
                updateConnectionStatus('connected', 'Connected');
            });
            
            socket.on('disconnect', () => {
                console.log('‚ùå Disconnected from server');
                updateConnectionStatus('disconnected', 'Disconnected');
                if (multiplayerMode && opponentConnected) {
                    showNotification('‚ö†Ô∏è Connection lost to server', 'warning');
                }
            });
            
            socket.on('connect_error', (error) => {
                console.warn('‚ö†Ô∏è Multiplayer WebSocket unavailable:', error.message);
                console.log('‚ÑπÔ∏è Use Rooms system for multiplayer (new feature)');
                updateConnectionStatus('disconnected', 'Use Rooms for multiplayer');
                // Don't show error - rooms system is the new way
            });
            
            // Room created
            socket.on('room-created', (data) => {
                console.log('üéÆ Room created:', data);
                currentRoomCode = data.roomCode;
                myPlayerColor = data.playerColor;
                multiplayerMode = true;
                
                // Update UI
                document.getElementById('room-code-display').textContent = data.roomCode;
                showView('mp-create-room');
                updateConnectionStatus('waiting', 'Waiting for opponent...');
                document.getElementById('player-color-display').textContent = myPlayerColor.toUpperCase();
                document.getElementById('current-room-code').textContent = data.roomCode;
                document.getElementById('room-info').style.display = 'block';
                document.getElementById('multiplayer-status').style.display = 'block';
            });
            
            // Opponent joined
            socket.on('opponent-joined', (data) => {
                console.log('üë§ Opponent joined:', data);
                opponentConnected = true;
                showNotification(`‚úÖ Opponent joined! You are ${myPlayerColor.toUpperCase()}`, 'success');
            });
            
            // Room joined
            socket.on('room-joined', (data) => {
                console.log('‚úÖ Joined room:', data);
                currentRoomCode = data.roomCode;
                myPlayerColor = data.playerColor;
                multiplayerMode = true;
                opponentConnected = true;
                
                // Update UI
                updateConnectionStatus('connected', 'Connected to game');
                document.getElementById('player-color-display').textContent = myPlayerColor.toUpperCase();
                document.getElementById('current-room-code').textContent = data.roomCode;
                document.getElementById('room-info').style.display = 'block';
                document.getElementById('multiplayer-status').style.display = 'block';
                
                showNotification(`‚úÖ Joined as ${myPlayerColor.toUpperCase()}!`, 'success');
            });
            
            // Game start
            socket.on('game-start', (data) => {
                console.log('üéÆ Game starting:', data);
                closeMultiplayerModal();
                
            // Hide start menu
            document.getElementById('start-menu').style.display = 'none';
            // Show game board
            document.getElementById('board-display-container').style.display = 'block';
            
            // Mark that we're now in an active game
            gameInProgress = true;
            
                // Initialize board
            initializeBoard('full');
                aiEnabled = false;
            currentTurnPiece = null;
            escapeRaceNotificationShown = false;
            clearMovementHistory();
            clearMoveRepetitions();
            clearCoordinateLabels();
            highlightThreatenedPieces();
                
                showNotification(`üéÆ Game started! ${data.currentPlayer.toUpperCase()} goes first`, 'info');
            });
            
            // Move made by opponent
            socket.on('move-made', (data) => {
                if (data.playerColor === myPlayerColor) return; // Ignore our own moves
                
                console.log('üì• Opponent move:', data);
                
                // Apply the move
                applyOpponentMove(data.move, data.gameState);
            });
            
            // Turn ended
            socket.on('turn-ended', (data) => {
                console.log('üîÑ Turn ended:', data);
                currentPlayer = data.currentPlayer;
                updateTurnDisplay();
                highlightThreatenedPieces();
                
                if (currentPlayer === myPlayerColor) {
                    showNotification('‚ú® Your turn!', 'info');
                }
            });
            
            // Game ended
            socket.on('game-ended', (data) => {
                console.log('üèÜ Game ended:', data);
                showGameOver(data.winner, data.reason);
            });
            
            // Room errors
            socket.on('room-error', (data) => {
                console.error('‚ùå Room error:', data.message);
                document.getElementById('mp-error-message').textContent = data.message;
            });
            
            // Opponent disconnected
            socket.on('opponent-disconnected', (data) => {
                console.log('‚ö†Ô∏è Opponent disconnected:', data);
                opponentConnected = false;
                showNotification(`‚ö†Ô∏è ${data.message}`, 'warning');
            });
            
            // Room closed
            socket.on('room-closed', (data) => {
                console.log('üóëÔ∏è Room closed:', data.reason);
                showNotification(`Room closed: ${data.reason}`, 'warning');
                resetMultiplayerState();
            });
        }
        
        // Multiplayer UI Functions
        function openMultiplayerModal() {
            if (!socket) {
                initializeMultiplayerConnection();
            }
            document.getElementById('multiplayer-modal').classList.add('active');
            showView('mp-main-menu');
        }
        
        function closeMultiplayerModal() {
            document.getElementById('multiplayer-modal').classList.remove('active');
        }
        
        function showView(viewId) {
            // Hide all views
            document.getElementById('mp-main-menu').style.display = 'none';
            document.getElementById('mp-create-room').style.display = 'none';
            document.getElementById('mp-join-room').style.display = 'none';
            document.getElementById('mp-matchmaking').style.display = 'none';
            document.getElementById('mp-public-rooms').style.display = 'none';
            document.getElementById('mp-waiting-room').style.display = 'none';
            
            // Show requested view
            const viewElement = document.getElementById(viewId);
            if (viewElement) {
                viewElement.style.display = 'block';
            }
        }

        function showMultiplayerConnectionStatus(status, message) {
            console.log(`üîå Connection status: ${status} - ${message}`);
            
            // Update connection indicator if it exists
            updateConnectionStatus(status, message);
            
            // Also show in modal if open
            const modal = document.getElementById('multiplayer-modal');
            if (modal && modal.classList.contains('active')) {
                const errorElement = document.getElementById('mp-error-message');
                if (errorElement) {
                    if (status === 'error') {
                        errorElement.textContent = message;
                        errorElement.style.display = 'block';
                        errorElement.style.color = '#e74c3c';
                    } else if (status === 'connected') {
                        errorElement.style.display = 'none';
                    }
                }
            }
        }
        
        // ============================================
        // MULTIPLAYER ROOM & MATCHMAKING FUNCTIONS
        // ============================================

        let isPlayerReady = false;

        async function createMultiplayerRoom() {
            try {
                // Check if user is logged in
                const token = localStorage.getItem('romgon-jwt');
                if (!token) {
                    alert('Please log in to create a multiplayer room');
                    return;
                }

                // Clear any previous errors
                const errorElement = document.getElementById('mp-error-message');
                if (errorElement) {
                    errorElement.style.display = 'none';
                }

                showView('mp-create-room');
                document.getElementById('room-code-display').textContent = 'Creating...';

                // Create room via HTTP API (don't wait for WebSocket)
                const room = await roomClient.createRoom({ isPrivate: false });
                
                document.getElementById('room-code-display').textContent = room.code;
                console.log('‚úÖ Room created:', room);

                // Try to connect WebSocket in background (non-blocking)
                if (!roomClient.socket || !roomClient.socket.connected) {
                    console.log('üîå Connecting to WebSocket in background...');
                    roomClient.connect();
                }

                // Setup room event handlers
                roomClient.onPlayerJoinedRoom = (data) => {
                    console.log('üë§ Player joined:', data);
                    updateRoomPlayersList(data.players);
                    
                    // Show ready button when both players present
                    if (data.players && data.players.length === 2) {
                        document.getElementById('ready-button').style.display = 'block';
                    }
                };

                roomClient.onGameStarted = (data) => {
                    console.log('üéÆ Game starting!', data);
                    closeMultiplayerModal();
                    startMultiplayerGame(data.gameId);
                };
            } catch (error) {
                console.error('‚ùå Error creating room:', error);
                alert('Failed to create room: ' + error.message);
                backToMultiplayerMenu();
            }
        }

        async function startMatchmaking() {
            try {
                // Check if user is logged in
                const token = localStorage.getItem('romgon-jwt');
                if (!token) {
                    alert('Please log in to use matchmaking');
                    return;
                }

                // Connect to WebSocket
                if (!roomClient.socket || !roomClient.socket.connected) {
                    roomClient.connect();
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }

                showView('mp-matchmaking');

                const result = await roomClient.joinMatchmaking({ variant: 'standard' });

                if (result.matched) {
                    // Match found immediately
                    console.log('üéØ Match found!', result.room);
                    showView('mp-waiting-room');
                    document.getElementById('waiting-room-code').textContent = result.room.code;
                    startMultiplayerGame(result.room.gameId);
                } else {
                    // Waiting for match
                    console.log('üîç Searching for opponent...');
                    
                    // Setup callback for when match is found
                    roomClient.onPlayerJoinedRoom = (data) => {
                        if (data.players && data.players.length === 2) {
                            console.log('üéØ Opponent found!');
                            showView('mp-waiting-room');
                            document.getElementById('waiting-room-code').textContent = roomClient.currentRoom.code;
                            updateWaitingRoomPlayers(data.players);
                        }
                    };

                    roomClient.onGameStarted = (data) => {
                        console.log('üéÆ Game starting!', data);
                        closeMultiplayerModal();
                        startMultiplayerGame(data.gameId);
                    };
                }
            } catch (error) {
                console.error('‚ùå Matchmaking error:', error);
                alert('Matchmaking failed: ' + error.message);
                backToMultiplayerMenu();
            }
        }

        async function cancelMatchmaking() {
            await roomClient.leaveMatchmaking();
            backToMultiplayerMenu();
        }

        async function showPublicRooms() {
            try {
                showView('mp-public-rooms');
                
                const rooms = await roomClient.listPublicRooms();
                const container = document.getElementById('public-rooms-list');

                if (rooms.length === 0) {
                    container.innerHTML = '<p style="text-align: center; color: #888;">No public rooms available</p>';
                } else {
                    container.innerHTML = rooms.map(room => `
                        <div class="public-room-item" onclick="joinPublicRoom('${room.code}')" style="
                            background: rgba(255,255,255,0.05);
                            border: 1px solid rgba(255,255,255,0.1);
                            border-radius: 8px;
                            padding: 12px;
                            margin-bottom: 10px;
                            cursor: pointer;
                            transition: all 0.2s;
                        " onmouseover="this.style.background='rgba(255,255,255,0.08)'" 
                           onmouseout="this.style.background='rgba(255,255,255,0.05)'">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <div>
                                    <strong style="font-size: 16px; color: #fff;">
                                        ${room.name || room.hostUsername + "'s Room"}
                                    </strong>
                                    <span class="room-code-badge" style="
                                        background: rgba(52,152,219,0.3);
                                        color: #3498db;
                                        padding: 2px 8px;
                                        border-radius: 4px;
                                        font-size: 12px;
                                        font-weight: bold;
                                        margin-left: 8px;
                                    ">${room.code}</span>
                                    ${room.isPermanent ? '<span style="background: rgba(241,196,15,0.3); color: #f1c40f; padding: 2px 8px; border-radius: 4px; font-size: 11px; margin-left: 4px;">ALWAYS OPEN</span>' : ''}
                                    ${room.allowGuests ? '<span style="background: rgba(46,204,113,0.3); color: #2ecc71; padding: 2px 8px; border-radius: 4px; font-size: 11px; margin-left: 4px;">‚úì GUESTS OK</span>' : ''}
                                </div>
                                <div style="font-size: 14px; color: #888;">
                                    ${room.playerCount}/${room.maxPlayers} players
                                </div>
                            </div>
                            ${room.description ? `<div style="font-size: 13px; color: #aaa; margin-top: 4px;">${room.description}</div>` : ''}
                        </div>
                    `).join('');
                }
            } catch (error) {
                console.error('‚ùå Error loading public rooms:', error);
            }
        }

        async function joinPublicRoom(roomCode) {
            try {
                const token = localStorage.getItem('romgon-jwt');
                const room = (await roomClient.listPublicRooms()).find(r => r.code === roomCode);
                
                // Check if room allows guests
                if (!token && room && !room.allowGuests) {
                    alert('Please log in to join this room. Only "üé≠ Guest Arena" allows guest players.');
                    return;
                }
                
                // If guest and room allows guests, join as guest
                if (!token && room && room.allowGuests) {
                    const guestName = prompt('Enter your guest name (optional):') || '';
                    await joinAsGuest(roomCode, guestName);
                    return;
                }
                
                await joinMultiplayerRoomByCode(roomCode);
            } catch (error) {
                console.error('‚ùå Error joining public room:', error);
                alert('Failed to join room: ' + error.message);
            }
        }
        
        async function joinAsGuest(roomCode, guestName) {
            try {
                const response = await fetch(`${BACKEND_API_URL}/api/rooms/join/guest`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ roomCode, guestName })
                });
                
                const data = await response.json();
                if (!data.success) {
                    alert('Failed to join: ' + data.error);
                    return;
                }
                
                console.log('‚úÖ Joined as guest:', data.guestInfo);
                
                // Store guest info temporarily
                localStorage.setItem('romgon-guest-info', JSON.stringify(data.guestInfo));
                
                // Show waiting room
                showView('mp-waiting-room');
                document.getElementById('waiting-room-code').textContent = data.room.code;
                updateWaitingRoomPlayers(data.room.players);
                
                alert('Joined as ' + data.guestInfo.guestUsername + '! Waiting for opponent...');
            } catch (error) {
                console.error('‚ùå Error joining as guest:', error);
                alert('Failed to join as guest: ' + error.message);
            }
        }
        
        function showJoinRoom() {
            showView('mp-join-room');
            document.getElementById('mp-error-message').textContent = '';
            document.getElementById('room-code-input').value = '';
        }
        
        async function joinMultiplayerRoom() {
            const roomCode = document.getElementById('room-code-input').value.trim().toUpperCase();
            await joinMultiplayerRoomByCode(roomCode);
        }

        async function joinMultiplayerRoomByCode(roomCode) {
            try {
                if (roomCode.length !== 6) {
                    document.getElementById('mp-error-message').textContent = 'Room code must be 6 characters';
                    return;
                }

                // Check if user is logged in
                const token = localStorage.getItem('romgon-jwt');
                if (!token) {
                    alert('Please log in to join a multiplayer room');
                    return;
                }

                // Connect to WebSocket
                if (!roomClient.socket || !roomClient.socket.connected) {
                    roomClient.connect();
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }

                document.getElementById('mp-error-message').textContent = '';

                const room = await roomClient.joinRoom(roomCode);
                
                console.log('‚úÖ Joined room:', room);

                showView('mp-waiting-room');
                document.getElementById('waiting-room-code').textContent = room.code;
                updateWaitingRoomPlayers(room.players);

                // Setup room event handlers
                roomClient.onPlayerReady = (data) => {
                    console.log('‚úÖ Player ready:', data);
                    updateWaitingRoomPlayers(data.players);
                };

                roomClient.onGameStarted = (data) => {
                    console.log('üéÆ Game starting!', data);
                    closeMultiplayerModal();
                    startMultiplayerGame(data.gameId);
                };
            } catch (error) {
                console.error('‚ùå Error joining room:', error);
                document.getElementById('mp-error-message').textContent = error.message;
            }
        }

        async function toggleReady() {
            isPlayerReady = !isPlayerReady;
            
            const readyButton = document.getElementById('ready-button') || document.getElementById('waiting-ready-button');
            if (readyButton) {
                readyButton.textContent = isPlayerReady ? '‚úì Ready' : 'Ready?';
                readyButton.style.background = isPlayerReady 
                    ? 'linear-gradient(135deg, #2ecc71 0%, #27ae60 100%)'
                    : 'linear-gradient(135deg, #4ecdc4 0%, #44a08d 100%)';
            }

            await roomClient.setReady(isPlayerReady);
        }

        function updateRoomPlayersList(players) {
            const container = document.getElementById('room-players-list');
            if (!container || !players) return;

            container.innerHTML = players.map(player => `
                <div class="room-player ${player.ready ? 'ready' : ''}">
                    <span class="player-name">${player.username} (${player.color})</span>
                    ${player.ready ? '<span class="player-ready-badge">‚úì Ready</span>' : ''}
                </div>
            `).join('');
        }

        function updateWaitingRoomPlayers(players) {
            const container = document.getElementById('waiting-room-players');
            if (!container || !players) return;

            container.innerHTML = players.map(player => `
                <div class="room-player ${player.ready ? 'ready' : ''}">
                    <span class="player-name">${player.username} (${player.color})</span>
                    ${player.ready ? '<span class="player-ready-badge">‚úì Ready</span>' : ''}
                </div>
            `).join('');
        }

        async function leaveWaitingRoom() {
            await roomClient.leaveRoom();
            isPlayerReady = false;
            backToMultiplayerMenu();
        }

        function cancelCreateRoom() {
            if (roomClient.currentRoom) {
                roomClient.leaveRoom();
            }
            resetMultiplayerState();
            showView('mp-main-menu');
        }
        
        function backToMultiplayerMenu() {
            showView('mp-main-menu');
            document.getElementById('mp-error-message').textContent = '';
            isPlayerReady = false;
        }

        function startMultiplayerGame(gameId) {
            console.log('üéÆ Starting multiplayer game:', gameId);
            
            multiplayerMode = true;
            
            // Determine player color from room
            if (roomClient.currentRoom && roomClient.currentRoom.players) {
                const token = localStorage.getItem('romgon-jwt');
                const payload = JSON.parse(atob(token.split('.')[1]));
                const myPlayer = roomClient.currentRoom.players.find(p => p.userId === payload.userId);
                
                if (myPlayer) {
                    myPlayerColor = myPlayer.color;
                    console.log('üë§ You are playing as:', myPlayerColor);
                }
            }

            // Join the game room via WebSocket
            roomClient.socket.emit('game:join', {
                gameId,
                userId: JSON.parse(atob(localStorage.getItem('romgon-jwt').split('.')[1])).userId
            });

            // Start the game
            closeMultiplayerModal();
            document.getElementById('multiplayer-status').style.display = 'block';
            document.getElementById('room-info').style.display = 'block';
            document.getElementById('current-room-code').textContent = roomClient.currentRoom?.code || gameId.slice(0, 6);
            document.getElementById('player-color-display').textContent = myPlayerColor || 'Unknown';

            // Initialize game
            initGame();
        }
        
        function updateConnectionStatus(status, text) {
            const indicator = document.getElementById('connection-indicator');
            const textElement = document.getElementById('connection-text');
            
            if (indicator) indicator.className = 'status-indicator ' + status;
            if (textElement) textElement.textContent = text;
        }
        
        function resetMultiplayerState() {
            multiplayerMode = false;
            myPlayerColor = null;
            opponentConnected = false;
            isPlayerReady = false;
            if (document.getElementById('multiplayer-status')) {
                document.getElementById('multiplayer-status').style.display = 'none';
            }
            if (document.getElementById('room-info')) {
                document.getElementById('room-info').style.display = 'none';
            }
        }
        
        // Game state synchronization functions
        function getPiecePositions() {
            const pieces = [];
            document.querySelectorAll('.hexagon').forEach(hex => {
                const piece = hex.querySelector('[class*="-piece"]');
                if (piece) {
                    pieces.push({
                        hexId: hex.id,
                        classes: piece.className
                    });
                }
            });
            return pieces;
        }
        
        function broadcastMove(fromId, toId, pieceClasses, captured) {
            // Don't broadcast in dev mode or if no socket
            if (!multiplayerMode || !socket || myPlayerColor === 'both') return;
            
            socket.emit('make-move', {
                move: {
                    from: fromId,
                    to: toId,
                    piece: pieceClasses,
                    captured: captured
                },
                gameState: {
                    currentPlayer: currentPlayer,
                    pieces: getPiecePositions(),
                    triangleOrientations: Object.fromEntries(triangleOrientations)
                }
            });
        }
        
        function broadcastTurnEnd() {
            if (!multiplayerMode || !socket) return;
            
            socket.emit('end-turn', {
                gameState: {
                    currentPlayer: currentPlayer,
                    pieces: getPiecePositions(),
                    triangleOrientations: Object.fromEntries(triangleOrientations),
                    moveHistory: moveHistory
                }
            });
        }
        
        function broadcastGameOver(winner, reason) {
            // Don't broadcast in dev mode
            if (!multiplayerMode || !socket || myPlayerColor === 'both') return;
            
            socket.emit('game-over', {
                winner: winner,
                reason: reason
            });
        }
        
        function applyOpponentMove(move, gameState) {
            // Find and move the piece
            const fromHex = document.getElementById(move.from);
            const toHex = document.getElementById(move.to);
            
            if (!fromHex || !toHex) return;
            
            const piece = fromHex.querySelector('[class*="-piece"]');
            if (!piece) return;
            
            // Handle capture
            const existingPiece = toHex.querySelector('[class*="-piece"]');
            if (existingPiece) {
                addToEliminatedPieces(existingPiece);
                existingPiece.remove();
                playSound('capture');
            } else {
                playSound('click');
            }
            
            // Move piece
            toHex.appendChild(piece);
            
            // Highlight the opponent's last move
            highlightLastMove(move.from, move.to);
            
            // Update game state
            if (gameState.triangleOrientations) {
                triangleOrientations = new Map(Object.entries(gameState.triangleOrientations));
            }
            
            // Update turn display
            updateTurnDisplay();
            highlightThreatenedPieces();
        }
        
        function showNotification(message, type = 'info') {
            // Create notification element
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 140px;
                right: 20px;
                background: ${type === 'success' ? '#26de81' : type === 'warning' ? '#ffa502' : '#4ecdc4'};
                color: white;
                padding: 15px 20px;
                border-radius: 10px;
                box-shadow: 0 4px 15px rgba(0,0,0,0.3);
                z-index: 10000;
                font-weight: bold;
                animation: slideIn 0.3s ease;
            `;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            // Remove after 3 seconds
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }
        
        // Override switchTurn to broadcast in multiplayer
        const originalSwitchTurn = window.switchTurn;
        window.switchTurn = function() {
            if (multiplayerMode && myPlayerColor !== 'both') {
                // Only allow turn switch if it's our turn (except in dev mode)
                if (currentPlayer !== myPlayerColor) {
                    console.log('Not your turn!');
                    return;
                }
            }
            
            // Call original function
            if (originalSwitchTurn) {
                originalSwitchTurn();
            }
            
            // Broadcast turn end in multiplayer (but not in dev mode)
            if (multiplayerMode && myPlayerColor !== 'both') {
                broadcastTurnEnd();
            }
        };
        
        // Override showGameOver to broadcast in multiplayer
        const originalShowGameOver = window.showGameOver;
        window.showGameOver = function(winner, reason) {
            // Call original function
            if (originalShowGameOver) {
                originalShowGameOver(winner, reason);
            }
            
            // Broadcast game over in multiplayer
            if (multiplayerMode) {
                broadcastGameOver(winner, reason);
            }
        };
        
        // ========== DEV MODE (Local Testing) ==========
        
        function startDevMode() {
            console.log('üîß Starting Dev Mode - Local Multiplayer Test');
            
            // Simulate multiplayer mode without server
            multiplayerMode = true;
            myPlayerColor = 'both'; // Special mode - control both players
            currentRoomCode = 'DEV-MODE';
            opponentConnected = true;
            
            // Update UI
            updateConnectionStatus('connected', 'Dev Mode Active');
            document.getElementById('player-color-display').textContent = 'BOTH (DEV)';
            document.getElementById('current-room-code').textContent = 'DEV-MODE';
            document.getElementById('room-info').style.display = 'block';
            document.getElementById('multiplayer-status').style.display = 'block';
            
            // Close modal and start game
            closeMultiplayerModal();
            
            // Hide start menu
            document.getElementById('start-menu').style.display = 'none';
            // Show game board
            document.getElementById('board-display-container').style.display = 'block';
            // Initialize board
            initializeBoard('full');
            aiEnabled = false;
            currentTurnPiece = null;
            escapeRaceNotificationShown = false;
            clearMovementHistory();
            clearMoveRepetitions();
            clearCoordinateLabels();
            highlightThreatenedPieces();
            
            showNotification('üîß Dev Mode: You can move both Black and White pieces!', 'info');
            
            console.log('‚úÖ Dev Mode active - you can control both players locally');
        }

        // Function to show start menu
        function showStartMenu() {
            // Hide game over overlay if it exists
            const gameOverOverlay = document.querySelector('[style*="position: fixed"][style*="z-index: 1000"]');
            if (gameOverOverlay) {
                gameOverOverlay.remove();
            }
            
            // Show global account bar when returning to menu
            const currentUser = localStorage.getItem('romgon-user');
            if (currentUser) {
                showGlobalAccountBar();
            }
            
            // If we're in an active game, don't reset the game state
            if (!gameInProgress) {
                // Stop and reset timers
                stopTimer();
                timerEnabled = false;
                const playerTimersEl = document.getElementById('player-timers');
                if (playerTimersEl) playerTimersEl.style.display = 'none';
                
                // Reset game state
                gameOver = false;
                currentPlayer = 'black';
                currentTurnPiece = null;
                gameMode = 'full';
                
                // Reset board to original configuration
                resetBoardToOriginal();
                
                // Reset turn display
                updateTurnDisplay();
            }
            
            // Show/hide return to game button based on game state
            const returnToGameContainer = document.getElementById('return-to-game-container');
            if (returnToGameContainer) {
                returnToGameContainer.style.display = gameInProgress ? 'block' : 'none';
            }
            
            // Hide splash page
            const splashPage = document.getElementById('splash-page');
            if (splashPage) splashPage.style.display = 'none';
            
            // Show start menu
            const startMenuEl = document.getElementById('start-menu');
            if (startMenuEl) startMenuEl.style.display = 'flex';
            // Hide game board
            const boardDisplayEl = document.getElementById('board-display-container');
            if (boardDisplayEl) boardDisplayEl.style.display = 'none';
            // Hide AI reasoning panel
            const aiPanelEl = document.getElementById('ai-reasoning-panel');
            if (aiPanelEl) aiPanelEl.style.display = 'none';
        }
        
        // Function to return to active game
        function returnToGame() {
            // Hide global account bar when returning to gameplay
            hideGlobalAccountBar();
            
            // Hide start menu
            const startMenuEl = document.getElementById('start-menu');
            if (startMenuEl) startMenuEl.style.display = 'none';
            
            // Show game board
            const boardDisplayEl = document.getElementById('board-display-container');
            if (boardDisplayEl) boardDisplayEl.style.display = 'block';
            
            // Show AI reasoning panel if AI is enabled
            const aiPanelEl = document.getElementById('ai-reasoning-panel');
            if (aiPanelEl && aiEnabled) aiPanelEl.style.display = 'block';
            
            // Reset gameInProgress flag
            gameInProgress = false;
        }
        
        function showAIModelSelector() {
            // Create model selector overlay
            const overlay = document.createElement('div');
            overlay.id = 'ai-model-overlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 2000;
            `;
            
            const selector = document.createElement('div');
            selector.style.cssText = `
                background: linear-gradient(135deg, #1e3c72, #2a5298);
                border: 2px solid #00d2ff;
                border-radius: 20px;
                padding: 30px;
                max-width: 500px;
                width: 90%;
                color: white;
                box-shadow: 0 10px 50px rgba(0, 210, 255, 0.5);
            `;
            
            selector.innerHTML = `
                <h2 style="text-align: center; color: #00d2ff; margin-bottom: 20px;">üß† Select AI Model</h2>
                <p style="text-align: center; font-size: 0.9em; color: #aaa; margin-bottom: 30px;">
                    Choose which AI model to play against (Mockup - uses same algorithm with different personalities)
                </p>
                
                <div style="display: flex; flex-direction: column; gap: 15px;">
                    <button class="ai-model-option" data-model="claude-sonnet" style="
                        background: linear-gradient(45deg, #8b5cf6, #7c3aed);
                        border: 2px solid ${currentAIModel === 'claude-sonnet' ? '#00d2ff' : 'transparent'};
                        color: white;
                        padding: 15px;
                        border-radius: 12px;
                        cursor: pointer;
                        font-size: 0.95em;
                        font-weight: bold;
                        transition: all 0.3s ease;
                    ">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span style="font-size: 1.5em;">üß†</span>
                            <div style="text-align: left;">
                                <div>Claude Sonnet 3.5</div>
                                <div style="font-size: 0.7em; font-weight: normal; opacity: 0.8;">Analytical, methodical thinking</div>
                            </div>
                        </div>
                    </button>
                    
                    <button class="ai-model-option" data-model="gpt4" style="
                        background: linear-gradient(45deg, #10b981, #059669);
                        border: 2px solid ${currentAIModel === 'gpt4' ? '#00d2ff' : 'transparent'};
                        color: white;
                        padding: 15px;
                        border-radius: 12px;
                        cursor: pointer;
                        font-size: 0.95em;
                        font-weight: bold;
                        transition: all 0.3s ease;
                    ">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span style="font-size: 1.5em;">ü§ñ</span>
                            <div style="text-align: left;">
                                <div>GPT-4 Turbo</div>
                                <div style="font-size: 0.7em; font-weight: normal; opacity: 0.8;">Strategic, calculated moves</div>
                            </div>
                        </div>
                    </button>
                    
                    <button class="ai-model-option" data-model="grok" style="
                        background: linear-gradient(45deg, #f59e0b, #d97706);
                        border: 2px solid ${currentAIModel === 'grok' ? '#00d2ff' : 'transparent'};
                        color: white;
                        padding: 15px;
                        border-radius: 12px;
                        cursor: pointer;
                        font-size: 0.95em;
                        font-weight: bold;
                        transition: all 0.3s ease;
                    ">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span style="font-size: 1.5em;">üöÄ</span>
                            <div style="text-align: left;">
                                <div>Grok 2</div>
                                <div style="font-size: 0.7em; font-weight: normal; opacity: 0.8;">Aggressive, bold playstyle</div>
                            </div>
                        </div>
                    </button>
                    
                    <button class="ai-model-option" data-model="gemini" style="
                        background: linear-gradient(45deg, #3b82f6, #2563eb);
                        border: 2px solid ${currentAIModel === 'gemini' ? '#00d2ff' : 'transparent'};
                        color: white;
                        padding: 15px;
                        border-radius: 12px;
                        cursor: pointer;
                        font-size: 0.95em;
                        font-weight: bold;
                        transition: all 0.3s ease;
                    ">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span style="font-size: 1.5em;">‚ú®</span>
                            <div style="text-align: left;">
                                <div>Gemini Pro</div>
                                <div style="font-size: 0.7em; font-weight: normal; opacity: 0.8;">Pattern-focused, precise</div>
                            </div>
                        </div>
                    </button>
                </div>
                
                <button id="close-model-selector" style="
                    width: 100%;
                    background-color: #ef4444;
                    color: white;
                    border: none;
                    padding: 12px;
                    border-radius: 12px;
                    cursor: pointer;
                    font-weight: bold;
                    margin-top: 20px;
                    font-size: 1em;
                ">
                    CANCEL
                </button>
            `;
            
            overlay.appendChild(selector);
            document.body.appendChild(overlay);
            
            // Add event listeners
            document.querySelectorAll('.ai-model-option').forEach(btn => {
                btn.onmouseover = function() { this.style.transform = 'scale(1.02)'; };
                btn.onmouseout = function() { this.style.transform = 'scale(1)'; };
                btn.onclick = function() {
                    const model = this.dataset.model;
                    currentAIModel = model;
                    updateAIModelDisplay();
                    overlay.remove();
                };
            });
            
            document.getElementById('close-model-selector').onclick = () => overlay.remove();
            overlay.onclick = (e) => {
                if (e.target === overlay) overlay.remove();
            };
        }
        
        // Function to reset board to original full game configuration
        function resetBoardToOriginal() {
            // Remove all pieces from all hexes first
            const allHexes = document.querySelectorAll('.hexagon');
            allHexes.forEach(hex => {
                const pieces = hex.querySelectorAll('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                pieces.forEach(piece => piece.remove());
            });
            
            // Restore original pieces
            // White triangle at 1-0
            const hex10 = document.getElementById('hex-1-0');
            const triangle10 = document.createElement('div');
            triangle10.className = 'triangle-piece white-triangle';
            triangle10.draggable = true;
            hex10.appendChild(triangle10);
            
            // Black triangle at 1-6
            const hex16 = document.getElementById('hex-1-6');
            const triangle16 = document.createElement('div');
            triangle16.className = 'triangle-piece';
            triangle16.draggable = true;
            hex16.appendChild(triangle16);
            
            // White circle at 2-0
            const hex20 = document.getElementById('hex-2-0');
            const circle20 = document.createElement('div');
            circle20.className = 'circle-piece white-circle';
            circle20.draggable = true;
            hex20.appendChild(circle20);
            
            // Black hexgon at 2-7
            const hex27 = document.getElementById('hex-2-7');
            const hexgon27 = document.createElement('div');
            hexgon27.className = 'hexgon-piece';
            hexgon27.draggable = true;
            hex27.appendChild(hexgon27);
            
            // White rhombus at 3-0
            const hex30 = document.getElementById('hex-3-0');
            const rhombus30 = document.createElement('div');
            rhombus30.className = 'rhombus-piece white-rhombus';
            rhombus30.draggable = true;
            hex30.appendChild(rhombus30);
            
            // Black rhombus at 3-8
            const hex38 = document.getElementById('hex-3-8');
            const rhombus38 = document.createElement('div');
            rhombus38.className = 'rhombus-piece';
            rhombus38.draggable = true;
            hex38.appendChild(rhombus38);
            
            // White hexgon at 4-0
            const hex40 = document.getElementById('hex-4-0');
            const hexgon40 = document.createElement('div');
            hexgon40.className = 'hexgon-piece white-hexgon';
            hexgon40.draggable = true;
            hex40.appendChild(hexgon40);
            
            // Black circle at 4-7
            const hex47 = document.getElementById('hex-4-7');
            const circle47 = document.createElement('div');
            circle47.className = 'circle-piece';
            circle47.draggable = true;
            hex47.appendChild(circle47);
            
            // White triangle at 5-0
            const hex50 = document.getElementById('hex-5-0');
            const triangle50 = document.createElement('div');
            triangle50.className = 'triangle-piece white-triangle';
            triangle50.draggable = true;
            hex50.appendChild(triangle50);
            
            // Black triangle at 5-6
            const hex56 = document.getElementById('hex-5-6');
            const triangle56 = document.createElement('div');
            triangle56.className = 'triangle-piece';
            triangle56.draggable = true;
            hex56.appendChild(triangle56);
            
            // White square at 0-0
            const hex00 = document.getElementById('hex-0-0');
            const square00 = document.createElement('div');
            square00.className = 'square-piece white-piece';
            square00.draggable = true;
            hex00.appendChild(square00);
            
            // Black square at 6-0
            const hex60 = document.getElementById('hex-6-0');
            const square60 = document.createElement('div');
            square60.className = 'square-piece';
            square60.draggable = true;
            hex60.appendChild(square60);
            
            // Re-setup drag and drop
            setupDragAndDrop();
        }

        // Function to show help
        function showHelp() {
            const helpOverlay = document.createElement('div');
            helpOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 1500;
                color: white;
                font-family: 'Arial', sans-serif;
            `;
            
            const helpContent = document.createElement('div');
            helpContent.style.cssText = `
                background: rgba(0, 0, 0, 0.9);
                padding: 30px;
                border-radius: 15px;
                border: 2px solid #4ecdc4;
                max-width: 600px;
                text-align: left;
                max-height: 80vh;
                overflow-y: auto;
            `;
            
            helpContent.innerHTML = `
                <h2 style="color: #4ecdc4; text-align: center; margin-bottom: 20px;">üéÆ ROMGON - COMPLETE GUIDE</h2>
                
                <h3 style="color: #ff6b6b;">üéØ Victory Conditions</h3>
                <p><strong>Black:</strong> Move rhombus to 3-0 | <strong>White:</strong> Move rhombus to 3-8</p>
                <p><strong>Base Defence:</strong> Cannot win if opponent's rhombus is at their base!</p>
                <p><strong>Deadlock (Checkmate):</strong> Win if opponent's rhombus is under attack with no legal moves!</p>
                <p><strong>Escape Race:</strong> When only rhombuses remain, first to goal wins (Base Defence disabled)!</p>
                <p><strong>Three-Fold Repetition:</strong> Opponent loses if they repeat the same move 3 times!</p>
                
                <h3 style="color: #4ecdc4;">üéÆ Controls</h3>
                <ul>
                    <li><strong>Drag & Drop:</strong> Click and drag pieces to move</li>
                    <li><strong>Valid Moves:</strong> Shown in GREEN when dragging</li>
                    <li><strong>Attack Moves:</strong> Shown in RED when dragging</li>
                    <li><strong>Threat Warning:</strong> RED circle on pieces under attack</li>
                </ul>
                
                <h3 style="color: #ffd93d;">üî∑ Piece Types & Movement</h3>
                <ul>
                    <li><strong>Squares:</strong> Move in straight lines (4 adjacent directions)</li>
                    <li><strong>Triangles:</strong> Move in triangular patterns (3 directions) + ROTATION!</li>
                    <li><strong>Rhombuses:</strong> Complex diagonal movement, key to winning! (Black at 3-8, White at 3-0)</li>
                    <li><strong>Circles:</strong> Zone-based movement - move/attack within perimeter rings (Black at 4-7, White at 2-0)</li>
                    <li><strong>Hexgons:</strong> Move to all 6 adjacent neighboring hexes (Black at 2-7, White at 4-0)</li>
                </ul>
                
                <h3 style="color: #00d2ff;">‚≠ï Circle Movement System</h3>
                <ul>
                    <li><strong>Zone Movement:</strong> Circles move within their current perimeter zone</li>
                    <li><strong>4 Zones:</strong> Dead (center - blocked), Inner, Middle, Outer</li>
                    <li><strong>Zone Change:</strong> Use gateway hexes to move between zones (ends turn)</li>
                    <li><strong>Friendly Blocking:</strong> Cannot jump friendly pieces - stops at first piece in path</li>
                    <li><strong>Golden Gateway Markers:</strong> Visible when dragging circles</li>
                </ul>
                
                <h3 style="color: #ff9f43;">üîÑ Triangle Rotation System</h3>
                <ul>
                    <li><strong>Move + Rotate:</strong> Triangles can move AND rotate in same turn</li>
                    <li><strong>Rotation Buttons:</strong> LEFT/RIGHT buttons appear after moving</li>
                    <li><strong>Free Rotation:</strong> Rotate as many times as needed</li>
                    <li><strong>KEEP Button:</strong> End turn without rotating</li>
                    <li><strong>No Attack + Rotate:</strong> Cannot rotate after attacking</li>
                </ul>
                
                <h3 style="color: #ff6b6b;">‚ö†Ô∏è Game Rules</h3>
                <ul>
                    <li><strong>Turn-based:</strong> Black starts first</li>
                    <li><strong>One Piece Per Turn:</strong> Can only move/rotate ONE piece per turn</li>
                    <li><strong>Rhombus Protection:</strong> Rhombuses cannot attack other rhombuses</li>
                    <li><strong>Game Over:</strong> If any rhombus is eliminated</li>
                    <li><strong>Base Defence:</strong> Active when rhombus is at starting position (3-0 for white, 3-8 for black)</li>
                    <li><strong>Friendly Blocking:</strong> Cannot move to hexes occupied by friendly pieces</li>
                    <li><strong>Attack to Capture:</strong> Move to opponent's hex to eliminate their piece</li>
                </ul>
                
                <h3 style="color: #e74c3c;">‚ôüÔ∏è Deadlock (Checkmate & Stalemate) System</h3>
                <ul>
                    <li><strong>Checkmate:</strong> Opponent's rhombus is UNDER ATTACK and has NO legal moves ‚Üí You Win!</li>
                    <li><strong>Stalemate:</strong> If you have NO legal moves ‚Üí You Lose! (Must resign manually)</li>
                    <li><strong>Check Protection:</strong> You CANNOT move if it puts your rhombus under attack...</li>
                    <li><strong>Exception:</strong> ...UNLESS you capture the attacking piece in the same move!</li>
                    <li><strong>Legal Moves:</strong> Rhombus can move to empty hex OR capture a non-rhombus piece</li>
                    <li><strong>Automatic Detection:</strong> Game checks for checkmate after each turn ends</li>
                    <li><strong>Strategy:</strong> Trap opponent's rhombus with attack, or trap all their pieces!</li>
                </ul>
                
                <h3 style="color: #ff6b6b;">‚öîÔ∏è Escape Race Mode</h3>
                <ul>
                    <li><strong>Activation:</strong> When ALL other pieces are eliminated (only rhombuses remain)</li>
                    <li><strong>Base Defence DISABLED:</strong> Rhombus at base can no longer block opponent's win</li>
                    <li><strong>First to Goal Wins:</strong> Race to reach your goal position (3-0 for Black, 3-8 for White)</li>
                    <li><strong>No Draws:</strong> One player MUST reach their goal before the other</li>
                    <li><strong>Visual Alert:</strong> Game displays "ESCAPE RACE!" notification when mode activates</li>
                    <li><strong>Forced Movement:</strong> If you have ONLY your rhombus left, Base Defence no longer works - must move!</li>
                </ul>
                
                <h3 style="color: #c0392b;">üîÑ Five-Fold Shuttle Repetition Loss</h3>
                <ul>
                    <li><strong>Anti-Stalling Rule:</strong> Prevents infinite shuttling between positions</li>
                    <li><strong>Shuttle Pattern:</strong> Moving between same 2 positions (A‚ÜíB and B‚ÜíA count as SAME shuttle!)</li>
                    <li><strong>Five Shuttles Maximum:</strong> Each shuttle pattern can only be used 5 times TOTAL - then you LOSE!</li>
                    <li><strong>NEVER Resets:</strong> Shuttle counters are permanent across the entire game - cannot be reset!</li>
                    <li><strong>Captures Don't Count:</strong> Making a capture doesn't count toward shuttle limit</li>
                    <li><strong>Tactical Repositioning:</strong> You CAN retreat/advance 2-3 times, but must eventually commit to new positions!</li>
                    <li><strong>‚ö†Ô∏è Visual Warnings:</strong> Moves are color-coded in tracking panel:
                        <ul style="margin-top: 5px;">
                            <li>üü° <strong>Orange (3/5):</strong> Third shuttle - WARNING!</li>
                            <li>üü† <strong>Dark Orange (4/5):</strong> Fourth shuttle - DANGER!</li>
                            <li>üî¥ <strong>Red (5/5):</strong> Fifth shuttle - LOSS!</li>
                        </ul>
                    </li>
                    <li><strong>Example:</strong> Square 1-2‚Üí1-3 (1‚úÖ), 1-3‚Üí1-2 (2‚úÖ), 1-2‚Üí1-3 (3‚ö†Ô∏è), 1-3‚Üí1-2 (4üî•), 1-2‚Üí1-3 (5üíÄ LOSS!)</li>
                    <li><strong>Strategy:</strong> Manage your shuttle budget wisely - each pair of positions has only 5 uses!</li>
                </ul>
                
                <h3 style="color: #a55eea;">üéµ Audio Features</h3>

                <h3 style="color: #ffd700;">‚ö° Advanced Features</h3>
                <ul>
                    <li><strong>Repetition Detection:</strong> Three-fold repetition rule, draw offers, and visual warnings.</li>
                    <li><strong>Base Defense System:</strong> Prevents early base captures, toggleable in settings.</li>
                    <li><strong>Threat Analysis:</strong> Real-time threat and checkmate detection, highlights threatened pieces.</li>
                    <li><strong>Show All Moves:</strong> Toggle to display all legal moves and rotations for current player.</li>
                    <li><strong>Defense Highlights:</strong> Highlights pieces defended by others, optional toggle.</li>
                    <li><strong>Dark Mode:</strong> Switch between light/dark themes, remembers your preference.</li>
                    <li><strong>Game Variants:</strong> Blitz, Fog of War, King of the Hill (see Quick Reference for more).</li>
                    <li><strong>Statistics Dashboard:</strong> Win/loss tracking, piece performance, progress charts, personal records (planned).</li>
                </ul>

                <h3 style="color: #a55eea;">üéµ Audio Features</h3>
                <ul>
                    <li><strong>Move Sound:</strong> Click sound when moving pieces</li>
                    <li><strong>Capture Sound:</strong> Special sound when capturing</li>
                    <li><strong>Win Sound:</strong> Victory sound when winning</li>
                </ul>
                
                <h3 style="color: #26de81;">üìä Game Features</h3>
                <ul>
                    <li><strong>Movement Tracking:</strong> See all moves in side panels (separated by player)</li>
                    <li><strong>Eliminated Pieces:</strong> View captured pieces on sides</li>
                    <li><strong>Coordinate Toggle:</strong> Show/hide hex coordinates (button next to menu)</li>
                    <li><strong>Threat Detection:</strong> Visual warnings for vulnerable pieces</li>
                    <li><strong>Undo Button:</strong> Revert last move (pieces, captures, turn state)</li>
                    <li><strong>Base Defence Indicators:</strong> Shows when rhombus is defending base</li>
                </ul>
                
                <h3 style="color: #ffa502;">üé≤ Game Modes</h3>
                <ul>
                    <li><strong>Full Game:</strong> All 5 piece types (Squares, Triangles, Rhombuses, Circles, Hexgons)</li>
                    <li><strong>Square Attack Mode:</strong> Simplified variant with only Squares and Rhombuses - perfect for learning!</li>
                </ul>
                
                <div style="text-align: center; margin-top: 20px;">
                    <button onclick="this.parentElement.parentElement.parentElement.remove()" style="
                        background-color: #4ecdc4;
                        color: white;
                        border: none;
                        padding: 10px 25px;
                        border-radius: 20px;
                        cursor: pointer;
                        font-weight: bold;
                    ">Close Help</button>
                </div>
            `;
            
            helpOverlay.appendChild(helpContent);
            document.body.appendChild(helpOverlay);
        }


        // Function to check if piece belongs to current player
        function isCurrentPlayerPiece(piece) {
            // Block ALL moves if AI is thinking
            if (aiThinking) return false;
            
            const isWhite = piece.classList.contains('white-piece') || 
                           piece.classList.contains('white-triangle') || 
                           piece.classList.contains('white-rhombus') ||
                           piece.classList.contains('white-circle') ||
                           piece.classList.contains('white-hexgon');
            
            // In AI mode, player can ONLY play Black pieces
            if (aiEnabled && isWhite) return false;
            
            // Return true if it's the current player's piece
            // Note: Board flip doesn't change piece ownership, only visual perspective
            return (currentPlayer === 'white' && isWhite) || (currentPlayer === 'black' && !isWhite);
        }

        // ========== LLM AI MOCKUP ==========
        
        function updateAIModelDisplay() {
            const modelData = {
                'claude-sonnet': { name: 'Claude', icon: 'üß†' },
                'gpt4': { name: 'GPT-4', icon: 'ü§ñ' },
                'grok': { name: 'Grok', icon: 'üöÄ' },
                'gemini': { name: 'Gemini', icon: '‚ú®' }
            };
            const model = modelData[currentAIModel] || { name: 'AI', icon: 'üß†' };
            document.getElementById('ai-model-name').textContent = model.name;
            document.getElementById('ai-model-icon').textContent = model.icon;
        }
        
        function makeLLMAIMove() {
            console.log('üß† LLM AI thinking...');
            
            // Show thinking status
            document.getElementById('ai-thinking-status').textContent = '‚è≥';
            document.getElementById('ai-reasoning-text').textContent = 'Analyzing...';
            document.getElementById('ai-move-text').textContent = '‚ö° Calculating...';
            
            // Quick delay for visual feedback (500ms)
            const thinkingDelay = 500;
            
            setTimeout(() => {
                // Get all valid moves (same as regular AI)
                const whitePieces = document.querySelectorAll('.white-piece, .white-triangle, .white-rhombus, .white-circle, .white-hexgon');
                const validMoves = [];
                
                whitePieces.forEach(piece => {
                    const pieceHex = piece.closest('.hexagon');
                    if (!pieceHex) return;
                    
                    const pieceId = pieceHex.id;
                    const [, fromRow, fromCol] = pieceId.match(/hex-(\d+)-(\d+)/);
                    
                    let pieceType = 'square';
                    if (piece.classList.contains('triangle-piece')) pieceType = 'triangle';
                    else if (piece.classList.contains('rhombus-piece')) pieceType = 'rhombus';
                    else if (piece.classList.contains('circle-piece')) pieceType = 'circle';
                    else if (piece.classList.contains('hexgon-piece')) pieceType = 'hexgon';
                    
                    const moves = getPossibleMoves(parseInt(fromRow), parseInt(fromCol), pieceType, true);
                    moves.forEach(move => {
                        validMoves.push({
                            piece: piece,
                            fromRow: parseInt(fromRow),
                            fromCol: parseInt(fromCol),
                            toRow: move.row,
                            toCol: move.col,
                            isCapture: move.isCapture,
                            type: pieceType,
                            score: evaluateMove(parseInt(fromRow), parseInt(fromCol), move.row, move.col, pieceType, move.isCapture)
                        });
                    });
                });
                
                if (validMoves.length === 0) {
                    console.log('üß† LLM AI has no valid moves!');
                    aiThinking = false;
                    switchTurn();
                    return;
                }
                
                // Sort by score
                validMoves.sort((a, b) => b.score - a.score);
                
                // Pick best move (with slight randomness for variety)
                const topMoves = validMoves.slice(0, Math.min(3, validMoves.length));
                const selectedMove = topMoves[Math.floor(Math.random() * topMoves.length)];
                
                // Generate reasoning based on move
                const reasoning = generateAIReasoning(selectedMove, validMoves);
                
                // Update display with reasoning
                document.getElementById('ai-thinking-status').textContent = '‚úÖ';
                document.getElementById('ai-reasoning-text').innerHTML = reasoning;
                
                const pieceEmoji = {
                    'square': '‚¨õ',
                    'triangle': '‚ñ≤',
                    'rhombus': '‚ô¶Ô∏è',
                    'circle': '‚ö´',
                    'hexgon': '‚¨°'
                }[selectedMove.type] || '?';
                
                document.getElementById('ai-move-text').textContent = 
                    `${pieceEmoji} ${selectedMove.fromRow}-${selectedMove.fromCol} ‚Üí ${selectedMove.toRow}-${selectedMove.toCol}`;
                
                // Execute move immediately (reasoning stays visible)
                executeAIMove(selectedMove);
                
            }, thinkingDelay);
        }
        
        function generateAIReasoning(selectedMove, allMoves) {
            const templates = getReasoningTemplates(currentAIModel);
            const template = templates[Math.floor(Math.random() * templates.length)];
            
            // Analyze board state
            const blackRhombus = document.querySelector('.rhombus-piece:not(.white-rhombus)');
            const whiteRhombus = document.querySelector('.rhombus-piece.white-rhombus');
            
            let blackRhombusPos = null;
            let whiteRhombusPos = null;
            
            if (blackRhombus) {
                const hex = blackRhombus.closest('.hexagon');
                if (hex) {
                    const [, r, c] = hex.id.match(/hex-(\d+)-(\d+)/);
                    blackRhombusPos = `${r}-${c}`;
                }
            }
            
            if (whiteRhombus) {
                const hex = whiteRhombus.closest('.hexagon');
                if (hex) {
                    const [, r, c] = hex.id.match(/hex-(\d+)-(\d+)/);
                    whiteRhombusPos = `${r}-${c}`;
                }
            }
            
            // Build compact reasoning
            let reasoning = '';
            
            // Strategic analysis (concise)
            if (selectedMove.type === 'rhombus') {
                const distanceToGoal = Math.abs(selectedMove.toRow - 3) + Math.abs(selectedMove.toCol - 8);
                reasoning += `üìç <strong>Goal distance: ${distanceToGoal}</strong><br>`;
                if (blackRhombusPos && blackRhombusPos === '3-0') {
                    reasoning += 'Black base defended - careful advance<br>';
                } else {
                    reasoning += 'Advancing toward 3-8 victory<br>';
                }
            } else if (selectedMove.isCapture) {
                reasoning += `‚öîÔ∏è <strong>Capturing ${selectedMove.type}</strong><br>`;
                reasoning += 'Weakens opponent defense<br>';
            } else {
                const positionValue = evaluatePositionStrength(selectedMove.toRow, selectedMove.toCol);
                reasoning += positionValue > 50 ? 'üéØ <strong>Strong position</strong><br>' : 'üìà <strong>Improving position</strong><br>';
            }
            
            // Threat analysis (compact)
            const threatenedCount = countThreatenedOpponentPieces(selectedMove.toRow, selectedMove.toCol, selectedMove.type);
            if (threatenedCount > 0) {
                reasoning += `üî• Threatens ${threatenedCount} piece${threatenedCount > 1 ? 's' : ''}`;
            }
            
            return reasoning;
        }
        
        function evaluatePositionStrength(row, col) {
            let strength = 0;
            // Central positions are stronger
            const centerDistance = Math.abs(row - 3) + Math.abs(col - 4);
            strength += (10 - centerDistance) * 10;
            // Row 3 is critical
            if (row === 3) strength += 30;
            return strength;
        }
        
        function getReasoningTemplates(model) {
            // Compact templates for small panel
            const templates = {
                'claude-sonnet': [
                    { intro: "Analyzing holistically...", conclusion: "" },
                    { intro: "Systematic evaluation:", conclusion: "" },
                    { intro: "Multi-factor analysis:", conclusion: "" }
                ],
                'gpt4': [
                    { intro: "Position evaluated:", conclusion: "" },
                    { intro: "Optimal path identified:", conclusion: "" }
                ],
                'grok': [
                    { intro: "Let's get tactical!", conclusion: "" },
                    { intro: "Spicy play incoming:", conclusion: "" }
                ],
                'gemini': [
                    { intro: "Pattern recognized:", conclusion: "" },
                    { intro: "Strategic path detected:", conclusion: "" }
                ]
            };
            
            return templates[model] || templates['claude-sonnet'];
        }
        
        // ========== AI LOGIC ==========
        
        function makeAIMove() {
            console.log('ü§ñ AI thinking...');
            console.log('ü§ñ AI enabled:', aiEnabled);
            console.log('ü§ñ Current player:', currentPlayer);
            console.log('ü§ñ Game over:', gameOver);
            aiThinking = true; // Lock player input
            
            // If LLM mode, use simulated AI model
            if (llmMode) {
                makeLLMAIMove();
                return;
            }
            
            // Get all White pieces
            const whitePieces = document.querySelectorAll('.white-piece, .white-triangle, .white-rhombus, .white-circle, .white-hexgon');
            console.log('ü§ñ Found white pieces:', whitePieces.length);
            
            // Check if white rhombus is trapped
            const whiteRhombus = document.querySelector('.rhombus-piece.white-rhombus');
            if (whiteRhombus) {
                const rhombusHex = whiteRhombus.closest('.hexagon');
                if (rhombusHex) {
                    const [, rRow, rCol] = rhombusHex.id.match(/hex-(\d+)-(\d+)/);
                    const rhombusMoves = getPossibleMoves(parseInt(rRow), parseInt(rCol), 'rhombus', true);
                    if (rhombusMoves.length === 0) {
                        console.log('‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è CRITICAL ALERT: White rhombus is TRAPPED at', rRow, '-', rCol, '!');
                        console.log('‚ö†Ô∏è Rhombus has ZERO legal moves! AI must free it or move it if possible!');
                    } else {
                        console.log('‚úÖ White rhombus at', rRow, '-', rCol, 'has', rhombusMoves.length, 'legal moves');
                    }
                }
            }
            
            const validMoves = [];
            const validRotations = [];
            
            // Find all valid moves for all white pieces
            whitePieces.forEach(piece => {
                const pieceHex = piece.closest('.hexagon');
                if (!pieceHex) return;
                
                const pieceId = pieceHex.id;
                const [, fromRow, fromCol] = pieceId.match(/hex-(\d+)-(\d+)/);
                
                // Get piece type
                let pieceType = 'square';
                if (piece.classList.contains('triangle-piece')) pieceType = 'triangle';
                else if (piece.classList.contains('rhombus-piece')) pieceType = 'rhombus';
                else if (piece.classList.contains('circle-piece')) pieceType = 'circle';
                else if (piece.classList.contains('hexgon-piece')) pieceType = 'hexgon';
                
                // Get possible moves for this piece
                const moves = getPossibleMoves(parseInt(fromRow), parseInt(fromCol), pieceType, true);
                moves.forEach(move => {
                    // Basic evaluation for single move
                    const singleScore = evaluateMove(parseInt(fromRow), parseInt(fromCol), move.row, move.col, pieceType, move.isCapture);
                    
                    // Multi-move lookahead evaluation (only for hard difficulty)
                    let lookaheadScore = 0;
                    const difficulty = window.aiDifficulty || aiDifficulty || 'hard';
                    if (difficulty === 'hard') {
                        lookaheadScore = evaluateMultiMoveLookahead(
                            parseInt(fromRow), parseInt(fromCol),
                            move.row, move.col,
                            pieceType, move.isCapture
                        );
                    }
                    
                    validMoves.push({
                        piece: piece,
                        fromRow: parseInt(fromRow),
                        fromCol: parseInt(fromCol),
                        toRow: move.row,
                        toCol: move.col,
                        isCapture: move.isCapture,
                        type: pieceType,
                        isRotation: false,
                        score: singleScore,
                        lookaheadScore: lookaheadScore,
                        totalScore: singleScore + (lookaheadScore * 0.3) // Weight lookahead at 30%
                    });
                });
                
                // For Triangle and Hexagon pieces, also consider rotation actions
                // But only if the piece hasn't already acted this turn
                if (pieceType === 'triangle' || pieceType === 'hexgon') {
                    const actions = pieceActions.get(pieceId) || {moved: false, attacked: false, rotated: false};
                    
                    // Only allow rotation if piece hasn't moved, attacked, or rotated yet
                    if (!actions.moved && !actions.attacked && !actions.rotated) {
                        const rotationEvals = evaluateRotationOptions(parseInt(fromRow), parseInt(fromCol), pieceType, pieceId);
                        rotationEvals.forEach(rotEval => {
                            // Only add rotation if it actually improves the position (score > 0)
                            if (rotEval.score > 0) {
                                validRotations.push({
                                    piece: piece,
                                    pieceId: pieceId,
                                    fromRow: parseInt(fromRow),
                                    fromCol: parseInt(fromCol),
                                    type: pieceType,
                                    isRotation: true,
                                    rotationDirection: rotEval.direction,
                                    newOrientation: rotEval.newOrientation,
                                    score: rotEval.score,
                                    lookaheadScore: 0,
                                    totalScore: rotEval.score
                                });
                            }
                        });
                    }
                }
            });
            
            // Combine moves and rotations
            const allActions = [...validMoves, ...validRotations];
            
            if (allActions.length === 0) {
                console.log('ü§ñ AI has no valid actions!');
                console.log('ü§ñ White pieces found:', whitePieces.length);
                console.log('ü§ñ Valid moves found:', validMoves.length);
                console.log('ü§ñ Valid rotations found (before filtering):', validRotations.length);
                console.log('‚ö†Ô∏è AI is DRAGLOCK (stalemate) - White has no legal moves!');
                aiThinking = false;
                
                // DRAGLOCK: AI has no legal moves = AI loses!
                if (whitePieces.length > 0) {
                    console.log('üíÄ DRAGLOCK LOSS: White (AI) has no legal moves and loses!');
                    setTimeout(() => {
                        showGameOver('Black', 'White lost by draglock (no legal moves available)!');
                    }, 500);
                }
                return;
            }
            
            console.log('ü§ñ AI found', validMoves.length, 'moves and', validRotations.length, 'rotation options');
            
            // Log action breakdown
            if (allActions.length > 0) {
                const moveActions = allActions.filter(a => !a.isRotation);
                const rotateActions = allActions.filter(a => a.isRotation);
                console.log(`ü§ñ Action breakdown: ${moveActions.length} moves, ${rotateActions.length} rotations (total: ${allActions.length})`);
                
                // If only rotations available and they're all negative, something is wrong
                if (moveActions.length === 0 && rotateActions.length > 0) {
                    console.log('‚ö†Ô∏è WARNING: AI only has rotation options, no movement options!');
                    const bestRotationScore = Math.max(...rotateActions.map(r => r.totalScore));
                    console.log(`‚ö†Ô∏è Best rotation score: ${bestRotationScore.toFixed(1)}`);
                    
                    // If even rotations don't help, we might be stuck
                    if (bestRotationScore < -40) {
                        console.log('‚ö†Ô∏è All rotations are poor choices. AI may be in trouble.');
                    }
                }
            }
            
            // Sort all actions by total score (includes lookahead for hard mode)
            allActions.sort((a, b) => b.totalScore - a.totalScore);
            
            // Get difficulty setting (use window.aiDifficulty if set via modal)
            const difficulty = window.aiDifficulty || aiDifficulty || 'hard';
            
            // === ENHANCED DEBUG LOGGING ===
            // Show piece type distribution in top moves
            console.log('üìä AI Move Analysis:');
            const pieceTypeCount = {};
            allActions.slice(0, 10).forEach(action => {
                const type = action.isRotation ? `${action.type}-rotate` : action.type;
                pieceTypeCount[type] = (pieceTypeCount[type] || 0) + 1;
            });
            console.log('  Top 10 moves by piece type:', pieceTypeCount);
            
            // Log top move for EACH piece type
            console.log('üéØ Best move for each piece type:');
            const pieceTypes = ['square', 'triangle', 'rhombus', 'circle', 'hexgon'];
            pieceTypes.forEach(type => {
                const bestForType = allActions.find(a => !a.isRotation && a.type === type);
                if (bestForType) {
                    console.log(`  ${type}: ${bestForType.fromRow}-${bestForType.fromCol} ‚Üí ${bestForType.toRow}-${bestForType.toCol} | Score: ${bestForType.score.toFixed(1)} | Total: ${bestForType.totalScore.toFixed(1)}${bestForType.isCapture ? ' (CAPTURE)' : ''}`);
                }
            });
            
            // Log top 5 moves overall for debugging
            console.log('üèÜ Top 5 moves overall:');
            allActions.slice(0, 5).forEach((action, i) => {
                if (action.isRotation) {
                    console.log(`  ${i+1}. Rotate ${action.type} at ${action.fromRow}-${action.fromCol} ${action.rotationDirection} | Total: ${action.totalScore.toFixed(1)}`);
                } else {
                    const captureTag = action.isCapture ? ' ‚öîÔ∏èCAPTURE' : '';
                    console.log(`  ${i+1}. ${action.type} ${action.fromRow}-${action.fromCol} ‚Üí ${action.toRow}-${action.toCol}${captureTag} | Score: ${action.score.toFixed(1)}, Total: ${action.totalScore.toFixed(1)}`);
                }
            });
            
            // Select action based on difficulty
            let selectedAction;
            if (difficulty === 'easy') {
                // Easy: Random action from bottom 50%
                const bottomHalf = allActions.slice(Math.floor(allActions.length / 2));
                selectedAction = bottomHalf[Math.floor(Math.random() * bottomHalf.length)];
            } else if (difficulty === 'medium') {
                // Medium: Random action from top 50%
                const topHalf = allActions.slice(0, Math.ceil(allActions.length / 2));
                selectedAction = topHalf[Math.floor(Math.random() * topHalf.length)];
            } else {
                // Hard: Always best action (with lookahead)
                selectedAction = allActions[0];
            }
            
            if (selectedAction.isRotation) {
                console.log(`ü§ñ AI chose: Rotate ${selectedAction.type} at ${selectedAction.fromRow}-${selectedAction.fromCol} ${selectedAction.rotationDirection} (score: ${selectedAction.totalScore.toFixed(1)})`);
                executeAIRotation(selectedAction);
            } else {
                console.log(`ü§ñ AI chose: ${selectedAction.type} ${selectedAction.fromRow}-${selectedAction.fromCol} ‚Üí ${selectedAction.toRow}-${selectedAction.toCol} (total: ${selectedAction.totalScore.toFixed(1)})`);
                executeAIMove(selectedAction);
            }
        }
        
        // Evaluate multi-move lookahead: What happens after this move?
        function evaluateMultiMoveLookahead(fromRow, fromCol, toRow, toCol, pieceType, isCapture) {
            let lookaheadScore = 0;
            
            // Simulate the move temporarily
            const simulatedState = simulateMove(fromRow, fromCol, toRow, toCol, pieceType, isCapture);
            if (!simulatedState) return 0; // Invalid simulation
            
            // Evaluate follow-up opportunities from the new position
            const followUpMoves = getFollowUpMoves(toRow, toCol, pieceType, simulatedState);
            
            // Score based on follow-up opportunities
            followUpMoves.forEach(followUp => {
                // Can we capture something valuable next turn?
                if (followUp.isCapture) {
                    lookaheadScore += 50;
                    
                    // Extra bonus for capturing high-value pieces
                    if (followUp.capturedType === 'rhombus') lookaheadScore += 200;
                    else if (followUp.capturedType === 'triangle') lookaheadScore += 40;
                    else if (followUp.capturedType === 'hexgon') lookaheadScore += 35;
                    else if (followUp.capturedType === 'circle') lookaheadScore += 30;
                    else if (followUp.capturedType === 'square') lookaheadScore += 25;
                }
                
                // Can we threaten opponent's rhombus?
                if (followUp.threatenRhombus) {
                    lookaheadScore += 150;
                }
                
                // Can we advance our rhombus toward goal?
                if (pieceType === 'rhombus' && followUp.advanceToGoal) {
                    const distanceToGoal = Math.abs(followUp.toRow - 3) + Math.abs(followUp.toCol - 8);
                    lookaheadScore += (20 - distanceToGoal) * 10;
                }
                
                // Can we create multiple threats (fork)?
                if (followUp.createsFork) {
                    lookaheadScore += 80;
                }
            });
            
            // Check opponent's best response
            const opponentBestResponse = evaluateOpponentResponse(toRow, toCol, pieceType, simulatedState);
            
            // Penalty if opponent can counter-attack effectively
            if (opponentBestResponse.canCapture) {
                lookaheadScore -= 60;
                if (pieceType === 'rhombus') lookaheadScore -= 200; // CRITICAL: Don't lose rhombus!
            }
            
            // Penalty if opponent can threaten our rhombus
            if (opponentBestResponse.threatensOurRhombus) {
                lookaheadScore -= 120;
            }
            
            // Bonus if this move sets up a winning sequence
            if (opponentBestResponse.cannotPreventWin) {
                lookaheadScore += 500; // Forced win in 2 moves!
            }
            
            // Mobility evaluation: Do we have good options from new position?
            const mobilityAfterMove = followUpMoves.length;
            lookaheadScore += mobilityAfterMove * 5;
            
            // Clean up simulation
            cleanupSimulation(simulatedState);
            
            return lookaheadScore;
        }
        
        // Simulate a move and return the game state (temporary DOM manipulation)
        function simulateMove(fromRow, fromCol, toRow, toCol, pieceType, isCapture) {
            const fromHex = document.getElementById(`hex-${fromRow}-${fromCol}`);
            const toHex = document.getElementById(`hex-${toRow}-${toCol}`);
            
            if (!fromHex || !toHex) return null;
            
            const piece = fromHex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
            if (!piece) return null;
            
            // Store original state
            const originalState = {
                fromHex: fromHex,
                toHex: toHex,
                piece: piece.cloneNode(true),
                capturedPiece: null
            };
            
            // If capture, store the captured piece
            if (isCapture) {
                const captured = toHex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                if (captured) {
                    originalState.capturedPiece = captured.cloneNode(true);
                    captured.remove();
                }
            }
            
            // Move the piece (temporarily)
            toHex.appendChild(piece);
            
            return originalState;
        }
        
        // Get follow-up moves from a position
        function getFollowUpMoves(row, col, pieceType, simulatedState) {
            const followUps = [];
            
            // Get possible moves from this position
            const moves = getPossibleMoves(row, col, pieceType, true);
            
            moves.forEach(move => {
                const targetHex = document.getElementById(`hex-${move.row}-${move.col}`);
                if (!targetHex) return;
                
                const followUp = {
                    toRow: move.row,
                    toCol: move.col,
                    isCapture: move.isCapture,
                    capturedType: null,
                    threatenRhombus: false,
                    advanceToGoal: false,
                    createsFork: false
                };
                
                // Check what we'd capture
                if (move.isCapture) {
                    const targetPiece = targetHex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                    if (targetPiece) {
                        if (targetPiece.classList.contains('triangle-piece')) followUp.capturedType = 'triangle';
                        else if (targetPiece.classList.contains('rhombus-piece')) followUp.capturedType = 'rhombus';
                        else if (targetPiece.classList.contains('hexgon-piece')) followUp.capturedType = 'hexgon';
                        else if (targetPiece.classList.contains('circle-piece')) followUp.capturedType = 'circle';
                        else if (targetPiece.classList.contains('square-piece')) followUp.capturedType = 'square';
                    }
                }
                
                // Check if threatening opponent's rhombus
                const blackRhombus = document.querySelector('.rhombus-piece:not(.white-rhombus)');
                if (blackRhombus) {
                    const rhombusHex = blackRhombus.closest('.hexagon');
                    if (rhombusHex) {
                        const [, rRow, rCol] = rhombusHex.id.match(/hex-(\d+)-(\d+)/);
                        if (move.row == rRow && move.col == rCol) {
                            followUp.threatenRhombus = true;
                        }
                    }
                }
                
                // Check if advancing rhombus toward goal
                if (pieceType === 'rhombus') {
                    const distanceToGoal = Math.abs(move.row - 3) + Math.abs(move.col - 8);
                    const currentDistance = Math.abs(row - 3) + Math.abs(col - 8);
                    if (distanceToGoal < currentDistance) {
                        followUp.advanceToGoal = true;
                    }
                }
                
                // Check if creating a fork (multiple threats)
                const threatsFromNewPos = countThreatsFromPosition(move.row, move.col, pieceType);
                if (threatsFromNewPos >= 2) {
                    followUp.createsFork = true;
                }
                
                followUps.push(followUp);
            });
            
            return followUps;
        }
        
        // Count how many opponent pieces we threaten from a position
        function countThreatsFromPosition(row, col, pieceType) {
            let threats = 0;
            const moves = getPossibleMoves(row, col, pieceType, true);
            
            moves.forEach(move => {
                const targetHex = document.getElementById(`hex-${move.row}-${move.col}`);
                if (targetHex && move.isCapture) {
                    const targetPiece = targetHex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                    if (targetPiece) {
                        const isBlack = !targetPiece.classList.contains('white-piece') && 
                                       !targetPiece.classList.contains('white-triangle') && 
                                       !targetPiece.classList.contains('white-rhombus') &&
                                       !targetPiece.classList.contains('white-circle') &&
                                       !targetPiece.classList.contains('white-hexgon');
                        if (isBlack) threats++;
                    }
                }
            });
            
            return threats;
        }
        
        // Evaluate opponent's best response to our move
        function evaluateOpponentResponse(ourRow, ourCol, ourPieceType, simulatedState) {
            const response = {
                canCapture: false,
                threatensOurRhombus: false,
                cannotPreventWin: false
            };
            
            // Check if opponent can capture our piece at new position
            const blackPieces = document.querySelectorAll('.square-piece:not(.white-piece), .triangle-piece:not(.white-triangle), .rhombus-piece:not(.white-rhombus), .circle-piece:not(.white-circle), .hexgon-piece:not(.white-hexgon)');
            
            blackPieces.forEach(blackPiece => {
                const blackHex = blackPiece.closest('.hexagon');
                if (!blackHex) return;
                
                const [, bRow, bCol] = blackHex.id.match(/hex-(\d+)-(\d+)/);
                
                // Get piece type
                let blackType = 'square';
                if (blackPiece.classList.contains('triangle-piece')) blackType = 'triangle';
                else if (blackPiece.classList.contains('rhombus-piece')) blackType = 'rhombus';
                else if (blackPiece.classList.contains('circle-piece')) blackType = 'circle';
                else if (blackPiece.classList.contains('hexgon-piece')) blackType = 'hexgon';
                
                // Check if this black piece can attack our new position
                const blackMoves = getPossibleMoves(parseInt(bRow), parseInt(bCol), blackType, false);
                blackMoves.forEach(move => {
                    if (move.row == ourRow && move.col == ourCol) {
                        response.canCapture = true;
                    }
                });
            });
            
            // Check if opponent can threaten our rhombus
            const whiteRhombus = document.querySelector('.rhombus-piece.white-rhombus');
            if (whiteRhombus) {
                const rhombusHex = whiteRhombus.closest('.hexagon');
                if (rhombusHex) {
                    const [, rRow, rCol] = rhombusHex.id.match(/hex-(\d+)-(\d+)/);
                    
                    blackPieces.forEach(blackPiece => {
                        const blackHex = blackPiece.closest('.hexagon');
                        if (!blackHex) return;
                        
                        const [, bRow, bCol] = blackHex.id.match(/hex-(\d+)-(\d+)/);
                        let blackType = 'square';
                        if (blackPiece.classList.contains('triangle-piece')) blackType = 'triangle';
                        else if (blackPiece.classList.contains('rhombus-piece')) blackType = 'rhombus';
                        else if (blackPiece.classList.contains('circle-piece')) blackType = 'circle';
                        else if (blackPiece.classList.contains('hexgon-piece')) blackType = 'hexgon';
                        
                        const blackMoves = getPossibleMoves(parseInt(bRow), parseInt(bCol), blackType, false);
                        blackMoves.forEach(move => {
                            if (move.row == rRow && move.col == rCol) {
                                response.threatensOurRhombus = true;
                            }
                        });
                    });
                }
            }
            
            // Check if we're setting up a forced win (simplified check)
            if (ourPieceType === 'rhombus') {
                const distanceToGoal = Math.abs(ourRow - 3) + Math.abs(ourCol - 8);
                if (distanceToGoal <= 2 && !response.canCapture) {
                    response.cannotPreventWin = true;
                }
            }
            
            return response;
        }
        
        // Clean up simulated move
        function cleanupSimulation(simulatedState) {
            if (!simulatedState) return;
            
            // Find the real piece that was moved to toHex during simulation
            const movedPiece = simulatedState.toHex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
            
            // Move the REAL piece back to original position (don't use the clone)
            if (movedPiece) {
                simulatedState.fromHex.appendChild(movedPiece);
            }
            
            // Restore captured piece if any
            if (simulatedState.capturedPiece) {
                simulatedState.toHex.appendChild(simulatedState.capturedPiece);
            }
        }
        
        // Evaluate rotation options for Triangle or Hexagon pieces
        function evaluateRotationOptions(row, col, pieceType, pieceId) {
            const rotations = [];
            
            // Get current orientation
            let currentOrientation;
            if (pieceType === 'triangle') {
                currentOrientation = getTriangleOrientation(pieceId);
            } else if (pieceType === 'hexgon') {
                currentOrientation = getHexgonOrientation(pieceId);
            }
            
            // Evaluate rotating left and right
            ['left', 'right'].forEach(direction => {
                let newOrientation = currentOrientation;
                if (direction === 'left') {
                    newOrientation = (currentOrientation - 1 + 6) % 6;
                } else {
                    newOrientation = (currentOrientation + 1) % 6;
                }
                
                // Calculate score for this rotation
                const score = evaluateRotation(row, col, pieceType, currentOrientation, newOrientation);
                
                rotations.push({
                    direction: direction,
                    newOrientation: newOrientation,
                    score: score
                });
            });
            
            return rotations;
        }
        
        // Evaluate the value of rotating a piece
        function evaluateRotation(row, col, pieceType, currentOrientation, newOrientation) {
            let score = 0;
            
            // Get moves with current orientation
            let currentMoves = [];
            if (pieceType === 'triangle') {
                currentMoves = getRotatedTriangleTargets(row, col, currentOrientation, true);
            } else if (pieceType === 'hexgon') {
                currentMoves = getRotatedHexgonTargets(row, col, currentOrientation, true);
            }
            
            // Get moves with new orientation
            let newMoves = [];
            if (pieceType === 'triangle') {
                newMoves = getRotatedTriangleTargets(row, col, newOrientation, true);
            } else if (pieceType === 'hexgon') {
                newMoves = getRotatedHexgonTargets(row, col, newOrientation, true);
            }
            
            // If orientations have the same effective pattern (0==3, 1==4, 2==5), heavily penalize
            const effectiveCurrent = currentOrientation % 3;
            const effectiveNew = newOrientation % 3;
            if (effectiveCurrent === effectiveNew) {
                score -= 1000; // Don't rotate to same effective position!
                return score;
            }
            
            // Mobility bonus: More moves = better
            const mobilityDiff = newMoves.length - currentMoves.length;
            score += mobilityDiff * 15;
            
            // Check if new orientation creates attack opportunities
            let currentAttacks = 0;
            let newAttacks = 0;
            
            // Count attacks on opponent pieces with current orientation
            currentMoves.forEach(([targetRow, targetCol]) => {
                const targetHex = document.getElementById(`hex-${targetRow}-${targetCol}`);
                if (targetHex) {
                    const piece = targetHex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                    if (piece) {
                        const isWhite = piece.classList.contains('white-piece') || 
                                       piece.classList.contains('white-triangle') || 
                                       piece.classList.contains('white-rhombus') ||
                                       piece.classList.contains('white-circle') ||
                                       piece.classList.contains('white-hexgon');
                        if (!isWhite) currentAttacks++;
                    }
                }
            });
            
            // Count attacks on opponent pieces with new orientation
            newMoves.forEach(([targetRow, targetCol]) => {
                const targetHex = document.getElementById(`hex-${targetRow}-${targetCol}`);
                if (targetHex) {
                    const piece = targetHex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                    if (piece) {
                        const isWhite = piece.classList.contains('white-piece') || 
                                       piece.classList.contains('white-triangle') || 
                                       piece.classList.contains('white-rhombus') ||
                                       piece.classList.contains('white-circle') ||
                                       piece.classList.contains('white-hexgon');
                        if (!isWhite) {
                            newAttacks++;
                            // Extra bonus for threatening rhombus
                            if (piece.classList.contains('rhombus-piece')) {
                                score += 400;
                            }
                        }
                    }
                }
            });
            
            // Attack opportunity difference
            const attackDiff = newAttacks - currentAttacks;
            score += attackDiff * 80;
            
            // If we lose attack opportunities, heavily penalize
            if (attackDiff < 0) {
                score -= 100; // Don't rotate away from attacks!
            }
            
            // Check if new orientation threatens more important pieces
            newMoves.forEach(([targetRow, targetCol]) => {
                const targetHex = document.getElementById(`hex-${targetRow}-${targetCol}`);
                if (targetHex) {
                    const piece = targetHex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                    if (piece) {
                        const isWhite = piece.classList.contains('white-piece') || 
                                       piece.classList.contains('white-triangle') || 
                                       piece.classList.contains('white-rhombus') ||
                                       piece.classList.contains('white-circle') ||
                                       piece.classList.contains('white-hexgon');
                        if (!isWhite) {
                            // Bonus based on piece value
                            if (piece.classList.contains('triangle-piece')) score += 30;
                            else if (piece.classList.contains('hexgon-piece')) score += 25;
                            else if (piece.classList.contains('circle-piece')) score += 20;
                            else if (piece.classList.contains('square-piece')) score += 15;
                        }
                    }
                }
            });
            
            // Check if new orientation opens up path to key positions
            // Bonus for attacking toward opponent's base (column 0)
            newMoves.forEach(([targetRow, targetCol]) => {
                if (targetCol < col) { // Moving toward opponent side
                    score += 10;
                }
                if (targetRow === 3) { // Center row
                    score += 8;
                }
            });
            
            // Strong penalty to prefer moving over rotating (unless rotation is clearly better)
            score -= 50;
            
            return score;
        }
        
        // Execute AI rotation action
        function executeAIRotation(action) {
            setTimeout(() => {
                const { pieceId, rotationDirection, newOrientation, type } = action;
                
                if (type === 'triangle') {
                    setTriangleOrientation(pieceId, newOrientation);
                    updateTriangleVisual(pieceId);
                    console.log(`ü§ñ AI rotated triangle at ${pieceId} ${rotationDirection} to orientation ${newOrientation}`);
                } else if (type === 'hexgon') {
                    setHexgonOrientation(pieceId, newOrientation);
                    updateHexgonVisual(pieceId);
                    console.log(`ü§ñ AI rotated hexagon at ${pieceId} ${rotationDirection} to orientation ${newOrientation}`);
                }
                
                // Mark piece as having taken action this turn
                const actions = pieceActions.get(pieceId) || {moved: false, attacked: false, rotated: false};
                actions.rotated = true;
                pieceActions.set(pieceId, actions);
                
                // End turn
                aiThinking = false;
                switchPlayer();
                
                // Play click sound
                playClickSound();
            }, 500); // Small delay for realism
        }

        function getPossibleMoves(fromRow, fromCol, pieceType, isWhite) {
            const moves = [];
            let targets = [];
            
            // Get movement pattern based on piece type
            if (pieceType === 'square') {
                targets = getSquareTargets(fromRow, fromCol);
            } else if (pieceType === 'triangle') {
                // Use rotation-aware movement for triangles
                const hexId = `hex-${fromRow}-${fromCol}`;
                const orientation = getTriangleOrientation(hexId);
                targets = getRotatedTriangleTargets(fromRow, fromCol, orientation, isWhite);
            } else if (pieceType === 'rhombus') {
                targets = getRhombusTargets(fromRow, fromCol);
            } else if (pieceType === 'circle') {
                targets = getCircleTargets(fromRow, fromCol);
            } else if (pieceType === 'hexgon') {
                targets = getHexgonTargets(fromRow, fromCol);
            }
            
            // Check each target
            targets.forEach(([targetRow, targetCol]) => {
                const targetHex = document.getElementById(`hex-${targetRow}-${targetCol}`);
                if (!targetHex) return;
                
                const existingPiece = targetHex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                
                if (!existingPiece) {
                    // Empty hex - valid move
                    moves.push({ row: targetRow, col: targetCol, isCapture: false });
                } else {
                    // Check if it's an opponent piece
                    const isExistingWhite = existingPiece.classList.contains('white-piece') || 
                                           existingPiece.classList.contains('white-triangle') || 
                                           existingPiece.classList.contains('white-rhombus') ||
                                           existingPiece.classList.contains('white-circle') ||
                                           existingPiece.classList.contains('white-hexgon');
                    
                    if (isWhite !== isExistingWhite) {
                        // Opponent piece - check if can attack
                        if (pieceType !== 'rhombus' || !existingPiece.classList.contains('rhombus-piece')) {
                            moves.push({ row: targetRow, col: targetCol, isCapture: true });
                        }
                    }
                }
            });
            
            return moves;
        }
        
        function getSquareTargets(row, col) {
            const targets = [];
            let offsets = [];
            
            if (row === 0) offsets = [[1, 0], [1, 1], [-1, 1], [-1, 0]];
            else if (row === 1) offsets = [[1, 0], [1, 1], [-1, -1], [-1, 0]];
            else if (row === 2) offsets = [[1, 0], [1, 1], [-1, -1], [-1, 0]];
            else if (row === 3) offsets = [[1, -1], [1, 0], [-1, 0], [-1, -1]];
            else if (row === 4) offsets = [[-1, 0], [-1, 1], [1, -1], [1, 0]];
            else if (row === 5) offsets = [[1, 0], [1, 1], [-1, -1], [-1, 0]];
            else if (row === 6) offsets = [[1, 0], [1, 1], [-1, 1], [-1, 0]];
            
            offsets.forEach(([dr, dc]) => {
                const newRow = row + dr;
                const newCol = col + dc;
                if (newRow >= 0 && newRow <= 6 && newCol >= 0) targets.push([newRow, newCol]);
            });
            
            return targets;
        }
        
        function getWhiteTriangleTargets(row, col) {
            const targets = [];
            let offsets = [];
            
            if (row === 0) offsets = [[1, 1], [-1, 1], [0, 1]];
            else if (row === 1) offsets = [[1, 1], [-1, 0], [0, 1]];
            else if (row === 2) offsets = [[1, 1], [-1, 0], [0, 1]];
            else if (row === 3) offsets = [[1, 0], [0, 1], [-1, 0]];
            else if (row === 4) offsets = [[1, 0], [0, 1], [-1, 1]];
            else if (row === 5) offsets = [[1, 0], [0, 1], [-1, 1]];
            else if (row === 6) offsets = [[1, 1], [-1, 1], [0, 1]];
            
            offsets.forEach(([dr, dc]) => {
                const newRow = row + dr;
                const newCol = col + dc;
                if (newRow >= 0 && newRow <= 6 && newCol >= 0) targets.push([newRow, newCol]);
            });
            
            return targets;
        }
        
        function getBlackTriangleTargets(row, col) {
            // Black triangle movement pattern - opposite direction from white triangles
            // Return OFFSETS, not absolute coordinates
            if (row === 0) return [[1, 0], [-1, 0], [0, -1]];
            else if (row === 1) return [[1, 0], [-1, -1], [0, -1]];
            else if (row === 2) return [[1, 0], [-1, -1], [0, -1]];
            else if (row === 3) return [[1, -1], [0, -1], [-1, -1]];
            else if (row === 4) return [[1, -1], [0, -1], [-1, 0]];
            else if (row === 5) return [[1, -1], [0, -1], [-1, 0]];
            else if (row === 6) return [[1, 0], [-1, 0], [0, -1]];
            else return [];
        }
        
        function getRhombusTargets(row, col) {
            return getRhombusMoves(row, col);
        }
        
        function getCircleTargets(row, col) {
            // Circle logic with proper blocking for AI
            const coord = `${row}-${col}`;
            let zoneOrder = null;
            
            // Check if in dead zone first (cannot move from dead zone)
            if (circleDeadZone.has(coord)) {
                console.log(`AI Circle at ${coord} is in DEAD ZONE - cannot move`);
                return [];
            }
            
            // Determine which zone and get the ORDER array (not the Set!)
            if (circleInnerZone.has(coord)) {
                zoneOrder = circleInnerOrder;
            } else if (circleMiddleZone.has(coord)) {
                zoneOrder = circleMiddleOrder;
            } else if (circleOuterZone.has(coord)) {
                zoneOrder = circleOuterOrder;
            }
            
            // If not in any zone (shouldn't happen), return empty
            if (!zoneOrder || !Array.isArray(zoneOrder)) {
                console.log(`AI Circle at ${coord} not in any valid zone!`);
                return [];
            }
            
            const targets = [];
            const startIdx = zoneOrder.indexOf(coord);
            
            if (startIdx === -1) {
                console.log(`AI Circle coord ${coord} not found in zone order!`);
                return [];
            }
            
            // PART 1: Perimetric movement within current zone
            
            // Check clockwise direction for reachable hexes
            for (let i = (startIdx + 1) % zoneOrder.length; i !== startIdx; i = (i + 1) % zoneOrder.length) {
                const targetCoord = zoneOrder[i];
                const [r, c] = targetCoord.split('-').map(Number);
                const targetHex = document.getElementById(`hex-${r}-${c}`);
                
                if (targetHex) {
                    const piece = targetHex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                    if (piece) {
                        // Found a piece - can potentially attack it, but can't go further clockwise
                        targets.push([r, c]);
                        break;
                    } else {
                        // Empty hex - can move here
                        targets.push([r, c]);
                    }
                }
            }
            
            // Check counter-clockwise direction for reachable hexes
            for (let i = (startIdx - 1 + zoneOrder.length) % zoneOrder.length; i !== startIdx; i = (i - 1 + zoneOrder.length) % zoneOrder.length) {
                const targetCoord = zoneOrder[i];
                const [r, c] = targetCoord.split('-').map(Number);
                const targetHex = document.getElementById(`hex-${r}-${c}`);
                
                if (targetHex) {
                    const piece = targetHex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                    if (piece) {
                        // Found a piece - can potentially attack it, but can't go further counter-clockwise
                        targets.push([r, c]);
                        break;
                    } else {
                        // Empty hex - can move here
                        targets.push([r, c]);
                    }
                }
            }
            
            // PART 2: Gateway transitions to adjacent zones
            // Use the hardcoded circleZoneTransitions map (working implementation)
            const validTransitions = circleZoneTransitions.get(coord);
            
            if (validTransitions && validTransitions.length > 0) {
                validTransitions.forEach(targetPos => {
                    const [targetRow, targetCol] = targetPos.split('-').map(Number);
                    const targetHex = document.getElementById(`hex-${targetRow}-${targetCol}`);
                    
                    if (targetHex) {
                        // Check if target is already in our targets list (avoid duplicates from perimetric sweep)
                        const alreadyAdded = targets.some(([r, c]) => r === targetRow && c === targetCol);
                        
                        if (!alreadyAdded) {
                            const piece = targetHex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                            if (!piece) {
                                // Empty gateway - can transition
                                targets.push([targetRow, targetCol]);
                            }
                            // NOTE: Cannot capture through zone gateways (only empty hexes allow transition)
                        }
                    }
                });
            }
            
            return targets;
        }
        
        function getHexgonTargets(row, col) {
            return getHexgonMoves(row, col);
        }
        
        function getRotatedHexgonTargets(row, col, orientation, isWhite) {
            console.log(`üîç getRotatedHexgonTargets called: row=${row}, col=${col}, orientation=${orientation}, isWhite=${isWhite}`);
            
            // Hexagons have 6 visual orientations (0-5) but only 3 unique movement patterns
            // Orientations 3, 4, 5 repeat the patterns of 0, 1, 2
            let offsets = [];
            
            if (row === 0) {
                if (col === 0) { // Position 00
                    // Orientation 0 & 3: 12-01
                    if (orientation === 0 || orientation === 3) offsets = [[1, 2], [0, 1]];
                    // Orientation 1 & 4: 21-11-12
                    else if (orientation === 1 || orientation === 4) offsets = [[2, 1], [1, 1], [1, 2]];
                    // Orientation 2 & 5: 21-10
                    else if (orientation === 2 || orientation === 5) offsets = [[2, 1], [1, 0]];
                }
                else if (col === 1) { // Position 01
                    // Orientation 0 & 3: 10-00-13-02
                    if (orientation === 0 || orientation === 3) offsets = [[1, -1], [0, -1], [1, 2], [0, 1]];
                    // Orientation 1 & 4: 22-12-13
                    else if (orientation === 1 || orientation === 4) offsets = [[2, 1], [1, 1], [1, 2]];
                    // Orientation 2 & 5: 22-11-10
                    else if (orientation === 2 || orientation === 5) offsets = [[2, 1], [1, 0], [1, -1]];
                }
                else if (col === 2) { // Position 02
                    // Orientation 0 & 3: 11-01-14-03
                    if (orientation === 0 || orientation === 3) offsets = [[1, -1], [0, -1], [1, 2], [0, 1]];
                    // Orientation 1 & 4: 23-13-14
                    else if (orientation === 1 || orientation === 4) offsets = [[2, 1], [1, 1], [1, 2]];
                    // Orientation 2 & 5: 23-12-11
                    else if (orientation === 2 || orientation === 5) offsets = [[2, 1], [1, 0], [1, -1]];
                }
                else if (col === 3) { // Position 03
                    // Orientation 0 & 3: 12-02-15-04
                    if (orientation === 0 || orientation === 3) offsets = [[1, -1], [0, -1], [1, 2], [0, 1]];
                    // Orientation 1 & 4: 24-14-15
                    else if (orientation === 1 || orientation === 4) offsets = [[2, 1], [1, 1], [1, 2]];
                    // Orientation 2 & 5: 24-13-12
                    else if (orientation === 2 || orientation === 5) offsets = [[2, 1], [1, 0], [1, -1]];
                }
                else if (col === 4) { // Position 04
                    // Orientation 0 & 3: 13-03-16-05
                    if (orientation === 0 || orientation === 3) offsets = [[1, -1], [0, -1], [1, 2], [0, 1]];
                    // Orientation 1 & 4: 25-15-16
                    else if (orientation === 1 || orientation === 4) offsets = [[2, 1], [1, 1], [1, 2]];
                    // Orientation 2 & 5: 25-14-13
                    else if (orientation === 2 || orientation === 5) offsets = [[2, 1], [1, 0], [1, -1]];
                }
                else if (col === 5) { // Position 05
                    // Orientation 0 & 3: 14-04
                    if (orientation === 0 || orientation === 3) offsets = [[1, -1], [0, -1]];
                    // Orientation 1 & 4: 26-16
                    else if (orientation === 1 || orientation === 4) offsets = [[2, 1], [1, 1]];
                    // Orientation 2 & 5: 26-15-14
                    else if (orientation === 2 || orientation === 5) offsets = [[2, 1], [1, 0], [1, -1]];
                }
            }
            else if (row === 1) {
                if (col === 0) { // Position 10
                    // Orientation 0 & 3: 22-11-01
                    if (orientation === 0 || orientation === 3) offsets = [[1, 2], [0, 1], [-1, 1]];
                    // Orientation 1 & 4: 31-21-22
                    else if (orientation === 1 || orientation === 4) offsets = [[2, 1], [1, 1], [1, 2]];
                    // Orientation 2 & 5: 00-01-20-31
                    else if (orientation === 2 || orientation === 5) offsets = [[-1, 0], [-1, 1], [1, 0], [2, 1]];
                }
                else if (col === 1) { // Position 11
                    // Orientation 0 & 3: 23-12-02-10-20
                    if (orientation === 0 || orientation === 3) offsets = [[1, 2], [0, 1], [-1, 1], [0, -1], [1, -1]];
                    // Orientation 1 & 4: 00-32-22-23
                    else if (orientation === 1 || orientation === 4) offsets = [[-1, -1], [2, 1], [1, 1], [1, 2]];
                    // Orientation 2 & 5: 01-02-20-21-32
                    else if (orientation === 2 || orientation === 5) offsets = [[-1, 0], [-1, 1], [1, -1], [1, 0], [2, 1]];
                }
                else if (col === 2) { // Position 12
                    // Orientation 0 & 3: 24-13-03-21-11-00
                    if (orientation === 0 || orientation === 3) offsets = [[1, 2], [0, 1], [-1, 1], [1, -1], [0, -1], [-1, -2]];
                    // Orientation 1 & 4: 00-01-33-23-24
                    else if (orientation === 1 || orientation === 4) offsets = [[-1, -2], [-1, -1], [2, 1], [1, 1], [1, 2]];
                    // Orientation 2 & 5: 02-03-21-22-33
                    else if (orientation === 2 || orientation === 5) offsets = [[-1, 0], [-1, 1], [1, -1], [1, 0], [2, 1]];
                }
                else if (col === 3) { // Position 13
                    // Orientation 0 & 3: 25-14-04-22-12-01
                    if (orientation === 0 || orientation === 3) offsets = [[1, 2], [0, 1], [-1, 1], [1, -1], [0, -1], [-1, -2]];
                    // Orientation 1 & 4: 01-02-34-24-25
                    else if (orientation === 1 || orientation === 4) offsets = [[-1, -2], [-1, -1], [2, 1], [1, 1], [1, 2]];
                    // Orientation 2 & 5: 03-04-21-22-23-34
                    else if (orientation === 2 || orientation === 5) offsets = [[-1, 0], [-1, 1], [1, -2], [1, -1], [1, 0], [2, 1]];
                }
                else if (col === 4) { // Position 14
                    // Orientation 0 & 3: 26-15-05-23-13-02
                    if (orientation === 0 || orientation === 3) offsets = [[1, 2], [0, 1], [-1, 1], [1, -1], [0, -1], [-1, -2]];
                    // Orientation 1 & 4: 02-03-35-25-26
                    else if (orientation === 1 || orientation === 4) offsets = [[-1, -2], [-1, -1], [2, 1], [1, 1], [1, 2]];
                    // Orientation 2 & 5: 05-04-23-24-35
                    else if (orientation === 2 || orientation === 5) offsets = [[-1, 1], [-1, 0], [1, -1], [1, 0], [2, 1]];
                }
                else if (col === 5) { // Position 15
                    // Orientation 0 & 3: 27-16-24-14-03
                    if (orientation === 0 || orientation === 3) offsets = [[1, 2], [0, 1], [1, -1], [0, -1], [-1, -2]];
                    // Orientation 1 & 4: 03-04-36-26-27
                    else if (orientation === 1 || orientation === 4) offsets = [[-1, -2], [-1, -1], [2, 1], [1, 1], [1, 2]];
                    // Orientation 2 & 5: 05-24-25-36
                    else if (orientation === 2 || orientation === 5) offsets = [[-1, 0], [1, -1], [1, 0], [2, 1]];
                }
                else if (col === 6) { // Position 16
                    // Orientation 0 & 3: 25-15-04
                    if (orientation === 0 || orientation === 3) offsets = [[1, -1], [0, -1], [-1, -2]];
                    // Orientation 1 & 4: 04-05-37-27
                    else if (orientation === 1 || orientation === 4) offsets = [[-1, -2], [-1, -1], [2, 1], [1, 1]];
                    // Orientation 2 & 5: 37-26-25
                    else if (orientation === 2 || orientation === 5) offsets = [[2, 1], [1, 0], [1, -1]];
                }
            }
            else if (row === 2) {
                if (col === 0) { // Position 20
                    // Orientation 0 & 3: 32-21-11 = [3,2],[2,1],[1,1]
                    if (orientation === 0 || orientation === 3) offsets = [[1, 2], [0, 1], [-1, 1]];
                    // Orientation 1 & 4: 40-31-32 = [4,0],[3,1],[3,2]
                    else if (orientation === 1 || orientation === 4) offsets = [[2, 0], [1, 1], [1, 2]];
                    // Orientation 2 & 5: 10-11-30-40 = [1,0],[1,1],[3,0],[4,0]
                    else if (orientation === 2 || orientation === 5) offsets = [[-1, 0], [-1, 1], [1, 0], [2, 0]];
                }
                else if (col === 1) { // Position 21
                    // Orientation 0 & 3: 20-30-33-22-12 = [2,0],[3,0],[3,3],[2,2],[1,2]
                    if (orientation === 0 || orientation === 3) offsets = [[0, -1], [1, -1], [1, 2], [0, 1], [-1, 1]];
                    // Orientation 1 & 4: 10-00-41-32-33 = [1,0],[0,0],[4,1],[3,2],[3,3]
                    else if (orientation === 1 || orientation === 4) offsets = [[-1, -1], [-2, -1], [2, 0], [1, 1], [1, 2]];
                    // Orientation 2 & 5: 30-31-41-00-12-11 = [3,0],[3,1],[4,1],[0,0],[1,2],[1,1]
                    else if (orientation === 2 || orientation === 5) offsets = [[1, -1], [1, 0], [2, 0], [-2, -1], [-1, 1], [-1, 0]];
                }
                else if (col === 2) { // Position 22
                    // Orientation 0 & 3: 21-31-10-34-23-13 = [2,1],[3,1],[1,0],[3,4],[2,3],[1,3]
                    if (orientation === 0 || orientation === 3) offsets = [[0, -1], [1, -1], [-1, -2], [1, 2], [0, 1], [-1, 1]];
                    // Orientation 1 & 4: 11-10-01-42-33-34 = [1,1],[1,0],[0,1],[4,2],[3,3],[3,4]
                    else if (orientation === 1 || orientation === 4) offsets = [[-1, -1], [-1, -2], [-2, -1], [2, 0], [1, 1], [1, 2]];
                    // Orientation 2 & 5: 31-32-42-01-12-13 = [3,1],[3,2],[4,2],[0,1],[1,2],[1,3]
                    else if (orientation === 2 || orientation === 5) offsets = [[1, -1], [1, 0], [2, 0], [-2, -1], [-1, 0], [-1, 1]];
                }
                else if (col === 3) { // Position 23
                    // Orientation 0 & 3: 22-32-11-35-24-14 = [2,2],[3,2],[1,1],[3,5],[2,4],[1,4]
                    if (orientation === 0 || orientation === 3) offsets = [[0, -1], [1, -1], [-1, -2], [1, 2], [0, 1], [-1, 1]];
                    // Orientation 1 & 4: 11-12-02-43-34-35 = [1,1],[1,2],[0,2],[4,3],[3,4],[3,5]
                    else if (orientation === 1 || orientation === 4) offsets = [[-1, -2], [-1, -1], [-2, -1], [2, 0], [1, 1], [1, 2]];
                    // Orientation 2 & 5: 33-32-43-14-13-02 = [3,3],[3,2],[4,3],[1,4],[1,3],[0,2]
                    else if (orientation === 2 || orientation === 5) offsets = [[1, 0], [1, -1], [2, 0], [-1, 1], [-1, 0], [-2, -1]];
                }
                else if (col === 4) { // Position 24
                    // Orientation 0 & 3: 23-33-12-36-25-15 = [2,3],[3,3],[1,2],[3,6],[2,5],[1,5]
                    if (orientation === 0 || orientation === 3) offsets = [[0, -1], [1, -1], [-1, -2], [1, 2], [0, 1], [-1, 1]];
                    // Orientation 1 & 4: 12-13-03-44-35-36 = [1,2],[1,3],[0,3],[4,4],[3,5],[3,6]
                    else if (orientation === 1 || orientation === 4) offsets = [[-1, -2], [-1, -1], [-2, -1], [2, 0], [1, 1], [1, 2]];
                    // Orientation 2 & 5: 33-34-44-14-03-15 = [3,3],[3,4],[4,4],[1,4],[0,3],[1,5]
                    else if (orientation === 2 || orientation === 5) offsets = [[1, -1], [1, 0], [2, 0], [-1, 0], [-2, -1], [-1, 1]];
                }
                else if (col === 5) { // Position 25
                    // Orientation 0 & 3: 24-34-13-37-26-16 = [2,4],[3,4],[1,3],[3,7],[2,6],[1,6]
                    if (orientation === 0 || orientation === 3) offsets = [[0, -1], [1, -1], [-1, -2], [1, 2], [0, 1], [-1, 1]];
                    // Orientation 1 & 4: 13-14-04-45-36-37 = [1,3],[1,4],[0,4],[4,5],[3,6],[3,7]
                    else if (orientation === 1 || orientation === 4) offsets = [[-1, -2], [-1, -1], [-2, -1], [2, 0], [1, 1], [1, 2]];
                    // Orientation 2 & 5: 04-15-16-34-35-45 = [0,4],[1,5],[1,6],[3,4],[3,5],[4,5]
                    else if (orientation === 2 || orientation === 5) offsets = [[-2, -1], [-1, 0], [-1, 1], [1, -1], [1, 0], [2, 0]];
                }
                else if (col === 6) { // Position 26
                    // Orientation 0 & 3: 25-35-14-27-38 = [2,5],[3,5],[1,4],[2,7],[3,8]
                    if (orientation === 0 || orientation === 3) offsets = [[0, -1], [1, -1], [-1, -2], [0, 1], [1, 2]];
                    // Orientation 1 & 4: 14-15-05-46-38-37 = [1,4],[1,5],[0,5],[4,6],[3,8],[3,7]
                    else if (orientation === 1 || orientation === 4) offsets = [[-1, -2], [-1, -1], [-2, -1], [2, 0], [1, 2], [1, 1]];
                    // Orientation 2 & 5: 16-05-35-36-46 = [1,6],[0,5],[3,5],[3,6],[4,6]
                    else if (orientation === 2 || orientation === 5) offsets = [[-1, 0], [-2, -1], [1, -1], [1, 0], [2, 0]];
                }
                else if (col === 7) { // Position 27
                    // Orientation 0 & 3: 36-26-15 = [3,6],[2,6],[1,5]
                    if (orientation === 0 || orientation === 3) offsets = [[1, -1], [0, -1], [-1, -2]];
                    // Orientation 1 & 4: 15-16-38-47 = [1,5],[1,6],[3,8],[4,7]
                    else if (orientation === 1 || orientation === 4) offsets = [[-1, -2], [-1, -1], [1, 1], [2, 0]];
                    // Orientation 2 & 5: 36-37-47 = [3,6],[3,7],[4,7]
                    else if (orientation === 2 || orientation === 5) offsets = [[1, -1], [1, 0], [2, 0]];
                }
            }
            else if (row === 3) {
                if (col === 0) { // Position 30
                    // Orientation 0 & 3: 41-31-21
                    if (orientation === 0 || orientation === 3) offsets = [[1, 1], [0, 1], [-1, 1]];
                    // Orientation 1 & 4: 41-40
                    else if (orientation === 1 || orientation === 4) offsets = [[1, 1], [1, 0]];
                    // Orientation 2 & 5: 21-20
                    else if (orientation === 2 || orientation === 5) offsets = [[-1, 1], [-1, 0]];
                }
                else if (col === 1) { // Position 31
                    // Orientation 0 & 3: 42-32-22-30
                    if (orientation === 0 || orientation === 3) offsets = [[1, 1], [0, 1], [-1, 1], [0, -1]];
                    // Orientation 1 & 4: 50-41-40-20-10
                    else if (orientation === 1 || orientation === 4) offsets = [[2, -1], [1, 0], [1, -1], [-1, -1], [-2, -1]];
                    // Orientation 2 & 5: 10-21-22-40-50
                    else if (orientation === 2 || orientation === 5) offsets = [[-2, -1], [-1, 0], [-1, 1], [1, -1], [2, -1]];
                }
                else if (col === 2) { // Position 32
                    // Orientation 0 & 3: 40-31-20-43-33-23
                    if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -2], [1, 1], [0, 1], [-1, 1]];
                    // Orientation 1 & 4: 51-42-43-20-21-11
                    else if (orientation === 1 || orientation === 4) offsets = [[2, -1], [1, 0], [1, 1], [-1, -2], [-1, -1], [-2, -1]];
                    // Orientation 2 & 5: 40-41-51-23-22-11
                    else if (orientation === 2 || orientation === 5) offsets = [[1, -2], [1, -1], [2, -1], [-1, 1], [-1, 0], [-2, -1]];
                }
                else if (col === 3) { // Position 33
                    // Orientation 0 & 3: 41-32-21-44-34-24
                    if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -2], [1, 1], [0, 1], [-1, 1]];
                    // Orientation 1 & 4: 52-43-44-21-22-12
                    else if (orientation === 1 || orientation === 4) offsets = [[2, -1], [1, 0], [1, 1], [-1, -2], [-1, -1], [-2, -1]];
                    // Orientation 2 & 5: 52-42-41-12-23-24
                    else if (orientation === 2 || orientation === 5) offsets = [[2, -1], [1, -1], [1, -2], [-2, -1], [-1, 0], [-1, 1]];
                }
                else if (col === 4) { // Position 34
                    // Orientation 0 & 3: 42-33-22-45-35-25
                    if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -2], [1, 1], [0, 1], [-1, 1]];
                    // Orientation 1 & 4: 53-44-45-22-23-13
                    else if (orientation === 1 || orientation === 4) offsets = [[2, -1], [1, 0], [1, 1], [-1, -2], [-1, -1], [-2, -1]];
                    // Orientation 2 & 5: 53-43-42-13-24-25
                    else if (orientation === 2 || orientation === 5) offsets = [[2, -1], [1, -1], [1, -2], [-2, -1], [-1, 0], [-1, 1]];
                }
                else if (col === 5) { // Position 35
                    // Orientation 0 & 3: 43-34-23-46-36-26
                    if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -2], [1, 1], [0, 1], [-1, 1]];
                    // Orientation 1 & 4: 54-45-46-23-24-14
                    else if (orientation === 1 || orientation === 4) offsets = [[2, -1], [1, 0], [1, 1], [-1, -2], [-1, -1], [-2, -1]];
                    // Orientation 2 & 5: 54-44-43-14-25-26
                    else if (orientation === 2 || orientation === 5) offsets = [[2, -1], [1, -1], [1, -2], [-2, -1], [-1, 0], [-1, 1]];
                }
                else if (col === 6) { // Position 36
                    // Orientation 0 & 3: 44-35-24-47-37-27
                    if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -2], [1, 1], [0, 1], [-1, 1]];
                    // Orientation 1 & 4: 55-46-47-24-25-15
                    else if (orientation === 1 || orientation === 4) offsets = [[2, -1], [1, 0], [1, 1], [-1, -2], [-1, -1], [-2, -1]];
                    // Orientation 2 & 5: 55-45-44-15-26-27
                    else if (orientation === 2 || orientation === 5) offsets = [[2, -1], [1, -1], [1, -2], [-2, -1], [-1, 0], [-1, 1]];
                }
                else if (col === 7) { // Position 37
                    // Orientation 0 & 3: 45-36-25-38
                    if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -2], [0, 1]];
                    // Orientation 1 & 4: 56-47-25-26-16
                    else if (orientation === 1 || orientation === 4) offsets = [[2, -1], [1, 0], [-1, -2], [-1, -1], [-2, -1]];
                    // Orientation 2 & 5: 27-16-58-46-45
                    else if (orientation === 2 || orientation === 5) offsets = [[-1, 0], [-2, -1], [2, 1], [1, -1], [1, -2]];
                }
                else if (col === 8) { // Position 38
                    // Orientation 0 & 3: 46-37-26
                    if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -2]];
                    // Orientation 1 & 4: 56-47-25-26-16
                    else if (orientation === 1 || orientation === 4) offsets = [[2, -2], [1, -1], [-1, -3], [-1, -2], [-2, -2]];
                    // Orientation 2 & 5: 27-16-58-46-45
                    else if (orientation === 2 || orientation === 5) offsets = [[-1, -1], [-2, -2], [2, 0], [1, -2], [1, -3]];
                }
            }
            else if (row === 4) {
                if (col === 0) { // Position 40
                    // Orientation 0 & 3: 51-41-32
                    if (orientation === 0 || orientation === 3) offsets = [[1, 1], [0, 1], [-1, 2]];
                    // Orientation 1 & 4: 51-50-30-20
                    else if (orientation === 1 || orientation === 4) offsets = [[1, 1], [1, 0], [-1, 0], [-2, 0]];
                    // Orientation 2 & 5: 31-20-32
                    else if (orientation === 2 || orientation === 5) offsets = [[-1, 1], [-2, 0], [-1, 2]];
                }
                else if (col === 1) { // Position 41
                    // Orientation 0 & 3: 40-52-42-33
                    if (orientation === 0 || orientation === 3) offsets = [[0, -1], [1, 1], [0, 1], [-1, 2]];
                    // Orientation 1 & 4: 52-51-60-30-31-21
                    else if (orientation === 1 || orientation === 4) offsets = [[1, 1], [1, 0], [2, -1], [-1, -1], [-1, 0], [-2, 0]];
                    // Orientation 2 & 5: 60-50-33-32-21
                    else if (orientation === 2 || orientation === 5) offsets = [[2, -1], [1, -1], [-1, 2], [-1, 1], [-2, 0]];
                }
                else if (col === 2) { // Position 42
                    // Orientation 0 & 3: 50-41-31-53-43-34
                    if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -1], [1, 1], [0, 1], [-1, 2]];
                    // Orientation 1 & 4: 61-52-53-31-32-22
                    else if (orientation === 1 || orientation === 4) offsets = [[2, -1], [1, 0], [1, 1], [-1, -1], [-1, 0], [-2, 0]];
                    // Orientation 2 & 5: 61-51-50-34-33-22
                    else if (orientation === 2 || orientation === 5) offsets = [[2, -1], [1, -1], [1, -2], [-1, 2], [-1, 1], [-2, 0]];
                }
                else if (col === 3) { // Position 43
                    // Orientation 0 & 3: 51-42-32-54-44-35
                    if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -1], [1, 1], [0, 1], [-1, 2]];
                    // Orientation 1 & 4: 62-53-54-32-33-23
                    else if (orientation === 1 || orientation === 4) offsets = [[2, -1], [1, 0], [1, 1], [-1, -1], [-1, 0], [-2, 0]];
                    // Orientation 2 & 5: 62-52-51-35-34-23
                    else if (orientation === 2 || orientation === 5) offsets = [[2, -1], [1, -1], [1, -2], [-1, 2], [-1, 1], [-2, 0]];
                }
                else if (col === 4) { // Position 44
                    // Orientation 0 & 3: 52-43-33-55-45-36
                    if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -1], [1, 1], [0, 1], [-1, 2]];
                    // Orientation 1 & 4: 63-54-55-33-34-24
                    else if (orientation === 1 || orientation === 4) offsets = [[2, -1], [1, 0], [1, 1], [-1, -1], [-1, 0], [-2, 0]];
                    // Orientation 2 & 5: 63-53-52-36-35-24
                    else if (orientation === 2 || orientation === 5) offsets = [[2, -1], [1, -1], [1, -2], [-1, 2], [-1, 1], [-2, 0]];
                }
                else if (col === 5) { // Position 45
                    // Orientation 0 & 3: 53-44-34-56-46-37
                    if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -1], [1, 1], [0, 1], [-1, 2]];
                    // Orientation 1 & 4: 62-55-56-34-35-25
                    else if (orientation === 1 || orientation === 4) offsets = [[2, -3], [1, 0], [1, 1], [-1, -1], [-1, 0], [-2, 0]];
                    // Orientation 2 & 5: 64-54-53-37-36-25
                    else if (orientation === 2 || orientation === 5) offsets = [[2, -1], [1, -1], [1, -2], [-1, 2], [-1, 1], [-2, 0]];
                }
                else if (col === 6) { // Position 46
                    // Orientation 0 & 3: 54-45-35-47-38
                    if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -1], [0, 1], [-1, 2]];
                    // Orientation 1 & 4: 65-56-35-36-26
                    else if (orientation === 1 || orientation === 4) offsets = [[2, -1], [1, 0], [-1, -1], [-1, 0], [-2, 0]];
                    // Orientation 2 & 5: 65-55-54-38-37-26
                    else if (orientation === 2 || orientation === 5) offsets = [[2, -1], [1, -1], [1, -2], [-1, 2], [-1, 1], [-2, 0]];
                }
                else if (col === 7) { // Position 47
                    // Orientation 0 & 3: 55-46-36
                    if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -1]];
                    // Orientation 1 & 4: 56-55-38-27
                    else if (orientation === 1 || orientation === 4) offsets = [[1, -1], [1, -2], [-1, 1], [-2, 0]];
                    // Orientation 2 & 5: 56-55-38-27
                    else if (orientation === 2 || orientation === 5) offsets = [[1, -1], [1, -2], [-1, 1], [-2, 0]];
                }
            }
            else if (row === 5) {
                if (col === 0) { // Position 50
                    // Orientation 0 & 3: 61-51-42
                    if (orientation === 0 || orientation === 3) offsets = [[1, 1], [0, 1], [-1, 2]];
                    // Orientation 1 & 4: 40-31-60-61
                    else if (orientation === 1 || orientation === 4) offsets = [[-1, 0], [-2, 1], [1, 0], [1, 1]];
                    // Orientation 2 & 5: 42-41-31
                    else if (orientation === 2 || orientation === 5) offsets = [[-1, 2], [-1, 1], [-2, 1]];
                }
                else if (col === 1) { // Position 51
                    // Orientation 0 & 3: 62-52-43-50-40
                    if (orientation === 0 || orientation === 3) offsets = [[1, 1], [0, 1], [-1, 2], [0, -1], [-1, -1]];
                    // Orientation 1 & 4: 40-41-32-61-62
                    else if (orientation === 1 || orientation === 4) offsets = [[-1, -1], [-1, 0], [-2, 1], [1, 0], [1, 1]];
                    // Orientation 2 & 5: 60-43-42-32
                    else if (orientation === 2 || orientation === 5) offsets = [[1, -1], [-1, 2], [-1, 1], [-2, 1]];
                }
                else if (col === 2) { // Position 52
                    // Orientation 0 & 3: 60-51-41-63-53-44
                    if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -1], [1, 1], [0, 1], [-1, 2]];
                    // Orientation 1 & 4: 41-42-33-62-63
                    else if (orientation === 1 || orientation === 4) offsets = [[-1, -1], [-1, 0], [-2, 1], [1, 0], [1, 1]];
                    // Orientation 2 & 5: 60-61-44-43-33
                    else if (orientation === 2 || orientation === 5) offsets = [[1, -2], [1, -1], [-1, 2], [-1, 1], [-2, 1]];
                }
                else if (col === 3) { // Position 53
                    // Orientation 0 & 3: 61-52-42-64-54-45
                    if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -1], [1, 1], [0, 1], [-1, 2]];
                    // Orientation 1 & 4: 42-43-34-63-64
                    else if (orientation === 1 || orientation === 4) offsets = [[-1, -1], [-1, 0], [-2, 1], [1, 0], [1, 1]];
                    // Orientation 2 & 5: 61-62-45-44-34
                    else if (orientation === 2 || orientation === 5) offsets = [[1, -2], [1, -1], [-1, 2], [-1, 1], [-2, 1]];
                }
                else if (col === 4) { // Position 54
                    // Orientation 0 & 3: 62-53-43-65-55-46
                    if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -1], [1, 1], [0, 1], [-1, 2]];
                    // Orientation 1 & 4: 64-65-43-44-35
                    else if (orientation === 1 || orientation === 4) offsets = [[1, 0], [1, 1], [-1, -1], [-1, 0], [-2, 1]];
                    // Orientation 2 & 5: 62-63-46-45-35
                    else if (orientation === 2 || orientation === 5) offsets = [[1, -2], [1, -1], [-1, 2], [-1, 1], [-2, 1]];
                }
                else if (col === 5) { // Position 55
                    // Orientation 0 & 3: 63-54-44-56-47
                    if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -1], [0, 1], [-1, 2]];
                    // Orientation 1 & 4: 45-44-36-65
                    else if (orientation === 1 || orientation === 4) offsets = [[-1, 0], [-1, -1], [-2, 1], [1, 0]];
                    // Orientation 2 & 5: 64-63-47-46-36
                    else if (orientation === 2 || orientation === 5) offsets = [[1, -1], [1, -2], [-1, 2], [-1, 1], [-2, 1]];
                }
                else if (col === 6) { // Position 56
                    // Orientation 0 & 3: 64-55-45
                    if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -1]];
                    // Orientation 1 & 4: 45-46-37
                    else if (orientation === 1 || orientation === 4) offsets = [[-1, -1], [-1, 0], [-2, 1]];
                    // Orientation 2 & 5: 64-65-47-37
                    else if (orientation === 2 || orientation === 5) offsets = [[1, -2], [1, -1], [-1, 1], [-2, 1]];
                }
            }
            
            // If no pattern found or offsets empty, use base movement (orientation 0)
            if (offsets.length === 0) {
                console.log(`‚ö†Ô∏è No rotation pattern found for row=${row}, col=${col}, orientation=${orientation}. Using base pattern.`);
                const baseTargets = getHexgonMoves(row, col);
                console.log('üìç Base hexagon targets:', baseTargets);
                return baseTargets;
            }
            
            console.log(`üîç Hexagon pattern for ${row}-${col} orientation ${orientation}:`, offsets);
            
            // Convert offsets to absolute coordinates
            const targets = offsets.map(([dr, dc]) => [row + dr, col + dc]);
            console.log(`üéØ Hexagon target coordinates:`, targets);
            
            return targets;
        }
        
        function getRotatedTriangleTargets(row, col, orientation, isWhite) {
            console.log(`üîç getRotatedTriangleTargets called: row=${row}, col=${col}, orientation=${orientation}, isWhite=${isWhite}`);
            
            // Get the specific movement pattern for this position and orientation
            let offsets = [];
            
            if (isWhite) {
                // White triangle patterns - rotation-aware patterns (opposite to black triangles)
                // White triangles face towards black pieces, so their patterns are opposite
                if (row === 0) {
                    // Row 0 patterns - corrected based on position 0-1 observations
                    if (orientation === 0) offsets = [[0, 1], [1, 1]]; // 02-12 pattern
                    else if (orientation === 1) offsets = [[1, 0], [1, 1], [0, 1]]; // 11-12-02 pattern
                    else if (orientation === 2) offsets = [[1, 1], [1, 0], [0, -1]]; // 12-11-00 pattern
                    else if (orientation === 3) offsets = [[1, 0], [0, -1]]; // 11-00 pattern
                    else if (orientation === 4) offsets = [[0, -1]]; // 00 pattern (correct)
                    else if (orientation === 5) offsets = [[0, 1]]; // 02 pattern (correct)
                } else if (row === 1) {
                    // Row 1 patterns - corrected based on position 1-2 observations
                    if (orientation === 0) offsets = [[1, 1], [0, 1], [-1, 0]]; // 23-13-02 pattern
                    else if (orientation === 1) offsets = [[1, 0], [1, 1], [0, 1]]; // 22-23-13 pattern
                    else if (orientation === 2) offsets = [[1, 1], [1, 0], [0, -1]]; // 23-22-11 pattern
                    else if (orientation === 3) offsets = [[1, 0], [0, -1], [-1, -1]]; // 22-11-01 pattern
                    else if (orientation === 4) offsets = [[0, -1], [-1, -1], [-1, 0]]; // 11-01-02 pattern
                    else if (orientation === 5) offsets = [[-1, -1], [-1, 0], [0, 1]]; // 01-02-13 pattern
                } else if (row === 2) {
                    // Row 2 patterns - corrected based on position 2-2 observations
                    if (orientation === 0) offsets = [[1, 1], [0, 1], [-1, 0]]; // 33-23-12 pattern
                    else if (orientation === 1) offsets = [[1, 0], [1, 1], [0, 1]]; // 32-33-23 pattern
                    else if (orientation === 2) offsets = [[1, 1], [1, 0], [0, -1]]; // 33-32-21 pattern
                    else if (orientation === 3) offsets = [[1, 0], [0, -1], [-1, -1]]; // 32-21-11 pattern
                    else if (orientation === 4) offsets = [[0, -1], [-1, -1], [-1, 0]]; // 21-11-12 pattern
                    else if (orientation === 5) offsets = [[-1, -1], [-1, 0], [0, 1]]; // 11-12-23 pattern
                } else if (row === 3) {
                    // Row 3 patterns - position-specific with rotation
                    if (col === 0) {
                        if (orientation === 0 || orientation === 3) offsets = [[1, 1], [0, 1], [-1, 1]]; // 41-31-21
                        else if (orientation === 1 || orientation === 4) offsets = [[1, 1], [1, 0]]; // 41-40
                        else if (orientation === 2 || orientation === 5) offsets = [[-1, 1], [-1, 0]]; // 21-20
                    } else if (col === 1) {
                        if (orientation === 0 || orientation === 3) offsets = [[1, 1], [0, 1], [-1, 1], [0, -1]]; // 42-32-22-30
                        else if (orientation === 1 || orientation === 4) offsets = [[2, -1], [1, 0], [1, -1], [-1, -1], [-2, -1]]; // 50-41-40-20-10
                        else if (orientation === 2 || orientation === 5) offsets = [[-2, -1], [-1, 0], [-1, 1], [1, -1], [2, -1]]; // 10-21-22-40-50
                    } else if (col === 2) {
                        if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -2], [1, 1], [0, 1], [-1, 1]]; // 40-31-20-43-33-23
                        else if (orientation === 1 || orientation === 4) offsets = [[2, -1], [1, 0], [1, 1], [-1, -2], [-1, -1], [-2, -1]]; // 51-42-43-20-21-11
                        else if (orientation === 2 || orientation === 5) offsets = [[1, -2], [1, -1], [2, -1], [-1, 1], [-1, 0], [-2, -1]]; // 40-41-51-23-22-11
                    } else if (col === 3) {
                        if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -2], [1, 1], [0, 1], [-1, 1]]; // 41-32-21-44-34-24
                        else if (orientation === 1 || orientation === 4) offsets = [[2, -1], [1, 0], [1, 1], [-1, -2], [-1, -1], [-2, -1]]; // 52-43-44-21-22-12
                        else if (orientation === 2 || orientation === 5) offsets = [[2, -1], [1, -1], [1, -2], [-2, -1], [-1, 0], [-1, 1]]; // 52-42-41-12-23-24
                    } else if (col === 4) {
                        if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -2], [1, 1], [0, 1], [-1, 1]]; // 42-33-22-45-35-25
                        else if (orientation === 1 || orientation === 4) offsets = [[2, -1], [1, 0], [1, 1], [-1, -2], [-1, -1], [-2, -1]]; // 53-44-45-22-23-13
                        else if (orientation === 2 || orientation === 5) offsets = [[2, -1], [1, -1], [1, -2], [-2, -1], [-1, 0], [-1, 1]]; // 53-43-42-13-24-25
                    } else if (col === 5) {
                        if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -2], [1, 1], [0, 1], [-1, 1]]; // 43-34-23-46-36-26
                        else if (orientation === 1 || orientation === 4) offsets = [[2, -1], [1, 0], [1, 1], [-1, -2], [-1, -1], [-2, -1]]; // 54-45-46-23-24-14
                        else if (orientation === 2 || orientation === 5) offsets = [[2, -1], [1, -1], [1, -2], [-2, -1], [-1, 0], [-1, 1]]; // 54-44-43-14-25-26
                    } else if (col === 6) {
                        if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -2], [1, 1], [0, 1], [-1, 1]]; // 44-35-24-47-37-27
                        else if (orientation === 1 || orientation === 4) offsets = [[2, -1], [1, 0], [1, 1], [-1, -2], [-1, -1], [-2, -1]]; // 55-46-47-24-25-15
                        else if (orientation === 2 || orientation === 5) offsets = [[2, -1], [1, -1], [1, -2], [-2, -1], [-1, 0], [-1, 1]]; // 55-45-44-15-26-27
                    } else if (col === 7) {
                        if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -2], [0, 1]]; // 45-36-25-38
                        else if (orientation === 1 || orientation === 4) offsets = [[2, -1], [1, 0], [-1, -2], [-1, -1], [-2, -1]]; // 56-47-25-26-16
                        else if (orientation === 2 || orientation === 5) offsets = [[-1, 0], [-2, -1], [2, 1], [1, -1], [1, -2]]; // 27-16-58-46-45
                    } else if (col === 8) {
                        if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -2]]; // 46-37-26
                        else if (orientation === 1 || orientation === 4) offsets = [[2, -2], [1, -1], [-1, -3], [-1, -2], [-2, -2]]; // 56-47-25-26-16
                        else if (orientation === 2 || orientation === 5) offsets = [[-1, -1], [-2, -2], [2, 0], [1, -2], [1, -3]]; // 27-16-58-46-45
                    } else {
                        // Default fallback for any other column
                        if (orientation === 0 || orientation === 3) offsets = [[1, 0], [0, 1], [-1, 0]]; // 43-34-23 pattern
                        else if (orientation === 1 || orientation === 4) offsets = [[0, 1], [1, 0], [1, -1]]; // 34-43-42 pattern
                        else if (orientation === 2 || orientation === 5) offsets = [[1, 0], [1, -1], [0, -1]]; // 43-42-32 pattern
                    }
                } else if (row === 4) {
                    // Row 4 patterns - position-specific with rotation (mirror structure of row 2)
                    if (col === 0) {
                        if (orientation === 0 || orientation === 3) offsets = [[1, 0], [0, 1], [-1, 1]]; // 50-41-31
                        else if (orientation === 1 || orientation === 4) offsets = [[2, 0], [1, 1], [1, 0]]; // 60-51-50
                        else if (orientation === 2 || orientation === 5) offsets = [[-1, 0], [-1, 1], [1, 0], [2, 0]]; // 30-31-50-60
                    } else if (col === 1) {
                        if (orientation === 0 || orientation === 3) offsets = [[0, -1], [1, -1], [1, 2], [0, 1], [-1, 1]]; // 40-50-53-42-32
                        else if (orientation === 1 || orientation === 4) offsets = [[-1, -1], [-2, -1], [2, 0], [1, 1], [1, 2]]; // 30-20-61-52-53
                        else if (orientation === 2 || orientation === 5) offsets = [[1, -1], [1, 0], [2, 0], [-2, -1], [-1, 1], [-1, 0]]; // 50-51-61-20-32-31
                    } else if (col === 2) {
                        if (orientation === 0 || orientation === 3) offsets = [[0, -1], [1, -1], [-1, -2], [1, 2], [0, 1], [-1, 1]]; // 41-51-30-54-43-33
                        else if (orientation === 1 || orientation === 4) offsets = [[-1, -1], [-1, -2], [-2, -1], [2, 0], [1, 1], [1, 2]]; // 31-30-21-62-53-54
                        else if (orientation === 2 || orientation === 5) offsets = [[1, -1], [1, 0], [2, 0], [-2, -1], [-1, 0], [-1, 1]]; // 51-52-62-21-32-33
                    } else if (col === 3) {
                        if (orientation === 0 || orientation === 3) offsets = [[0, -1], [1, -1], [-1, -2], [1, 2], [0, 1], [-1, 1]]; // 42-52-31-55-44-34
                        else if (orientation === 1 || orientation === 4) offsets = [[-1, -2], [-1, -1], [-2, -1], [2, 0], [1, 1], [1, 2]]; // 31-32-22-63-54-55
                        else if (orientation === 2 || orientation === 5) offsets = [[1, 0], [1, -1], [2, 0], [-1, 1], [-1, 0], [-2, -1]]; // 53-52-63-34-33-22
                    } else if (col === 4) {
                        if (orientation === 0 || orientation === 3) offsets = [[0, -1], [1, -1], [-1, -2], [1, 2], [0, 1], [-1, 1]]; // 43-53-32-56-45-35
                        else if (orientation === 1 || orientation === 4) offsets = [[-1, -2], [-1, -1], [-2, -1], [2, 0], [1, 1], [1, 2]]; // 32-33-23-64-55-56
                        else if (orientation === 2 || orientation === 5) offsets = [[1, -1], [1, 0], [2, 0], [-1, 0], [-2, -1], [-1, 1]]; // 53-54-64-34-23-35
                    } else if (col === 5) {
                        if (orientation === 0 || orientation === 3) offsets = [[0, -1], [1, -1], [-1, -2], [1, 2], [0, 1], [-1, 1]]; // 44-54-33-57-46-36
                        else if (orientation === 1 || orientation === 4) offsets = [[-1, -2], [-1, -1], [-2, -1], [2, 0], [1, 1], [1, 2]]; // 33-34-24-65-56-57
                        else if (orientation === 2 || orientation === 5) offsets = [[-2, -1], [-1, 0], [-1, 1], [1, -1], [1, 0], [2, 0]]; // 24-35-36-54-55-65
                    } else if (col === 6) {
                        if (orientation === 0 || orientation === 3) offsets = [[0, -1], [1, -1], [-1, -2], [0, 1], [1, 2]]; // 45-55-34-47-58
                        else if (orientation === 1 || orientation === 4) offsets = [[-1, -2], [-1, -1], [-2, -1], [2, 0], [1, 2], [1, 1]]; // 34-35-25-66-58-57
                        else if (orientation === 2 || orientation === 5) offsets = [[-1, 0], [-2, -1], [1, -1], [1, 0], [2, 0]]; // 36-25-55-56-66
                    } else if (col === 7) {
                        if (orientation === 0 || orientation === 3) offsets = [[1, -1], [0, -1], [-1, -2]]; // 56-46-35
                        else if (orientation === 1 || orientation === 4) offsets = [[-1, -2], [-1, -1], [1, 1], [2, 0]]; // 35-36-58-67
                        else if (orientation === 2 || orientation === 5) offsets = [[1, -1], [1, 0], [2, 0]]; // 56-57-67
                    } else {
                        // Default fallback
                        if (orientation === 0 || orientation === 3) offsets = [[1, 0], [0, 1], [-1, 1]]; 
                        else if (orientation === 1 || orientation === 4) offsets = [[1, 0], [1, -1], [0, 1]]; 
                        else if (orientation === 2 || orientation === 5) offsets = [[1, 0], [1, -1], [0, -1]]; 
                    }
                } else if (row === 5) {
                    // Row 5 patterns - corrected based on position 5-1 observations
                    if (orientation === 0) offsets = [[1, 0], [0, 1], [-1, 1]]; // 61-52-42 pattern
                    else if (orientation === 1) offsets = [[1, 0], [1, -1], [0, 1]]; // 61-60-52 pattern
                    else if (orientation === 2) offsets = [[1, 0], [1, -1], [0, -1]]; // 61-60-50 pattern
                    else if (orientation === 3) offsets = [[-1, 0], [0, -1], [1, -1]]; // 41-50-60 pattern
                    else if (orientation === 4) offsets = [[-1, 0], [-1, 1], [0, -1]]; // 41-42-50 pattern
                    else if (orientation === 5) offsets = [[-1, 0], [-1, 1], [0, 1]]; // 41-42-52 pattern (correct)
                } else if (row === 6) {
                    // Row 6 patterns - using same patterns as row 5
                    if (orientation === 0) offsets = [[1, 0], [0, 1], [-1, 1]]; // 61-52-42 pattern
                    else if (orientation === 1) offsets = [[1, 0], [1, -1], [0, 1]]; // 61-60-52 pattern
                    else if (orientation === 2) offsets = [[1, 0], [1, -1], [0, -1]]; // 61-60-50 pattern
                    else if (orientation === 3) offsets = [[-1, 0], [0, -1], [1, -1]]; // 41-50-60 pattern
                    else if (orientation === 4) offsets = [[-1, 0], [-1, 1], [0, -1]]; // 41-42-50 pattern
                    else if (orientation === 5) offsets = [[-1, 0], [-1, 1], [0, 1]]; // 41-42-52 pattern
                }
            } else {
                // Black triangle patterns - specific patterns for each orientation
                // Most rows use the same rotation patterns, but some rows have special cases
                if (row === 3) {
                    // Row 3 patterns - corrected based on position 3-4 observations
                    if (orientation === 0) offsets = [[1, -1], [0, -1], [-1, -1]]; // 43-33-23 pattern
                    else if (orientation === 1) offsets = [[0, -1], [-1, -1], [-1, 0]]; // 33-23-24 pattern
                    else if (orientation === 2) offsets = [[-1, -1], [-1, 0], [0, 1]]; // 23-24-35 pattern
                    else if (orientation === 3) offsets = [[1, 0], [0, 1], [-1, 0]]; // 44-35-24 pattern
                    else if (orientation === 4) offsets = [[0, 1], [1, 0], [1, -1]]; // 56-65-64 pattern (correct)
                    else if (orientation === 5) offsets = [[1, 0], [1, -1], [0, -1]]; // 65-64-54 pattern (correct)
                } else if (row === 4) {
                    // Row 4 patterns - using same patterns as rows 5 & 6
                    if (orientation === 0) offsets = [[1, -1], [0, -1], [-1, 0]]; // 64-54-45 pattern
                    else if (orientation === 1) offsets = [[0, -1], [-1, 0], [-1, 1]]; // 54-45-46 pattern
                    else if (orientation === 2) offsets = [[-1, 0], [-1, 1], [0, 1]]; // 45-46-56 pattern
                    else if (orientation === 3) offsets = [[1, 0], [0, 1], [-1, 1]]; // 65-56-46 pattern
                    else if (orientation === 4) offsets = [[0, 1], [1, 0], [1, -1]]; // 56-65-64 pattern
                    else if (orientation === 5) offsets = [[1, 0], [1, -1], [0, -1]]; // 65-64-54 pattern
                } else if (row === 5 || row === 6) {
                    // Rows 5 & 6 patterns - these were working correctly before
                    if (orientation === 0) offsets = [[1, -1], [0, -1], [-1, 0]]; // 64-54-45 pattern
                    else if (orientation === 1) offsets = [[0, -1], [-1, 0], [-1, 1]]; // 54-45-46 pattern
                    else if (orientation === 2) offsets = [[-1, 0], [-1, 1], [0, 1]]; // 45-46-56 pattern
                    else if (orientation === 3) offsets = [[1, 0], [0, 1], [-1, 1]]; // 65-56-46 pattern
                    else if (orientation === 4) offsets = [[0, 1], [1, 0], [1, -1]]; // 56-65-64 pattern
                    else if (orientation === 5) offsets = [[1, 0], [1, -1], [0, -1]]; // 65-64-54 pattern
                } else if (row === 2) {
                    // Row 2 patterns - corrected based on position 2-3 observations
                    if (orientation === 0) offsets = [[0, -1], [1, 0], [-1, -1]]; // 22-33-12 pattern
                    else if (orientation === 1) offsets = [[-1, -1], [0, -1], [-1, 0]]; // 12-22-13 pattern
                    else if (orientation === 2) offsets = [[-1, 0], [-1, -1], [0, 1]]; // 13-12-24 pattern
                    else if (orientation === 3) offsets = [[1, 1], [0, 1], [-1, 0]]; // 34-24-13 pattern
                    else if (orientation === 4) offsets = [[1, 1], [1, 0], [0, 1]]; // 34-33-24 pattern
                    else if (orientation === 5) offsets = [[1, 1], [0, -1], [1, 0]]; // 34-22-33 pattern
                } else if (row === 1) {
                    // Row 1 patterns - corrected based on position 1-3 observations
                    if (orientation === 0) offsets = [[1, 0], [-1, -1], [0, -1]]; // 23-02-12 pattern
                    else if (orientation === 1) offsets = [[0, -1], [-1, -1], [-1, 0]]; // 12-02-03 pattern
                    else if (orientation === 2) offsets = [[-1, -1], [-1, 0], [0, 1]]; // 02-03-14 pattern
                    else if (orientation === 3) offsets = [[1, 1], [0, 1], [-1, 0]]; // 24-14-03 pattern
                    else if (orientation === 4) offsets = [[0, 1], [1, 0], [1, 1]]; // 14-23-24 pattern
                    else if (orientation === 5) offsets = [[1, 1], [1, 0], [0, -1]]; // 24-23-12 pattern
                } else if (row === 0) {
                    // Row 0 patterns - corrected based on position 0-3 observations
                    if (orientation === 0) offsets = [[1, 0], [0, -1]]; // 13-02 pattern
                    else if (orientation === 1) offsets = [[0, -1]]; // 02 pattern (correct)
                    else if (orientation === 2) offsets = [[0, 1]]; // 04 pattern (correct)
                    else if (orientation === 3) offsets = [[0, 1], [1, 1]]; // 04-14 pattern
                    else if (orientation === 4) offsets = [[0, 1], [1, 1], [1, 0]]; // 04-14-13 pattern
                    else if (orientation === 5) offsets = [[1, 0], [1, 1], [0, -1]]; // 13-14-02 pattern
                } else {
                    // Standard rotation patterns for any other cases
                    if (orientation === 0) offsets = [[1, -1], [0, -1], [-1, 0]]; // 64-54-45 pattern
                    else if (orientation === 1) offsets = [[0, -1], [-1, 0], [-1, 1]]; // 54-45-46 pattern
                    else if (orientation === 2) offsets = [[-1, 0], [-1, 1], [0, 1]]; // 45-46-56 pattern
                    else if (orientation === 3) offsets = [[1, 0], [0, 1], [-1, 0]]; // 65-56-46 pattern
                    else if (orientation === 4) offsets = [[0, 1], [1, 0], [1, -1]]; // 56-65-64 pattern
                    else if (orientation === 5) offsets = [[1, 0], [1, -1], [0, -1]]; // 65-64-54 pattern
                }
            }
            
            console.log(`üîç Pattern for ${row}-${col} orientation ${orientation}:`, offsets);
            console.log(`üîç Pattern details:`, offsets.map(([dr, dc]) => `[${dr}, ${dc}]`));
            
            // Show expected target coordinates
            const expectedTargets = offsets.map(([dr, dc]) => `hex-${row + dr}-${col + dc}`);
            console.log(`üéØ Expected target coordinates:`, expectedTargets);
            
            return offsets;
        }
        
        function evaluateMove(fromRow, fromCol, toRow, toCol, pieceType, isCapture) {
            let score = 0;
            
            // === CRITICAL: AVOID MOVING INTO THREATS ===
            
            // NEVER move into a position where we'll be captured!
            if (isPieceUnderThreat(toRow, toCol, true)) {
                // Only acceptable if we're capturing something MORE valuable
                if (!isCapture) {
                    score -= 2000; // Huge penalty for walking into danger
                } else {
                    // Capturing while threatened - only worth it for high-value pieces
                    const targetHex = document.getElementById(`hex-${toRow}-${toCol}`);
                    if (targetHex) {
                        const targetPiece = targetHex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                        if (!targetPiece || !targetPiece.classList.contains('rhombus-piece')) {
                            score -= 1000; // Don't trade pieces when we're threatened
                        }
                    }
                }
            }
            
            // === HIGH PRIORITY: WINNING & SURVIVAL ===
            
            // Get rhombus positions for strategic evaluation
            let blackRhombus = document.querySelector('.rhombus-piece:not(.white-rhombus)');
            const whiteRhombus = document.querySelector('.rhombus-piece.white-rhombus');
            
            // Check if this is a winning move
            if (pieceType === 'rhombus' && toRow === 3 && toCol === 8) {
                // Check if black rhombus is blocking our base
                if (blackRhombus) {
                    const blackHex = blackRhombus.closest('.hexagon');
                    if (blackHex) {
                        const [, bRow, bCol] = blackHex.id.match(/hex-(\d+)-(\d+)/);
                        if (bRow == 3 && bCol == 8) {
                            // Black is blocking our goal - can't win yet
                            score += 500; // Still good position
                        } else {
                            score += 100000; // INSTANT WIN!
                        }
                    }
                }
            }
            
            // Protect our rhombus from being checkmated/stalemated
            if (whiteRhombus) {
                const rhombusHex = whiteRhombus.closest('.hexagon');
                if (rhombusHex) {
                    const [, rRow, rCol] = rhombusHex.id.match(/hex-(\d+)-(\d+)/);
                    
                    // CRITICAL: Check if rhombus is trapped/locked (no legal moves)
                    const rhombusMoves = getPossibleMoves(parseInt(rRow), parseInt(rCol), 'rhombus', true);
                    const rhombusIsTrapped = rhombusMoves.length === 0;
                    
                    if (rhombusIsTrapped) {
                        console.log('‚ö†Ô∏è CRITICAL: White rhombus is TRAPPED at', rRow, '-', rCol, '!');
                        
                        // If THIS IS the rhombus and it has ANY legal move, take it!
                        if (pieceType === 'rhombus' && fromRow == rRow && fromCol == rCol) {
                            score += 5000; // MAXIMUM PRIORITY: Escape the trap!
                            console.log('‚úÖ Rhombus escape move:', fromRow, '-', fromCol, '‚Üí', toRow, '-', toCol);
                        }
                        
                        // If another piece can capture a piece blocking the rhombus
                        if (isCapture && pieceType !== 'rhombus') {
                            // Check if the captured piece was blocking rhombus escape routes
                            const distanceToRhombus = Math.abs(toRow - rRow) + Math.abs(toCol - rCol);
                            if (distanceToRhombus <= 2) {
                                score += 2000; // Very high priority: Free the rhombus!
                                console.log('‚úÖ Capturing blocker near trapped rhombus');
                            }
                        }
                    } else if (isPieceUnderThreat(parseInt(rRow), parseInt(rCol), true)) {
                        // Rhombus is threatened but not trapped
                        // Moving rhombus away from danger
                        if (pieceType === 'rhombus') {
                            score += 1500; // CRITICAL: Escape danger!
                        }
                        // Or blocking/capturing the threat
                        if (isCapture) score += 800;
                        
                        // Check if THIS move blocks the threat to our rhombus
                        if (wouldBlockThreat(fromRow, fromCol, toRow, toCol, rRow, rCol)) {
                            score += 1000; // Blocking threat to rhombus!
                        }
                    }
                }
            }
            
            // === CAPTURES ===
            if (isCapture) {
                // Prioritize capturing valuable pieces - BALANCED scoring
                const targetHex = document.getElementById(`hex-${toRow}-${toCol}`);
                if (targetHex) {
                    const targetPiece = targetHex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                    if (targetPiece) {
                        if (targetPiece.classList.contains('triangle-piece')) score += 180; // BALANCED
                        else if (targetPiece.classList.contains('hexgon-piece')) score += 170; // BALANCED
                        else if (targetPiece.classList.contains('circle-piece')) score += 160; // BALANCED
                        else if (targetPiece.classList.contains('square-piece')) score += 150; // BALANCED
                    }
                }
            }
            
            // === RHOMBUS STRATEGY ===
            if (pieceType === 'rhombus') {
                // Check if this is a diagonal move (dead zone ‚Üî inner perimeter)
                const isDiagonalMove = isRhombusDiagonalMove(fromRow, fromCol, toRow, toCol);
                
                if (isDiagonalMove) {
                    score += 180; // Bonus for using special diagonal ability
                    console.log(`üî∑ Rhombus diagonal move detected: ${fromRow}-${fromCol} ‚Üí ${toRow}-${toCol}`);
                    
                    // Extra bonus if diagonal move is ESCAPING a trap
                    const currentMobility = getRhombusMoves(fromRow, fromCol).length;
                    const futureMobility = getRhombusMoves(toRow, toCol).length;
                    
                    if (currentMobility <= 2 && futureMobility > currentMobility) {
                        score += 1000; // CRITICAL ESCAPE using diagonal!
                        console.log(`‚úÖ Rhombus diagonal ESCAPE: ${fromRow}-${fromCol} ‚Üí ${toRow}-${toCol} (mobility: ${currentMobility} ‚Üí ${futureMobility})`);
                    }
                    
                    // Bonus if diagonal move brings us closer to goal
                    const currentDistToGoal = Math.abs(fromRow - 3) + Math.abs(fromCol - 8);
                    const futureDistToGoal = Math.abs(toRow - 3) + Math.abs(toCol - 8);
                    
                    if (futureDistToGoal < currentDistToGoal) {
                        score += 250; // Diagonal shortcut to goal!
                        console.log(`‚úÖ Rhombus diagonal advancement: closer to goal by ${currentDistToGoal - futureDistToGoal}`);
                    }
                    
                    // Bonus if diagonal move creates threats
                    const threatsFromNewPos = countThreatenedOpponentPieces(toRow, toCol, 'rhombus');
                    if (threatsFromNewPos > 0) {
                        score += threatsFromNewPos * 60;
                        console.log(`‚úÖ Rhombus diagonal creates ${threatsFromNewPos} threats`);
                    }
                }
                
                // Progressive advancement toward 3-8 (BALANCED)
                const distanceToGoal = Math.abs(toRow - 3) + Math.abs(toCol - 8);
                score += (20 - distanceToGoal) * 5; // BALANCED - strategic but not dominant
                
                // Prefer row 3 (direct path to goal)
                if (toRow === 3) score += 15; // BALANCED
                
                // Don't leave base until we have support
                if (fromRow === 3 && fromCol === 0) {
                    const whiteSquares = document.querySelectorAll('.square-piece.white-piece');
                    const whiteTriangles = document.querySelectorAll('.triangle-piece.white-triangle');
                    if (whiteSquares.length + whiteTriangles.length < 3) {
                        score -= 200; // Stay at base if we're weak
                    }
                }
                
                // Avoid getting trapped
                const rhombusMoves = getRhombusMoves(toRow, toCol);
                score += rhombusMoves.length * 12; // BALANCED - mobility important for rhombus
                
                // Extra penalty if moving INTO a position with fewer options
                const currentRhombusMoves = getRhombusMoves(fromRow, fromCol);
                if (rhombusMoves.length < currentRhombusMoves.length - 1) {
                    score -= 80; // Losing mobility is risky for rhombus
                }
            }
            
            // === DEFENSIVE PLAY ===
            
            // Block opponent's rhombus path
            if (blackRhombus) {
                const blackHex = blackRhombus.closest('.hexagon');
                if (blackHex) {
                    const [, bRow, bCol] = blackHex.id.match(/hex-(\d+)-(\d+)/);
                    const blackDistanceToGoal = Math.abs(bRow - 3) + Math.abs(bCol - 0);
                    
                    // If black is close to winning, block them!
                    if (blackDistanceToGoal <= 3) {
                        const distanceToBlackRhombus = Math.abs(toRow - bRow) + Math.abs(toCol - bCol);
                        score += (10 - distanceToBlackRhombus) * 30; // Get close to block
                    }
                }
            }
            
            // Defend our base (3-8) if rhombus has left
            if (whiteRhombus) {
                const rhombusHex = whiteRhombus.closest('.hexagon');
                if (rhombusHex) {
                    const [, rRow, rCol] = rhombusHex.id.match(/hex-(\d+)-(\d+)/);
                    if (!(rRow == 3 && rCol == 8)) {
                        // Rhombus not at base - defend it
                        if (toRow === 3 && toCol === 8) score += 100;
                    }
                }
            }
            
            // === POSITIONAL PLAY ===
            
            // Control center (row 3, middle columns) - BALANCED
            if (toRow === 3) score += 20; // BALANCED
            const centerDistance = Math.abs(toRow - 3) + Math.abs(toCol - 4);
            score += (10 - centerDistance) * 3; // BALANCED
            
            // Forward progress (move toward opponent) - BALANCED
            if (toCol < fromCol) score += 10; // BALANCED - White wants to go left toward black's side
            
            // Piece mobility - prefer moves that give more options
            let mobilityBonus = 0;
            if (pieceType === 'square') {
                const futureMoves = getSquareTargets(toRow, toCol);
                mobilityBonus = futureMoves.length * 3;
            } else if (pieceType === 'triangle') {
                const futureMoves = getWhiteTriangleTargets(toRow, toCol);
                mobilityBonus = futureMoves.length * 3;
            } else if (pieceType === 'hexgon') {
                const futureMoves = getHexgonTargets(toRow, toCol);
                mobilityBonus = futureMoves.length * 3;
            }
            score += mobilityBonus;
            
            // === PIECE DIVERSITY BONUS ===
            // Encourage using non-rhombus pieces to create balanced play
            if (pieceType !== 'rhombus') {
                score += 30; // REDUCED from 80 - Moderate bonus for tactical pieces
                
                // Extra bonus if we have many pieces (don't just turtle with rhombus)
                const whitePieces = document.querySelectorAll('.square-piece.white-piece, .triangle-piece.white-triangle, .circle-piece.white-circle, .hexgon-piece.white-hexgon');
                if (whitePieces.length >= 4) {
                    score += 20; // REDUCED from 60
                }
            }
            
            // === TACTICAL THREATS ===
            
            // Check if this move threatens opponent's pieces - BALANCED
            const threatenedPieces = countThreatenedOpponentPieces(toRow, toCol, pieceType);
            score += threatenedPieces * 50; // BALANCED - threats matter but not overwhelming
            
            // MAJOR BONUS: Threaten opponent's rhombus!
            if (blackRhombus) {
                const blackHex = blackRhombus.closest('.hexagon');
                if (blackHex) {
                    const [, bRow, bCol] = blackHex.id.match(/hex-(\d+)-(\d+)/);
                    if (wouldThreatenPosition(toRow, toCol, pieceType, parseInt(bRow), parseInt(bCol))) {
                        score += 400; // BALANCED - very important but not overwhelming
                    }
                }
            }
            
            // BONUS: Move our pieces to safety if they're currently threatened
            if (isPieceUnderThreat(fromRow, fromCol, true) && !isPieceUnderThreat(toRow, toCol, true)) {
                score += 300; // Escaping from danger!
            }
            
            // === REPETITION AVOIDANCE ===
            // Check if this move would contribute to fivefold shuttle loss
            if (!isCapture) { // Only non-captures count for shuttle
                const fromPos = `${fromRow}${fromCol}`;
                const toPos = `${toRow}${toCol}`;
                const sortedPositions = [fromPos, toPos].sort();
                const shuttleKey = `white-${pieceType}-shuttle-${sortedPositions[0]}-${sortedPositions[1]}`;
                
                const currentShuttleCount = moveRepetitions.get(shuttleKey) || 0;
                
                if (currentShuttleCount >= 4) {
                    // This would be the FIFTH shuttle - instant loss!
                    score -= 50000; // Catastrophic penalty!
                    console.log(`‚ö†Ô∏è AI AVOIDING 5th SHUTTLE: ${pieceType} ${fromPos}‚Üî${toPos} (count: ${currentShuttleCount})`);
                } else if (currentShuttleCount >= 3) {
                    // This would be the FOURTH shuttle - very dangerous!
                    score -= 10000; // Huge penalty
                    console.log(`‚ö†Ô∏è AI AVOIDING 4th shuttle: ${pieceType} ${fromPos}‚Üî${toPos} (count: ${currentShuttleCount})`);
                } else if (currentShuttleCount >= 2) {
                    // This would be the THIRD shuttle - concerning
                    score -= 2000; // Large penalty
                    console.log(`‚ö†Ô∏è AI cautious about 3rd shuttle: ${pieceType} ${fromPos}‚Üî${toPos} (count: ${currentShuttleCount})`);
                }
            }
            
            // Small random factor for variety
            score += Math.random() * 3;
            
            return score;
        }
        
        // Check if a rhombus move is a diagonal move (dead zone ‚Üî inner perimeter)
        function isRhombusDiagonalMove(fromRow, fromCol, toRow, toCol) {
            const deadZone = new Set(["3-3", "3-4", "3-5"]);
            const innerPerimeter = new Set(["2-2", "2-3", "2-4", "2-5", "3-2", "3-6", "4-2", "4-3", "4-4", "4-5"]);
            
            const from = `${fromRow}-${fromCol}`;
            const to = `${toRow}-${toCol}`;
            
            // Diagonal move if: (from in dead zone AND to in inner perimeter) OR (from in inner perimeter AND to in dead zone)
            return (deadZone.has(from) && innerPerimeter.has(to)) ||
                   (innerPerimeter.has(from) && deadZone.has(to));
        }
        
        // Check if a piece at toRow,toCol would threaten targetRow,targetCol
        function wouldThreatenPosition(pieceRow, pieceCol, pieceType, targetRow, targetCol) {
            if (pieceType === 'square') {
                return canSquareAttack(pieceRow, pieceCol, targetRow, targetCol);
            } else if (pieceType === 'triangle') {
                // AI plays white triangles
                return canWhiteTriangleAttack(pieceRow, pieceCol, targetRow, targetCol, null);
            } else if (pieceType === 'rhombus') {
                return canRhombusAttack(pieceRow, pieceCol, targetRow, targetCol);
            } else if (pieceType === 'circle') {
                // Need to simulate circle attack - simplified check
                const targets = getCircleTargets(pieceRow, pieceCol);
                return targets.some(([r, c]) => r === targetRow && c === targetCol);
            } else if (pieceType === 'hexgon') {
                const moves = getHexgonMoves(pieceRow, pieceCol);
                return moves.includes(`${targetRow}-${targetCol}`);
            }
            return false;
        }
        
        // Check if moving a piece to toRow,toCol would block threats to our rhombus at rhombusRow,rhombusCol
        function wouldBlockThreat(fromRow, fromCol, toRow, toCol, rhombusRow, rhombusCol) {
            // Find all black pieces that threaten our rhombus
            const blackPieces = document.querySelectorAll('.square-piece:not(.white-piece), .triangle-piece:not(.white-triangle), .circle-piece:not(.white-circle), .hexgon-piece:not(.white-hexgon)');
            
            let blocksAnyThreat = false;
            
            blackPieces.forEach(piece => {
                const pieceHex = piece.closest('.hexagon');
                if (!pieceHex) return;
                
                const [, pRow, pCol] = pieceHex.id.match(/hex-(\d+)-(\d+)/);
                const pr = parseInt(pRow);
                const pc = parseInt(pCol);
                
                // Check if this black piece threatens our rhombus
                let threatens = false;
                if (piece.classList.contains('square-piece')) {
                    threatens = canSquareAttack(pr, pc, rhombusRow, rhombusCol);
                } else if (piece.classList.contains('triangle-piece')) {
                    threatens = canBlackTriangleAttack(pr, pc, rhombusRow, rhombusCol, piece);
                } else if (piece.classList.contains('circle-piece')) {
                    threatens = canCircleAttack(pr, pc, rhombusRow, rhombusCol, piece);
                } else if (piece.classList.contains('hexgon-piece')) {
                    const moves = getHexgonMoves(pr, pc);
                    threatens = moves.includes(`${rhombusRow}-${rhombusCol}`);
                }
                
                if (threatens) {
                    // Check if our new position blocks this threat
                    // Simple check: are we moving between the attacker and our rhombus?
                    if (isPositionBetween(toRow, toCol, pr, pc, rhombusRow, rhombusCol)) {
                        blocksAnyThreat = true;
                    }
                }
            });
            
            return blocksAnyThreat;
        }
        
        // Simple check if position is "between" two other positions (same row or adjacent)
        function isPositionBetween(row, col, attackerRow, attackerCol, targetRow, targetCol) {
            // Check if on same row and between
            if (row === attackerRow && row === targetRow) {
                const minCol = Math.min(attackerCol, targetCol);
                const maxCol = Math.max(attackerCol, targetCol);
                return col > minCol && col < maxCol;
            }
            // Check if on same column-ish path (simplified)
            if (col === attackerCol && col === targetCol) {
                const minRow = Math.min(attackerRow, targetRow);
                const maxRow = Math.max(attackerRow, targetRow);
                return row > minRow && row < maxRow;
            }
            return false;
        }
        
        // Helper: Count how many opponent pieces this move threatens
        function countThreatenedOpponentPieces(row, col, pieceType) {
            let count = 0;
            let targets = [];
            
            if (pieceType === 'square') targets = getSquareTargets(row, col);
            else if (pieceType === 'triangle') targets = getWhiteTriangleTargets(row, col);
            else if (pieceType === 'rhombus') targets = getRhombusTargets(row, col);
            else if (pieceType === 'circle') targets = getCircleTargets(row, col);
            else if (pieceType === 'hexgon') targets = getHexgonTargets(row, col);
            
            targets.forEach(([r, c]) => {
                const hex = document.getElementById(`hex-${r}-${c}`);
                if (hex) {
                    const piece = hex.querySelector('.square-piece, .triangle-piece, .circle-piece, .hexgon-piece');
                    if (piece && !piece.classList.contains('white-piece') && 
                        !piece.classList.contains('white-triangle') && 
                        !piece.classList.contains('white-circle') && 
                        !piece.classList.contains('white-hexgon')) {
                        count++;
                    }
                }
            });
            
            return count;
        }
        
        function executeAIMove(move) {
            console.log('ü§ñ executeAIMove called:', move);
            const fromHex = document.getElementById(`hex-${move.fromRow}-${move.fromCol}`);
            const toHex = document.getElementById(`hex-${move.toRow}-${move.toCol}`);
            
            if (!fromHex || !toHex) {
                console.log('‚ùå Invalid hex IDs:', `hex-${move.fromRow}-${move.fromCol}`, `hex-${move.toRow}-${move.toCol}`);
                return;
            }
            
            console.log('‚úÖ From hex:', fromHex.id, 'To hex:', toHex.id);
            
            const piece = move.piece;
            console.log('üéØ Moving piece classes:', piece.className);
            
            const existingPiece = toHex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
            
            if (existingPiece) {
                console.log('‚öîÔ∏è Capture detected! Existing piece at target:', existingPiece.className);
            }
            
            // Handle capture
            if (existingPiece) {
                addToEliminatedPieces(existingPiece);
                existingPiece.remove();
                new Audio('ASSETS/captured.mp3').play().catch(e => console.log('Audio play failed:', e));
            } else {
                new Audio('ASSETS/click.mp3').play().catch(e => console.log('Audio play failed:', e));
            }
            
            // Move piece
            console.log('üì¶ Removing piece from:', fromHex.id);
            piece.remove();
            const newPiece = piece.cloneNode(true);
            console.log('üì¶ Adding cloned piece to:', toHex.id);
            toHex.appendChild(newPiece);
            
            // Re-setup drag and drop
            setupDragAndDrop();
            
            // Record move
            const repetitionCount = checkRepetition(move.fromRow, move.fromCol, move.toRow, move.toCol, move.type, true, move.isCapture);
            recordMove(move.fromRow, move.fromCol, move.toRow, move.toCol, move.type, true, move.isCapture, repetitionCount);
            
            // Check position repetition (threefold repetition rule)
            checkPositionRepetition(true); // AI plays white
            
            // Check win conditions (pass the target position and new piece)
            checkWinConditions(move.toRow, move.toCol, newPiece);
            
            // Switch turn back to player
            aiThinking = false; // Unlock player input
            if (!gameOver) {
                switchTurn();
            }
        }
        
        // Function to switch turns
        function switchTurn() {
            currentPlayer = currentPlayer === 'black' ? 'white' : 'black';
            updateTurnDisplay();
            
            // Auto-flip board based on current player
            autoBoardFlip();
            
            // Refresh "show all moves" if it's enabled
            if (showAllMoves) {
                displayAllPossibleMoves();
            }
            
            // Update timers if enabled
            if (timerEnabled) {
                updateTimerDisplay();
            }
            
            // Update puzzle move counter if in puzzle mode
            if (puzzleMode) {
                updatePuzzleMoves();
            }
            
            // Clear all piece actions for the new turn
            pieceActions.clear();
            // Reset the active piece for the new turn
            currentTurnPiece = null;
            console.log('Cleared currentTurnPiece in switchTurn');
            // Hide rotation controls and clear selection when turn ends
            const rotationControlsEl = document.getElementById('rotation-controls');
            if (rotationControlsEl) {
                rotationControlsEl.style.display = 'none';
            }
            selectedPiece = null;
            console.log('Turn switched, cleared selectedPiece');
            
            // AI Move: If AI is enabled and it's White's turn
            console.log('üîÑ Turn switch - AI enabled:', aiEnabled, 'Current player:', currentPlayer, 'Game over:', gameOver);
            console.log('üîÑ selectedGameMode:', selectedGameMode, 'aiThinking:', aiThinking);
            
            if (aiEnabled && currentPlayer === 'white' && !gameOver && !aiThinking) {
                console.log('ü§ñ Triggering AI move in 800ms...');
                // Small delay for better UX (let player see board state)
                setTimeout(() => {
                    if (!gameOver) {
                        console.log('ü§ñ About to call makeAIMove()');
                        makeAIMove();
                    } else {
                        console.log('‚ö†Ô∏è Game ended before AI could move!');
                    }
                }, 800);
            } else {
                if (!aiEnabled) console.log('‚ùå AI not enabled');
                if (currentPlayer !== 'white') console.log('‚ÑπÔ∏è Not white\'s turn (current:', currentPlayer, ')');
                if (gameOver) console.log('‚ùå Game is over, cannot trigger AI');
                if (aiThinking) console.log('‚ö†Ô∏è AI is already thinking');
            }
            
            // Highlight threatened pieces after each turn
            highlightAllPiecesUnderAttack();
            
            // Show persistent circle attack highlights
            showCircleAttackHighlights();
            
            // Update Fog of War visibility for new player
            updateFogOfWar();
            
            // Check for rhombus deadlock (checkmate) after turn switch
            const isCheckmate = checkRhombusDeadlock();
            
            // TODO: Stalemate checking is disabled for now due to performance and complexity
            // It's an extremely rare scenario in Romgon
            // If no checkmate, check for stalemate (no legal moves but rhombus not under attack)
            // if (!isCheckmate && !gameOver) {
            //     const currentPlayerIsWhite = currentPlayer === 'white';
            //     const hasLegalMoves = doesPlayerHaveAnyLegalMoves(currentPlayerIsWhite);
            //     
            //     if (!hasLegalMoves) {
            //         console.log(`üîí STALEMATE! ${currentPlayer.toUpperCase()} has no legal moves!`);
            //         // In Romgon, if you have no legal moves, your OPPONENT WINS
            //         const winner = currentPlayer === 'white' ? 'Black' : 'White';
            //         showGameOver(winner, `üèÜ ${winner} Wins by Stalemate! ${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)} has no legal moves!`);
            //     }
            // }
            // Check if Escape Race mode just activated and show notification
            checkAndNotifyEscapeRace();
        }

        // Function to toggle board flip for white player perspective
        function toggleBoardFlip() {
            boardFlipped = !boardFlipped;
            const board = document.querySelector('.board');
            if (boardFlipped) {
                board.classList.add('flipped');
            } else {
                board.classList.remove('flipped');
            }
            
            // Play flip sound
            playFlipboardSound();
            
            // Update flip button text
            const flipButton = document.getElementById('flip-button');
            if (flipButton) {
                flipButton.innerHTML = boardFlipped ? 'üîÑ NORMAL' : 'üîÑ FLIP';
            }
            
            console.log('Board flip manually toggled:', boardFlipped);
        }
        
        // Function to auto-flip board based on current player
        function autoBoardFlip() {
            const board = document.querySelector('.board');
            
            // White's turn: Flip board so white is at bottom
            // Black's turn: Normal view so black is at bottom
            if (currentPlayer === 'white') {
                board.classList.add('flipped');
                boardFlipped = true;
                playFlipboardSound(); // Play flip sound
                console.log('üîÑ Auto-flipped board for White player');
            } else {
                board.classList.remove('flipped');
                boardFlipped = false;
                playFlipboardSound(); // Play flip sound
                console.log('üîÑ Board normal view for Black player');
            }
            
            // Update flip button text if it exists
            const flipButton = document.getElementById('flip-button');
            if (flipButton) {
                flipButton.innerHTML = boardFlipped ? 'üîÑ NORMAL' : 'üîÑ FLIP';
            }
        }
        
        // Function to toggle "show all moves" mode
        function toggleShowAllMoves() {
            showAllMoves = !showAllMoves;
            
            if (showAllMoves) {
                displayAllPossibleMoves();
                console.log('üëÅÔ∏è Show all moves: ENABLED');
            } else {
                clearAllMoveHighlights();
                console.log('üëÅÔ∏è Show all moves: DISABLED');
            }
            
            // Update button appearance
            const showAllButton = document.getElementById('show-all-moves-button');
            if (showAllButton) {
                showAllButton.innerHTML = showAllMoves ? 'üëÅÔ∏è HIDE ALL' : 'üëÅÔ∏è SHOW ALL';
                showAllButton.style.backgroundColor = showAllMoves ? '#00ff00' : '#666';
            }
        }

        // Keyboard System Toggle Functions
        function togglePVPKeyboard() {
            if (typeof window.keyboardNav === 'undefined' || window.keyboardNav === null) {
                console.log('‚ö†Ô∏è PVP Keyboard system not initialized');
                alert('PVP Keyboard system not available during this screen');
                return;
            }

            const isEnabled = window.keyboardNav.enabled;
            window.keyboardNav.enabled = !isEnabled;

            const button = document.getElementById('kb-pvp-toggle');
            if (button) {
                if (window.keyboardNav.enabled) {
                    button.style.backgroundColor = '#26de81';
                    button.innerHTML = '‚úì PVP KEYBOARD';
                    console.log('‚úÖ PVP Keyboard ENABLED');
                } else {
                    button.style.backgroundColor = '#888';
                    button.innerHTML = '‚óã PVP KEYBOARD';
                    console.log('‚ùå PVP Keyboard DISABLED');
                }
            }
        }

        function toggleGeneralNavigation() {
            if (typeof window.generalNav === 'undefined' || window.generalNav === null) {
                console.log('‚ö†Ô∏è General Navigation system not initialized');
                alert('General Navigation system not available during this screen');
                return;
            }

            const isEnabled = window.generalNav.enabled;
            window.generalNav.enabled = !isEnabled;

            const button = document.getElementById('kb-general-toggle');
            if (button) {
                if (window.generalNav.enabled) {
                    button.style.backgroundColor = '#26de81';
                    button.innerHTML = '‚úì GENERAL NAVIGATION';
                    console.log('‚úÖ General Navigation ENABLED');
                } else {
                    button.style.backgroundColor = '#888';
                    button.innerHTML = '‚óã GENERAL NAVIGATION';
                    console.log('‚ùå General Navigation DISABLED');
                }
            }
        }

        function updateKeyboardToggleButtons() {
            // Update PVP keyboard button
            const pvpButton = document.getElementById('kb-pvp-toggle');
            if (pvpButton && typeof window.keyboardNav !== 'undefined' && window.keyboardNav !== null) {
                if (window.keyboardNav.enabled) {
                    pvpButton.style.backgroundColor = '#26de81';
                    pvpButton.innerHTML = '‚úì PVP KEYBOARD';
                } else {
                    pvpButton.style.backgroundColor = '#888';
                    pvpButton.innerHTML = '‚óã PVP KEYBOARD';
                }
            }

            // Update General navigation button
            const genButton = document.getElementById('kb-general-toggle');
            if (genButton && typeof window.generalNav !== 'undefined' && window.generalNav !== null) {
                if (window.generalNav.enabled) {
                    genButton.style.backgroundColor = '#26de81';
                    genButton.innerHTML = '‚úì GENERAL NAVIGATION';
                } else {
                    genButton.style.backgroundColor = '#888';
                    genButton.innerHTML = '‚óã GENERAL NAVIGATION';
                }
            }
        }
        
        // Keyboard System Toggle Functions
        function togglePVPKeyboard() {
            if (typeof window.keyboardNav === 'undefined' || window.keyboardNav === null) {
                console.log('‚ö†Ô∏è PVP Keyboard system not initialized');
                alert('PVP Keyboard system not available during this screen');
                return;
            }

            const isEnabled = window.keyboardNav.enabled;
            window.keyboardNav.enabled = !isEnabled;

            const button = document.getElementById('kb-pvp-toggle');
            if (button) {
                if (window.keyboardNav.enabled) {
                    button.style.backgroundColor = '#26de81';
                    button.innerHTML = '‚úì PVP KEYBOARD';
                    console.log('‚úÖ PVP Keyboard ENABLED');
                } else {
                    button.style.backgroundColor = '#888';
                    button.innerHTML = '‚óã PVP KEYBOARD';
                    console.log('‚ùå PVP Keyboard DISABLED');
                }
            }
        }

        function toggleGeneralNavigation() {
            if (typeof window.generalNav === 'undefined' || window.generalNav === null) {
                console.log('‚ö†Ô∏è General Navigation system not initialized');
                alert('General Navigation system not available during this screen');
                return;
            }

            const isEnabled = window.generalNav.enabled;
            window.generalNav.enabled = !isEnabled;

            const button = document.getElementById('kb-general-toggle');
            if (button) {
                if (window.generalNav.enabled) {
                    button.style.backgroundColor = '#26de81';
                    button.innerHTML = '‚úì GENERAL NAVIGATION';
                    console.log('‚úÖ General Navigation ENABLED');
                } else {
                    button.style.backgroundColor = '#888';
                    button.innerHTML = '‚óã GENERAL NAVIGATION';
                    console.log('‚ùå General Navigation DISABLED');
                }
            }
        }
        
        // Function to display all possible moves for all pieces
        function displayAllPossibleMoves() {
            // Clear any existing highlights first
            clearAllMoveHighlights();
            
            // Get all pieces for current player
            const pieces = currentPlayer === 'black' 
                ? document.querySelectorAll('.square-piece:not(.white-piece), .triangle-piece:not(.white-triangle), .rhombus-piece:not(.white-rhombus), .circle-piece:not(.white-circle), .hexgon-piece:not(.white-hexgon)')
                : document.querySelectorAll('.white-piece, .white-triangle, .white-rhombus, .white-circle, .white-hexgon');
            
            console.log(`üëÅÔ∏è Displaying all moves for ${pieces.length} ${currentPlayer} pieces`);
            
            
            pieces.forEach(piece => {
                const pieceHex = piece.closest('.hexagon');
                if (!pieceHex) return;
                
                const [, row, col] = pieceHex.id.match(/hex-(\d+)-(\d+)/);
                
                // Get piece type
                let pieceType = 'square';
                if (piece.classList.contains('triangle-piece')) pieceType = 'triangle';
                else if (piece.classList.contains('rhombus-piece')) pieceType = 'rhombus';
                else if (piece.classList.contains('circle-piece')) pieceType = 'circle';
                else if (piece.classList.contains('hexgon-piece')) pieceType = 'hexgon';
                
                // Highlight all possible moves for this piece
                highlightPieceMoves(parseInt(row), parseInt(col), pieceType, pieceHex.id);
                
                // Add rotation indicator for rotatable pieces
                if (pieceType === 'triangle' || pieceType === 'hexgon') {
                    addRotationIndicator(pieceHex, pieceType);
                }
            });
            
            console.log(`üìç Displayed all moves for ${currentPlayer} pieces`);
        }
        
        // Function to highlight moves for a specific piece (without clearing existing highlights)
        function highlightPieceMoves(row, col, pieceType, hexId) {
            let targets = [];
            
            // Get movement pattern based on piece type
            if (pieceType === 'square') {
                targets = getSquareTargets(row, col);
            } else if (pieceType === 'triangle') {
                const orientation = getTriangleOrientation(hexId);
                const hex = document.getElementById(hexId);
                const piece = hex.querySelector('.triangle-piece');
                const isWhite = piece && (piece.classList.contains('white-triangle') || piece.classList.contains('white-piece'));
                // getRotatedTriangleTargets returns offsets, need to convert to absolute coords
                const offsets = getRotatedTriangleTargets(row, col, orientation, isWhite);
                targets = offsets.map(([dr, dc]) => [row + dr, col + dc]);
            } else if (pieceType === 'rhombus') {
                targets = getRhombusTargets(row, col);
            } else if (pieceType === 'circle') {
                targets = getCircleTargets(row, col);
            } else if (pieceType === 'hexgon') {
                const orientation = getHexgonOrientation(hexId);
                const hex = document.getElementById(hexId);
                const piece = hex.querySelector('.hexgon-piece');
                const isWhite = piece && (piece.classList.contains('white-hexgon') || piece.classList.contains('white-piece'));
                targets = getRotatedHexgonTargets(row, col, orientation, isWhite);
            }
            
            // Determine if piece is white or black
            const hex = document.getElementById(hexId);
            const piece = hex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
            const isWhite = piece && (
                piece.classList.contains('white-piece') ||
                piece.classList.contains('white-triangle') ||
                piece.classList.contains('white-rhombus') ||
                piece.classList.contains('white-circle') ||
                piece.classList.contains('white-hexgon')
            );
            
            // Highlight each target
            targets.forEach(([targetRow, targetCol]) => {
                const targetHex = document.getElementById(`hex-${targetRow}-${targetCol}`);
                if (!targetHex) return;
                
                // Check if target has a piece
                const targetPiece = targetHex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                
                if (!targetPiece) {
                    // Empty hex - valid move (green)
                    targetHex.classList.add('highlight-green');
                } else {
                    // Has a piece - check if it's opponent or friendly
                    const targetIsWhite = targetPiece.classList.contains('white-piece') ||
                                        targetPiece.classList.contains('white-triangle') ||
                                        targetPiece.classList.contains('white-rhombus') ||
                                        targetPiece.classList.contains('white-circle') ||
                                        targetPiece.classList.contains('white-hexgon');
                    
                    if (targetIsWhite !== isWhite) {
                        // Opponent piece - valid attack (red)
                        targetHex.classList.add('highlight-red');
                    }
                    // Skip friendly pieces (no gray highlight)
                }
            });
        }
        
        // Function to add rotation indicator on a piece
        function addRotationIndicator(hexElement, pieceType) {
            // Check if piece has already acted this turn
            const actions = pieceActions.get(hexElement.id) || {moved: false, attacked: false, rotated: false};
            if (actions.moved || actions.attacked || actions.rotated) {
                return; // Don't show rotation for pieces that already acted
            }
            
            // Create rotation indicator overlay
            const rotationOverlay = document.createElement('div');
            rotationOverlay.className = 'rotation-overlay';
            rotationOverlay.innerHTML = '‚ü≤'; // Rotation symbol
            rotationOverlay.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 18px;
                height: 18px;
                background: rgba(155, 89, 182, 0.85);
                color: white;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 12px;
                font-weight: bold;
                pointer-events: none;
                z-index: 10;
                box-shadow: 0 0 5px rgba(155, 89, 182, 1);
                border: 1.5px solid rgba(255, 255, 255, 0.9);
            `;
            
            hexElement.appendChild(rotationOverlay);
        }
        
        // Function to clear all move highlights
        function clearAllMoveHighlights() {
            // Remove all highlight classes
            document.querySelectorAll('.hexagon').forEach(hex => {
                hex.classList.remove('highlight-green', 'highlight-red', 'highlight-danger', 'highlight-diagonal', 'highlight-gray');
            });
            
            // Remove rotation indicators
            document.querySelectorAll('.rotation-overlay').forEach(overlay => {
                overlay.remove();
            });
        }


        // Function to update turn display
        function updateTurnDisplay() {
            // Don't show turn indicator on splash page
            const splashPage = document.getElementById('splash-page');
            const boardContainer = document.getElementById('board-display-container');
            
            // Only show turn indicator if we're on the game board
            if (!boardContainer || boardContainer.style.display === 'none') {
                // Remove existing turn indicator if board is not visible
                const existingIndicator = document.getElementById('turn-indicator');
                if (existingIndicator) {
                    existingIndicator.remove();
                }
                return;
            }
            
            // Remove existing turn indicator
            const existingIndicator = document.getElementById('turn-indicator');
            if (existingIndicator) {
                existingIndicator.remove();
            }

            // Create new turn indicator container
            const turnIndicator = document.createElement('div');
            turnIndicator.id = 'turn-indicator';
            turnIndicator.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                display: flex;
                align-items: center;
                gap: 15px;
                z-index: 3001;
            `;

            // Create left button (Main Menu)
            const menuButton = document.createElement('button');
            menuButton.innerHTML = '<span class="game-menu-button-emoji">üè†</span><span class="game-menu-button-label">Main<br>Menu</span>';
            menuButton.className = 'game-menu-button';
            menuButton.title = '';
            menuButton.onclick = function() {
                gameInProgress = true;
                showStartMenu();
            };
            menuButton.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            menuButton.onmouseout = function() { this.style.transform = 'scale(1)'; };

            // Create AI model selector button (only for LLM mode)
            let aiModelButton = null;
            if (llmMode) {
                aiModelButton = document.createElement('button');
                aiModelButton.id = 'ai-model-selector-btn';
                aiModelButton.innerHTML = '<span class="game-menu-button-emoji">üß†</span><span class="game-menu-button-label">AI<br>Model</span>';
                aiModelButton.className = 'game-menu-button';
                aiModelButton.title = '';
                aiModelButton.onclick = showAIModelSelector;
                aiModelButton.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
                aiModelButton.onmouseout = function() { this.style.transform = 'scale(1)'; };
            }

            // Create Game Library button
            const libraryButton = document.createElement('button');
            libraryButton.innerHTML = '<span class="game-menu-button-emoji">üìö</span><span class="game-menu-button-label">Game<br>Library</span>';
            libraryButton.className = 'game-menu-button';
            libraryButton.title = 'Browse custom games';
            libraryButton.onclick = function() {
                window.location.href = 'game-library.html';
            };
            libraryButton.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            libraryButton.onmouseout = function() { this.style.transform = 'scale(1)'; };

            // Create Game Creator button
            const creatorButton = document.createElement('button');
            creatorButton.innerHTML = '<span class="game-menu-button-emoji">üé®</span><span class="game-menu-button-label">Create<br>Game</span>';
            creatorButton.className = 'game-menu-button';
            creatorButton.title = 'Design your own game';
            creatorButton.onclick = function() {
                window.location.href = 'game-creator.html';
            };
            creatorButton.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            creatorButton.onmouseout = function() { this.style.transform = 'scale(1)'; };

            // Create coordinate toggle button
            const coordButton = document.createElement('button');
            coordButton.innerHTML = '<span class="game-menu-button-emoji">üìç</span><span class="game-menu-button-label">Show<br>Coords</span>';
            coordButton.className = 'game-menu-button';
            coordButton.title = '';
            coordButton.onclick = toggleCoordinates;
            coordButton.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            coordButton.onmouseout = function() { this.style.transform = 'scale(1)'; };

            // Create defense toggle button
            const defenseButton = document.createElement('button');
            defenseButton.innerHTML = '<span class="game-menu-button-emoji">üõ°Ô∏è</span><span class="game-menu-button-label">Show<br>Defense</span>';
            defenseButton.className = 'game-menu-button';
            defenseButton.title = '';
            let defenseHighlightEnabled = false;
            defenseButton.onclick = function() {
                defenseHighlightEnabled = !defenseHighlightEnabled;
                
                if (defenseHighlightEnabled) {
                    showDefenseHighlights();
                } else {
                    clearDefenseHighlights();
                }
            };
            defenseButton.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            defenseButton.onmouseout = function() { this.style.transform = 'scale(1)'; };

            // Create Fog of War toggle button
            const fogButton = document.createElement('button');
            fogButton.innerHTML = fogOfWarEnabled ? '<span class="game-menu-button-emoji">üëÅÔ∏è</span><span class="game-menu-button-label">Fog<br>War</span>' : '<span class="game-menu-button-emoji">üëÅÔ∏è</span><span class="game-menu-button-label">Fog<br>War</span>';
            fogButton.className = 'game-menu-button';
            fogButton.title = '';
            fogButton.onclick = function() {
                fogOfWarEnabled = !fogOfWarEnabled;
                this.innerHTML = '<span class="game-menu-button-emoji">üëÅÔ∏è</span><span class="game-menu-button-label">Fog<br>War</span>';
                updateFogOfWar();
                console.log('üå´Ô∏è Fog of War:', fogOfWarEnabled ? 'ENABLED' : 'DISABLED');
            };
            fogButton.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            fogButton.onmouseout = function() { this.style.transform = 'scale(1)'; };

            function showDefenseHighlights() {
                // Get all pieces on the board
                const allPieces = document.querySelectorAll('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                
                allPieces.forEach(piece => {
                    const pieceHex = piece.closest('.hexagon');
                    if (!pieceHex) return;
                    
                    const pieceId = pieceHex.id;
                    const [, row, col] = pieceId.match(/hex-(\d+)-(\d+)/);
                    const isWhite = piece.classList.contains('white-piece') || 
                                   piece.classList.contains('white-triangle') || 
                                   piece.classList.contains('white-rhombus') ||
                                   piece.classList.contains('white-circle') ||
                                   piece.classList.contains('white-hexgon');
                    
                    // Check if this piece is defended by a friendly piece
                    if (isPieceDefendedByFriendly(parseInt(row), parseInt(col), isWhite)) {
                        pieceHex.classList.add('highlight-defended');
                    }
                });
            }
            
            function clearDefenseHighlights() {
                document.querySelectorAll('.hexagon').forEach(hex => {
                    hex.classList.remove('highlight-defended');
                });
            }
            
            function isPieceDefendedByFriendly(pieceRow, pieceCol, isWhite) {
                // Get all friendly pieces
                const friendlyPieceTypes = isWhite ? 
                    ['.square-piece.white-piece', '.triangle-piece.white-triangle', '.rhombus-piece.white-rhombus', '.circle-piece.white-circle', '.hexgon-piece.white-hexgon'] :
                    ['.square-piece:not(.white-piece)', '.triangle-piece:not(.white-triangle)', '.rhombus-piece:not(.white-rhombus)', '.circle-piece:not(.white-circle)', '.hexgon-piece:not(.white-hexgon)'];
                
                // Check each friendly piece to see if it can reach this position
                for (let pieceType of friendlyPieceTypes) {
                    const friendlyPieces = document.querySelectorAll(pieceType);
                    for (let piece of friendlyPieces) {
                        const pieceHex = piece.closest('.hexagon');
                        if (!pieceHex) continue;
                        
                        const pieceId = pieceHex.id;
                        const [, friendlyRow, friendlyCol] = pieceId.match(/hex-(\d+)-(\d+)/);
                        
                        // Skip if checking the same piece
                        if (parseInt(friendlyRow) === pieceRow && parseInt(friendlyCol) === pieceCol) {
                            continue;
                        }
                        
                        // Check if this friendly piece can attack/reach the target position
                        if (canPieceActuallyAttack(parseInt(friendlyRow), parseInt(friendlyCol), pieceRow, pieceCol, piece)) {
                            return true;
                        }
                    }
                }
                return false;
            }

            // Create rotation controls container
            const rotationControls = document.createElement('div');
            rotationControls.id = 'rotation-controls';
            rotationControls.style.cssText = `
                display: none;
                position: fixed;
                bottom: 15px;
                left: 50%;
                transform: translateX(-50%);
                z-index: 3002;
                background: rgba(0, 0, 0, 0.95);
                padding: 8px 10px;
                border-radius: 8px;
                border: 2px solid rgba(78, 205, 196, 0.5);
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
            `;

            // Create rotate left button
            const rotateLeftButton = document.createElement('button');
            rotateLeftButton.innerHTML = '‚Üª RIGHT';
            rotateLeftButton.style.cssText = `
                background-color: rgba(155, 89, 182, 0.3);
                border: 2px solid #9b59b6;
                color: white;
                padding: 8px 12px;
                margin: 0 4px;
                border-radius: 6px;
                cursor: pointer;
                font-weight: bold;
                font-size: 0.85em;
                transition: all 0.2s ease;
                box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            `;
            rotateLeftButton.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            rotateLeftButton.onmouseout = function() { this.style.transform = 'scale(1)'; };
            rotateLeftButton.onclick = function() {
                console.log('Left rotation button clicked!');
                console.log('Selected piece:', selectedPiece);
                if (selectedPiece) {
                    const [, row, col] = selectedPiece.id.match(/hex-(\d+)-(\d+)/);
                    console.log('Rotating piece at:', row, col);
                    const piece = selectedPiece.querySelector('.triangle-piece, .hexgon-piece');
                    if (piece && piece.classList.contains('triangle-piece')) {
                        rotateTriangleLeft(`hex-${row}-${col}`);
                    } else if (piece && piece.classList.contains('hexgon-piece')) {
                        rotateHexgonLeft(`hex-${row}-${col}`);
                    }
                    // Just rotate visually, don't update movement pattern
                } else {
                    console.log('No selected piece!');
                }
            };

            // Create rotate right button
            const rotateRightButton = document.createElement('button');
            rotateRightButton.innerHTML = '‚Ü∫ LEFT';
            rotateRightButton.style.cssText = `
                background-color: rgba(155, 89, 182, 0.3);
                border: 2px solid #9b59b6;
                color: white;
                padding: 8px 12px;
                margin: 0 4px;
                border-radius: 6px;
                cursor: pointer;
                font-weight: bold;
                font-size: 0.85em;
                transition: all 0.2s ease;
                box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            `;
            rotateRightButton.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            rotateRightButton.onmouseout = function() { this.style.transform = 'scale(1)'; };
            rotateRightButton.onclick = function() {
                console.log('Right rotation button clicked!');
                console.log('Selected piece:', selectedPiece);
                if (selectedPiece) {
                    const [, row, col] = selectedPiece.id.match(/hex-(\d+)-(\d+)/);
                    console.log('Rotating piece at:', row, col);
                    const piece = selectedPiece.querySelector('.triangle-piece, .hexgon-piece');
                    if (piece && piece.classList.contains('triangle-piece')) {
                        rotateTriangleRight(`hex-${row}-${col}`);
                    } else if (piece && piece.classList.contains('hexgon-piece')) {
                        rotateHexgonRight(`hex-${row}-${col}`);
                    }
                    // Just rotate visually, don't update movement pattern
                } else {
                    console.log('No selected piece!');
                }
            };

            // Create keep button
            const keepButton = document.createElement('button');
            keepButton.innerHTML = 'KEEP';
            keepButton.style.cssText = `
                background-color: rgba(39, 174, 96, 0.3);
                border: 2px solid #27ae60;
                color: white;
                padding: 8px 12px;
                margin: 0 4px;
                border-radius: 6px;
                cursor: pointer;
                font-weight: bold;
                font-size: 0.85em;
                transition: all 0.2s ease;
                box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            `;
            keepButton.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            keepButton.onmouseout = function() { this.style.transform = 'scale(1)'; };
            keepButton.onclick = function() {
                console.log('Keep button clicked!');
                console.log('Selected piece:', selectedPiece);
                if (selectedPiece) {
                    const hexId = selectedPiece.id;
                    const [, row, col] = hexId.match(/hex-(\d+)-(\d+)/);
                    const piece = selectedPiece.querySelector('.triangle-piece, .hexgon-piece');
                    const pieceType = piece && piece.classList.contains('triangle-piece') ? 'triangle' : 'hexgon';
                    console.log(`Keeping ${pieceType} at:`, row, col, 'with current orientation');
                    
                    // Check if any action was performed this turn
                    const actions = pieceActions.get(hexId) || {moved: false, attacked: false, rotated: false};
                    const hasPerformedAction = actions.moved || actions.attacked || actions.rotated;
                    
                    // If no action was performed, confirm with user
                    if (!hasPerformedAction) {
                        const confirmed = confirm('‚ö†Ô∏è WARNING: You haven\'t made any move, rotation, or attack!\n\nAre you sure you want to end your turn without doing anything?');
                        if (!confirmed) {
                            console.log('Keep action cancelled by user');
                            return; // Don't end turn
                        }
                    }
                    
                    // Mark as rotated (even though no rotation happened) to end turn
                    actions.rotated = true;
                    pieceActions.set(hexId, actions);
                    
                    // End turn
                    if (!gameOver) {
                        console.log('Ending turn after keep');
                        switchTurn();
                        // Update base defence display
                        updateBaseDefenceDisplay();
                        // Update attack highlights for all pieces
                        highlightAllPiecesUnderAttack();
                    }
                } else {
                    console.log('No selected piece!');
                }
            };

            // Create release button
            const releaseButton = document.createElement('button');
            releaseButton.innerHTML = 'RELEASE';
            releaseButton.style.cssText = `
                background-color: rgba(231, 76, 60, 0.3);
                border: 2px solid #e74c3c;
                color: white;
                padding: 8px 12px;
                margin: 0 4px;
                border-radius: 6px;
                cursor: pointer;
                font-weight: bold;
                font-size: 0.85em;
                transition: all 0.2s ease;
                box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            `;
            releaseButton.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            releaseButton.onmouseout = function() { this.style.transform = 'scale(1)'; };
            releaseButton.onclick = function() {
                console.log('Release button clicked!');
                console.log('Before release - currentTurnPiece:', currentTurnPiece ? currentTurnPiece.id : 'null');
                console.log('Before release - selectedPiece:', selectedPiece ? selectedPiece.id : 'null');
                if (selectedPiece) {
                    // Clear highlights
                    document.querySelectorAll('.hexagon').forEach(hex => {
                        hex.classList.remove('highlight-green', 'highlight-red', 'highlight-danger', 'highlight-diagonal', 'highlight-gray', 'highlight-selected', 'highlight-under-attack', 'highlight-rhombus-check');
                    });
                    
                    // Clear selection
                    selectedPiece = null;
                    
                    // Clear current turn piece restriction
                    currentTurnPiece = null;
                    
                    // Clear dragged pieces
                    draggedPiece = null;
                    draggedFromHex = null;
                    
                    // Hide rotation controls
                    rotationControls.style.display = 'none';
                    
                    console.log('After release - currentTurnPiece:', currentTurnPiece);
                    console.log('After release - selectedPiece:', selectedPiece);
                    console.log('Piece released - you can now select another piece');
                } else {
                    console.log('No selected piece to release!');
                }
            };

            rotationControls.appendChild(rotateLeftButton);
            rotationControls.appendChild(keepButton);
            rotationControls.appendChild(rotateRightButton);
            rotationControls.appendChild(releaseButton);

            // Create center turn display
            const turnDisplay = document.createElement('div');
            turnDisplay.style.cssText = `
                background-color: ${currentPlayer === 'black' ? '#333' : '#fff'};
                color: ${currentPlayer === 'black' ? '#fff' : '#333'};
                padding: 10px 20px;
                border-radius: 20px;
                font-weight: bold;
                font-size: 16px;
                border: 2px solid ${currentPlayer === 'black' ? '#fff' : '#333'};
                box-shadow: 0 2px 10px rgba(0,0,0,0.5);
            `;
            turnDisplay.textContent = `${currentPlayer.toUpperCase()} TURN`;

            // Add guest indicator if user is logged in as guest
            if (isGuestUser()) {
                const guestIndicator = document.createElement('div');
                guestIndicator.style.cssText = `
                    display: inline-block;
                    background-color: #4ecdc4;
                    color: #262421;
                    padding: 2px 8px;
                    border-radius: 10px;
                    font-size: 10px;
                    font-weight: bold;
                    margin-left: 10px;
                    border: 1px solid #fff;
                    text-transform: uppercase;
                `;
                guestIndicator.textContent = 'GUEST';
                turnDisplay.appendChild(guestIndicator);
            }

            // Create right button (Help)
            const helpButton = document.createElement('button');
            helpButton.innerHTML = '<span class="game-menu-button-emoji">‚ùì</span><span class="game-menu-button-label">Game<br>Help</span>';
            helpButton.className = 'game-menu-button';
            helpButton.title = '';
            helpButton.onclick = showHelp;
            helpButton.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            helpButton.onmouseout = function() { this.style.transform = 'scale(1)'; };

            // Create music toggle button
            const musicButton = document.createElement('button');
            const updateMusicButtonDisplayLocal = () => {
                const isMusicOn = gameSettings.music && currentMusicTrack > 0;
                musicButton.innerHTML = isMusicOn ? '<span class="game-menu-button-emoji">üîä</span><span class="game-menu-button-label">Music<br>On</span>' : '<span class="game-menu-button-emoji">üîá</span><span class="game-menu-button-label">Music<br>Off</span>';
            };
            updateMusicButtonDisplayLocal();
            musicButton.className = 'game-menu-button';
            musicButton.title = '';
            musicButton.onclick = function() {
                if (gameSettings.music && currentMusicTrack > 0) {
                    stopBackgroundMusic();
                    gameSettings.music = false;
                } else {
                    gameSettings.music = true;
                    if (gameSettings.currentMusicTrack > 0) {
                        playBackgroundMusic(gameSettings.currentMusicTrack);
                    } else {
                        playBackgroundMusic(1);
                    }
                }
                updateMusicButtonDisplayLocal();
                saveSettings();
            };
            musicButton.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            musicButton.onmouseout = function() { this.style.transform = 'scale(1)'; };

            // Create undo button
            const undoButton = document.createElement('button');
            undoButton.innerHTML = '<span class="game-menu-button-emoji">‚Ü©Ô∏è</span><span class="game-menu-button-label">Undo<br>Move</span>';
            undoButton.className = 'game-menu-button';
            undoButton.title = '';
            undoButton.onclick = undoLastMove;
            undoButton.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            undoButton.onmouseout = function() { this.style.transform = 'scale(1)'; };

            // Create resign button
            const resignButton = document.createElement('button');
            resignButton.innerHTML = '<span class="game-menu-button-emoji">üè≥Ô∏è</span><span class="game-menu-button-label">Resign<br>Game</span>';
            resignButton.className = 'game-menu-button';
            resignButton.title = '';
            resignButton.onclick = resignGame;
            resignButton.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            resignButton.onmouseout = function() { this.style.transform = 'scale(1)'; };

            // Create keyboard help toggle button
            const kbHelpButton = document.createElement('button');
            kbHelpButton.innerHTML = '<span class="game-menu-button-emoji">‚å®Ô∏è</span><span class="game-menu-button-label">Keys<br>Help</span>';
            kbHelpButton.className = 'game-menu-button';
            kbHelpButton.title = '';
            kbHelpButton.onclick = function() {
                const panel = document.getElementById('kb-info-panel');
                if (panel && panel.style.display === 'none') {
                    panel.style.display = 'block';
                    updateKeyboardToggleButtons();
                } else if (panel) {
                    panel.style.display = 'none';
                }
            };
            kbHelpButton.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            kbHelpButton.onmouseout = function() { this.style.transform = 'scale(1)'; };

            // Create toggle last move highlight button
            const toggleLastMoveButton = document.createElement('button');
            const isLastMoveVisible = typeof gameSettings !== 'undefined' ? gameSettings.showLastMove : true;
            toggleLastMoveButton.innerHTML = '<span class="game-menu-button-emoji">üëÅÔ∏è</span><span class="game-menu-button-label">Last<br>Move</span>';
            toggleLastMoveButton.title = '';
            toggleLastMoveButton.className = 'game-menu-button';
            toggleLastMoveButton.onclick = function() {
                if (typeof gameSettings !== 'undefined') {
                    gameSettings.showLastMove = !gameSettings.showLastMove;
                    
                    if (gameSettings.showLastMove) {
                        highlightLastMove(lastMoveFrom, lastMoveTo);
                    } else {
                        clearLastMoveHighlight();
                    }
                }
            };
            toggleLastMoveButton.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            toggleLastMoveButton.onmouseout = function() { this.style.transform = 'scale(1)'; };

            // Create show all moves button
            const showAllMovesButton = document.createElement('button');
            showAllMovesButton.className = 'game-menu-button';
            showAllMovesButton.id = 'show-all-moves-button';
            showAllMovesButton.innerHTML = '<span class="game-menu-button-emoji">üëÅÔ∏è</span><span class="game-menu-button-label">All<br>Moves</span>';
            showAllMovesButton.title = '';
            showAllMovesButton.onclick = toggleShowAllMoves;
            showAllMovesButton.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            showAllMovesButton.onmouseout = function() { this.style.transform = 'scale(1)'; };

            // Create board flip button
            const flipButton = document.createElement('button');
            flipButton.id = 'flip-button';
            flipButton.innerHTML = '<span class="game-menu-button-emoji">üîÑ</span><span class="game-menu-button-label">Flip<br>Board</span>';
            flipButton.title = '';
            flipButton.className = 'game-menu-button';
            flipButton.onclick = function() {
                toggleBoardFlip();
            };
            flipButton.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            flipButton.onmouseout = function() { this.style.transform = 'scale(1)'; };

            // Create copy position button (RPN)
            const copyPositionBtn = document.createElement('button');
            copyPositionBtn.innerHTML = '<span class="game-menu-button-emoji">üìã</span><span class="game-menu-button-label">Copy<br>Pos</span>';
            copyPositionBtn.title = '';
            copyPositionBtn.className = 'game-menu-button';
            copyPositionBtn.onclick = copyPositionToClipboard;
            copyPositionBtn.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            copyPositionBtn.onmouseout = function() { this.style.transform = 'scale(1)'; };

            // Create load position button (RPN)
            const loadPositionBtn = document.createElement('button');
            loadPositionBtn.innerHTML = '<span class="game-menu-button-emoji">üì•</span><span class="game-menu-button-label">Load<br>Pos</span>';
            loadPositionBtn.title = '';
            loadPositionBtn.className = 'game-menu-button';
            loadPositionBtn.onclick = openLoadPositionModal;
            loadPositionBtn.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            loadPositionBtn.onmouseout = function() { this.style.transform = 'scale(1)'; };

            // Create export game button (RPN)
            const exportGameBtn = document.createElement('button');
            exportGameBtn.innerHTML = '<span class="game-menu-button-emoji">üíæ</span><span class="game-menu-button-label">Save<br>Game</span>';
            exportGameBtn.title = '';
            exportGameBtn.className = 'game-menu-button';
            exportGameBtn.onclick = downloadGameRMN;
            exportGameBtn.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            exportGameBtn.onmouseout = function() { this.style.transform = 'scale(1)'; };

            // Create log RPN button (dev tool)
            const logRPNBtn = document.createElement('button');
            logRPNBtn.innerHTML = '<span class="game-menu-button-emoji">üîç</span><span class="game-menu-button-label">Log<br>RPN</span>';
            logRPNBtn.title = '';
            logRPNBtn.className = 'game-menu-button';
            logRPNBtn.onclick = logPositionRPN;
            logRPNBtn.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            logRPNBtn.onmouseout = function() { this.style.transform = 'scale(1)'; };

            // Create dark mode button
            const darkModeBtn = document.createElement('button');
            darkModeBtn.innerHTML = '<span class="game-menu-button-emoji">üåô</span><span class="game-menu-button-label">Dark<br>Mode</span>';
            darkModeBtn.title = '';
            darkModeBtn.className = 'game-menu-button';
            darkModeBtn.onclick = toggleDarkMode;
            darkModeBtn.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            darkModeBtn.onmouseout = function() { this.style.transform = 'scale(1)'; };

            // Create wooden theme button
            const woodenThemeBtn = document.createElement('button');
            woodenThemeBtn.innerHTML = '<span class="game-menu-button-emoji">ü™µ</span><span class="game-menu-button-label">Wooden<br>Board</span>';
            woodenThemeBtn.title = '';
            woodenThemeBtn.className = 'game-menu-button';
            woodenThemeBtn.onclick = toggleWoodenTheme;
            woodenThemeBtn.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            woodenThemeBtn.onmouseout = function() { this.style.transform = 'scale(1)'; };

            // Create toggle panel button
            const togglePanelBtn = document.createElement('button');
            togglePanelBtn.id = 'toggle-panel-btn';
            togglePanelBtn.innerHTML = '‚â°';
            togglePanelBtn.title = 'Toggle side menu panel';
            togglePanelBtn.className = 'game-menu-button';
            togglePanelBtn.style.cssText = `
                padding: 6px 12px !important;
                font-size: 16px !important;
                min-width: 45px !important;
            `;
            
            // Create side panel for all other buttons
            let gameButtonsPanel = document.getElementById('game-buttons-panel');
            if (gameButtonsPanel) {
                gameButtonsPanel.remove();
            }
            
            gameButtonsPanel = document.createElement('div');
            gameButtonsPanel.id = 'game-buttons-panel';
            gameButtonsPanel.classList.add('hidden'); // Start hidden
            
            // Add all buttons to the side panel
            gameButtonsPanel.appendChild(menuButton);
            if (aiModelButton) {
                gameButtonsPanel.appendChild(aiModelButton);
            }
            
            // Game Maker Platform navigation buttons
            gameButtonsPanel.appendChild(libraryButton);
            gameButtonsPanel.appendChild(creatorButton);
            
            gameButtonsPanel.appendChild(coordButton);
            gameButtonsPanel.appendChild(defenseButton);
            gameButtonsPanel.appendChild(fogButton);
            gameButtonsPanel.appendChild(musicButton);
            gameButtonsPanel.appendChild(undoButton);
            gameButtonsPanel.appendChild(resignButton);
            gameButtonsPanel.appendChild(kbHelpButton);
            gameButtonsPanel.appendChild(toggleLastMoveButton);
            gameButtonsPanel.appendChild(showAllMovesButton);
            gameButtonsPanel.appendChild(flipButton);
            gameButtonsPanel.appendChild(helpButton);
            
            // Add RPN buttons to panel
            gameButtonsPanel.appendChild(copyPositionBtn);
            gameButtonsPanel.appendChild(loadPositionBtn);
            gameButtonsPanel.appendChild(exportGameBtn);
            gameButtonsPanel.appendChild(logRPNBtn);
            gameButtonsPanel.appendChild(darkModeBtn);
            gameButtonsPanel.appendChild(woodenThemeBtn);
            
            // Toggle panel functionality
            togglePanelBtn.onclick = function(e) {
                e.preventDefault();
                e.stopPropagation();
                gameButtonsPanel.classList.toggle('hidden');
                // Change button appearance to show state
                if (gameButtonsPanel.classList.contains('hidden')) {
                    togglePanelBtn.style.backgroundColor = '#2c3e50';
                } else {
                    togglePanelBtn.style.backgroundColor = '#34495e';
                }
                console.log('Panel visible:', !gameButtonsPanel.classList.contains('hidden'));
                console.log('Panel computed style:', window.getComputedStyle(gameButtonsPanel).transform);
            };
            togglePanelBtn.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            togglePanelBtn.onmouseout = function() { this.style.transform = 'scale(1)'; };
            
            // Add only turn display and toggle button to top
            turnIndicator.appendChild(togglePanelBtn);
            turnIndicator.appendChild(turnDisplay);
            
            // Append panel and turn indicator to document
            document.body.appendChild(gameButtonsPanel);


            
            // ============================================
            // END RPN BUTTONS
            // ============================================
            
            document.body.appendChild(turnIndicator);
            document.body.appendChild(rotationControls);
        }

        // Function to add eliminated piece to display
        function addToEliminatedPieces(piece) {
            const isWhite = piece.classList.contains('white-piece') || 
                           piece.classList.contains('white-triangle') || 
                           piece.classList.contains('white-rhombus') ||
                           piece.classList.contains('white-circle') ||
                           piece.classList.contains('white-hexgon');
            
            // Track in captured arrays for RPN export
            const pieceChar = pieceToChar(piece);
            if (pieceChar) {
                if (isWhite) {
                    capturedWhitePieces.push(pieceChar);
                    console.log(`üì¶ Captured WHITE piece: ${pieceChar}, total white captured: ${capturedWhitePieces.length}`);
                } else {
                    capturedBlackPieces.push(pieceChar);
                    console.log(`üì¶ Captured BLACK piece: ${pieceChar}, total black captured: ${capturedBlackPieces.length}`);
                }
            }
            
            const eliminatedContainer = isWhite ? 
                document.getElementById('white-eliminated') : 
                document.getElementById('black-eliminated');
            
            // Create a copy of the piece for the eliminated display
            const eliminatedPiece = document.createElement('div');
            eliminatedPiece.className = piece.className + ' eliminated-piece';
            
            // Remove positioning and make it smaller
            eliminatedPiece.style.position = 'static';
            eliminatedPiece.style.transform = 'none';
            eliminatedPiece.style.top = 'auto';
            eliminatedPiece.style.left = 'auto';
            eliminatedPiece.style.margin = '2px';
            
            eliminatedContainer.appendChild(eliminatedPiece);
            // Link eliminated entry to original so undo can remove it
            const elimId = Date.now().toString() + Math.random().toString(36).slice(2);
            piece.setAttribute('data-eliminated-id', elimId);
            eliminatedPiece.setAttribute('data-eliminated-id', elimId);
            
            // Check if a rhombus was eliminated - if so, game over
            if (piece.classList.contains('rhombus-piece')) {
                showGameOver(isWhite ? 'Black' : 'White', 'A rhombus was eliminated!');
            }
        }
        
        // Helper function to add captured piece to display from RPN character
        function addCapturedPieceToDisplay(pieceChar, isWhite) {
            const eliminatedContainer = isWhite ? 
                document.getElementById('white-eliminated') : 
                document.getElementById('black-eliminated');
            
            const pieceData = charToPiece(pieceChar);
            if (!pieceData) return;
            
            const eliminatedPiece = document.createElement('div');
            eliminatedPiece.className = pieceData.baseClass + ' eliminated-piece';
            if (pieceData.specificClass) {
                eliminatedPiece.classList.add(pieceData.specificClass);
            }
            
            // Remove positioning and make it smaller
            eliminatedPiece.style.position = 'static';
            eliminatedPiece.style.transform = 'none';
            eliminatedPiece.style.top = 'auto';
            eliminatedPiece.style.left = 'auto';
            eliminatedPiece.style.margin = '2px';
            
            eliminatedContainer.appendChild(eliminatedPiece);
            console.log(`üì¶ Added ${isWhite ? 'WHITE' : 'BLACK'} ${pieceData.baseClass} to eliminated panel`);
        }

        // Function to check win conditions
        function checkWinConditions(row, col, piece) {
            console.log('üéØ checkWinConditions called - Row:', row, 'Col:', col, 'Piece classes:', piece.className);
            
            // Check if it's a rhombus piece
            if (piece.classList.contains('rhombus-piece')) {
                const isWhite = piece.classList.contains('white-rhombus');
                console.log('‚úÖ Rhombus piece detected - IsWhite:', isWhite);
                console.log('üéØ Checking position: row=' + row + ', col=' + col);
                console.log('üéØ Black goal is at row=3, col=0 (3-0) - Black reaches White\'s starting position');
                console.log('üéØ White goal is at row=3, col=8 (3-8) - White reaches Black\'s starting position');
                
                // Check if we're in "Escape Race" mode (only rhombuses remain)
                const isEscapeRaceMode = checkEscapeRaceMode();
                console.log('üèÉ Escape Race Mode:', isEscapeRaceMode);
                
                // Black rhombus reaches 3-0 (WHITE's starting position) - Black wins
                if (!isWhite && row == 3 && col == 0) {
                    console.log('üè¥ BLACK RHOMBUS REACHED GOAL at 3-0!');
                    if (isEscapeRaceMode) {
                        // Escape Race mode - Base Defence disabled, instant win!
                        console.log('üéâ Calling showGameOver - Black Escape Race Win');
                        showGameOver('Black', '‚öîÔ∏è ESCAPE RACE! Black rhombus reached the goal first!');
                        return;
                    }
                    
                    // Normal mode - Check if white base defence is active
                    const activeDefences = isBaseDefenceActive();
                    console.log('üõ°Ô∏è Active defences:', activeDefences);
                    if (activeDefences.includes('white')) {
                        // White base defence is active, black cannot win
                        console.log('üõ°Ô∏è White base defence active, blocking black win');
                        return;
                    }
                    console.log('üéâ Calling showGameOver - Black Normal Win');
                    showGameOver('Black', 'Black rhombus reached the goal!');
                }
                // White rhombus reaches 3-8 (BLACK's starting position) - White wins
                else if (isWhite && row == 3 && col == 8) {
                    console.log('‚ö™ WHITE RHOMBUS REACHED GOAL at 3-8!');
                    if (isEscapeRaceMode) {
                        // Escape Race mode - Base Defence disabled, instant win!
                        console.log('üéâ Calling showGameOver - White Escape Race Win');
                        showGameOver('White', '‚öîÔ∏è ESCAPE RACE! White rhombus reached the goal first!');
                        return;
                    }
                    
                    // Normal mode - Check if black base defence is active
                    const activeDefences = isBaseDefenceActive();
                    console.log('üõ°Ô∏è Active defences:', activeDefences);
                    if (activeDefences.includes('black')) {
                        // Black base defence is active, white cannot win
                        console.log('üõ°Ô∏è Black base defence active, blocking white win');
                        return;
                    }
                    console.log('üéâ Calling showGameOver - White Normal Win');
                    showGameOver('White', 'White rhombus reached the goal!');
                } else {
                    console.log('‚úÖ Rhombus moved but did not reach goal - continuing game');
                }
            }
        }
        
        // Function to check if game is in "Escape Race" mode (only rhombuses remain)
        function checkEscapeRaceMode() {
            const allSquares = document.querySelectorAll('.square-piece');
            const allTriangles = document.querySelectorAll('.triangle-piece');
            const allCircles = document.querySelectorAll('.circle-piece');
            const allHexgons = document.querySelectorAll('.hexgon-piece');
            
            // Check if ONLY rhombuses remain (no other pieces)
            const onlyRhombusesRemain = allSquares.length === 0 && 
                                       allTriangles.length === 0 && 
                                       allCircles.length === 0 && 
                                       allHexgons.length === 0;
            
            return onlyRhombusesRemain;
        }
        
        // Track if we've already shown the Escape Race notification
        let escapeRaceNotificationShown = false;
        
        // Function to check and notify when Escape Race mode activates
        function checkAndNotifyEscapeRace() {
            if (escapeRaceNotificationShown) return; // Already shown
            
            if (checkEscapeRaceMode()) {
                escapeRaceNotificationShown = true;
                
                // Create overlay notification
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: linear-gradient(135deg, #ff6b6b, #ee5a6f);
                    color: white;
                    padding: 30px 50px;
                    border-radius: 20px;
                    border: 3px solid #fff;
                    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
                    z-index: 2000;
                    text-align: center;
                    font-family: Arial, sans-serif;
                    animation: escapeRacePulse 0.5s ease-in-out;
                `;
                
                notification.innerHTML = `
                    <h2 style="margin: 0 0 15px 0; font-size: 2.5em; text-shadow: 2px 2px 4px rgba(0,0,0,0.3);">
                        ‚öîÔ∏è ESCAPE RACE! ‚öîÔ∏è
                    </h2>
                    <p style="margin: 0 0 10px 0; font-size: 1.2em; line-height: 1.5;">
                        All other pieces eliminated!<br>
                        <strong>Base Defence is DISABLED</strong><br>
                        First rhombus to goal wins!
                    </p>
                    <p style="margin: 10px 0 0 0; font-size: 0.9em; opacity: 0.9;">
                        White goal: 3-8 | Black goal: 3-0
                    </p>
                `;
                
                // Add animation CSS
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes escapeRacePulse {
                        0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
                        50% { transform: translate(-50%, -50%) scale(1.1); }
                        100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
                    }
                `;
                document.head.appendChild(style);
                
                document.body.appendChild(notification);
                
                // Auto-remove after 4 seconds
                setTimeout(() => {
                    notification.style.transition = 'opacity 0.5s, transform 0.5s';
                    notification.style.opacity = '0';
                    notification.style.transform = 'translate(-50%, -50%) scale(0.8)';
                    setTimeout(() => notification.remove(), 500);
                }, 4000);
            }
        }

        // Function to check if current player has ANY legal moves (for stalemate detection)
        function doesPlayerHaveAnyLegalMoves(isWhite) {
            console.log(`üîç Checking if ${isWhite ? 'WHITE' : 'BLACK'} has any legal moves...`);
            
            // Get all pieces for this player
            const pieceSelector = isWhite 
                ? '.square-piece.white-piece, .triangle-piece.white-triangle, .rhombus-piece.white-rhombus, .circle-piece.white-circle, .hexgon-piece.white-hexgon'
                : '.square-piece:not(.white-piece), .triangle-piece:not(.white-triangle), .rhombus-piece:not(.white-rhombus), .circle-piece:not(.white-circle), .hexgon-piece:not(.white-hexgon)';
            
            const playerPieces = document.querySelectorAll(pieceSelector);
            console.log(`Found ${playerPieces.length} pieces for ${isWhite ? 'WHITE' : 'BLACK'}`);
            
            // Check each piece to see if it has at least one legal move
            for (const piece of playerPieces) {
                const hex = piece.closest('.hexagon');
                if (!hex) continue;
                
                const [, row, col] = hex.id.match(/hex-(\d+)-(\d+)/);
                const pieceRow = parseInt(row);
                const pieceCol = parseInt(col);
                
                // Get possible moves based on piece type
                let possibleMoves = [];
                if (piece.classList.contains('square-piece')) {
                    possibleMoves = getSquareMoves(pieceRow, pieceCol);
                } else if (piece.classList.contains('triangle-piece')) {
                    possibleMoves = getTriangleMoves(pieceRow, pieceCol, getTriangleOrientation(hex.id) || 0);
                } else if (piece.classList.contains('rhombus-piece')) {
                    possibleMoves = getRhombusMoves(pieceRow, pieceCol);
                } else if (piece.classList.contains('circle-piece')) {
                    possibleMoves = getCircleMoves(pieceRow, pieceCol);
                } else if (piece.classList.contains('hexgon-piece')) {
                    possibleMoves = getHexgonMoves(pieceRow, pieceCol);
                }
                
                // Check if any of these moves are legal (don't put rhombus in check)
                for (const [targetRow, targetCol] of possibleMoves) {
                    const targetHex = document.getElementById(`hex-${targetRow}-${targetCol}`);
                    if (!targetHex) continue;
                    
                    const occupyingPiece = targetHex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                    
                    // Skip if occupied by friendly piece (except rhombus can't capture rhombus)
                    if (occupyingPiece) {
                        const isOccupyingWhite = occupyingPiece.classList.contains('white-piece') || 
                                                occupyingPiece.classList.contains('white-triangle') || 
                                                occupyingPiece.classList.contains('white-rhombus') ||
                                                occupyingPiece.classList.contains('white-circle') ||
                                                occupyingPiece.classList.contains('white-hexgon');
                        
                        if (isOccupyingWhite === isWhite) continue; // Friendly piece
                        if (piece.classList.contains('rhombus-piece') && occupyingPiece.classList.contains('rhombus-piece')) {
                            continue; // Rhombus can't capture rhombus
                        }
                    }
                    
                    // Check if this move would put own rhombus in check
                    const pieceClasses = piece.className;
                    const wouldBeIllegal = wouldMoveResultInOwnCheckmate(hex.id, targetHex.id, pieceClasses, occupyingPiece);
                    
                    if (!wouldBeIllegal) {
                        console.log(`‚úÖ Legal move found: ${hex.id} ‚Üí ${targetHex.id}`);
                        return true; // Found at least one legal move
                    }
                }
            }
            
            console.log(`‚ùå NO LEGAL MOVES for ${isWhite ? 'WHITE' : 'BLACK'}!`);
            return false; // No legal moves found
        }

        // Function to check if a rhombus is in deadlock (checkmate) or stalemate
        function checkRhombusDeadlock() {
            console.log('üîç Checking for rhombus deadlock...');
            
            // Check both rhombuses
            const whiteRhombus = document.querySelector('.rhombus-piece.white-rhombus');
            const blackRhombus = document.querySelector('.rhombus-piece:not(.white-rhombus)');
            
            // Check white rhombus deadlock (ONLY if under attack AND no moves)
            if (whiteRhombus) {
                const deadlockResult = isRhombusInDeadlock(whiteRhombus, true);
                console.log('White rhombus deadlock check:', deadlockResult);
                // CRITICAL: Only trigger game over if rhombus is BOTH under attack AND has no moves
                if (deadlockResult.isDeadlocked && deadlockResult.underAttack) {
                    console.log('‚ö†Ô∏è WHITE RHOMBUS CHECKMATE! Black wins!');
                    showGameOver('Black', '‚ôüÔ∏è Checkmate! White rhombus is under attack with no escape!');
                    return true;
                }
                // If rhombus has no moves but is NOT under attack, game continues (not stalemate)
            }
            
            // Check black rhombus deadlock (ONLY if under attack AND no moves)
            if (blackRhombus) {
                const deadlockResult = isRhombusInDeadlock(blackRhombus, false);
                console.log('Black rhombus deadlock check:', deadlockResult);
                // CRITICAL: Only trigger game over if rhombus is BOTH under attack AND has no moves
                if (deadlockResult.isDeadlocked && deadlockResult.underAttack) {
                    console.log('‚ö†Ô∏è BLACK RHOMBUS CHECKMATE! White wins!');
                    showGameOver('White', '‚ôüÔ∏è Checkmate! Black rhombus is under attack with no escape!');
                    return true;
                }
                // If rhombus has no moves but is NOT under attack, game continues (not stalemate)
            }
            
            console.log('No rhombus deadlock detected');
            return false;
        }

        // Function to check if a specific rhombus is in deadlock (returns object with details)
        function isRhombusInDeadlock(rhombus, isWhite) {
            const rhombusHex = rhombus.parentElement;
            const rhombusId = rhombusHex.id;
            const [, rhombusRow, rhombusCol] = rhombusId.match(/hex-(\d+)-(\d+)/);
            
            console.log(`Checking ${isWhite ? 'WHITE' : 'BLACK'} rhombus at ${rhombusRow}-${rhombusCol}`);
            
            // Check if rhombus is under attack
            const underAttack = isPieceUnderThreat(parseInt(rhombusRow), parseInt(rhombusCol), isWhite);
            console.log(`Rhombus under attack: ${underAttack}`);
            
            // Get all possible moves for this rhombus
            const possibleMoves = getRhombusMoves(parseInt(rhombusRow), parseInt(rhombusCol));
            console.log(`Possible moves for rhombus:`, possibleMoves);
            
            // Check each possible move
            let hasLegalMove = false;
            for (const [targetRow, targetCol] of possibleMoves) {
                const targetHex = document.getElementById(`hex-${targetRow}-${targetCol}`);
                if (!targetHex) continue;
                
                // Check if this hex is occupied
                const occupyingPiece = targetHex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                
                let canMoveHere = false;
                
                if (!occupyingPiece) {
                    // Empty hex - can potentially move here
                    canMoveHere = true;
                } else {
                    // Check if it's an opponent piece (can capture)
                    const isOccupyingWhite = occupyingPiece.classList.contains('white-piece') || 
                                            occupyingPiece.classList.contains('white-triangle') || 
                                            occupyingPiece.classList.contains('white-rhombus') ||
                                            occupyingPiece.classList.contains('white-circle') ||
                                            occupyingPiece.classList.contains('white-hexgon');
                    
                    // If occupying piece is opponent and not a rhombus, can capture
                    if (isOccupyingWhite !== isWhite && !occupyingPiece.classList.contains('rhombus-piece')) {
                        canMoveHere = true;
                    }
                }
                
                // If we can move here, check if rhombus would STILL be under attack after moving
                if (canMoveHere) {
                    console.log(`Simulating move to ${targetRow}-${targetCol}...`);
                    
                    // Simulate the move: hide rhombus at current position, check if it would be threatened at new position
                    rhombus.style.display = 'none';
                    if (occupyingPiece) occupyingPiece.style.display = 'none';
                    
                    // Create temporary rhombus at target position
                    const tempRhombus = document.createElement('div');
                    tempRhombus.className = rhombus.className;
                    tempRhombus.setAttribute('data-temp-simulation', 'true');
                    targetHex.appendChild(tempRhombus);
                    
                    // Check if rhombus would be under attack at new position
                    const wouldBeUnderAttack = isPieceUnderThreat(targetRow, targetCol, isWhite);
                    console.log(`Would be under attack at ${targetRow}-${targetCol}: ${wouldBeUnderAttack}`);
                    
                    // Clean up simulation
                    tempRhombus.remove();
                    rhombus.style.display = '';
                    if (occupyingPiece) occupyingPiece.style.display = '';
                    
                    // If this move would get rhombus out of check, it's a legal move!
                    if (!wouldBeUnderAttack) {
                        console.log(`Found legal move to ${targetRow}-${targetCol}!`);
                        hasLegalMove = true;
                        break;
                    }
                }
            }
            
            // If no legal moves available that get rhombus out of check - deadlock!
            if (!hasLegalMove) {
                console.log('No legal moves found - rhombus is in deadlock!');
                return { isDeadlocked: true, underAttack: underAttack };
            }
            
            console.log('Rhombus has legal moves - NOT in deadlock');
            return { isDeadlocked: false, underAttack: underAttack };
        }
        
        // NEW: Check if a move would result in checkmate for your own rhombus
        function wouldMoveResultInOwnCheckmate(fromHexId, toHexId, movingPieceClasses, capturedPiece) {
            // Check if a move would result in own rhombus being checkmated
            
            // Find the player's rhombus
            const isWhiteMoving = movingPieceClasses.includes('white-piece') || 
                                 movingPieceClasses.includes('white-triangle') || 
                                 movingPieceClasses.includes('white-rhombus') ||
                                 movingPieceClasses.includes('white-circle') ||
                                 movingPieceClasses.includes('white-hexgon');
            
            // determine if white is moving
            
            const rhombusSelector = isWhiteMoving ? '.rhombus-piece.white-rhombus' : '.rhombus-piece:not(.white-rhombus)';
            const playerRhombus = document.querySelector(rhombusSelector);
            
            if (!playerRhombus) {
                console.log('No rhombus found for player');
                return false; // No rhombus to protect
            }
            
            const rhombusHex = playerRhombus.parentElement;
            const rhombusId = rhombusHex.id;
            const [, rhombusRow, rhombusCol] = rhombusId.match(/hex-(\d+)-(\d+)/);
            
            // player rhombus coordinates: rhombusRow,rhombusCol
            
            // Check if the rhombus itself is being moved
            const isMovingRhombus = movingPieceClasses.includes('rhombus-piece');
            // flag: isMovingRhombus
            
            // Get the piece being moved
            const fromHex = document.getElementById(fromHexId);
            const toHex = document.getElementById(toHexId);
            const movingPiece = fromHex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
            
            if (!movingPiece) {
                return false;
            }
            
            // Temporarily hide the moving piece and captured piece for simulation
            movingPiece.style.display = 'none';
            const capturedPieceBackup = capturedPiece ? capturedPiece.style.display : null;
            if (capturedPiece) capturedPiece.style.display = 'none';
            
            // Create temporary piece at destination
            const tempPiece = document.createElement('div');
            tempPiece.className = movingPieceClasses;
            tempPiece.setAttribute('data-temp-simulation', 'true');
            toHex.appendChild(tempPiece);
            
            // temp piece created at destination for simulation
            
            // QUICK WIN CASE: If the move places the player's rhombus onto the opponent's goal hex, it's an immediate win -> NOT illegal
            // Note: Winning goal hexes are fixed: Black goal = hex-3-0, White goal = hex-3-8
            const moverIsWhite = movingPieceClasses.includes('white-rhombus') || movingPieceClasses.includes('white-piece');
            // The goal hex for the mover: White wins by reaching hex-3-8, Black wins by reaching hex-3-0
            const moverGoalHex = moverIsWhite ? 'hex-3-8' : 'hex-3-0';
            // quick-win mover details
            if (isMovingRhombus && toHexId === moverGoalHex) {
                // For shape-defense variant, do not auto-allow a rhombus win if the destination
                // goal hex is attackable by the opponent. In that case, the move should be
                // considered illegal (blocked) unless the attacker is captured.
                try {
                    // Check either the global variable or the settings-backed variant (UI may set gameSettings)
                    const currentBaseDefense = (typeof window.baseDefenseVariant !== 'undefined') ? window.baseDefenseVariant : (window.gameSettings && window.gameSettings.baseDefenseVariant);
                    // current base defense variant checked
                    if (currentBaseDefense === 'shape-defense') {
                        const [, destR, destC] = toHexId.match(/hex-(\d+)-(\d+)/);
                        const destAttackable = isSquareAttackableByColor(parseInt(destR), parseInt(destC), !moverIsWhite);
                        // wouldMoveResultInOwnCheckmate tracing removed
                        if (destAttackable) {
                            // Clean up simulation before returning that move is illegal
                            tempPiece.remove();
                            movingPiece.style.display = '';
                            if (capturedPiece && capturedPieceBackup !== null) {
                                capturedPiece.style.display = capturedPieceBackup;
                            }
                            return true; // mark as illegal
                        }
                    }
                } catch (e) {
                    console.warn('Error evaluating shape-defense on quick win:', e);
                }

                // move places rhombus on mover goal hex - allow as win
                // Clean up the temp simulation before returning
                tempPiece.remove();
                movingPiece.style.display = '';
                if (capturedPiece && capturedPieceBackup !== null) {
                    capturedPiece.style.display = capturedPieceBackup;
                }
                return false;
            }

            // If moving the rhombus itself, check the NEW position; otherwise check the original position
            const [, toRow, toCol] = toHexId.match(/hex-(\d+)-(\d+)/);
            const checkRow = isMovingRhombus ? parseInt(toRow) : parseInt(rhombusRow);
            const checkCol = isMovingRhombus ? parseInt(toCol) : parseInt(rhombusCol);
            
            console.log(`Checking if rhombus would be under attack at: ${checkRow}-${checkCol}`);
            
            // Check if rhombus would be under attack after this move
            const underAttack = isPieceUnderThreat(checkRow, checkCol, isWhiteMoving);
            
            console.log('Rhombus under attack after move:', underAttack);
            
            let wouldBeIllegal = false;
            
            if (underAttack) {
                // If rhombus is moving and capturing the piece that would be attacking it, that's LEGAL!
                if (isMovingRhombus && capturedPiece) {
                    console.log('‚úÖ Rhombus is capturing the attacking piece - move is LEGAL');
                    wouldBeIllegal = false;
                } else {
                    // Rhombus would be under attack after this move - ILLEGAL!
                    // In chess terms: You cannot make a move that leaves your king in check
                    console.log('‚ùå ILLEGAL! This move would leave your rhombus under attack!');
                    wouldBeIllegal = true;
                }
            } else {
                console.log('‚úÖ Rhombus not under attack - move is safe');
            }
            
            // Clean up simulation
            tempPiece.remove();
            movingPiece.style.display = '';
            if (capturedPiece && capturedPieceBackup !== null) {
                capturedPiece.style.display = capturedPieceBackup;
            }
            
            console.log('Final result - would be illegal move:', wouldBeIllegal);
            
            return wouldBeIllegal;
        }

        // Function to get all possible moves for a hexgon at a given position
        function getHexgonMoves(centerRow, centerCol, rotation = 0) {
            let targets = [];
            
            if (centerRow === 0) {
                switch (centerCol) {
                    case 0: targets = [[0,1],[1,2]]; break;
                    case 1: targets = [[0,0],[1,0],[0,2],[1,3]]; break;
                    case 2: targets = [[0,1],[1,1],[0,3],[1,4]]; break;
                    case 3: targets = [[0,2],[1,2],[0,4],[1,5]]; break;
                    case 4: targets = [[0,3],[1,3],[0,5],[1,6]]; break;
                    case 5: targets = [[0,4],[1,4]]; break;
                    default: targets = [];
                }
            } else if (centerRow === 1) {
                switch (centerCol) {
                    case 0: targets = [[1,1],[2,2],[0,1]]; break;
                    case 1: targets = [[0,0],[1,0],[0,2],[1,3]]; break;
                    case 2: targets = [[1,1],[2,1],[0,0],[1,3],[2,4],[0,3]]; break;
                    case 3: targets = [[1,2],[2,2],[0,1],[1,4],[2,5],[0,4]]; break;
                    case 4: targets = [[1,3],[2,3],[0,2],[1,5],[2,6],[0,5]]; break;
                    case 5: targets = [[1,4],[2,4],[0,3],[1,6]]; break;
                    case 6: targets = [[2,6],[3,6],[1,5]]; break;
                    default: targets = [];
                }
            } else if (centerRow === 2) {
                switch (centerCol) {
                    case 0: targets = [[2,1],[3,2],[1,1]]; break;
                    case 1: targets = [[2,2],[3,3],[1,2],[2,0]]; break;
                    case 2: targets = [[2,3],[3,4],[1,3],[2,1],[3,1],[1,0]]; break;
                    case 3: targets = [[2,4],[3,5],[1,4],[2,2],[3,2],[1,1]]; break;
                    case 4: targets = [[2,5],[3,6],[1,5],[2,3],[3,3],[1,2]]; break;
                    case 5: targets = [[2,6],[3,7],[1,6],[2,4],[3,4],[1,3]]; break;
                    case 6: targets = [[2,7],[2,5],[3,5],[1,4]]; break;
                    case 7: targets = [[2,6],[3,6],[1,5]]; break;
                    default: targets = [];
                }
            } else if (centerRow === 3) {
                // Row 3 with rotation-based patterns
                if (centerCol === 0) {
                    if (rotation === 0) targets = [[4,1],[3,1],[2,1]];
                    else if (rotation === 1) targets = [[4,1],[4,0]];
                    else if (rotation === 2) targets = [[2,1],[2,0]];
                } else if (centerCol === 1) {
                    if (rotation === 0) targets = [[4,2],[3,2],[2,2],[3,0]];
                    else if (rotation === 1) targets = [[5,0],[4,1],[4,0],[2,0],[1,0]];
                    else if (rotation === 2) targets = [[1,0],[2,1],[2,2],[4,0],[5,0]];
                } else if (centerCol === 2) {
                    if (rotation === 0) targets = [[4,0],[3,1],[2,0],[4,3],[3,3],[2,3]];
                    else if (rotation === 1) targets = [[5,1],[4,2],[4,3],[2,0],[2,1],[1,1]];
                    else if (rotation === 2) targets = [[4,0],[4,1],[5,1],[2,3],[2,2],[1,1]];
                } else if (centerCol === 3) {
                    if (rotation === 0) targets = [[4,1],[3,2],[2,1],[4,4],[3,4],[2,4]];
                    else if (rotation === 1) targets = [[5,2],[4,3],[4,4],[2,1],[2,2],[1,2]];
                    else if (rotation === 2) targets = [[5,2],[4,2],[4,1],[1,2],[2,3],[2,4]];
                } else if (centerCol === 4) {
                    if (rotation === 0) targets = [[4,2],[3,3],[2,2],[4,5],[3,5],[2,5]];
                    else if (rotation === 1) targets = [[5,3],[4,4],[4,5],[2,2],[2,3],[1,3]];
                    else if (rotation === 2) targets = [[5,3],[4,3],[4,2],[1,3],[2,4],[2,5]];
                } else if (centerCol === 5) {
                    if (rotation === 0) targets = [[4,3],[3,4],[2,3],[4,6],[3,6],[2,6]];
                    else if (rotation === 1) targets = [[5,4],[4,5],[4,6],[2,3],[2,4],[1,4]];
                    else if (rotation === 2) targets = [[5,4],[4,4],[4,3],[1,4],[2,5],[2,6]];
                } else if (centerCol === 6) {
                    if (rotation === 0) targets = [[4,4],[3,5],[2,4],[4,7],[3,7],[2,7]];
                    else if (rotation === 1) targets = [[5,5],[4,6],[4,7],[2,4],[2,5],[1,5]];
                    else if (rotation === 2) targets = [[5,5],[4,5],[4,4],[1,5],[2,6],[2,7]];
                } else if (centerCol === 7) {
                    if (rotation === 0) targets = [[4,5],[3,6],[2,5],[3,8]];
                    else if (rotation === 1) targets = [[5,6],[4,7],[2,5],[2,6],[1,6]];
                    else if (rotation === 2) targets = [[2,7],[1,6],[5,8],[4,6],[4,5]];
                } else if (centerCol === 8) {
                    if (rotation === 0) targets = [[4,6],[3,7],[2,6]];
                    else if (rotation === 1) targets = [[5,6],[4,7],[2,5],[2,6],[1,6]];
                    else if (rotation === 2) targets = [[2,7],[1,6],[5,8],[4,6],[4,5]];
                }
            } else if (centerRow === 4) {
                switch (centerCol) {
                    case 0: targets = [[4,1],[3,2],[5,1]]; break;
                    case 1: targets = [[4,0],[4,2],[5,2],[3,3]]; break;
                    case 2: targets = [[4,1],[5,0],[3,1],[4,3],[5,3],[3,4]]; break;
                    case 3: targets = [[4,2],[5,1],[3,2],[4,4],[5,4],[3,5]]; break;
                    case 4: targets = [[4,3],[5,2],[3,3],[4,5],[5,5],[3,6]]; break;
                    case 5: targets = [[4,4],[5,3],[3,4],[4,6],[5,6],[3,7]]; break;
                    case 6: targets = [[4,5],[5,4],[3,5],[4,7]]; break;
                    case 7: targets = [[4,6],[5,5],[3,6]]; break;
                    default: targets = [];
                }
            } else if (centerRow === 5) {
                switch (centerCol) {
                    case 0: targets = [[5,1],[6,1],[4,2]]; break;
                    case 1: targets = [[5,0],[6,2],[5,2],[4,3]]; break;
                    case 2: targets = [[5,1],[6,0],[4,1],[5,3],[6,3],[4,4]]; break;
                    case 3: targets = [[5,2],[6,1],[4,2],[5,4],[6,4],[4,5]]; break;
                    case 4: targets = [[5,3],[6,2],[4,3],[5,5],[6,5],[4,6]]; break;
                    case 5: targets = [[5,4],[6,3],[4,4],[5,6]]; break;
                    case 6: targets = [[5,5],[6,4],[4,5]]; break;
                    default: targets = [];
                }
            } else if (centerRow === 6) {
                switch (centerCol) {
                    case 0: targets = [[6,1],[5,2]]; break;
                    case 1: targets = [[6,0],[5,0],[6,2],[5,3]]; break;
                    case 2: targets = [[6,1],[5,1],[6,3],[5,4]]; break;
                    case 3: targets = [[6,2],[5,2],[6,4],[5,5]]; break;
                    case 4: targets = [[6,3],[5,3],[6,5],[5,6]]; break;
                    case 5: targets = [[6,4],[5,4]]; break;
                    default: targets = [];
                }
            }
            
            return targets;
        }
        
        // Function to get all possible moves for a rhombus at a given position
        function getRhombusMoves(centerRow, centerCol) {
            let targets = [];
            
            // Dead zone and inner perimeter definitions for special diagonal moves
            const deadZone = new Set(["3-3", "3-4", "3-5"]);
            const innerPerimeter = new Set(["2-2", "2-3", "2-4", "2-5", "3-2", "3-6", "4-2", "4-3", "4-4", "4-5"]);
            const currentPos = `${centerRow}-${centerCol}`;
            
            // Use the same mapping as showRhombusMovementPattern
            if (centerRow === 0) {
                switch (centerCol) {
                    case 0: targets = [[2,1],[0,1],[0,2]]; break;
                    case 1: targets = [[2,2],[0,2],[0,3],[0,0]]; break;
                    case 2: targets = [[2,3],[0,3],[0,4],[0,0],[0,1]]; break;
                    case 3: targets = [[2,4],[0,4],[0,5],[0,1],[0,2]]; break;
                    case 4: targets = [[2,5],[0,5],[0,3],[0,2]]; break;
                    case 5: targets = [[2,6],[0,4],[0,3]]; break;
                }
            } else if (centerRow === 1) {
                switch (centerCol) {
                    case 0: targets = [[3,1],[1,2],[1,1]]; break;
                    case 1: targets = [[3,2],[1,0],[1,2],[1,3]]; break;
                    case 2: targets = [[3,3],[1,3],[1,4],[1,1],[1,0]]; break;
                    case 3: targets = [[3,4],[1,4],[1,5],[1,2],[1,1]]; break;
                    case 4: targets = [[3,5],[1,5],[1,6],[1,3],[1,2]]; break;
                    case 5: targets = [[1,4],[1,3],[3,6]]; break;
                    case 6: targets = [[3,7],[1,5],[1,4]]; break;
                }
            } else if (centerRow === 2) {
                switch (centerCol) {
                    case 0: targets = [[4,0],[2,1],[2,2]]; break;
                    case 1: targets = [[4,1],[2,2],[2,3],[0,0]]; break;
                    case 2: targets = [[2,1],[2,0],[4,2],[2,3],[2,4],[0,1]]; break;
                    case 3: targets = [[2,2],[2,1],[4,3],[2,4],[2,5],[0,2]]; break;
                    case 4: targets = [[2,3],[2,2],[4,4],[2,5],[2,6],[0,3]]; break;
                    case 5: targets = [[2,4],[2,3],[4,5],[2,6],[2,7],[0,4]]; break;
                    case 6: targets = [[2,5],[2,4],[4,6],[2,7],[0,5]]; break;
                    case 7: targets = [[2,6],[2,5],[4,7]]; break;
                }
            } else if (centerRow === 3) {
                switch (centerCol) {
                    case 0: targets = [[3,2],[3,1]]; break;
                    case 1: targets = [[1,0],[5,0],[3,2],[3,3]]; break;
                    case 2: targets = [[1,1],[5,1],[3,1],[3,0],[3,3],[3,4]]; break;
                    case 3: targets = [[1,2],[5,2],[3,2],[3,1],[3,4],[3,5]]; break;
                    case 4: targets = [[1,3],[5,3],[3,3],[3,2],[3,5],[3,6]]; break;
                    case 5: targets = [[1,4],[5,4],[3,4],[3,3],[3,6],[3,7]]; break;
                    case 6: targets = [[1,5],[5,5],[3,5],[3,4],[3,7],[3,8]]; break;
                    case 7: targets = [[1,6],[5,6],[3,6],[3,5],[3,8]]; break;
                    case 8: targets = [[3,7],[3,6]]; break;
                }
            } else if (centerRow === 4) {
                switch (centerCol) {
                    case 0: targets = [[4,1],[4,2],[2,0]]; break;
                    case 1: targets = [[6,0],[2,1],[4,0],[4,2],[4,3]]; break;
                    case 2: targets = [[6,1],[2,2],[4,1],[4,0],[4,3],[4,4]]; break;
                    case 3: targets = [[6,2],[2,3],[4,2],[4,1],[4,4],[4,5]]; break;
                    case 4: targets = [[6,3],[2,4],[4,3],[4,2],[4,5],[4,6]]; break;
                    case 5: targets = [[6,4],[2,5],[4,4],[4,3],[4,6],[4,7]]; break;
                    case 6: targets = [[6,5],[2,6],[4,5],[4,4],[4,7]]; break;
                    case 7: targets = [[4,6],[4,5],[2,7]]; break;
                }
            } else if (centerRow === 5) {
                switch (centerCol) {
                    case 0: targets = [[5,1],[5,2],[3,1]]; break;
                    case 1: targets = [[3,2],[5,0],[5,2],[5,3]]; break;
                    case 2: targets = [[3,3],[5,3],[5,4],[5,1],[5,0]]; break;
                    case 3: targets = [[3,4],[5,4],[5,5],[5,2],[5,1]]; break;
                    case 4: targets = [[3,5],[5,5],[5,6],[5,3],[5,2]]; break;
                    case 5: targets = [[5,4],[5,3],[3,6]]; break;
                    case 6: targets = [[3,7],[5,5],[5,4]]; break;
                }
            } else if (centerRow === 6) {
                switch (centerCol) {
                    case 0: targets = [[6,1],[6,2],[4,1]]; break;
                    case 1: targets = [[6,0],[6,2],[6,3],[4,2]]; break;
                    case 2: targets = [[6,3],[6,4],[6,1],[6,0],[4,3]]; break;
                    case 3: targets = [[6,4],[6,5],[6,2],[6,1],[4,4]]; break;
                    case 4: targets = [[6,5],[6,3],[6,2],[4,5]]; break;
                    case 5: targets = [[6,4],[6,3],[4,6]]; break;
                }
            }
            
            // SPECIAL ABILITY: When rhombus is in dead zone or specific inner perimeter positions,
            // it can move diagonally between these zones (ONLY between dead zone and inner zone)
            if (deadZone.has(currentPos) || innerPerimeter.has(currentPos)) {
                const diagonalMoves = [];
                
                // Define exact diagonal connections between dead zone and inner perimeter
                // These are the ONLY allowed diagonal moves for this special ability
                const diagonalConnections = {
                    // Dead zone positions and their specific diagonal inner perimeter neighbors
                    "3-3": [[4,2], [2,2], [2,3], [4,3]],           // 3-3 can reach 4-2, 2-2, 2-3, 4-3
                    "3-4": [[4,3], [4,4], [2,3], [2,4]],           // 3-4 can reach 4-3, 4-4, 2-3, 2-4
                    "3-5": [[4,4], [4,5], [2,4], [2,5]],           // 3-5 can reach 4-4, 4-5, 2-4, 2-5
                    // Inner perimeter positions that can reach dead zone diagonally
                    "4-2": [[3,3]],                                 // 4-2 can reach 3-3
                    "4-3": [[3,3], [3,4]],                         // 4-3 can reach 3-3, 3-4
                    "4-4": [[3,4], [3,5]],                         // 4-4 can reach 3-4, 3-5
                    "4-5": [[3,5]],                                 // 4-5 can reach 3-5
                    "2-2": [[3,3]],                                 // 2-2 can reach 3-3
                    "2-3": [[3,3], [3,4]],                         // 2-3 can reach 3-3, 3-4
                    "2-4": [[3,4], [3,5]],                         // 2-4 can reach 3-4, 3-5
                    "2-5": [[3,5]]                                  // 2-5 can reach 3-5
                };
                
                // Add diagonal moves if current position has defined connections
                if (diagonalConnections[currentPos]) {
                    for (const [row, col] of diagonalConnections[currentPos]) {
                        // Only add if not already in targets
                        const alreadyExists = targets.some(([r, c]) => r === row && c === col);
                        if (!alreadyExists) {
                            diagonalMoves.push([row, col]);
                        }
                    }
                }
                
                // Add the diagonal moves to the targets
                targets = targets.concat(diagonalMoves);
            }
            
            return targets;
        }

        // Function to check if base defence is active
        function isBaseDefenceActive() {
            const activeDefences = [];
            
            // Check if white rhombus is still at its base (3-0)
            const whiteRhombus = document.querySelector('.rhombus-piece.white-rhombus');
            if (whiteRhombus) {
                const whiteHex = whiteRhombus.parentElement;
                const whiteId = whiteHex.id;
                const [, whiteRow, whiteCol] = whiteId.match(/hex-(\d+)-(\d+)/);
                if (whiteRow == 3 && whiteCol == 0) {
                    // Check if white has other pieces besides rhombus
                    const whiteOtherPieces = document.querySelectorAll(
                        '.square-piece.white-piece, .triangle-piece.white-triangle, .circle-piece.white-circle, .hexgon-piece.white-hexgon'
                    );
                    
                    // Base defence only active if white has OTHER pieces
                    // If only rhombus left, MUST move from base
                    if (whiteOtherPieces.length > 0) {
                        activeDefences.push('white'); // White base defence is active
                    }
                }
            }

            // Check if black rhombus is still at its base (3-8)
            const blackRhombus = document.querySelector('.rhombus-piece:not(.white-rhombus)');
            if (blackRhombus) {
                const blackHex = blackRhombus.parentElement;
                const blackId = blackHex.id;
                const [, blackRow, blackCol] = blackId.match(/hex-(\d+)-(\d+)/);
                if (blackRow == 3 && blackCol == 8) {
                    // Check if black has other pieces besides rhombus
                    const blackOtherPieces = document.querySelectorAll(
                        '.square-piece:not(.white-piece), .triangle-piece:not(.white-triangle), .circle-piece:not(.white-circle), .hexgon-piece:not(.white-hexgon)'
                    );
                    
                    // Base defence only active if black has OTHER pieces
                    // If only rhombus left, MUST move from base
                    if (blackOtherPieces.length > 0) {
                        activeDefences.push('black'); // Black base defence is active
                    }
                }
            }

            return activeDefences; // Return array of active defences
        }

        // Function to update base defence display
        function updateBaseDefenceDisplay() {
            // Remove existing base defence indicators
            const existingWhiteIndicator = document.getElementById('white-base-defence');
            const existingBlackIndicator = document.getElementById('black-base-defence');
            const existingGuestIndicatorBlack = document.getElementById('guest-indicator-black');
            const existingGuestIndicatorWhite = document.getElementById('guest-indicator-white');
            if (existingWhiteIndicator) existingWhiteIndicator.remove();
            if (existingBlackIndicator) existingBlackIndicator.remove();
            if (existingGuestIndicatorBlack) existingGuestIndicatorBlack.remove();
            if (existingGuestIndicatorWhite) existingGuestIndicatorWhite.remove();

            const activeDefences = isBaseDefenceActive();
            
            // Add guest indicator above BOTH eliminated sections if user is guest
            if (isGuestUser()) {
                const blackEliminatedSection = document.querySelector('.eliminated-section:last-child');
                const whiteEliminatedSection = document.querySelector('.eliminated-section:first-child');
                const makeGuestIndicator = (id) => {
                    const el = document.createElement('div');
                    el.id = id;
                    el.className = 'guest-indicator-badge';
                    el.style.cssText = `
                        background-color: #ff6b6b;
                        color: white;
                        padding: 8px 12px;
                        border-radius: 10px;
                        font-weight: bold;
                        font-size: 12px;
                        text-align: center;
                        margin-bottom: 10px;
                        border: 2px solid #fff;
                        box-shadow: 0 2px 6px rgba(0,0,0,0.3);
                        cursor: pointer;
                        position: relative;
                    `;
                    el.textContent = 'üë§ Logged in as Guest';

                    // Tooltip element
                    const tip = document.createElement('div');
                    tip.className = 'guest-tooltip';
                    tip.style.cssText = `
                        position: absolute;
                        top: 110%;
                        left: 50%;
                        transform: translateX(-50%);
                        background: rgba(0,0,0,0.85);
                        color: #fff;
                        padding: 6px 8px;
                        font-size: 11px;
                        border-radius: 6px;
                        white-space: nowrap;
                        display: none;
                        z-index: 100;
                    `;
                    tip.textContent = 'Guest: limited features (no cloud saves, no online ranking)';
                    el.appendChild(tip);

                    // Show tooltip on hover
                    el.addEventListener('mouseenter', () => { tip.style.display = 'block'; });
                    el.addEventListener('mouseleave', () => { tip.style.display = 'none'; });

                    // Click to prompt login
                    el.addEventListener('click', (e) => { e.stopPropagation(); showAccountModal(); });

                    return el;
                };

                if (blackEliminatedSection) {
                    const guestIndicatorBlack = makeGuestIndicator('guest-indicator-black');
                    blackEliminatedSection.insertBefore(guestIndicatorBlack, blackEliminatedSection.firstChild);
                }
                if (whiteEliminatedSection) {
                    const guestIndicatorWhite = makeGuestIndicator('guest-indicator-white');
                    whiteEliminatedSection.insertBefore(guestIndicatorWhite, whiteEliminatedSection.firstChild);
                }
            }
            
            // Insert white base defence indicator into its placeholder so ordering is
            // eliminated -> base-defence -> variant -> openings -> moves
            const whitePlaceholder = document.getElementById('white-base-defence-placeholder');
            if (whitePlaceholder) {
                const whiteIndicator = document.createElement('div');
                whiteIndicator.id = 'white-base-defence';
                const isWhiteDefending = activeDefences.includes('white');
                whiteIndicator.style.cssText = `
                    background-color: ${isWhiteDefending ? '#ff6b6b' : '#333'};
                    color: white;
                    padding: 8px 12px;
                    border-radius: 10px;
                    font-weight: bold;
                    font-size: 12px;
                    text-align: center;
                    margin-top: 10px;
                    border: 2px solid ${isWhiteDefending ? '#fff' : '#666'};
                    box-shadow: 0 2px 6px rgba(0,0,0,0.3);
                `;
                whiteIndicator.textContent = isWhiteDefending ? 'BASE DEFENCE' : 'BASE OPEN';
                whitePlaceholder.innerHTML = ''; // clear existing placeholder
                whitePlaceholder.appendChild(whiteIndicator);
            }

            // Insert black base defence indicator into its placeholder
            const blackPlaceholder = document.getElementById('black-base-defence-placeholder');
            if (blackPlaceholder) {
                const blackIndicator = document.createElement('div');
                blackIndicator.id = 'black-base-defence';
                const isBlackDefending = activeDefences.includes('black');
                blackIndicator.style.cssText = `
                    background-color: ${isBlackDefending ? '#ff6b6b' : '#333'};
                    color: white;
                    padding: 8px 12px;
                    border-radius: 10px;
                    font-weight: bold;
                    font-size: 12px;
                    text-align: center;
                    margin-top: 10px;
                    border: 2px solid ${isBlackDefending ? '#fff' : '#666'};
                    box-shadow: 0 2px 6px rgba(0,0,0,0.3);
                `;
                blackIndicator.textContent = isBlackDefending ? 'BASE DEFENCE' : 'BASE OPEN';
                blackPlaceholder.innerHTML = '';
                blackPlaceholder.appendChild(blackIndicator);
            }
        }

        // ============================================
        // RATING SYSTEM - ELO & SKILL TRACKING
        // ============================================

        const INITIAL_RATING = 1600;
        const K_FACTOR = 32; // Standard K-factor for rating calculation
        
        /**
         * Calculate new ELO rating based on game result
         * Standard ELO formula: New Rating = Old Rating + K √ó (Score - Expected Score)
         * @param {number} playerRating - Player's current rating
         * @param {number} opponentRating - Opponent's current rating
         * @param {number} score - 1 for win, 0 for loss, 0.5 for draw
         * @returns {number} New rating
         */
        function calculateEloRating(playerRating, opponentRating, score) {
            // Expected score for player
            const expectedScore = 1 / (1 + Math.pow(10, (opponentRating - playerRating) / 400));
            
            // New rating
            const newRating = playerRating + K_FACTOR * (score - expectedScore);
            
            return Math.round(newRating);
        }

        /**
         * Get opponent's rating (AI or other player)
         * @param {string} opponentName - Opponent name
         * @returns {number} Opponent's rating
         */
        function getOpponentRating(opponentName) {
            const allUsers = JSON.parse(localStorage.getItem('romgon-users') || '{}');
            
            // Check if opponent is a registered player
            if (allUsers[opponentName] && allUsers[opponentName].rating) {
                return allUsers[opponentName].rating;
            }
            
            // AI difficulty levels (adjust as needed)
            const aiRatings = {
                'AI': 1600,
                'AI_Easy': 1200,
                'AI_Medium': 1600,
                'AI_Hard': 2000,
                'AI_Expert': 2400
            };
            
            return aiRatings[opponentName] || 1600; // Default to 1600
        }

        /**
         * Initialize rating for new user
         * @param {string} username - Username
         */
        function initializeUserRating(username) {
            const allUsers = JSON.parse(localStorage.getItem('romgon-users') || '{}');
            
            if (allUsers[username]) {
                if (!allUsers[username].rating) {
                    allUsers[username].rating = INITIAL_RATING;
                }
                if (!allUsers[username].ratingHistory) {
                    allUsers[username].ratingHistory = [{
                        date: new Date().toISOString(),
                        rating: INITIAL_RATING,
                        change: 0,
                        opponent: 'Game Start',
                        result: 'start'
                    }];
                }
                localStorage.setItem('romgon-users', JSON.stringify(allUsers));
            }
        }

        /**
         * Update player rating after game end
         * @param {string} username - Username
         * @param {boolean} playerWon - Whether player won
         * @param {string} opponent - Opponent name
         */
        function updatePlayerRating(username, playerWon, opponent) {
            const allUsers = JSON.parse(localStorage.getItem('romgon-users') || '{}');
            
            if (!allUsers[username]) {
                console.warn('‚ö†Ô∏è User not found in localStorage for rating update:', username);
                console.log('‚ÑπÔ∏è OAuth users use backend rating system - skipping localStorage rating update');
                // Return a neutral rating change for OAuth users
                return {
                    oldRating: 1600,
                    newRating: 1600,
                    ratingChange: 0
                };
            }
            
            // Initialize rating if not exists
            if (!allUsers[username].rating) {
                allUsers[username].rating = INITIAL_RATING;
            }
            if (!allUsers[username].ratingHistory) {
                allUsers[username].ratingHistory = [];
            }
            
            // Get opponent rating
            const opponentRating = getOpponentRating(opponent);
            
            // Calculate new rating
            const score = playerWon ? 1 : 0;
            const oldRating = allUsers[username].rating;
            const newRating = calculateEloRating(oldRating, opponentRating, score);
            const ratingChange = newRating - oldRating;
            
            // Update rating
            allUsers[username].rating = newRating;
            
            // Add to history
            allUsers[username].ratingHistory.push({
                date: new Date().toISOString(),
                rating: newRating,
                change: ratingChange,
                opponent: opponent,
                result: playerWon ? 'win' : 'loss',
                opponentRating: opponentRating
            });
            
            // Keep only last 100 rating changes
            if (allUsers[username].ratingHistory.length > 100) {
                allUsers[username].ratingHistory = allUsers[username].ratingHistory.slice(-100);
            }
            
            // Save to localStorage
            localStorage.setItem('romgon-users', JSON.stringify(allUsers));
            
            console.log(`‚≠ê Rating Update for ${username}:`);
            console.log(`   Old Rating: ${oldRating}`);
            console.log(`   New Rating: ${newRating}`);
            console.log(`   Change: ${ratingChange > 0 ? '+' : ''}${ratingChange}`);
            console.log(`   Opponent: ${opponent} (Rating: ${opponentRating})`);
            
            return {
                oldRating,
                newRating,
                ratingChange
            };
        }

        /**
         * Get rating badge/tier based on rating
         * @param {number} rating - Player's rating
         * @returns {object} Badge info {name, emoji, color}
         */
        function getRatingTier(rating) {
            if (rating >= 2400) return { name: 'Grandmaster', emoji: 'üëë', color: '#FFD700' };
            if (rating >= 2200) return { name: 'Master', emoji: 'üèÜ', color: '#FF69B4' };
            if (rating >= 2000) return { name: 'Expert', emoji: '‚≠ê', color: '#FF6B6B' };
            if (rating >= 1800) return { name: 'Advanced', emoji: 'ü•á', color: '#F39C12' };
            if (rating >= 1600) return { name: 'Intermediate', emoji: 'ü•à', color: '#4ecdc4' };
            if (rating >= 1400) return { name: 'Beginner', emoji: 'ü•â', color: '#27ae60' };
            return { name: 'Novice', emoji: 'üéØ', color: '#3498db' };
        }

        /**
         * Create rating change indicator HTML
         * @param {number} change - Rating change amount
         * @returns {string} HTML string
         */
        function getRatingChangeHTML(change) {
            if (change === 0) return '<span style="color: #999;">¬±0</span>';
            if (change > 0) {
                return `<span style="color: #27ae60; font-weight: bold;">+${change}</span>`;
            }
            return `<span style="color: #e74c3c; font-weight: bold;">${change}</span>`;
        }

        /**
         * Show leaderboard of top-rated players
         */
        function showLeaderboard() {
            console.log('üèÜ Opening Leaderboard...');
            
            const allUsers = JSON.parse(localStorage.getItem('romgon-users') || '{}');
            
            // Get all users sorted by rating (descending)
            const players = Object.values(allUsers)
                .filter(user => user.rating !== undefined)
                .map(user => ({
                    username: user.username,
                    rating: user.rating || INITIAL_RATING,
                    tier: getRatingTier(user.rating || INITIAL_RATING),
                    wins: user.stats?.wins || 0,
                    losses: user.stats?.losses || 0,
                    totalGames: user.stats?.totalGames || 0,
                    winRate: user.stats?.totalGames > 0 
                        ? ((user.stats.wins / user.stats.totalGames) * 100).toFixed(1)
                        : 0
                }))
                .sort((a, b) => b.rating - a.rating);
            
            // Create leaderboard modal
            const leaderboardModal = document.createElement('div');
            leaderboardModal.id = 'leaderboard-modal';
            leaderboardModal.style.cssText = `
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                width: 100% !important;
                height: 100% !important;
                background-color: rgba(0, 0, 0, 0.9) !important;
                display: flex !important;
                justify-content: center !important;
                align-items: center !important;
                z-index: 99999 !important;
                font-family: sans-serif !important;
                pointer-events: auto !important;
                visibility: visible !important;
                opacity: 1 !important;
            `;
            
            const leaderboardContent = document.createElement('div');
            leaderboardContent.style.cssText = `
                background-color: #2a2a2a !important;
                border-radius: 12px !important;
                padding: 40px !important;
                max-width: 900px !important;
                width: 90% !important;
                max-height: 85vh !important;
                overflow-y: auto !important;
                box-shadow: 0 0 40px rgba(78, 205, 196, 0.3) !important;
                border: 2px solid #4ecdc4 !important;
                z-index: 100000 !important;
                position: relative !important;
                pointer-events: auto !important;
            `;
            
            leaderboardContent.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px;">
                    <h1 style="color: #4ecdc4 !important; margin: 0 !important; font-size: 2em !important;">üèÜ Global Leaderboard</h1>
                    <button onclick="document.getElementById('leaderboard-modal').remove();" style="
                        background-color: #ff6b6b !important;
                        color: white !important;
                        border: none !important;
                        padding: 8px 16px !important;
                        font-size: 1em !important;
                        border-radius: 6px !important;
                        cursor: pointer !important;
                        font-weight: bold !important;
                    ">‚úñÔ∏è Close</button>
                </div>
                
                <div style="margin-bottom: 20px; padding: 15px; background-color: rgba(78, 205, 196, 0.1); border-radius: 8px; border-left: 4px solid #4ecdc4;">
                    <div style="color: #999; font-size: 0.9em;">Total Players: ${players.length}</div>
                    <div style="color: #999; font-size: 0.9em;">Top Rating: ${players.length > 0 ? players[0].rating : 'N/A'}</div>
                </div>
                
                ${players.length > 0 ? `
                    <div style="overflow-x: auto;">
                        <table style="
                            width: 100%;
                            border-collapse: collapse;
                            font-size: 0.95em;
                        ">
                            <thead>
                                <tr style="border-bottom: 2px solid #4ecdc4;">
                                    <th style="text-align: left; padding: 12px; color: #4ecdc4; font-weight: bold;">Rank</th>
                                    <th style="text-align: left; padding: 12px; color: #4ecdc4; font-weight: bold;">Player</th>
                                    <th style="text-align: center; padding: 12px; color: #4ecdc4; font-weight: bold;">Rating</th>
                                    <th style="text-align: center; padding: 12px; color: #4ecdc4; font-weight: bold;">Tier</th>
                                    <th style="text-align: center; padding: 12px; color: #4ecdc4; font-weight: bold;">W-L</th>
                                    <th style="text-align: center; padding: 12px; color: #4ecdc4; font-weight: bold;">Win Rate</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${players.map((player, idx) => {
                                    const rankEmoji = idx === 0 ? 'ü•á' : idx === 1 ? 'ü•à' : idx === 2 ? 'ü•â' : '';
                                    const medalColor = idx === 0 ? '#FFD700' : idx === 1 ? '#C0C0C0' : idx === 2 ? '#CD7F32' : '#999';
                                    
                                    return `
                                        <tr style="border-bottom: 1px solid #444; transition: all 0.3s ease;" onmouseover="this.style.backgroundColor='rgba(78, 205, 196, 0.1)'" onmouseout="this.style.backgroundColor='transparent'">
                                            <td style="padding: 12px; color: ${medalColor}; font-weight: bold; text-align: left;">
                                                ${rankEmoji} #${idx + 1}
                                            </td>
                                            <td style="padding: 12px; color: #4ecdc4; font-weight: bold;">
                                                ${player.username}
                                            </td>
                                            <td style="padding: 12px; color: #fff; text-align: center; font-weight: bold;">
                                                ${player.rating}
                                            </td>
                                            <td style="padding: 12px; text-align: center;">
                                                <span style="color: ${player.tier.color}; font-weight: bold;">
                                                    ${player.tier.emoji} ${player.tier.name}
                                                </span>
                                            </td>
                                            <td style="padding: 12px; color: #999; text-align: center;">
                                                <span style="color: #27ae60;">${player.wins}W</span> - <span style="color: #e74c3c;">${player.losses}L</span>
                                            </td>
                                            <td style="padding: 12px; color: #f39c12; text-align: center; font-weight: bold;">
                                                ${player.winRate}%
                                            </td>
                                        </tr>
                                    `;
                                }).join('')}
                            </tbody>
                        </table>
                    </div>
                ` : `
                    <div style="text-align: center; color: #999; padding: 40px;">
                        <p>No players with ratings yet. Start playing to appear on the leaderboard!</p>
                    </div>
                `}
                
                <div style="margin-top: 30px; padding: 20px; background-color: rgba(78, 205, 196, 0.1); border-radius: 8px;">
                    <h3 style="color: #4ecdc4; margin: 0 0 15px 0;">üìä Rating Tiers</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 0.9em;">
                        <div><span style="color: #FFD700;">üëë</span> Grandmaster: 2400+</div>
                        <div><span style="color: #FF69B4;">üèÜ</span> Master: 2200-2399</div>
                        <div><span style="color: #FF6B6B;">‚≠ê</span> Expert: 2000-2199</div>
                        <div><span style="color: #F39C12;">ü•á</span> Advanced: 1800-1999</div>
                        <div><span style="color: #4ecdc4;">ü•à</span> Intermediate: 1600-1799</div>
                        <div><span style="color: #27ae60;">ü•â</span> Beginner: 1400-1599</div>
                    </div>
                </div>
            `;
            
            leaderboardModal.appendChild(leaderboardContent);
            document.body.appendChild(leaderboardModal);
            
            console.log('üèÜ Leaderboard displayed with', players.length, 'players');
        }

        // Function to show game over screen
        async function showGameOver(winner, reason) {
            console.log('üèÅ GAME OVER SCREEN TRIGGERED!');
            console.log('Winner:', winner, 'Reason:', reason);
            
            gameOver = true; // Set game over flag
            gameInProgress = false; // Game is no longer in progress
            
            // Hide ChatGPT button
            hideChatGPTButton();
            
            // Get current user FIRST before any checks
            const currentUser = JSON.parse(localStorage.getItem('romgon-user') || '{}');
            console.log('üîç Current User from localStorage:', currentUser);
            console.log('üîç User username:', currentUser.username);
            console.log('üîç User type:', currentUser.type);
            
            // Update user statistics if a user is logged in
            if (currentUser.username && currentUser.type !== 'guest') {
                console.log('üìä Logged-in user detected, saving game stats...');
                
                // Get the current user's game records
                let allUsers = JSON.parse(localStorage.getItem('romgon-users') || '{}');
                if (!allUsers[currentUser.username]) {
                    allUsers[currentUser.username] = {
                        username: currentUser.username,
                        games: [],
                        stats: {
                            wins: 0,
                            losses: 0,
                            totalGames: 0,
                            totalMoves: 0,
                            totalCaptures: 0
                        }
                    };
                }
                
                // Determine if current player won or lost
                const playerIsWhite = true; // Assuming single player is always white in AI mode
                const playerWon = (winner.toLowerCase() === 'white' && playerIsWhite) || 
                                 (winner.toLowerCase() === 'black' && !playerIsWhite);
                
                // Calculate move count and captures
                const moveCount = moveHistory ? moveHistory.length : 0;
                const captureCount = 0; // You may need to track this during gameplay
                
                // Record the game
                const gameRecord = {
                    date: new Date().toISOString(),
                    opponent: 'AI',
                    result: playerWon ? 'win' : 'loss',
                    winner: winner,
                    reason: reason,
                    moves: moveCount,
                    captures: captureCount
                };
                
                allUsers[currentUser.username].games.push(gameRecord);
                allUsers[currentUser.username].stats.totalGames += 1;
                allUsers[currentUser.username].stats.totalMoves += moveCount;
                allUsers[currentUser.username].stats.totalCaptures += captureCount;
                
                if (playerWon) {
                    allUsers[currentUser.username].stats.wins += 1;
                } else {
                    allUsers[currentUser.username].stats.losses += 1;
                }
                
                // ============================================
                // RATING SYSTEM - Update player rating
                // ============================================
                
                // Initialize rating if not exists
                initializeUserRating(currentUser.username);
                
                // Update rating based on game result
                const ratingUpdate = updatePlayerRating(currentUser.username, playerWon, 'AI');
                
                // Store rating update info in gameRecord
                gameRecord.ratingChange = ratingUpdate.ratingChange;
                gameRecord.oldRating = ratingUpdate.oldRating;
                gameRecord.newRating = ratingUpdate.newRating;
                
                // Update game record with rating info
                allUsers[currentUser.username].games[allUsers[currentUser.username].games.length - 1] = gameRecord;
                
                // Save updated user data
                localStorage.setItem('romgon-users', JSON.stringify(allUsers));
                
                // ALSO update the currentUser in localStorage with new stats and rating
                currentUser.stats = allUsers[currentUser.username].stats;
                currentUser.rating = allUsers[currentUser.username].rating;
                currentUser.gameHistory = allUsers[currentUser.username].games;
                localStorage.setItem('romgon-user', JSON.stringify(currentUser));
                
                console.log('‚úÖ Game result saved to user stats:', gameRecord);
                console.log('üìä Updated user stats:', allUsers[currentUser.username].stats);
                console.log('‚≠ê Updated user rating:', allUsers[currentUser.username].rating);
                console.log('üíæ Updated currentUser in localStorage');
                
                // ============================================
                // BACKEND SYNC - Submit game result to backend
                // ============================================
                const jwtToken = localStorage.getItem('romgon-jwt');
                if (jwtToken && currentUser.id) {
                    console.log('üîÑ Submitting game result to backend...');
                    console.log('   User ID:', currentUser.id);
                    console.log('   Result:', playerWon ? 'win' : 'loss');
                    console.log('   Winner:', winner);
                    console.log('   Move count:', moveCount);
                    
                    // For local/AI games, we need to submit as a completed game
                    try {
                        const gameData = {
                            opponent_type: 'ai', // or 'local' for PvP
                            result: playerWon ? 'win' : 'loss',
                            winner: winner.toLowerCase(),
                            move_count: moveCount,
                        };
                        
                        console.log('üì§ Sending game data:', gameData);
                        
                        const response = await fetch(`${BACKEND_API_URL || 'https://api.romgon.net'}/api/games/submit-result`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${jwtToken}`
                            },
                            body: JSON.stringify(gameData)
                        });
                        
                        console.log('üì• Backend response status:', response.status);
                        
                        if (response.ok) {
                            const result = await response.json();
                            console.log('‚úÖ Game result submitted to backend successfully:', result);
                        } else {
                            const errorText = await response.text();
                            console.error('‚ùå Backend game submission failed:', response.status, response.statusText);
                            console.error('   Error details:', errorText);
                        }
                    } catch (error) {
                        console.error('‚ùå Error submitting game to backend:', error);
                    }
                } else {
                    console.log('‚ÑπÔ∏è No JWT token or user ID - skipping backend sync');
                    console.log('   JWT token exists:', !!jwtToken);
                    console.log('   User ID:', currentUser.id);
                }
            } else {
                console.log('üë§ Guest user - no stats saved');
            }
            
            // Notify keyboard systems that game has ended
            const gameEndEvent = new CustomEvent('gameEnded', {
                detail: {
                    winner,
                    reason,
                    isPVP: false
                }
            });
            console.log('üì° Dispatching gameEnded event');
            document.dispatchEvent(gameEndEvent);
            
            // DIRECT: Switch back to General Navigation
            if (window.keyboardRouter) {
                console.log('üéÆ DIRECT: Switching to General Navigation after game end');
                window.keyboardRouter.activateGeneralSystem();
            }
            
            // Hide rotation controls on game over
            const rotationControls = document.getElementById('rotation-controls');
            if (rotationControls) {
                rotationControls.style.display = 'none';
            }
            
            // Play win sound
            playWinSound();
            
            // Create game over overlay
            const gameOverOverlay = document.createElement('div');
            gameOverOverlay.style.cssText = `
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                width: 100% !important;
                height: 100% !important;
                background-color: rgba(0, 0, 0, 0.8) !important;
                display: flex !important;
                justify-content: center !important;
                align-items: center !important;
                z-index: 99999 !important;
                font-family: sans-serif !important;
                pointer-events: auto !important;
                visibility: visible !important;
                opacity: 1 !important;
            `;
            
            const gameOverContent = document.createElement('div');
            gameOverContent.style.cssText = `
                background-color: #2a2a2a !important;
                padding: 40px !important;
                border-radius: 15px !important;
                border: 3px solid #444 !important;
                text-align: center !important;
                color: white !important;
                max-width: 400px !important;
                position: relative !important;
                z-index: 100000 !important;
                pointer-events: auto !important;
            `;
            
            // Check if user is logged in to show stats saved message
            let ratingDisplayHTML = '';
            if (currentUser.username && currentUser.type !== 'guest') {
                // Get rating update info from the latest game
                const allUsers = JSON.parse(localStorage.getItem('romgon-users') || '{}');
                if (allUsers[currentUser.username] && allUsers[currentUser.username].games) {
                    const lastGame = allUsers[currentUser.username].games[allUsers[currentUser.username].games.length - 1];
                    if (lastGame && lastGame.ratingChange !== undefined) {
                        const ratingChangeColor = lastGame.ratingChange > 0 ? '#27ae60' : '#e74c3c';
                        const ratingChangeSymbol = lastGame.ratingChange > 0 ? '+' : '';
                        ratingDisplayHTML = `
                            <div style="
                                background-color: rgba(78, 205, 196, 0.1) !important;
                                border: 2px solid #4ecdc4 !important;
                                border-radius: 8px !important;
                                padding: 15px !important;
                                margin: 15px 0 0 0 !important;
                            ">
                                <p style="color: #4ecdc4 !important; margin: 0 0 10px 0 !important; font-size: 0.9em !important;">‚≠ê Rating Update</p>
                                <div style="display: flex; justify-content: space-around; align-items: center; gap: 10px;">
                                    <div>
                                        <div style="color: #999 !important; font-size: 0.8em !important;">Before</div>
                                        <div style="color: #fff !important; font-size: 1.3em !important; font-weight: bold !important;">${lastGame.oldRating}</div>
                                    </div>
                                    <div style="color: #4ecdc4; font-size: 1.5em;">‚Üí</div>
                                    <div>
                                        <div style="color: #999 !important; font-size: 0.8em !important;">After</div>
                                        <div style="color: #fff !important; font-size: 1.3em !important; font-weight: bold !important;">${lastGame.newRating}</div>
                                    </div>
                                    <div style="border-left: 2px solid #444; padding-left: 10px;">
                                        <div style="color: #999 !important; font-size: 0.8em !important;">Change</div>
                                        <div style="color: ${ratingChangeColor} !important; font-size: 1.3em !important; font-weight: bold !important;">${ratingChangeSymbol}${lastGame.ratingChange}</div>
                                    </div>
                                </div>
                            </div>
                        `;
                    }
                }
            }
            
            const userStatsMessage = currentUser.username && currentUser.type !== 'guest' 
                ? '<p style="margin: 15px 0 0 0; font-size: 0.9em; color: #4ecdc4;">‚úÖ Game result saved to your user hub!</p>'
                : '';
            
            gameOverContent.innerHTML = `
                <h1 style="color: #ff6b6b; margin: 0 0 20px 0; font-size: 2.5em;">GAME OVER</h1>
                <h2 style="color: #4ecdc4; margin: 0 0 20px 0; font-size: 1.8em;">${winner} WINS!</h2>
                <p style="margin: 0 0 20px 0; font-size: 1.2em;">${reason}</p>
                ${ratingDisplayHTML}
                ${userStatsMessage}
                <div style="display: flex; flex-direction: column; gap: 15px; align-items: center; margin-top: 20px;">
                    <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                        <button onclick="showUserAccountHub()" style="
                            background-color: #27ae60;
                            color: white;
                            border: none;
                            padding: 15px 30px;
                            font-size: 1.2em;
                            border-radius: 8px;
                            cursor: pointer;
                            font-weight: bold;
                        ">üë§ User Hub</button>
                        <button onclick="showLeaderboard()" style="
                            background-color: #f39c12;
                            color: white;
                            border: none;
                            padding: 15px 30px;
                            font-size: 1.2em;
                            border-radius: 8px;
                            cursor: pointer;
                            font-weight: bold;
                        ">üèÜ Leaderboard</button>
                        <button onclick="analyzeGameFromGameOver()" style="
                            background-color: #9b59b6;
                            color: white;
                            border: none;
                            padding: 15px 30px;
                            font-size: 1.2em;
                            border-radius: 8px;
                            cursor: pointer;
                            font-weight: bold;
                        ">üìä Analyze</button>
                    </div>
                    <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                        <button onclick="copyRPNFromGameOver()" style="
                            background-color: #16a085;
                            color: white;
                            border: none;
                            padding: 15px 30px;
                            font-size: 1.2em;
                            border-radius: 8px;
                            cursor: pointer;
                            font-weight: bold;
                        ">üìã Copy RPN</button>
                        <button onclick="saveGameFromGameOver()" style="
                            background-color: #e67e22;
                            color: white;
                            border: none;
                            padding: 15px 30px;
                            font-size: 1.2em;
                            border-radius: 8px;
                            cursor: pointer;
                            font-weight: bold;
                        ">üíæ Save Game</button>
                    </div>
                    <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                        <button onclick="observeGameFromGameOver()" style="
                            background-color: #3498db;
                            color: white;
                            border: none;
                            padding: 15px 30px;
                            font-size: 1.2em;
                            border-radius: 8px;
                            cursor: pointer;
                            font-weight: bold;
                        ">üëÅÔ∏è Observe Game</button>
                        <button onclick="location.reload()" style="
                            background-color: #4ecdc4;
                            color: white;
                            border: none;
                            padding: 15px 30px;
                            font-size: 1.2em;
                            border-radius: 8px;
                            cursor: pointer;
                            font-weight: bold;
                        ">‚ñ∂Ô∏è Play Again</button>
                        <button onclick="showStartMenu()" style="
                            background-color: #ff6b6b;
                            color: white;
                            border: none;
                            padding: 15px 30px;
                            font-size: 1.2em;
                            border-radius: 8px;
                            cursor: pointer;
                            font-weight: bold;
                        ">üè† Main Menu</button>
                    </div>
                </div>
            `;
            
            gameOverOverlay.appendChild(gameOverContent);
            console.log('‚úÖ Overlay content appended');
            console.log('üì¶ gameOverOverlay element:', gameOverOverlay);
            console.log('üì¶ gameOverOverlay styles:', gameOverOverlay.style.cssText);
            
            // Force it to show immediately with important flags
            gameOverOverlay.id = 'game-over-overlay';
            
            console.log('üèÅ ABOUT TO APPEND GAME OVER SCREEN');
            
            // Remove any existing game over overlays to avoid conflicts
            const existingOverlays = document.querySelectorAll('[id="game-over-overlay"]');
            console.log('üîç Found', existingOverlays.length, 'existing overlays - removing them');
            existingOverlays.forEach(overlay => overlay.remove());
            
            // Append to document.body
            document.body.appendChild(gameOverOverlay);
            console.log('‚úÖ Overlay appended to document.body');
            console.log('üì¶ Checking if overlay in DOM:', document.body.contains(gameOverOverlay));
            console.log('üì¶ Overlay z-index:', gameOverOverlay.style.zIndex);
            console.log('üì¶ Overlay display:', gameOverOverlay.style.display);
            
            // Force it to be visible immediately
            gameOverOverlay.style.display = 'flex';
            gameOverOverlay.style.visibility = 'visible';
            gameOverOverlay.style.opacity = '1';
            gameOverOverlay.style.pointerEvents = 'auto';
            
            // Double-check after a tiny delay
            setTimeout(() => {
                gameOverOverlay.style.display = 'flex';
                gameOverOverlay.style.visibility = 'visible';
                gameOverOverlay.style.opacity = '1';
            }, 10);
            
            // Ensure it's visible by checking computed styles
            setTimeout(() => {
                const overlay = document.getElementById('game-over-overlay');
                if (overlay) {
                    const computed = window.getComputedStyle(overlay);
                    console.log('‚è±Ô∏è Computed styles after append:');
                    console.log('   Position:', computed.position);
                    console.log('   Display:', computed.display);
                    console.log('   Z-Index:', computed.zIndex);
                    console.log('   Visibility:', computed.visibility);
                    console.log('   Opacity:', computed.opacity);
                    console.log('   PointerEvents:', computed.pointerEvents);
                    console.log('üéØ OVERLAY SHOULD BE VISIBLE NOW');
                } else {
                    console.error('‚ùå Game over overlay not found in DOM!');
                }
            }, 100);
        }

        // Function to go back to game from game over screen (spectate mode)
        function backToGameFromGameOver() {
            console.log('üéÆ Returning to game board for spectating...');
            // Close the game over overlay
            const gameOverOverlay = document.querySelector('div[style*="position: fixed"]');
            if (gameOverOverlay) {
                gameOverOverlay.remove();
            }
            // The board is already showing the final position
            // User can now view the board, copy RPN, or take screenshots
            console.log('‚úÖ Game board visible. You can now spectate the final position.');
            console.log('üíæ To save RPN, open console and type: exportPositionRPN()');
        }

        // Function to show user account hub with updated stats
        async function showUserAccountHub() {
            console.log('üë§ Opening Player Hub from game end modal...');
            
            // Close the game over overlay first
            const gameOverOverlay = document.getElementById('game-over-overlay');
            if (gameOverOverlay) {
                console.log('üîç Closing game over overlay');
                gameOverOverlay.remove();
            }
            
            // Call the main Player Hub which has backend integration
            showAccountModal();
        }

        // Function to copy RPN notation from game over screen
        function copyRPNFromGameOver() {
            console.log('üìã Copying RPN to clipboard...');
            
            // Export the full RPN string
            const fullRPN = exportPositionRPN();
            
            // Copy to clipboard
            navigator.clipboard.writeText(fullRPN).then(() => {
                alert('‚úÖ Full RPN copied to clipboard!\n\n' + fullRPN);
            }).catch(err => {
                // Fallback if clipboard API fails
                console.error('Failed to copy to clipboard:', err);
                alert('‚ùå Could not copy to clipboard automatically.\n\nRPN:\n' + fullRPN + '\n\n(Please copy manually from console)');
            });
        }

        // Function to analyze game from game over screen
        function analyzeGameFromGameOver() {
            console.log('üìä Opening analysis from game over screen...');
            // Close the game over overlay
            const gameOverOverlay = document.querySelector('div[style*="position: fixed"]');
            if (gameOverOverlay) {
                gameOverOverlay.remove();
            }
            // Call the existing loadCurrentGame function
            loadCurrentGame();
        }

        // Function to observe game from game over screen
        function observeGameFromGameOver() {
            console.log('üëÅÔ∏è Entering observe mode from game over screen...');
            // Close the game over overlay
            const gameOverOverlay = document.getElementById('game-over-overlay');
            if (gameOverOverlay) {
                gameOverOverlay.remove();
            } else {
                // Fallback: remove by style selector
                const overlay = document.querySelector('div[style*="position: fixed"]');
                if (overlay) {
                    overlay.remove();
                }
            }
            
            // Disable all piece dragging
            const pieces = document.querySelectorAll('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
            pieces.forEach(piece => {
                piece.draggable = false;
                piece.style.cursor = 'default';
            });
            
            // Hide rotation controls if visible
            const rotationControls = document.getElementById('rotation-controls');
            if (rotationControls) {
                rotationControls.style.display = 'none';
            }
            
            // Add a banner to indicate observe mode
            const observeBanner = document.createElement('div');
            observeBanner.id = 'observe-mode-banner';
            observeBanner.style.cssText = `
                position: fixed;
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
                background: linear-gradient(135deg, #3498db, #2980b9);
                color: white;
                padding: 15px 30px;
                border-radius: 10px;
                border: 2px solid #fff;
                box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
                z-index: 9999;
                font-weight: bold;
                font-size: 1.1em;
                text-align: center;
            `;
            observeBanner.innerHTML = `
                üëÅÔ∏è OBSERVE MODE - Game Review
                <button onclick="exitObserveMode()" style="
                    background-color: #e74c3c;
                    color: white;
                    border: none;
                    padding: 8px 16px;
                    border-radius: 5px;
                    cursor: pointer;
                    font-weight: bold;
                    margin-left: 20px;
                    font-size: 0.9em;
                ">Exit</button>
            `;
            
            // Remove any existing observe banner
            const existingBanner = document.getElementById('observe-mode-banner');
            if (existingBanner) {
                existingBanner.remove();
            }
            
            document.body.appendChild(observeBanner);
            
            console.log('‚úÖ Observe mode activated - pieces disabled, banner shown');
        }

        // Function to exit observe mode
        window.exitObserveMode = function() {
            console.log('üö™ Exiting observe mode...');
            
            // Remove observe banner
            const observeBanner = document.getElementById('observe-mode-banner');
            if (observeBanner) {
                observeBanner.remove();
            }
            
            // Return to start menu
            showStartMenu();
        }

        // Function to save game from game over screen
        function saveGameFromGameOver() {
            console.log('üíæ Saving game from game over screen...');
            
            // Export the current game state as RMN
            const fullRPN = exportPositionRPN();
            const boardPosition = fullRPN.split(' ')[0];
            
            // Generate RMN content
            const today = new Date();
            const dateStr = today.toISOString().split('T')[0];
            
            const rmnContent = `[White "Player 1"]
[Black "Player 2"]
[Date "${dateStr}"]
[Result "*"]
[StartPosition "S4s/T05t0/C6h0/R7r/H06c/t05T0/s4S"]

${moveHistory || '(No moves played yet - starting position)'}

*`;
            
            // Create a blob and download it
            const blob = new Blob([rmnContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `romgon-game-${dateStr}.rmn`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            alert('‚úÖ Game saved successfully!\n\nFile: romgon-game-' + dateStr + '.rmn');
        }

        // Add drag and drop functionality
        // NOTE: These MUST be global so keyboard navigation can access them
        window.draggedPiece = null;
        window.draggedFromHex = null;

        // Make pieces draggable
        function setupDragAndDrop() {
            const pieces = document.querySelectorAll('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
            
            pieces.forEach(piece => {
                piece.draggable = true;
                
                piece.addEventListener('dragstart', function(e) {
                    // Check if it's the current player's turn and piece
                    if (gameOver || !isCurrentPlayerPiece(this)) {
                        e.preventDefault(); // Prevent drag if not current player's turn
                        return;
                    }

                    // Check if another piece is already active this turn
                    if (currentTurnPiece && currentTurnPiece !== this.parentElement) {
                        e.preventDefault(); // Prevent drag if another piece is already active
                        alert('You can only move or rotate one piece per turn!');
                        return;
                    }

                    draggedPiece = this;
                    draggedFromHex = this.parentElement;
                    selectedPiece = this.parentElement; // Set selected piece for rotation controls
                    currentTurnPiece = this.parentElement; // Mark this piece as active for the turn
                    console.log('Set currentTurnPiece to:', currentTurnPiece.id);
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/html', this.outerHTML);
                    
                    // Show movement highlights based on piece type
                    const hexId = this.parentElement.id;
                    const [, row, col] = hexId.match(/hex-(\d+)-(\d+)/);
                    
                    const rotationControls = document.getElementById('rotation-controls');
                    if (rotationControls) {
                        if (this.classList.contains('triangle-piece') || this.classList.contains('hexgon-piece')) {
                            console.log('Showing rotation controls for rotatable piece');
                            rotationControls.style.display = 'block';
                            
                            // Also show mobile rotation controls on mobile
                            const mobileRotationControls = document.getElementById('mobile-rotation-controls');
                            console.log('üîß Piece selected, checking mobile rotation controls...', {
                                mobileRotationControls: !!mobileRotationControls,
                                windowWidth: window.innerWidth,
                                shouldShow: window.innerWidth <= 768
                            });
                            if (mobileRotationControls && window.innerWidth <= 768) {
                                console.log('üì± Showing mobile rotation controls');
                                mobileRotationControls.style.display = 'flex';
                            }
                        } else {
                            console.log('Hiding rotation controls for non-rotatable piece');
                            rotationControls.style.display = 'none';
                            
                            // Also hide mobile rotation controls
                            const mobileRotationControls = document.getElementById('mobile-rotation-controls');
                            if (mobileRotationControls) {
                                mobileRotationControls.style.display = 'none';
                            }
                        }
                    }
                    
                    console.log('üé¨ [INITIAL SETUP] Showing movement pattern for:', this.className);
                    console.log('Is circle?', this.classList.contains('circle-piece'));
                    console.log('Is hexgon?', this.classList.contains('hexgon-piece'));
                    console.log('Is triangle?', this.classList.contains('triangle-piece'));
                    console.log('Is rhombus?', this.classList.contains('rhombus-piece'));
                    
                    if (this.classList.contains('circle-piece')) {
                        console.log('üìû Calling showCircleMovementPattern');
                        showCircleMovementPattern(parseInt(row), parseInt(col));
                    } else if (this.classList.contains('hexgon-piece')) {
                        console.log('üìû Calling showHexgonMovementPattern');
                        showHexgonMovementPattern(parseInt(row), parseInt(col));
                    } else if (this.classList.contains('triangle-piece')) {
                        console.log('üìû Calling showTriangleMovementPattern');
                        // Both white and black triangles use the same rotation-aware movement system
                        showTriangleMovementPattern(parseInt(row), parseInt(col));
                    } else if (this.classList.contains('rhombus-piece')) {
                        showRhombusMovementPattern(parseInt(row), parseInt(col));
                    } else {
                        showSquareMovementPattern(parseInt(row), parseInt(col));
                    }
                });
                
                piece.addEventListener('dragend', function(e) {
                    // Clear highlights when drag ends (but keep threat highlights)
                    document.querySelectorAll('.hexagon').forEach(hex => {
                        hex.classList.remove('highlight-green', 'highlight-red', 'highlight-danger', 'highlight-diagonal', 'highlight-gray');
                    });
                    draggedPiece = null;
                    draggedFromHex = null;
                    
                    // Keep selection and rotation controls for triangles AND hexagons
                    // Only clear for pieces that cannot rotate
                    if (!this.classList.contains('triangle-piece') && !this.classList.contains('hexgon-piece')) {
                        selectedPiece = null;
                        currentTurnPiece = null; // Clear current turn piece for non-rotatables
                        console.log('Cleared currentTurnPiece in dragend');
                        const rotationControls = document.getElementById('rotation-controls');
                        if (rotationControls) {
                            rotationControls.style.display = 'none';
                        }
                    }
                    // For triangles and hexagons, selectedPiece is set in the drop event, not here
                });
            });
        }

        // Setup drag and drop when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                initAudio();
                setupDragAndDrop();
                // Initial check for pieces under attack at game start
                setTimeout(() => highlightAllPiecesUnderAttack(), 100);
                // Initialize keyboard navigation system
                setTimeout(() => initializeKeyboardNavigation(), 200);
            });
        } else {
            initAudio();
            setupDragAndDrop();
            // Initial check for pieces under attack at game start
            setTimeout(() => highlightAllPiecesUnderAttack(), 100);
            // Initialize keyboard navigation system
            setTimeout(() => initializeKeyboardNavigation(), 200);
        }

        /**
         * Initialize the keyboard navigation system after game is loaded
         */
        function initializeKeyboardNavigation() {
            if (typeof KeyboardNavigationSystem === 'undefined') {
                console.warn('‚ö†Ô∏è KeyboardNavigationSystem not loaded');
                return;
            }
            
            // Create keyboard nav instance
            window.keyboardNav = new KeyboardNavigationSystem({
                debug: false // Set to true for console logging
            });
            
            // Show keyboard indicator
            const indicator = document.getElementById('kb-player-indicator');
            if (indicator) {
                indicator.style.display = 'block';
                indicator.textContent = '‚å®Ô∏è KB: Player 1 (Black)';
                indicator.style.backgroundColor = '#333';
                indicator.style.color = '#fff';
            }
            
            console.log('‚úÖ Keyboard Navigation System initialized and ready!');
            console.log('‚å®Ô∏è Use arrow keys or WASD to move pieces');
            console.log('üìç Space/Enter to confirm, Escape to deselect');
        }


        // Make hexagons drop targets
                    document.querySelectorAll('.hexagon').forEach(hex => {
            hex.addEventListener('dragover', function(e) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            });
            
            // Add click/tap handler for mobile (tap highlighted hex to move)
            hex.addEventListener('click', function(e) {
                // Only handle if there's a selected piece and this hex is highlighted
                if (!selectedPiece) return;
                
                const targetHex = this;
                
                // Check if this hex is highlighted (valid move)
                if (!targetHex.classList.contains('highlight-green') && 
                    !targetHex.classList.contains('highlight-red') && 
                    !targetHex.classList.contains('highlight-danger') && 
                    !targetHex.classList.contains('highlight-diagonal')) {
                    return; // Not a valid move
                }
                
                // Get the piece from the selected hexagon
                const piece = selectedPiece.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                if (!piece) return;
                
                // Set global variables for the drop handler
                draggedPiece = piece;
                draggedFromHex = selectedPiece; // Set the global draggedFromHex
                
                console.log('üì± Click-to-move:', draggedFromHex.id, '‚Üí', targetHex.id);
                
                // Create a fake drop event and dispatch it
                const dropEvent = new DragEvent('drop', {
                    bubbles: true,
                    cancelable: true,
                    dataTransfer: new DataTransfer()
                });
                
                targetHex.dispatchEvent(dropEvent);
            });
            
                hex.addEventListener('drop', function(e) {
                e.preventDefault();
                
                if (!draggedPiece) return;
                
                const targetHex = this;
                const targetId = targetHex.id;
                const [, targetRow, targetCol] = targetId.match(/hex-(\d+)-(\d+)/);
                
                // Check if this is a valid move (highlighted position)
                // Note: highlight-threat is just a visual warning and doesn't block movement
                
                if (!targetHex.classList.contains('highlight-green') && 
                    !targetHex.classList.contains('highlight-red') && 
                    !targetHex.classList.contains('highlight-danger') && 
                    !targetHex.classList.contains('highlight-diagonal')) {
                    console.log('‚ùå DROP BLOCKED: No valid highlight found');
                    return; // Invalid move
                }
                console.log('‚úÖ DROP: Valid highlight found, proceeding...');
                
                // Check piece colors for capture logic
                const isDraggedWhite = draggedPiece.classList.contains('white-piece') || 
                                    draggedPiece.classList.contains('white-triangle') || 
                                    draggedPiece.classList.contains('white-rhombus') ||
                                    draggedPiece.classList.contains('white-circle') ||
                                    draggedPiece.classList.contains('white-hexgon');


                // ENFORCE BASE DEFENSE RULE (use already declared fromHexId and toHexId below)
                if (!enforceBaseDefenseRule(draggedFromHex.id, targetHex.id, draggedPiece, isDraggedWhite)) return;

                // Additional shape defense check: block rhombus escape if opponent's base (destination) is under attack
                if (window.baseDefenseVariant === 'shape-defense' && 
                    draggedPiece.classList.contains('rhombus-piece') && 
                    targetHex.id === 'hex-' + getBaseHex(!isDraggedWhite)) {
                    // Destination is opponent base - check if opponent can attack that base
                    const [, destRow, destCol] = targetHex.id.match(/hex-(\d+)-(\d+)/);
                    // Simulate the rhombus at the destination and test if opponent could attack it
                    try {
                        const destHexEl = document.getElementById('hex-' + destRow + '-' + destCol);
                        let tempSim = null;
                        if (destHexEl) {
                            tempSim = document.createElement('div');
                            tempSim.className = isDraggedWhite ? 'rhombus-piece white-rhombus' : 'rhombus-piece';
                            tempSim.setAttribute('data-temp-simulation', 'true');
                            destHexEl.appendChild(tempSim);
                        }
                            const attackable = isPieceUnderThreat(parseInt(destRow), parseInt(destCol), !isDraggedWhite);
                            if (tempSim) tempSim.remove();
                        if (attackable) {
                            showShapeDefenseWarning('rhombus');
                            return;
                        }
                    } catch (e) {
                        // drop-handler simulation error suppressed
                    }
                }

                // Check if there's an opponent piece to capture
                const existingPiece = targetHex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');

                // CRITICAL: Check if this move would put own rhombus in checkmate
                const pieceClasses = draggedPiece.className;
                // --- PATCH: Allow rhombus to win by skipping checkmate check when moving from base to opponent's base ---
                const isDraggedRhombus = draggedPiece.classList.contains('rhombus-piece');
                // Patch: Use full hex ID format for base hexes
                const fromBaseHex = 'hex-' + getBaseHex(isDraggedWhite);
                const toOppBaseHex = 'hex-' + getBaseHex(!isDraggedWhite);
                if (isDraggedRhombus && draggedFromHex.id === fromBaseHex && targetId === toOppBaseHex) {
                    // skipping checkmate check for rhombus moving from base to opponent base
                } else {
                    if (wouldMoveResultInOwnCheckmate(draggedFromHex.id, targetId, pieceClasses, existingPiece)) {
                        alert('‚ùå ILLEGAL MOVE! This move puts your rhombus under attack. You can only do this if you capture the attacking piece!');
                        return; // Block the move
                    }
                }
                
                let didCapture = false;
                if (existingPiece) {
                    // Check if both pieces are rhombuses - if so, no attack allowed
                    const isDraggedRhombus = draggedPiece.classList.contains('rhombus-piece');
                    const isExistingRhombus = existingPiece.classList.contains('rhombus-piece');
                    
                    if (isDraggedRhombus && isExistingRhombus) {
                        // Rhombus cannot attack another rhombus - block the move
                        return;
                    }
                    
                    // Check if it's an opponent piece (different color)
                    const isExistingWhite = existingPiece.classList.contains('white-piece') || 
                                        existingPiece.classList.contains('white-triangle') || 
                                        existingPiece.classList.contains('white-rhombus') ||
                                        existingPiece.classList.contains('white-circle') ||
                                        existingPiece.classList.contains('white-hexgon');
                    
                    // If different colors, capture the opponent piece
                    if (isDraggedWhite !== isExistingWhite) {
                        // Add to eliminated pieces display before removing
                        addToEliminatedPieces(existingPiece);
                        existingPiece.remove(); // Capture the opponent piece
                        // Play captured sound for capture
                        playCapturedSound();
                        didCapture = true;
                        
                        // Reveal attack area in Fog of War mode
                        revealAttackArea(draggedFromHex.id, targetHex.id);
                    }
                }
                
                // Move the piece
                const fromHexId = draggedFromHex.id;
                
                // Preserve triangle or hexgon orientation if it's a rotatable piece
                let preservedOrientation = null;
                let isTriangle = draggedPiece.classList.contains('triangle-piece');
                let isHexgon = draggedPiece.classList.contains('hexgon-piece');
                
                if (isTriangle) {
                    preservedOrientation = getTriangleOrientation(fromHexId);
                    console.log('Preserving triangle orientation:', preservedOrientation, 'from', fromHexId);
                } else if (isHexgon) {
                    preservedOrientation = getHexgonOrientation(fromHexId);
                    console.log('Preserving hexgon orientation:', preservedOrientation, 'from', fromHexId);
                }
                
                draggedPiece.remove();
                    
                const newPiece = document.createElement('div');
                newPiece.className = pieceClasses;
                newPiece.draggable = true;
                targetHex.appendChild(newPiece);
                
                console.log('üéØ Player piece created at:', targetHex.id, 'Classes:', newPiece.className);
                console.log('üéØ Immediately after player move - white rhombuses:', document.querySelectorAll('.rhombus-piece.white-rhombus').length);
                
                // Restore triangle or hexgon orientation if it was preserved
                if (preservedOrientation !== null) {
                    const toHexId = targetHex.id;
                    if (isTriangle) {
                        setTriangleOrientation(toHexId, preservedOrientation);
                        updateTriangleVisual(toHexId);
                        console.log('Restored triangle orientation:', preservedOrientation, 'to', toHexId);
                        
                        // Clean up the old orientation from the source hex
                        triangleOrientations.delete(fromHexId);
                        console.log('Cleaned up old triangle orientation from:', fromHexId);
                    } else if (isHexgon) {
                        setHexgonOrientation(toHexId, preservedOrientation);
                        updateHexgonVisual(toHexId);
                        console.log('Restored hexgon orientation:', preservedOrientation, 'to', toHexId);
                        
                        // Clean up the old orientation from the source hex
                        hexgonOrientations.delete(fromHexId);
                        console.log('Cleaned up old hexgon orientation from:', fromHexId);
                    }
                }
                
                // Broadcast move to multiplayer opponent
                broadcastMove(fromHexId, targetId, pieceClasses, didCapture);
                
                // Update selectedPiece to the new location for triangles and hexagons
                if (newPiece.classList.contains('triangle-piece') || newPiece.classList.contains('hexgon-piece')) {
                    selectedPiece = targetHex;
                    currentTurnPiece = targetHex; // Also update currentTurnPiece for rotatable pieces
                    console.log('Set selectedPiece to targetHex for rotatable piece:', selectedPiece);
                    console.log('Set currentTurnPiece to targetHex for rotatable piece:', currentTurnPiece);
                    // Show rotation controls for rotatable pieces after movement
                    const rotationControls = document.getElementById('rotation-controls');
                    if (rotationControls) {
                        rotationControls.style.display = 'block';
                    }
                }
                
                // Record the move
                const fromHex = draggedFromHex;
                const [, fromRow, fromCol] = fromHex.id.match(/hex-(\d+)-(\d+)/);
                const isWhite = newPiece.classList.contains('white-piece') || 
                               newPiece.classList.contains('white-triangle') || 
                               newPiece.classList.contains('white-rhombus') ||
                               newPiece.classList.contains('white-circle') ||
                               newPiece.classList.contains('white-hexgon');
                const pieceType = newPiece.classList.contains('square-piece') ? 'square' : 
                                 newPiece.classList.contains('triangle-piece') ? 'triangle' : 
                                 newPiece.classList.contains('rhombus-piece') ? 'rhombus' : 
                                 newPiece.classList.contains('circle-piece') ? 'circle' : 'hexgon';
                const isCapture = didCapture;
                
                // Check repetition BEFORE recording move
                const repetitionCount = checkRepetition(parseInt(fromRow), parseInt(fromCol), targetRow, targetCol, pieceType, isWhite, isCapture);
                
                // Record move with repetition count for color-coding
                recordMove(parseInt(fromRow), parseInt(fromCol), targetRow, targetCol, pieceType, isWhite, isCapture, repetitionCount);
                
                // Check position repetition (threefold repetition rule)
                checkPositionRepetition(isWhite);
                
                // Record move in RPN format for export/import (pass hex IDs, not elements)
                recordMoveRPN(fromHex.id, targetHex.id, newPiece, isCapture, false, '');
                
                // Track piece actions for move+rotate vs attack rules
                const toHexId = targetHex.id;
                const actions = pieceActions.get(fromHexId) || {moved: false, attacked: false, rotated: false};
                
                if (isCapture) {
                    actions.attacked = true;
                } else {
                    actions.moved = true;
                }
                
                // Transfer actions to new hex if piece moved
                if (fromHexId !== toHexId) {
                    pieceActions.set(toHexId, actions);
                    pieceActions.delete(fromHexId);
                } else {
                    pieceActions.set(fromHexId, actions);
                }

                // If a RHOMBUS moved from its base, update base defence display immediately
                try {
                    const movedIsRhombus = newPiece.classList.contains('rhombus-piece');
                    if (movedIsRhombus && fromHexId) {
                        const m = fromHexId.match(/hex-(\d+)-(\d+)/);
                        if (m) {
                            const fromR = parseInt(m[1], 10);
                            const fromC = parseInt(m[2], 10);
                            // white base is 3-0, black base is 3-8
                            if ((fromR === 3 && fromC === 0) || (fromR === 3 && fromC === 8)) {
                                // Rhombus left its base ‚Äî refresh indicators
                                updateBaseDefenceDisplay();
                            }
                        }
                    }
                } catch (e) {
                    // ignore UI update failures
                }
                
                // Play click sound
                playClickSound();
                
                // Highlight the last move
                highlightLastMove(fromHexId, toHexId);
                
                // Check ALL pieces on the board to see if they're under attack
                highlightAllPiecesUnderAttack();
                
                // Check for win conditions based on rhombus position
                checkWinConditions(targetRow, targetCol, newPiece);
                
                // CRITICAL: Check for rhombus deadlock/checkmate immediately after move
                // This catches situations where opponent's rhombus is now in checkmate
                if (!gameOver) {
                    checkRhombusDeadlock();
                }
                
                // End turn rules
                if (!gameOver) {
                    // Log board state before ANY turn switch
                    console.log('üìã PLAYER MOVE COMPLETE - Checking board state');
                    console.log('üìã White rhombuses on board:', document.querySelectorAll('.rhombus-piece.white-rhombus').length);
                    console.log('üìã Black rhombuses on board:', document.querySelectorAll('.rhombus-piece:not(.white-rhombus)').length);
                    
                    // Log all white rhombus locations
                    const whiteRhombuses = document.querySelectorAll('.rhombus-piece.white-rhombus');
                    whiteRhombuses.forEach((r, i) => {
                        const parent = r.parentElement;
                        if (parent) {
                            console.log(`üìã White rhombus #${i+1} at:`, parent.id);
                        } else {
                            console.log(`üìã White rhombus #${i+1} has NO PARENT (orphaned piece!)`);
                        }
                    });
                    
                    const blackRhombuses = document.querySelectorAll('.rhombus-piece:not(.white-rhombus)');
                    blackRhombuses.forEach((r, i) => {
                        const parent = r.parentElement;
                        if (parent) {
                            console.log(`üìã Black rhombus #${i+1} at:`, parent.id);
                        } else {
                            console.log(`üìã Black rhombus #${i+1} has NO PARENT (orphaned piece!)`);
                        }
                    });
                    
                    if (isCapture) {
                        console.log('üìã Turn ending due to CAPTURE');
                        switchTurn();
                        updateBaseDefenceDisplay();
                    } else if (!newPiece.classList.contains('triangle-piece') && !newPiece.classList.contains('hexgon-piece')) {
                        // Non-rotatable pieces end the turn automatically
                        console.log('üìã Turn ending - non-rotatable piece moved');
                        switchTurn();
                        updateBaseDefenceDisplay();
                    } else {
                        console.log('üìã Turn NOT ending yet - rotatable piece (triangle/hexagon) can still rotate');
                        console.log('üîç NEW PIECE ANALYSIS at turn-end check:');
                        console.log('  - Classes:', newPiece.className);
                        console.log('  - Has triangle-piece?', newPiece.classList.contains('triangle-piece'));
                        console.log('  - Has hexgon-piece?', newPiece.classList.contains('hexgon-piece'));
                        console.log('  - Has white-triangle?', newPiece.classList.contains('white-triangle'));
                        console.log('  - Has white-hexgon?', newPiece.classList.contains('white-hexgon'));
                        console.log('  - Parent hex:', newPiece.parentElement ? newPiece.parentElement.id : 'NO PARENT');
                    } // triangles and hexagons end turn via rotation/KEEP flow
                }

                // Push to move history for undo
                // Capture metadata for undo: remove one eliminated entry by id
                let capturedHTML = null;
                if (isCapture && existingPiece) {
                    const elimId = existingPiece.getAttribute('data-eliminated-id');
                    capturedHTML = JSON.stringify({html: existingPiece.outerHTML, elimId});
                }
                moveHistory.push({
                    fromId: fromHex.id,
                    toId: targetHex.id,
                    pieceClass: pieceClasses,
                    capturedHTML: capturedHTML,
                    endedTurn: isCapture || (!newPiece.classList.contains('triangle-piece') && !newPiece.classList.contains('hexgon-piece')),
                    isTriangle: newPiece.classList.contains('triangle-piece'),
                    isHexgon: newPiece.classList.contains('hexgon-piece')
                });

                // Re-add drag event listeners to the new piece
                newPiece.addEventListener('dragstart', function(e) {
                    // Check if it's the current player's turn and piece
                    if (gameOver || !isCurrentPlayerPiece(this)) {
                        e.preventDefault(); // Prevent drag if not current player's turn
                        return;
                    }

                    // Check if another piece is already active this turn
                    if (currentTurnPiece && currentTurnPiece !== this.parentElement) {
                        e.preventDefault(); // Prevent drag if another piece is already active
                        alert('You can only move or rotate one piece per turn!');
                        return;
                    }

                    draggedPiece = this;
                    draggedFromHex = this.parentElement;
                    selectedPiece = this.parentElement; // Set selected piece for rotation controls
                    currentTurnPiece = this.parentElement; // Mark this piece as active for the turn
                    console.log('Set currentTurnPiece to:', currentTurnPiece.id);
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/html', this.outerHTML);
                    
                    // Show rotation controls if this is a triangle or hexagon, hide if not
                    const rotationControls = document.getElementById('rotation-controls');
                    console.log('Rotation controls element:', rotationControls);
                    if (rotationControls) {
                        if (this.classList.contains('triangle-piece') || this.classList.contains('hexgon-piece')) {
                            console.log('Showing rotation controls for rotatable piece');
                            rotationControls.style.display = 'block';
                } else {
                            console.log('Hiding rotation controls for non-rotatable piece');
                            rotationControls.style.display = 'none';
                        }
                    } else {
                        console.log('Rotation controls element not found!');
                    }
                    
                    // Show movement pattern
                    const hexId = this.parentElement.id;
                    const [, row, col] = hexId.match(/hex-(\d+)-(\d+)/);
                    
                    console.log(`üé¨ DRAGSTART showing movement for piece at ${hexId}`);
                    console.log(`üé¨ Piece classes:`, this.className);
                    console.log(`üé¨ Is circle?`, this.classList.contains('circle-piece'));
                    console.log(`üé¨ Is hexgon?`, this.classList.contains('hexgon-piece'));
                    console.log(`üé¨ Is triangle?`, this.classList.contains('triangle-piece'));
                    console.log(`üé¨ Is rhombus?`, this.classList.contains('rhombus-piece'));
                    
                    if (this.classList.contains('circle-piece')) {
                        console.log(`üé¨ Calling showCircleMovementPattern`);
                        showCircleMovementPattern(parseInt(row), parseInt(col));
                    } else if (this.classList.contains('hexgon-piece')) {
                        console.log(`üé¨ Calling showHexgonMovementPattern`);
                        showHexgonMovementPattern(parseInt(row), parseInt(col));
                    } else if (this.classList.contains('triangle-piece')) {
                        console.log(`üé¨ Calling showTriangleMovementPattern`);
                        // Both white and black triangles use the same rotation-aware movement system
                        showTriangleMovementPattern(parseInt(row), parseInt(col));
                    } else if (this.classList.contains('rhombus-piece')) {
                        console.log(`üé¨ Calling showRhombusMovementPattern`);
                        showRhombusMovementPattern(parseInt(row), parseInt(col));
                    } else {
                        console.log(`üé¨ Calling showSquareMovementPattern`);
                        showSquareMovementPattern(parseInt(row), parseInt(col));
                    }
                });
                
                newPiece.addEventListener('dragend', function(e) {
                    // Clear highlights when drag ends (but keep threat highlights)
                    document.querySelectorAll('.hexagon').forEach(hex => {
                        hex.classList.remove('highlight-green', 'highlight-red', 'highlight-danger', 'highlight-diagonal', 'highlight-gray');
                    });
                    draggedPiece = null;
                    draggedFromHex = null;
                    
                    // Clear selectedPiece and rotation controls for non-rotatable pieces
                    if (!this.classList.contains('triangle-piece') && !this.classList.contains('hexgon-piece')) {
                    selectedPiece = null;
                        currentTurnPiece = null; // Clear current turn piece for non-rotatable pieces
                        console.log('Cleared currentTurnPiece in dragend');
                        const rotationControls = document.getElementById('rotation-controls');
                        if (rotationControls) {
                            rotationControls.style.display = 'none';
                        }
                    }
                    // For rotatable pieces (triangles and hexagons), selectedPiece is set in the drop event, not here
                });
                
                // Clear highlights (but keep threat highlights)
                    document.querySelectorAll('.hexagon').forEach(hex => {
                        hex.classList.remove('highlight-green', 'highlight-red', 'highlight-danger', 'highlight-diagonal', 'highlight-gray');
                    });
            });
        });

        // Function to show movement pattern for hexgon pieces (row-specific mapping)
        function showHexgonMovementPattern(centerRow, centerCol) {
            console.log(`üéØ showHexgonMovementPattern called: centerRow=${centerRow}, centerCol=${centerCol}`);
            
            // Clear any existing highlights (but keep threat highlights)
            document.querySelectorAll('.hexagon').forEach(hex => {
                hex.classList.remove('highlight-green', 'highlight-red', 'highlight-danger', 'highlight-diagonal', 'highlight-gray');
            });

            // Get hexgon orientation for rotation-aware movement
            const hexId = `hex-${centerRow}-${centerCol}`;
            const orientation = getHexgonOrientation(hexId);
            console.log(`üéØ Hexgon orientation: ${orientation}`);
            
            // Determine if it's white or black hexgon
            const hexgon = document.querySelector(`#${hexId} .hexgon-piece`);
            const isWhite = hexgon && (hexgon.classList.contains('white-hexgon') || hexgon.classList.contains('white-piece'));
            console.log(`üéØ Hexgon isWhite: ${isWhite}`);
            
            // Get rotation-aware movement pattern
            const targets = getRotatedHexgonTargets(centerRow, centerCol, orientation, isWhite);
            console.log(`üéØ Rotated targets:`, targets);

            // Get friendly and opponent piece types based on hexgon color
            let friendlyPieceTypes, opponentPieceTypes;
            const centerHex = document.getElementById(`hex-${centerRow}-${centerCol}`);
            const centerPiece = centerHex.querySelector('.hexgon-piece');
            
            if (centerPiece && centerPiece.classList.contains('white-hexgon')) {
                // White hexgon - friendly with white pieces, opponent with black pieces
                friendlyPieceTypes = ['.square-piece.white-piece', '.triangle-piece.white-triangle', '.rhombus-piece.white-rhombus', '.circle-piece.white-circle', '.hexgon-piece.white-hexgon'];
                opponentPieceTypes = ['.square-piece:not(.white-piece)', '.triangle-piece:not(.white-triangle)', '.rhombus-piece:not(.white-rhombus)', '.circle-piece:not(.white-circle)', '.hexgon-piece:not(.white-hexgon)'];
            } else {
                // Black hexgon - friendly with black pieces, opponent with white pieces
                friendlyPieceTypes = ['.square-piece:not(.white-piece)', '.triangle-piece:not(.white-triangle)', '.rhombus-piece:not(.white-rhombus)', '.circle-piece:not(.white-circle)', '.hexgon-piece:not(.white-hexgon)'];
                opponentPieceTypes = ['.square-piece.white-piece', '.triangle-piece.white-triangle', '.rhombus-piece.white-rhombus', '.circle-piece.white-circle', '.hexgon-piece.white-hexgon'];
            }

            // Highlight targets using rotation-aware movement pattern
            targets.forEach(([targetRow, targetCol]) => {
                const targetHex = document.getElementById(`hex-${targetRow}-${targetCol}`);
                if (!targetHex) return;
                
                // Check if target hex has a friendly piece
                let hasFriendlyPiece = false;
                friendlyPieceTypes.forEach(selector => {
                    if (targetHex.querySelector(selector)) {
                        hasFriendlyPiece = true;
                    }
                });
                
                // Check if target hex has an opponent piece
                let hasOpponentPiece = false;
                opponentPieceTypes.forEach(selector => {
                    if (targetHex.querySelector(selector)) {
                        hasOpponentPiece = true;
                    }
                });
                
                // Highlight in red if opponent piece, gray if friendly, green if empty, danger if vulnerable
                if (hasOpponentPiece) {
                    targetHex.classList.add('highlight-red');
                } else if (hasFriendlyPiece) {
                    targetHex.classList.add('highlight-gray');
                } else {
                    // Check if this position would be vulnerable to attack
                    if (isPositionVulnerable(targetRow, targetCol, isWhite)) {
                        targetHex.classList.add('highlight-danger');
                    } else {
                        targetHex.classList.add('highlight-green');
                    }
                }
            });
        }

        // ============================================
        // ROMGON POSITION NOTATION (RPN) SYSTEM
        // ============================================
        
        // Track move history for RPN game export (separate from undo moveHistory)
        // let rpnMoveHistory = []; // Moved to global scope above
        
        let gameMetadata = {
            white: 'Player 1',
            black: 'Player 2 (AI)',
            date: new Date().toISOString().split('T')[0],
            result: '*'
        };

        // Helper: Convert piece element to notation character
        function pieceToChar(pieceElement) {
            if (!pieceElement) return null;
            
            const isWhite = pieceElement.classList.contains('white-piece') ||
                          pieceElement.classList.contains('white-triangle') ||
                          pieceElement.classList.contains('white-rhombus') ||
                          pieceElement.classList.contains('white-circle') ||
                          pieceElement.classList.contains('white-hexgon');
            
            let char = '';
            
            if (pieceElement.classList.contains('square-piece')) {
                char = isWhite ? 'S' : 's';
            } else if (pieceElement.classList.contains('triangle-piece')) {
                char = isWhite ? 'T' : 't';
            } else if (pieceElement.classList.contains('rhombus-piece')) {
                char = isWhite ? 'R' : 'r';
            } else if (pieceElement.classList.contains('circle-piece')) {
                char = isWhite ? 'C' : 'c';
            } else if (pieceElement.classList.contains('hexgon-piece')) {
                char = isWhite ? 'H' : 'h';
            }
            
            return char;
        }

        // Helper: Get rotation state for triangle/hexagon
        function getPieceRotation(hexId, pieceType) {
            if (pieceType === 'T' || pieceType === 't') {
                return triangleOrientations.get(hexId) || 0;
            } else if (pieceType === 'H' || pieceType === 'h') {
                return hexgonOrientations.get(hexId) || 0;
            }
            return null;
        }

        // Helper: Convert notation character to piece classes
        function charToPiece(char, rotation = 0) {
            const isUpper = char === char.toUpperCase();
            
            const charUpper = char.toUpperCase();
            let baseClass = '';
            let specificClass = '';
            
            switch(charUpper) {
                case 'S':
                    baseClass = 'square-piece';
                    specificClass = isUpper ? 'white-piece' : '';
                    break;
                case 'T':
                    baseClass = 'triangle-piece';
                    specificClass = isUpper ? 'white-triangle' : '';
                    break;
                case 'R':
                    baseClass = 'rhombus-piece';
                    specificClass = isUpper ? 'white-rhombus' : '';
                    break;
                case 'C':
                    baseClass = 'circle-piece';
                    specificClass = isUpper ? 'white-circle' : '';
                    break;
                case 'H':
                    baseClass = 'hexgon-piece';
                    specificClass = isUpper ? 'white-hexgon' : '';
                    break;
                default:
                    return null;
            }
            
            return {
                baseClass,
                specificClass,
                rotation: rotation
            };
        }

        // Export current board position to RPN format
        function exportPositionRPN() {
            console.log('üîç === STARTING RPN EXPORT ===');
            console.log('üìã Board flipped state:', boardFlipped);
            console.log('üìã Current player:', currentPlayer);
            
            const boardRows = [
                [0, 6],   // Row 0: 0-0 to 0-5 (6 hexes)
                [1, 7],   // Row 1: 1-0 to 1-6 (7 hexes)
                [2, 8],   // Row 2: 2-0 to 2-7 (8 hexes)
                [3, 9],   // Row 3: 3-0 to 3-8 (9 hexes)
                [4, 8],   // Row 4: 4-0 to 4-7 (8 hexes)
                [5, 7],   // Row 5: 5-0 to 5-6 (7 hexes)
                [6, 6]    // Row 6: 6-0 to 6-5 (6 hexes)
            ];
            
            let rpnParts = [];
            let totalPiecesFound = 0;
            
            // Build board notation
            for (const [rowNum, hexCount] of boardRows) {
                let rowNotation = '';
                let emptyCount = 0;
                let piecesInRow = 0;
                
                for (let col = 0; col < hexCount; col++) {
                    const hexId = `hex-${rowNum}-${col}`;
                    const hex = document.getElementById(hexId);
                    
                    if (!hex) {
                        console.warn(`‚ö†Ô∏è Hex not found: ${hexId}`);
                        emptyCount++;
                        continue;
                    }
                    
                    const piece = hex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                    
                    // Check if piece exists and is visible
                    let isValidPiece = false;
                    if (piece) {
                        const isHidden = piece.style.display === 'none' || piece.hasAttribute('data-temp-simulation');
                        const isWhite = piece.classList.contains('white-piece') || 
                                      piece.classList.contains('white-triangle') || 
                                      piece.classList.contains('white-rhombus') || 
                                      piece.classList.contains('white-circle') || 
                                      piece.classList.contains('white-hexgon');
                        const color = isWhite ? 'WHITE' : 'BLACK';
                        console.log(`‚úÖ Found ${color} piece at ${hexId}:`, piece.className, isHidden ? '(HIDDEN - TREATED AS EMPTY)' : '(VISIBLE)');
                        
                        if (!isHidden) {
                            isValidPiece = true;
                            piecesInRow++;
                            totalPiecesFound++;
                        } else {
                            console.warn(`‚ö†Ô∏è Treating hidden piece at ${hexId} as empty space`);
                        }
                    }
                    
                    if (!isValidPiece) {
                        emptyCount++;
                    } else {
                        // Add any accumulated empty spaces
                        if (emptyCount > 0) {
                            rowNotation += emptyCount;
                            emptyCount = 0;
                        }
                        
                        // Add piece notation
                        const char = pieceToChar(piece);
                        console.log(`  ‚Üí pieceToChar returned: "${char}" for ${hexId}`);
                        if (char) {
                            rowNotation += char;
                            
                            // Add rotation for triangles and hexagons (ALWAYS include, even if 0, for unambiguous parsing)
                            if (char === 'T' || char === 't' || char === 'H' || char === 'h') {
                                const rotation = getPieceRotation(hexId, char) || 0;
                                rowNotation += rotation;
                            }
                        } else {
                            console.error(`‚ùå pieceToChar returned null for piece at ${hexId}:`, piece.className);
                        }
                    }
                }
                
                console.log(`üìä Row ${rowNum}: Found ${piecesInRow} pieces, notation: "${rowNotation}"`);
                
                // Add final empty count if row ends with empty spaces
                if (emptyCount > 0) {
                    rowNotation += emptyCount;
                }
                
                // If entire row is empty, use the hex count
                if (rowNotation === '') {
                    rowNotation = hexCount.toString();
                }
                
                rpnParts.push(rowNotation);
            }
            
            console.log(`üìä TOTAL PIECES FOUND: ${totalPiecesFound}`);
            console.log('üìã RPN Parts:', rpnParts);
            
            // Add metadata
            const activePlayer = currentPlayer === 'white' ? 'w' : 'b';
            const moveCount = Math.floor(window.rpnMoveHistory.length / 2);
            
            // Build captured pieces notation
            const capturedWhite = capturedWhitePieces.join('') || '-';
            const capturedBlack = capturedBlackPieces.join('') || '-';
            
            // Build piece action states (format: hexId:actions,hexId:actions,...)
            // actions: m=moved, a=attacked, r=rotated
            let actionStates = [];
            for (const [hexId, actions] of pieceActions.entries()) {
                const actionChars = [];
                if (actions.moved) actionChars.push('m');
                if (actions.attacked) actionChars.push('a');
                if (actions.rotated) actionChars.push('r');
                if (actionChars.length > 0) {
                    actionStates.push(`${hexId}:${actionChars.join('')}`);
                }
            }
            const actionStateStr = actionStates.length > 0 ? actionStates.join(',') : '-';
            
            // Build move history (format: move1;move2;move3...)
            const moveHistoryStr = window.rpnMoveHistory.length > 0 
                ? window.rpnMoveHistory.map(m => m.notation).join(';') 
                : '-';
            
            // Get base defence state (format: w|b|wb|-)
            // w = white defending, b = black defending, wb = both, - = neither
            const activeDefences = isBaseDefenceActive();
            const baseDefenceStr = activeDefences.length > 0 ? activeDefences.join('') : '-';
            
            // Get current turn piece (which piece is mid-turn for multi-actions)
            // Format: hex-3-0 or - if no active piece
            const activePieceStr = currentTurnPiece ? currentTurnPiece : '-';
            
            // Get timer state (format: whiteSeconds:blackSeconds or - if no timer)
            // Example: 595:600 means white has 9:55 left, black has 10:00 left
            const timerStr = timerInterval ? `${whiteTimeLeft}:${blackTimeLeft}` : '-';
            
            // Combine into full RPN with all data
            // Format: board activePlayer moveCount capturedWhite capturedBlack actionStates moveHistory baseDefence activePiece timer
            const rpn = `${rpnParts.join('/')} ${activePlayer} ${moveCount} ${capturedWhite} ${capturedBlack} ${actionStateStr} ${moveHistoryStr} ${baseDefenceStr} ${activePieceStr} ${timerStr}`;
            
            console.log('üéØ FINAL RPN STRING:', rpn);
            console.log(`üì¶ Captured White: ${capturedWhite}, Captured Black: ${capturedBlack}`);
            console.log(`‚ö° Action States: ${actionStateStr}`);
            console.log(`üìú Move History: ${moveHistoryStr.substring(0, 100)}${moveHistoryStr.length > 100 ? '...' : ''}`);
            // Base Defence log removed
            console.log(`üé≤ Active Piece: ${activePieceStr}`);
            console.log(`‚è±Ô∏è Timer State: ${timerStr}`);
            console.log('üîç === RPN EXPORT COMPLETE ===');
            
            return rpn;
        }

        // Rebuild move display panels from rpnMoveHistory
        function rebuildMoveDisplay() {
            console.log('üîÑ Rebuilding move display from history...');
            
            // Clear both move panels
            const whiteMovesList = document.getElementById('white-moves');
            const blackMovesList = document.getElementById('black-moves');
            
            if (whiteMovesList) whiteMovesList.innerHTML = '';
            if (blackMovesList) blackMovesList.innerHTML = '';
            
            // Helper to convert piece char to symbol
            const pieceCharToSymbol = (char) => {
                const upper = char.toUpperCase();
                if (upper === 'S') return '‚ñ†';
                if (upper === 'T') return '‚ñ≤';
                if (upper === 'R') return '‚óÜ';
                if (upper === 'C') return '‚óè';
                if (upper === 'H') return '‚¨°';
                return '?';
            };
            
            // Helper to parse notation like "C2-0>3-1x" or "r3-8>3-6"
            const parseNotation = (notation) => {
                const match = notation.match(/^([STRCHstrch])(\d+-\d+)>(\d+-\d+)(x)?/);
                if (!match) return null;
                
                const [, pieceChar, fromCoord, toCoord, captureFlag] = match;
                const [fromRow, fromCol] = fromCoord.split('-');
                const [toRow, toCol] = toCoord.split('-');
                
                return {
                    pieceChar,
                    fromRow,
                    fromCol,
                    toRow,
                    toCol,
                    isCapture: !!captureFlag
                };
            };
            
            // Rebuild from rpnMoveHistory
            let moveNumber = 1;
            for (let i = 0; i < window.rpnMoveHistory.length; i++) {
                const move = window.rpnMoveHistory[i];
                const isWhiteMove = i % 2 === 1;
                const moveList = isWhiteMove ? whiteMovesList : blackMovesList;

                if (moveList) {
                    const parsed = parseNotation(move.notation);
                    if (parsed) {
                        const li = document.createElement('li');
                        li.className = `movement-item ${isWhiteMove ? 'white-move' : 'black-move'}`;

                        const pieceSymbol = pieceCharToSymbol(parsed.pieceChar);
                        const captureText = parsed.isCapture ? ' (capture)' : '';

                        // Match the format from recordMove(): "1. ‚ñ† 3-8 ‚Üí 3-6 (capture)"
                        li.textContent = `${moveNumber}. ${pieceSymbol} ${parsed.fromRow}-${parsed.fromCol} ‚Üí ${parsed.toRow}-${parsed.toCol}${captureText}`;

                        moveList.appendChild(li);

                        if (isWhiteMove) moveNumber++;
                    }
                }
            }
            
            // Auto-scroll to bottom
            if (whiteMovesList) whiteMovesList.scrollTop = whiteMovesList.scrollHeight;
            if (blackMovesList) blackMovesList.scrollTop = blackMovesList.scrollHeight;
            
            console.log(`   Rebuilt ${rpnMoveHistory.length} moves in display panels`);
        }

        // Import board position from RPN format
        function importPositionRPN(rpnString) {
            try {
                // Parse RPN string
                const parts = rpnString.trim().split(' ');
                if (parts.length < 2) {
                    throw new Error('Invalid RPN format: missing components');
                }
                
                const boardNotation = parts[0];
                const activePlayer = parts[1];
                const capturedWhiteStr = parts.length >= 4 ? parts[3] : '-';
                const capturedBlackStr = parts.length >= 5 ? parts[4] : '-';
                const actionStatesStr = parts.length >= 6 ? parts[5] : '-';
                const moveHistoryStr = parts.length >= 7 ? parts[6] : '-';
                const baseDefenceStr = parts.length >= 8 ? parts[7] : '-';
                const activePieceStr = parts.length >= 9 ? parts[8] : '-';
                const timerStr = parts.length >= 10 ? parts[9] : '-';
                
                console.log('üì• Importing RPN with extended data:');
                console.log(`   Captured White: ${capturedWhiteStr}`);
                console.log(`   Captured Black: ${capturedBlackStr}`);
                console.log(`   Action States: ${actionStatesStr}`);
                console.log(`   Move History: ${moveHistoryStr.substring(0, 100)}${moveHistoryStr.length > 100 ? '...' : ''}`);
                console.log(`   Base Defence: ${baseDefenceStr}`);
                console.log(`   Active Piece: ${activePieceStr}`);
                console.log(`   Timer State: ${timerStr}`);
                
                // Clear current board
                clearBoard();
                
                // Reset orientations
                triangleOrientations.clear();
                hexgonOrientations.clear();
                
                // Clear captured pieces arrays
                capturedWhitePieces.length = 0;
                capturedBlackPieces.length = 0;
                
                // Clear piece actions
                pieceActions.clear();
                
                // Clear move history
                rpnMoveHistory.length = 0;
                
                // Parse rows
                const rows = boardNotation.split('/');
                if (rows.length !== 7) {
                    throw new Error('Invalid RPN format: must have 7 rows');
                }
                
                const boardRows = [
                    [0, 6],   // Row 0: 0-0 to 0-5
                    [1, 7],   // Row 1: 1-0 to 1-6
                    [2, 8],   // Row 2: 2-0 to 2-7
                    [3, 9],   // Row 3: 3-0 to 3-8
                    [4, 8],   // Row 4: 4-0 to 4-7
                    [5, 7],   // Row 5: 5-0 to 5-6
                    [6, 6]    // Row 6: 6-0 to 6-5
                ];
                
                // Process each row
                for (let i = 0; i < rows.length; i++) {
                    const rowNotation = rows[i];
                    const [rowNum, hexCount] = boardRows[i];
                    let col = 0;
                    let j = 0;
                    
                    console.log(`\nüì• Importing Row ${rowNum}: "${rowNotation}" (${hexCount} hexes total)`);
                    
                    while (j < rowNotation.length && col < hexCount) {
                        const char = rowNotation[j];
                        
                        // Check if it's a number (empty spaces)
                        if (!isNaN(char)) {
                            const skipCount = parseInt(char);
                            console.log(`  [j=${j}, col=${col}] Digit '${char}' ‚Üí Skip ${skipCount} spaces, new col=${col + skipCount}`);
                            col += skipCount;
                            j++;
                        } else {
                            // It's a piece
                            const hexId = `hex-${rowNum}-${col}`;
                            const hex = document.getElementById(hexId);
                            
                            console.log(`  [j=${j}, col=${col}] Letter '${char}' ‚Üí Piece at ${hexId}`);
                            
                            if (hex) {
                                // Check for rotation (ALWAYS present for T/t/H/h pieces)
                                let rotation = 0;
                                const isRotatablePiece = (char === 'T' || char === 't' || char === 'H' || char === 'h');
                                
                                if (isRotatablePiece) {
                                    // MUST have a rotation digit next
                                    if (j + 1 < rowNotation.length && !isNaN(rowNotation[j + 1])) {
                                        rotation = parseInt(rowNotation[j + 1]);
                                        console.log(`    ‚Üí Has rotation: ${rotation} (next char: '${rowNotation[j + 1]}')`);
                                        j++; // Skip rotation digit
                                    } else {
                                        console.error(`    ‚ùå ERROR: T/H piece missing rotation digit!`);
                                    }
                                }
                                
                                // Create piece
                                const pieceData = charToPiece(char, rotation);
                                if (pieceData) {
                                    const piece = document.createElement('div');
                                    piece.className = pieceData.baseClass;
                                    if (pieceData.specificClass) {
                                        piece.classList.add(pieceData.specificClass);
                                    }
                                    piece.draggable = true;
                                    
                                    hex.appendChild(piece);
                                    console.log(`    ‚úÖ Created ${pieceData.baseClass} ${pieceData.specificClass || ''}`);
                                    
                                    // Set rotation if applicable
                                    if ((char === 'T' || char === 't' || char === 'H' || char === 'h') && rotation > 0) {
                                        if (char === 'T' || char === 't') {
                                            setTriangleOrientation(hexId, rotation);
                                            // CRITICAL: Always include translate(-50%, -50%) for centering!
                                            const angleMap = [270, 330, 30, 90, 150, 210];
                                            const rotationDeg = angleMap[rotation % 6];
                                            piece.style.transform = `translate(-50%, -50%) rotate(${rotationDeg}deg)`;
                                        } else if (char === 'H' || char === 'h') {
                                            setHexgonOrientation(hexId, rotation);
                                            // CRITICAL: Always include translate(-50%, -50%) for centering!
                                            const angleMap = [0, 60, 120, 180, 240, 300];
                                            const rotationDeg = angleMap[rotation % 6];
                                            piece.style.transform = `translate(-50%, -50%) rotate(90deg) rotate(${rotationDeg}deg)`;
                                        }
                                    }
                                } else {
                                    console.error(`    ‚ùå charToPiece returned null for '${char}'`);
                                }
                            } else {
                                console.error(`    ‚ùå Hex ${hexId} not found in DOM`);
                            }
                            
                            col++;
                            j++;
                        }
                    }
                    console.log(`  ‚úÖ Row ${rowNum} complete: processed ${j} characters, placed pieces up to col ${col - 1}`);
                }
                
                // Set game state
                currentPlayer = activePlayer === 'w' ? 'white' : 'black';
                gameOver = false;
                
                // Restore captured pieces
                console.log(`üì¶ Restoring captured pieces: White="${capturedWhiteStr}", Black="${capturedBlackStr}"`);
                if (capturedWhiteStr && capturedWhiteStr !== '-') {
                    for (const char of capturedWhiteStr) {
                        capturedWhitePieces.push(char);
                        addCapturedPieceToDisplay(char, true);
                    }
                }
                if (capturedBlackStr && capturedBlackStr !== '-') {
                    for (const char of capturedBlackStr) {
                        capturedBlackPieces.push(char);
                        addCapturedPieceToDisplay(char, false);
                    }
                }
                
                // Restore piece action states
                console.log(`‚ö° Restoring action states: ${actionStatesStr}`);
                if (actionStatesStr && actionStatesStr !== '-') {
                    const actionEntries = actionStatesStr.split(',');
                    for (const entry of actionEntries) {
                        const [hexId, actions] = entry.split(':');
                        if (hexId && actions) {
                            pieceActions.set(hexId, {
                                moved: actions.includes('m'),
                                attacked: actions.includes('a'),
                                rotated: actions.includes('r')
                            });
                            console.log(`   ${hexId}: moved=${actions.includes('m')}, attacked=${actions.includes('a')}, rotated=${actions.includes('r')}`);
                        }
                    }
                }
                
                // Restore move history
                console.log(`üìú Restoring move history: ${moveHistoryStr.substring(0, 50)}...`);
                if (moveHistoryStr && moveHistoryStr !== '-') {
                    const moves = moveHistoryStr.split(';');
                    for (let i = 0; i < moves.length; i++) {
                        const moveNotation = moves[i];
                        if (moveNotation) {
                            rpnMoveHistory.push({
                                notation: moveNotation,
                                player: i % 2 === 0 ? 'black' : 'white',
                                timestamp: new Date().toISOString()
                            });
                        }
                    }
                    console.log(`   Restored ${rpnMoveHistory.length} moves`);
                    // Rebuild move display panels
                    rebuildMoveDisplay();
                }
                
                // Restore active piece (for multi-action turns)
                console.log(`üé≤ Restoring active piece: ${activePieceStr}`);
                if (activePieceStr && activePieceStr !== '-') {
                    currentTurnPiece = activePieceStr;
                    console.log(`   Current turn piece set to: ${currentTurnPiece}`);
                } else {
                    currentTurnPiece = null;
                    console.log(`   No active piece this turn`);
                }
                
                // Restore timer state
                console.log(`‚è±Ô∏è Restoring timer state: ${timerStr}`);
                if (timerStr && timerStr !== '-') {
                    const [whiteTime, blackTime] = timerStr.split(':').map(t => parseInt(t));
                    if (!isNaN(whiteTime) && !isNaN(blackTime)) {
                        whiteTimeLeft = whiteTime;
                        blackTimeLeft = blackTime;
                        console.log(`   White time: ${whiteTime}s, Black time: ${blackTime}s`);
                        
                        // Show timer display
                        const timerContainer = document.getElementById('player-timers');
                        if (timerContainer) {
                            timerContainer.style.display = 'flex';
                        }
                        
                        // Start the timer (it will auto-pause if needed)
                        if (!timerInterval) {
                            startTimer();
                        }
                        
                        // Update the display immediately
                        updateTimerDisplay();
                    }
                } else {
                    console.log(`   No timer active`);
                }
                
                // Re-setup drag and drop
                setupDragAndDrop();
                
                // Update display
                updateTurnDisplay();
                highlightThreatenedPieces();
                
                // Update base defence display (will show correct state based on board position)
                updateBaseDefenceDisplay();
                
                console.log('‚úÖ Position imported successfully from RPN');
                return true;
                
            } catch (error) {
                console.error('‚ùå Error importing RPN:', error);
                alert('Error importing position: ' + error.message);
                return false;
            }
        }

        // Validate RPN format
        function validateRPN(rpnString) {
            try {
                const parts = rpnString.trim().split(' ');
                if (parts.length < 2) return false;
                
                const boardNotation = parts[0];
                const rows = boardNotation.split('/');
                
                return rows.length === 7;
            } catch {
                return false;
            }
        }

        // Convert move to RMN (Romgon Move Notation)
        function moveToNotation(fromHex, toHex, piece, captured = false, rotated = false, special = '') {
            const pieceChar = pieceToChar(piece);
            if (!pieceChar) return null;
            
            const fromCoord = fromHex.replace('hex-', '');
            const toCoord = toHex.replace('hex-', '');
            
            let notation = `${pieceChar}${fromCoord}>${toCoord}`;
            
            if (captured) notation += 'x';
            if (rotated) notation += '@';
            if (special === 'diagonal') notation += 'd';
            
            return notation;
        }

        // Record a move in history
        function recordMoveRPN(fromHex, toHex, piece, captured = false, rotated = false, special = '') {
            const notation = moveToNotation(fromHex, toHex, piece, captured, rotated, special);
            console.log(`üìù recordMoveRPN called: ${fromHex} -> ${toHex}, notation: ${notation}`);
            if (notation) {
                rpnMoveHistory.push({
                    notation: notation,
                    player: currentPlayer,
                    timestamp: new Date().toISOString()
                });
                console.log(`   ‚úÖ Move recorded. Total moves: ${rpnMoveHistory.length}`);
                // Update opening display immediately after recording a move
                try { alwaysUpdateOpeningDisplay(); } catch (e) { /* ignore */ }
            } else {
                console.warn('   ‚ö†Ô∏è No notation generated, move not recorded');
            }
        }

        // Export full game in RMN format
        function exportGameRMN() {
            let output = '';
            
            // Add metadata
            output += `[White "${gameMetadata.white}"]\n`;
            output += `[Black "${gameMetadata.black}"]\n`;
            output += `[Date "${gameMetadata.date}"]\n`;
            output += `[Result "${gameMetadata.result}"]\n`;
            
            // Add starting position in RPN format (for game reconstruction)
            // Standard starting position with rotation numbers for triangles and hexagons
            const startingPosition = 'S4s/T05t0/C6h0/R7r/H06c/t05T0/s4S';
            output += `[StartPosition "${startingPosition}"]\n`;
            output += '\n';
            
            // Add moves (or note if no moves)
            if (rpnMoveHistory.length === 0) {
                output += '(No moves played yet - starting position)\n';
            } else {
                let moveNumber = 1;
                for (let i = 0; i < rpnMoveHistory.length; i += 2) {
                    const whiteMove = rpnMoveHistory[i] ? rpnMoveHistory[i].notation : '';
                    const blackMove = rpnMoveHistory[i + 1] ? rpnMoveHistory[i + 1].notation : '';
                    
                    output += `${moveNumber}. ${whiteMove}`;
                    if (blackMove) {
                        output += ` ${blackMove}`;
                    }
                    output += '\n';
                    moveNumber++;
                }
            }
            
            // Add result
            output += '\n' + gameMetadata.result;
            
            return output;
        }

        // Copy position to clipboard
        async function copyPositionToClipboard() {
            try {
                const rpn = exportPositionRPN();
                await navigator.clipboard.writeText(rpn);
                
                // Show feedback
                showNotification('‚úÖ Position copied to clipboard!', 'success');
                console.log('üìã RPN copied:', rpn);
            } catch (error) {
                console.error('‚ùå Error copying to clipboard:', error);
                alert('Error copying position: ' + error.message);
            }
        }

        // Show notification message
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 120px;
                right: 20px;
                background: ${type === 'success' ? '#4ecdc4' : type === 'error' ? '#ff6b6b' : '#555'};
                color: white;
                padding: 15px 25px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 10001;
                font-weight: 600;
                animation: slideIn 0.3s ease;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        // Open load position modal
        function openLoadPositionModal() {
            let modal = document.getElementById('load-position-modal');
            if (!modal) {
                modal = createLoadPositionModal();
            }
            modal.style.display = 'flex';
        }

        // Create load position modal
        function createLoadPositionModal() {
            const modal = document.createElement('div');
            modal.id = 'load-position-modal';
            modal.style.cssText = `
                display: none;
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.9);
                z-index: 10000;
                justify-content: center;
                align-items: center;
            `;
            
            modal.innerHTML = `
                <div style="background: #262421; border: 3px solid #4ecdc4; border-radius: 20px; padding: 40px; max-width: 600px; width: 90%;">
                    <h2 style="color: #4ecdc4; text-align: center; margin-bottom: 20px;">üì• Load Position</h2>
                    <p style="color: #ccc; margin-bottom: 15px; text-align: center;">Paste RPN (Romgon Position Notation) string:</p>
                    
                    <textarea id="rpn-input" style="
                        width: 100%;
                        height: 120px;
                        background: #1a1a1a;
                        color: #4ecdc4;
                        border: 2px solid #4ecdc4;
                        border-radius: 8px;
                        padding: 10px;
                        font-family: 'Courier New', monospace;
                        font-size: 0.9em;
                        resize: vertical;
                        margin-bottom: 20px;
                    " placeholder="Example: SSSSS/t0t0t0t0t0t0/6/r2R3/6/T0T0T0T0T0T0/sssss w 0 ----"></textarea>
                    
                    <div style="display: flex; gap: 10px;">
                        <button onclick="loadPositionFromInput()" style="
                            flex: 1;
                            background: #4ecdc4;
                            color: white;
                            border: none;
                            padding: 12px;
                            border-radius: 8px;
                            cursor: pointer;
                            font-weight: 600;
                            font-size: 1em;
                        ">‚úÖ Load Position</button>
                        <button onclick="closeLoadPositionModal()" style="
                            flex: 1;
                            background: #555;
                            color: white;
                            border: none;
                            padding: 12px;
                            border-radius: 8px;
                            cursor: pointer;
                            font-weight: 600;
                            font-size: 1em;
                        ">‚ùå Cancel</button>
                    </div>
                    
                    <div style="margin-top: 20px; padding: 15px; background: rgba(78, 205, 196, 0.1); border-radius: 8px; border-left: 4px solid #4ecdc4;">
                        <p style="color: #4ecdc4; margin: 0; font-size: 0.9em; font-weight: 600;">üí° Current Position RPN:</p>
                        <code id="current-rpn-display" style="
                            display: block;
                            margin-top: 8px;
                            color: #fff;
                            font-size: 0.85em;
                            word-break: break-all;
                            background: #1a1a1a;
                            padding: 8px;
                            border-radius: 4px;
                        ">Loading...</code>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Update current RPN display
            setTimeout(() => {
                const display = document.getElementById('current-rpn-display');
                if (display) {
                    display.textContent = exportPositionRPN();
                }
            }, 100);
            
            return modal;
        }

        // Close load position modal
        function closeLoadPositionModal() {
            const modal = document.getElementById('load-position-modal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        // Load position from input
        function loadPositionFromInput() {
            const input = document.getElementById('rpn-input');
            if (!input) return;
            
            const rpnString = input.value.trim();
            if (!rpnString) {
                alert('Please enter an RPN string');
                return;
            }
            
            if (!validateRPN(rpnString)) {
                alert('Invalid RPN format. Please check the notation.');
                return;
            }
            
            if (importPositionRPN(rpnString)) {
                closeLoadPositionModal();
                showNotification('‚úÖ Position loaded successfully!', 'success');
            }
        }

        // Download game as .rmn file
        function downloadGameRMN() {
            const rmn = exportGameRMN();
            const blob = new Blob([rmn], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `romgon_game_${gameMetadata.date}.rmn`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showNotification('‚úÖ Game exported successfully!', 'success');
        }

        // Log current position RPN to console
        function logPositionRPN() {
            const rpn = exportPositionRPN();
            console.log('üìã Current Position RPN:');
            console.log(rpn);
            console.log('\nüéÆ Copy this notation to share or save this position');
        }

        // ============================================
        // DARK MODE TOGGLE
        // ============================================
        
        // Toggle dark/light mode
        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            
            // Update button icon
            const darkModeBtn = document.querySelector('button[title="Toggle Dark/Light Mode"]');
            if (darkModeBtn) {
                if (document.body.classList.contains('dark-mode')) {
                    darkModeBtn.innerHTML = '‚òÄÔ∏è';
                    darkModeBtn.title = 'Switch to Light Mode';
                    // Save preference
                    localStorage.setItem('romgon-theme', 'dark');
                } else {
                    darkModeBtn.innerHTML = 'üåô';
                    darkModeBtn.title = 'Switch to Dark Mode';
                    // Save preference
                    localStorage.setItem('romgon-theme', 'light');
                }
            }
            
            console.log('üé® Theme switched to:', document.body.classList.contains('dark-mode') ? 'Dark Mode' : 'Light Mode');
        }
        
        // Initialize theme on page load
        function initializeTheme() {
            const savedTheme = localStorage.getItem('romgon-theme');
            
            // Default to light mode (if no preference saved)
            if (savedTheme === 'dark') {
                document.body.classList.add('dark-mode');
                const darkModeBtn = document.querySelector('button[title="Toggle Dark/Light Mode"]');
                if (darkModeBtn) {
                    darkModeBtn.innerHTML = '‚òÄÔ∏è';
                    darkModeBtn.title = 'Switch to Light Mode';
                }
            } else if (!savedTheme) {
                // First time user - set light mode as default
                localStorage.setItem('romgon-theme', 'light');
            }
        }
        
        // Call on page load (after DOM is ready)
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeTheme);
        } else {
            initializeTheme();
        }

        // ============================================
        // END OF DARK MODE
        // ============================================
        
        // ============================================
        // WOODEN BOARD THEME TOGGLE
        // ============================================
        
        // Toggle wooden/normal board
        function toggleWoodenTheme() {
            document.body.classList.toggle('wooden-theme');
            const isWooden = document.body.classList.contains('wooden-theme');
            
            // Update button icon
            const woodenBtn = document.querySelector('button[title="Toggle Wooden Board"]');
            if (woodenBtn) {
                woodenBtn.innerHTML = isWooden ? 'üé®' : 'ü™µ';
            }
            
            // Save preference to localStorage
            localStorage.setItem('romgon-board-theme', isWooden ? 'wooden' : 'normal');
            
            console.log('ü™µ Board theme switched to:', isWooden ? 'Wooden Board' : 'Normal Board');
        }
        
        // Initialize wooden theme on page load
        function initializeWoodenTheme() {
            const savedBoardTheme = localStorage.getItem('romgon-board-theme');
            const woodenBtn = document.querySelector('button[title="Toggle Wooden Board"]');
            
            if (savedBoardTheme === 'wooden') {
                document.body.classList.add('wooden-theme');
                if (woodenBtn) woodenBtn.innerHTML = 'üé®';
            } else {
                if (woodenBtn) woodenBtn.innerHTML = 'ü™µ';
            }
        }
        
        // Call on page load (after DOM is ready and button exists)
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => setTimeout(initializeWoodenTheme, 100));
        } else {
            setTimeout(initializeWoodenTheme, 100);
        }
        
        // ============================================
        // END OF WOODEN BOARD THEME
        // ============================================

        // ============================================
        // SPLASH PAGE INITIALIZATION
        // ============================================

        console.log('üìÑ Splash page script loaded. readyState:', document.readyState);

        // Initialize splash page on page load
        if (document.readyState === 'loading') {
            console.log('‚è≥ Waiting for DOMContentLoaded...');
            document.addEventListener('DOMContentLoaded', () => {
                console.log('‚úÖ DOMContentLoaded fired, calling initializeSplashPage in 200ms...');
                setTimeout(initializeSplashPage, 200);
            });
        } else {
            console.log('‚úÖ Document already loaded, calling initializeSplashPage in 200ms...');
            setTimeout(initializeSplashPage, 200);
        }

        // ============================================
        // END OF SPLASH PAGE INITIALIZATION
        // ============================================

        // Global login state and settings
        window.currentUser = null;
        window.gameSettings = window.gameSettings || {};

        // Initialize splash page
        function initializeSplashPage() {
            console.log('üöÄ Initializing splash page...');
            
            // Check for ?logout or ?splash URL parameter to force logout
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.has('logout') || urlParams.has('splash')) {
                console.log('üîì Logout requested via URL parameter');
                localStorage.removeItem('romgon-user');
                window.currentUser = null;
                // Clean URL
                window.history.replaceState({}, '', window.location.pathname);
            }
            
            // Check for OAuth token in URL (from Google sign-in redirect)
            const token = urlParams.get('token');
            if (token) {
                console.log('üîë OAuth token received, processing...');
                
                // Decode JWT to get user info
                try {
                    const base64Url = token.split('.')[1];
                    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
                    const payload = JSON.parse(window.atob(base64));
                    
                    const user = {
                        name: payload.username,
                        username: payload.username,  // Add username field for Player Hub
                        email: payload.email || null,
                        type: 'registered',
                        id: payload.userId,
                        token: token
                    };
                    
                    // Save to localStorage
                    localStorage.setItem('romgon-user', JSON.stringify(user));
                    localStorage.setItem('romgon-jwt', token); // ‚ö†Ô∏è CRITICAL: Save JWT token separately
                    window.currentUser = user;
                    
                    console.log('‚úÖ Google OAuth login successful:', user.name);
                    console.log('‚úÖ JWT token saved to localStorage');
                    
                    // Clean URL and redirect to lobby
                    window.history.replaceState({}, '', window.location.pathname);
                    hideSplashPage();
                    return;
                } catch (e) {
                    console.error('‚ùå Failed to process OAuth token:', e);
                    window.history.replaceState({}, '', window.location.pathname);
                }
            }
            
            // Check for ?menu URL parameter to force showing Start Menu instead of User Home
            const forceMenu = urlParams.has('menu');
            if (forceMenu) {
                console.log('üìã Menu requested via URL parameter');
                // Clean URL
                window.history.replaceState({}, '', window.location.pathname);
            }
            
            // Check for existing session and auto-login
            const savedUser = localStorage.getItem('romgon-user');
            if (savedUser && !forceMenu) {
                try {
                    const user = JSON.parse(savedUser);
                    console.log('üîÑ Found saved session:', user);
                    window.currentUser = user;
                    
                    // Auto-login: Skip splash page and go straight to user home
                    console.log('‚úÖ Auto-login successful as:', user.name || user.type);
                    hideSplashPage();
                    return; // Exit early, don't show splash page
                } catch (e) {
                    console.error('‚ùå Error loading saved session:', e);
                    localStorage.removeItem('romgon-user');
                }
            }
            
            // If ?menu parameter is present with saved session, show Start Menu
            if (savedUser && forceMenu) {
                try {
                    const user = JSON.parse(savedUser);
                    console.log('üîÑ Found saved session, showing Start Menu as requested:', user);
                    window.currentUser = user;
                    
                    // Show splash page first to ensure proper state
                    const splashPage = document.getElementById('splash-page');
                    if (splashPage) splashPage.style.display = 'none';
                    
                    // Show Start Menu directly
                    hideSplashPage();
                    console.log('‚úÖ Start Menu shown with active session');
                    return;
                } catch (e) {
                    console.error('‚ùå Error loading saved session:', e);
                    localStorage.removeItem('romgon-user');
                }
            }
            
            // No saved session, show splash page on load
            showSplashPage();

            // Add event listeners
            const googleBtn = document.getElementById('google-login-btn');
            const signinBtn = document.getElementById('signin-login-btn');
            const guestBtn = document.getElementById('guest-login-btn');

            console.log('üîç Button elements found:', {
                googleBtn: !!googleBtn,
                signinBtn: !!signinBtn,
                guestBtn: !!guestBtn
            });

            if (googleBtn) {
                googleBtn.addEventListener('click', handleGoogleLogin);
                console.log('‚úÖ Google login button event listener attached');
            }

            if (signinBtn) {
                signinBtn.addEventListener('click', window.showSignInModal);
                console.log('‚úÖ Sign In button event listener attached');
            }

            if (guestBtn) {
                guestBtn.addEventListener('click', handleGuestLoginWithBackend);
                console.log('‚úÖ Guest button event listener attached');
            }
        }

        // Show splash page
        function showSplashPage() {
            const splashPage = document.getElementById('splash-page');
            const startMenu = document.getElementById('start-menu');

            if (splashPage) splashPage.style.display = 'flex';
            if (startMenu) startMenu.style.display = 'none';
        }

        // Hide splash page and show main menu
        async function hideSplashPage() {
            const splashPage = document.getElementById('splash-page');
            const startMenu = document.getElementById('start-menu');

            if (splashPage) splashPage.style.display = 'none';
            if (startMenu) startMenu.style.display = 'flex';
            
            // Load user data when entering main menu
            await loadUserHomeData();
        }
        
        /**
         * Load user data for the main menu home screen
         */
        async function loadUserHomeData() {
            const currentUser = JSON.parse(localStorage.getItem('romgon-user') || '{}');
            
            if (!currentUser.id) {
                console.warn('No user logged in');
                return;
            }
            
            console.log('üìä Loading user home data...');
            
            // Update username in top bar
            const usernameEl = document.getElementById('user-home-name-small');
            if (usernameEl) {
                usernameEl.textContent = currentUser.name || 'Player';
            }
            
            // Update account type badge
            const accountTypeEl = document.getElementById('user-home-account-type');
            if (accountTypeEl) {
                const accountType = currentUser.type === 'guest' ? 'Guest' : 'Registered';
                accountTypeEl.textContent = accountType;
                
                if (accountType === 'Registered') {
                    accountTypeEl.style.background = 'rgba(78, 205, 196, 0.2)';
                    accountTypeEl.style.color = '#4ecdc4';
                } else {
                    accountTypeEl.style.background = 'rgba(255, 215, 0, 0.2)';
                    accountTypeEl.style.color = '#ffd700';
                }
            }
            
            // Update avatar
            const avatarEl = document.getElementById('user-home-avatar-small');
            const initial = currentUser.name ? currentUser.name.charAt(0).toUpperCase() : 'G';
            if (avatarEl) {
                avatarEl.textContent = initial;
            }
            
            // Show and update global account bar
            const accountType = currentUser.type === 'guest' ? 'Guest' : 'Registered';
            updateGlobalAccountBar(currentUser.name || 'Player', accountType, initial);
            showGlobalAccountBar();
            
            // Fetch and display stats if registered user
            if (currentUser.type !== 'guest' && currentUser.token) {
                try {
                    const stats = await fetchUserStats();
                    if (stats && stats.stats) {
                        // Backend returns { stats: { wins, losses, ... } }
                        const backendStats = stats.stats;
                        const wins = backendStats.wins || 0;
                        const losses = backendStats.losses || 0;
                        const totalGames = backendStats.totalGames || 0;
                        const winRate = Math.round(backendStats.winRate || 0);
                        
                        updateTopBarStats(wins, losses, winRate);
                        console.log('‚úÖ User stats loaded from backend:', {wins, losses, totalGames, winRate});
                    } else {
                        console.warn('‚ö†Ô∏è Stats not in expected format, using zeros');
                        updateTopBarStats(0, 0, 0);
                    }
                } catch (error) {
                    console.error('‚ùå Failed to load user stats:', error);
                    updateTopBarStats(0, 0, 0);
                }
            } else {
                // Guest user - show zeros
                updateTopBarStats(0, 0, 0);
            }
        }

        // ============================================
        // BACKEND API INTEGRATION
        // ============================================
        
        class RomgonAPI {
            constructor() {
                this.baseURL = this.getBaseURL();
                this.token = localStorage.getItem('romgon_token');
            }

            getBaseURL() {
                if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                    return 'http://localhost:3000/api';
                }
                return 'https://api.romgon.net/api';
            }

            getHeaders(includeAuth = true) {
                const headers = { 'Content-Type': 'application/json' };
                if (includeAuth && this.token) {
                    headers['Authorization'] = `Bearer ${this.token}`;
                }
                return headers;
            }

            async request(endpoint, options = {}) {
                const url = `${this.baseURL}${endpoint}`;
                const config = {
                    method: options.method || 'GET',
                    headers: this.getHeaders(options.includeAuth !== false),
                };

                if (options.body) {
                    config.body = JSON.stringify(options.body);
                }

                try {
                    const response = await fetch(url, config);
                    const data = await response.json();

                    if (!response.ok) {
                        throw new Error(data.error || 'Request failed');
                    }

                    return data;
                } catch (error) {
                    console.error('API Request Error:', error);
                    throw error;
                }
            }

            // Authentication
            async register(username, email, password, confirmPassword) {
                const data = await this.request('/auth/register', {
                    method: 'POST',
                    body: { username, email, password, confirmPassword },
                    includeAuth: false
                });

                if (data.token) {
                    this.token = data.token;
                    localStorage.setItem('romgon_token', data.token);
                }

                return data;
            }

            async login(username, password) {
                const data = await this.request('/auth/login', {
                    method: 'POST',
                    body: { username, password },
                    includeAuth: false
                });

                if (data.token) {
                    this.token = data.token;
                    localStorage.setItem('romgon_token', data.token);
                }

                return data;
            }

            async createGuest() {
                // Generate guest username in required format
                const guestUsername = 'Guest_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
                
                const data = await this.request('/auth/guest', {
                    method: 'POST',
                    body: { username: guestUsername },
                    includeAuth: false
                });

                if (data.token) {
                    this.token = data.token;
                    localStorage.setItem('romgon_token', data.token);
                }

                return data;
            }

            async logout() {
                await this.request('/auth/logout', { method: 'POST' });
                this.token = null;
                localStorage.removeItem('romgon_token');
            }

            // User Stats
            async getPlayerStats(userId) {
                return this.request(`/stats/player/${userId}`);
            }

            async updateGameResult(gameData) {
                return this.request('/games/end', {
                    method: 'POST',
                    body: gameData
                });
            }
        }

        // Initialize API client
        const romgonAPI = new RomgonAPI();

        // Enhanced handleGuestLogin with backend integration
        async function handleGuestLoginWithBackend() {
            try {
                showLoadingIndicator('Creating guest session...');
                
                // Create guest account in backend
                const guestData = await romgonAPI.createGuest();
                
                console.log('üîç Guest data received:', guestData);
                console.log('üîç User object:', guestData.user);
                console.log('üîç User ID:', guestData.user?.id);
                
                // Check if we got valid data
                if (!guestData || !guestData.user) {
                    console.error('‚ùå Invalid guest data (no user):', guestData);
                    throw new Error('Backend returned invalid guest data (no user object)');
                }
                
                if (!guestData.user.id) {
                    console.error('‚ùå Invalid guest data (no user.id):', guestData.user);
                    console.log('üìã Available user properties:', Object.keys(guestData.user));
                    throw new Error('Backend returned invalid guest data (no user ID)');
                }
                
                // Store user info locally
                const guest = {
                    type: 'guest',
                    name: guestData.user.username || 'Guest Player',
                    email: 'Guest Session',
                    id: guestData.user.id,
                    token: guestData.token,
                    rating: guestData.user.rating || 1600,
                    wins: 0,
                    losses: 0
                };
                
                window.currentUser = guest;
                localStorage.setItem('romgon-user', JSON.stringify(guest));
                
                // IMPORTANT: Store userId and token for active games feature
                localStorage.setItem('userId', guestData.user.id.toString());
                localStorage.setItem('token', guestData.token);
                
                console.log('‚úÖ Guest account created:', guest);
                console.log('‚úÖ userId:', guestData.user.id);
                console.log('‚úÖ token stored for active games');
                
                hideLoadingIndicator();
                showUserHome();
                
            } catch (error) {
                hideLoadingIndicator();
                console.error('‚ùå Guest login failed:', error);
                console.error('‚ùå Error details:', error.message);
                console.log('‚ö†Ô∏è Falling back to offline guest mode');
                // Fallback to offline guest
                handleGuestLogin();
            }
        }

        // Loading indicator helpers
        function showLoadingIndicator(message = 'Loading...') {
            let loader = document.getElementById('loading-indicator');
            if (!loader) {
                loader = document.createElement('div');
                loader.id = 'loading-indicator';
                loader.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(0, 0, 0, 0.9);
                    color: #4ecdc4;
                    padding: 30px 50px;
                    border-radius: 15px;
                    z-index: 999999;
                    font-size: 18px;
                    font-weight: 600;
                    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
                `;
                document.body.appendChild(loader);
            }
            loader.textContent = message;
            loader.style.display = 'block';
        }

        function hideLoadingIndicator() {
            const loader = document.getElementById('loading-indicator');
            if (loader) loader.style.display = 'none';
        }

        // ----------------------
        // Google Sign-In helpers - OAuth Flow (Backend)
        // ----------------------
        // Note: Google OAuth is handled through backend at /api/auth/google
        // The handleGoogleLogin() function redirects to backend OAuth endpoint
        
        function parseJwt(token) {
            try {
                const base64Url = token.split('.')[1];
                const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
                const jsonPayload = decodeURIComponent(atob(base64).split('').map(function(c) {
                    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
                }).join(''));
                return JSON.parse(jsonPayload);
            } catch (e) {
                console.error('JWT parse error:', e);
                return null;
            }
        }

        // Note: handleGoogleCredentialResponse removed - now using backend OAuth flow

        async function handleGoogleLogin() {
            try {
                console.log('üîÑ Initiating Google OAuth flow...');
                
                // Get backend URL - ensure it's a full URL
                let apiUrl = typeof BACKEND_API_URL !== 'undefined' ? BACKEND_API_URL : 'https://api.romgon.net';
                
                // Remove trailing /api if present
                apiUrl = apiUrl.replace(/\/api$/, '');
                
                // Ensure it starts with https://
                if (!apiUrl.startsWith('http')) {
                    apiUrl = 'https://' + apiUrl;
                }
                
                const fullUrl = `${apiUrl}/api/auth/google`;
                console.log(`üîÑ Redirecting to: ${fullUrl}`);
                
                // Redirect to backend OAuth endpoint
                window.location.href = fullUrl;
                
            } catch (e) {
                console.error('handleGoogleLogin error', e);
                alert('Failed to initiate Google sign-in. Please try Email/Password or Guest mode.');
            }
        }

        // Persist and show current user (used by Google login and guest flow)
        function persistCurrentUser(user) {
            if (!user) return;
            window.currentUser = user;
            try { localStorage.setItem('romgon-user', JSON.stringify(user)); } catch (e) {}
            // Update small badge and user-home UI
            try { showLoggedInUser(user); } catch (e) {}
            try { showUserHome(); } catch (e) {}
        }

        // Profile UI helpers (lightweight, mirrors deploy behavior)
        function showLoggedInUser(user) {
            if (!user) return;
            let badge = document.getElementById('user-profile-badge');
            if (!badge) {
                badge = document.createElement('div');
                badge.id = 'user-profile-badge';
                badge.style.cssText = 'position:fixed; top:12px; right:12px; z-index:20001; display:flex; gap:8px; align-items:center; background:#111; color:#fff; padding:6px 10px; border-radius:18px; box-shadow:0 6px 18px rgba(0,0,0,0.6); cursor:pointer;';
                document.body.appendChild(badge);
                badge.addEventListener('click', (e) => { e.stopPropagation(); showAccountModal(); });
            }
            badge.innerHTML = '';
            if (user.picture) {
                const img = document.createElement('img');
                img.src = user.picture;
                img.style.cssText = 'width:28px; height:28px; border-radius:50%; object-fit:cover;';
                badge.appendChild(img);
            }
            const txt = document.createElement('div');
            txt.style.cssText = 'font-size:13px; color:#fff;';
            txt.textContent = user.name || user.email || 'Player';
            badge.appendChild(txt);
        }

        function removeLoggedInUserUI() {
            const b = document.getElementById('user-profile-badge');
            if (b) b.remove();
        }

        function handleSignOut() {
            // Stop activity tracking
            stopActivityHeartbeat();
            
            window.currentUser = null;
            try { localStorage.removeItem('romgon-user'); } catch (e) {}
            try { localStorage.removeItem('romgon_token'); } catch (e) {}
            removeLoggedInUserUI();
            // Note: Google One Tap removed (using OAuth flow)
            // Hide user-home if visible
            try { hideUserHome(); } catch (e) {}
            alert('Signed out');
            try { closeAccountModal(); } catch (e) {}
        }

        // Show / hide the user-first landing page
        function showUserHome() {
            const uh = document.getElementById('user-home');
            if (!uh) return;
            const startMenu = document.getElementById('start-menu');
            const splash = document.getElementById('splash-page');
            if (startMenu) startMenu.style.display = 'none';
            if (splash) splash.style.display = 'none';
            // Populate user info
            const u = window.currentUser || (function(){ try { return JSON.parse(localStorage.getItem('romgon-user')); } catch(e){return null;} })();
            const avatar = document.getElementById('user-home-avatar');
            const nameEl = document.getElementById('user-home-name');
            const emailEl = document.getElementById('user-home-email');
            const statsDiv = document.getElementById('user-home-stats');
            const guestNotice = document.getElementById('guest-upgrade-notice');
            
            if (u) {
                // Update avatar
                if (avatar) {
                    avatar.style.display = 'flex';
                    avatar.style.alignItems = 'center';
                    avatar.style.justifyContent = 'center';
                    if (u.picture) {
                        avatar.style.background = 'transparent';
                        avatar.innerHTML = `<img src="${u.picture}" style="width:80px;height:80px;border-radius:50%;object-fit:cover;"/>`;
                    } else {
                        avatar.style.background = 'linear-gradient(135deg, #4ecdc4, #a55eea)';
                        avatar.innerHTML = '';
                        avatar.textContent = (u.name || 'G').charAt(0).toUpperCase();
                    }
                }
                
                // Update name and email
                if (nameEl) nameEl.textContent = u.name || u.email || 'Welcome Player';
                if (emailEl) emailEl.textContent = u.email || (u.type === 'guest' ? 'Guest Session' : 'Not signed in');
                
                // Show/hide guest upgrade notice
                if (guestNotice) {
                    guestNotice.style.display = (u.type === 'guest') ? 'block' : 'none';
                }
                
                // Update stats (always show, not hidden)
                if (statsDiv) {
                    const wins = u.wins || 0;
                    const losses = u.losses || 0;
                    const total = wins + losses;
                    const winrate = total > 0 ? Math.round((wins / total) * 100) : 0;
                    
                    const winsEl = document.getElementById('user-home-wins');
                    const lossesEl = document.getElementById('user-home-losses');
                    const winrateEl = document.getElementById('user-home-winrate');
                    const gamesEl = document.getElementById('user-home-games');
                    
                    if (winsEl) winsEl.textContent = wins;
                    if (lossesEl) lossesEl.textContent = losses;
                    if (winrateEl) winrateEl.textContent = winrate + '%';
                    if (gamesEl) gamesEl.textContent = total;
                }
                
                // Start activity heartbeat for active player tracking
                startActivityHeartbeat();
                
                // Initialize chat connection
                if (!chatConnected) {
                    initializeChat();
                }
                
                // Initialize lobby features
                initializeLobby();
            }
            uh.style.display = 'flex';
        }

        // Activity heartbeat to track active players
        let activityHeartbeatInterval = null;
        
        function startActivityHeartbeat() {
            // Clear existing interval
            if (activityHeartbeatInterval) {
                clearInterval(activityHeartbeatInterval);
            }
            
            // Send activity ping every 2 minutes
            activityHeartbeatInterval = setInterval(async () => {
                try {
                    if (romgonAPI.token) {
                        await romgonAPI.request('/stats/activity', { method: 'POST' });
                        console.log('üíì Activity heartbeat sent');
                    }
                } catch (error) {
                    console.error('‚ùå Activity heartbeat failed:', error);
                }
            }, 2 * 60 * 1000); // Every 2 minutes
            
            // Send initial ping
            if (romgonAPI.token) {
                romgonAPI.request('/stats/activity', { method: 'POST' }).catch(console.error);
            }
        }
        
        function stopActivityHeartbeat() {
            if (activityHeartbeatInterval) {
                clearInterval(activityHeartbeatInterval);
                activityHeartbeatInterval = null;
            }
        }

        function hideUserHome() {
            const uh = document.getElementById('user-home');
            if (!uh) return;
            uh.style.display = 'none';
        }

        // Handle guest login
        function handleGuestLogin() {
            // Create guest user with unique ID
            const guestId = 'guest_' + Date.now();
            const guest = { 
                type: 'guest', 
                name: 'Guest Player', 
                id: guestId,
                wins: 0,
                losses: 0
            };
            
            // Store guest info
            try { 
                persistCurrentUser(guest); 
            } catch (e) { 
                window.currentUser = guest; 
                localStorage.setItem('romgon-user', JSON.stringify(guest)); 
                hideSplashPage(); 
            }
            
            // IMPORTANT: Store guestId for active games (offline mode - no backend)
            localStorage.setItem('userId', guestId);
            localStorage.setItem('token', 'guest-offline-mode');
            
            console.log('üë§ Logged in as Guest (offline):', guest);
            console.log('üíæ Guest ID stored:', guestId);
        }

        // Get current user info
        function getCurrentUser() {
            if (!window.currentUser) {
                // Try to load from localStorage
                const savedUser = localStorage.getItem('romgon-user');
                if (savedUser) {
                    window.currentUser = JSON.parse(savedUser);
                }
            }
            return window.currentUser;
        }

        // Check if user is logged in as guest
        function isGuestUser() {
            const user = getCurrentUser();
            return user && user.type === 'guest';
        }

        // Prompt login - open start menu / splash page and focus login area
        function promptLogin() {
            const startMenu = document.getElementById('start-menu');
            const splash = document.getElementById('splash-page');
            // Show start menu (login options) and hide splash if necessary
            if (startMenu) startMenu.style.display = 'flex';
            if (splash) splash.style.display = 'none';
            // Optionally focus the guest login button
            const guestBtn = document.getElementById('guest-login-btn');
            if (guestBtn) {
                guestBtn.focus();
            }
        }

        // Preferred login handler shim: call the in-development handler if present,
        // otherwise fall back to promptLogin(). This lets you wire the new handler
        // later without changing every callsite.
        function preferredLoginHandler() {
            try {
                // If you implement handleLoginFlow or handleGoogleLogin, the shim will prefer them.
                if (typeof handleLoginFlow === 'function') {
                    return handleLoginFlow();
                }
                if (typeof handleGoogleLogin === 'function') {
                    return handleGoogleLogin();
                }
            } catch (e) {
                // swallow and fallback
                console.warn('preferredLoginHandler: preferred handler threw, falling back', e);
            }
            return promptLogin();
        }

        // Show a centered account modal with guest vs user info and login button


        // ============================================
        // END OF SPLASH PAGE LOGIC
        // ============================================

        // ============================================
        // END OF RPN SYSTEM
        // ============================================
        
        // ============================================
        // Keyboard systems are now managed by keyboard-system-router.js
        // which automatically switches between PVP and General modes

        // ============================================
        // EMERGENCY BUTTON INITIALIZATION (BACKUP)
        // VERSION: 2024-10-20-v3
        // ============================================
        console.log('üö® Running emergency button initialization v3...');
        console.log('üö® EMERGENCY CODE IS RUNNING - Version 3');
        setTimeout(() => {
            console.log('üö® Emergency timeout fired (500ms elapsed)');
            const signinBtn = document.getElementById('signin-login-btn');
            const guestBtn = document.getElementById('guest-login-btn');
            const googleBtn = document.getElementById('google-login-btn');
            
            console.log('üö® Emergency check - buttons found:', {
                signin: !!signinBtn,
                guest: !!guestBtn,
                google: !!googleBtn
            });
            
            try {
                if (signinBtn) {
                    console.log('üö® Attempting to attach Sign In listener...');
                    if (!signinBtn._listenerAttached) {
                        signinBtn.addEventListener('click', window.showSignInModal);
                        signinBtn._listenerAttached = true;
                        console.log('üö® Emergency: Sign In listener attached ‚úÖ');
                    } else {
                        console.log('üö® Sign In listener already attached (skipped)');
                    }
                } else {
                    console.log('‚ùå signinBtn is null!');
                }
            } catch (err) {
                console.error('‚ùå Error attaching Sign In listener:', err);
            }
            
            try {
                if (guestBtn) {
                    console.log('üö® Attempting to attach Guest listener...');
                    if (!guestBtn._listenerAttached) {
                        guestBtn.addEventListener('click', handleGuestLoginWithBackend);
                        guestBtn._listenerAttached = true;
                        console.log('üö® Emergency: Guest listener attached ‚úÖ');
                    } else {
                        console.log('üö® Guest listener already attached (skipped)');
                    }
                } else {
                    console.log('‚ùå guestBtn is null!');
                }
            } catch (err) {
                console.error('‚ùå Error attaching Guest listener:', err);
            }
            
            try {
                if (googleBtn) {
                    console.log('üö® Attempting to attach Google listener...');
                    if (!googleBtn._listenerAttached) {
                        googleBtn.addEventListener('click', handleGoogleLogin);
                        googleBtn._listenerAttached = true;
                        console.log('üö® Emergency: Google listener attached ‚úÖ');
                    } else {
                        console.log('üö® Google listener already attached (skipped)');
                    }
                } else {
                    console.log('‚ùå googleBtn is null!');
                }
            } catch (err) {
                console.error('‚ùå Error attaching Google listener:', err);
            }
        }, 500);

    </script>

    <!-- üéÆ Game Engine API - Enables external tools and AI systems to interact with the game -->
    <script src="romgon-engine-api.js"></script>
</body>
</html>
