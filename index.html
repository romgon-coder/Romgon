    <!-- DEPLOY TEST BADGE -->
    <div id="deploy-test-badge" style="position: fixed; top: 10px; right: 10px; background: #4ecdc4; color: white; padding: 12px 16px; border-radius: 8px; font-weight: bold; z-index: 9999; font-size: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);">
      ‚úÖ Deploy successful - <span id="deploy-timestamp">loading...</span>
    </div>
    <script>
      document.getElementById('deploy-timestamp').textContent = new Date().toLocaleString();
    </script>

    <!-- Statistics Dashboard Modal -->
    <!-- TEST: This comment was added to verify live deployment on romgon.net -->
    <div id="stats-dashboard-modal" style="
        display: none;
        position: fixed;
        top: 0; left: 0; width: 100vw; height: 100vh;
        background: rgba(10, 12, 15, 0.98);
        z-index: 3000;
        overflow-y: auto;
        padding: 0; margin: 0;
    ">
        <div style="
            max-width: 800px;
            margin: 40px auto;
            background: #0e1013;
            border-radius: 18px;
            box-shadow: 0 8px 40px #000a;
            padding: 36px 32px 32px 32px;
            color: #fff;
            position: relative;
        ">
            <button onclick="hideStatsDashboard()" style="
                position: absolute; top: 18px; right: 18px;
                background: #f1c40f; color: #23272e;
                border: none; border-radius: 8px;
                font-size: 1.2em; font-weight: bold;
                padding: 6px 16px; cursor: pointer; z-index: 10;">‚úñÔ∏è Close</button>
            <h2 style="color: #f1c40f; margin-top: 0;">üìä Romgon Statistics Dashboard</h2>
            <div id="stats-dashboard-content">
                <!-- Stats will be rendered here -->
            </div>
        </div>
    </div>
    <script>
    // Show/hide Statistics Dashboard modal
    function showStatsDashboard() {
        document.getElementById('stats-dashboard-modal').style.display = 'block';
        renderStatsDashboard();
    }
    function hideStatsDashboard() {
        document.getElementById('stats-dashboard-modal').style.display = 'none';
    }
    // Render statistics dashboard content (placeholder data)
    function renderStatsDashboard() {
        const content = document.getElementById('stats-dashboard-content');
        content.innerHTML = `
            <div style='margin-bottom:24px;'>
                <h3 style='color:#4ecdc4;'>üèÜ Win/Loss Record</h3>
                <p style='font-size:1.1em;'>Wins: <b>12</b> | Losses: <b>8</b> | Draws: <b>2</b></p>
            </div>
            <div style='margin-bottom:24px;'>
                <h3 style='color:#a55eea;'>‚ôüÔ∏è Piece Performance</h3>
                <table style='width:100%; border-collapse:collapse;'>
                    <thead><tr style='color:#aaa;'><th>Piece</th><th>Captures</th><th>Survived</th><th>Lost</th></tr></thead>
                    <tbody>
                        <tr><td>Square</td><td>18</td><td>7</td><td>5</td></tr>
                        <tr><td>Triangle</td><td>14</td><td>6</td><td>8</td></tr>
                        <tr><td>Rhombus</td><td>3</td><td>2</td><td>8</td></tr>
                        <tr><td>Circle</td><td>9</td><td>4</td><td>10</td></tr>
                        <tr><td>Hexagon</td><td>11</td><td>5</td><td>7</td></tr>
                    </tbody>
                </table>
            </div>
            <div style='margin-bottom:24px;'>
                <h3 style='color:#00b894;'>üìö Opening Repertoire</h3>
                <table style='width:100%; border-collapse:collapse;'>
                    <thead><tr style='color:#aaa;'><th>Opening</th><th>Games Played</th><th>Win Rate</th></tr></thead>
                    <tbody>
                        <tr><td>Classic Hex Start</td><td>7</td><td>71%</td></tr>
                        <tr><td>Triangle Rush</td><td>4</td><td>50%</td></tr>
                        <tr><td>Circle Flank</td><td>3</td><td>33%</td></tr>
                        <tr><td>Rhombus Defense</td><td>2</td><td>100%</td></tr>
                    </tbody>
                </table>
            </div>
            <div style='margin-bottom:24px;'>
                <h3 style='color:#0984e3;'>üìà Move Quality</h3>
                <table style='width:100%; border-collapse:collapse;'>
                    <thead><tr style='color:#aaa;'><th>Brilliant (!!)</th><th>Good (!)</th><th>Inaccuracy (!?)</th><th>Mistake (?)</th><th>Blunder (??)</th></tr></thead>
                    <tbody>
                        <tr><td>3</td><td>28</td><td>7</td><td>5</td><td>2</td></tr>
                    </tbody>
                </table>
            </div>
            <div style='margin-bottom:24px;'>
                <h3 style='color:#fdcb6e;'>‚ùå Blunder Rate</h3>
                <p style='font-size:1.1em;'>Blunders per game: <b>0.4</b></p>
            </div>
            <div style='margin-bottom:24px;'>
                <h3 style='color:#00cec9;'>üìä Average Evaluation</h3>
                <p style='font-size:1.1em;'>Avg. evaluation after move 10: <b>+1.2</b></p>
            </div>
            <div style='margin-bottom:24px;'>
                <h3 style='color:#e17055;'>‚ö° Tactical Success</h3>
                <ul style='color:#fff; font-size:1.05em;'>
                    <li>Forks Executed: <b>6</b></li>
                    <li>Pins Executed: <b>3</b></li>
                    <li>Sacrifices Successful: <b>2</b></li>
                </ul>
            </div>
            <div style='margin-bottom:24px;'>
                <h3 style='color:#ffd700;'>üìà Progress Chart</h3>
                <div style='background:#181b20; border-radius:8px; padding:16px; color:#aaa; text-align:center;'>
                    <i>Progress chart coming soon!</i>
                </div>
            </div>
            <div style='margin-bottom:24px;'>
                <h3 style='color:#ff6b6b;'>üèÖ Personal Records</h3>
                <ul style='color:#fff; font-size:1.05em;'>
                    <li>Longest Win Streak: <b>5</b></li>
                    <li>Fastest Win: <b>13 moves</b></li>
                    <li>Most Captures in a Game: <b>9</b></li>
                </ul>
            </div>
        `;
    }
    </script>
    <!-- Opening Book Modal -->
    <div id="opening-book-modal" style="
        display: none;
        position: fixed;
        top: 0; left: 0; width: 100vw; height: 100vh;
        background: rgba(20, 24, 32, 0.98);
        z-index: 3000;
        overflow-y: auto;
        padding: 0; margin: 0;
    ">
        <div style="
            max-width: 800px;
            margin: 40px auto;
            background: #23272e;
            border-radius: 18px;
            box-shadow: 0 8px 40px #000a;
            padding: 36px 32px 32px 32px;
            color: #fff;
            position: relative;
        ">
            <button onclick="hideOpeningBook()" style="
                position: absolute; top: 18px; right: 18px;
                background: #4ecdc4; color: #23272e;
                border: none; border-radius: 8px;
                font-size: 1.2em; font-weight: bold;
                padding: 6px 16px; cursor: pointer; z-index: 10;">‚úñÔ∏è Close</button>
            <h2 style="color: #4ecdc4; margin-top: 0;">üìñ Romgon Opening Book</h2>
            <div id="opening-book-content">
                <!-- Opening list will be rendered here -->
            </div>
        </div>
    </div>
    <script>
    // Show/hide Opening Book modal
    function showOpeningBook() {
        document.getElementById('opening-book-modal').style.display = 'block';
        renderOpeningBook();
    }
    function hideOpeningBook() {
        document.getElementById('opening-book-modal').style.display = 'none';
    }
    // Render opening book content (placeholder for now)
    // --- Opening Book Data ---
    const OPENING_BOOK = [
    {
        name: 'Triangle Coop',
        rpn: 'S4s/1T05/C5t0h0/R7r/H0T05c/5t01/S4s b 2 - - - t5-6>5-5;T1-0>1-1;t1-6>2-6;T5-0>4-1 whiteblack - -',
        moves: ['t5-6>5-5', 't1-6>2-6'],
        description: 'Both black triangles advance cooperatively.'
    },
    {
        name: 'Triangle Coop',
        rpn: 'S4s/1T05/C5t0h0/R7r/H0T05c/5t01/S4s b 2 - - - t5-6>5-5;T1-0>1-1;t1-6>2-6;T5-0>4-1 whiteblack - -',
        moves: ['T1-0>1-1', 'T5-0>4-1'],
        description: 'Both white triangles advance cooperatively.'
    },
    {
        name: '2 Square Advance',
        rpn: '6/T0S3st0/C6h0/R7r/H06c/T0S3st0/6 b 2 - - - s6-5>5-5;S0-0>1-1;s0-5>1-5;S6-0>5-1 whiteblack - -',
        moves: ['s6-5>5-5', 's0-5>1-5'],
        description: 'Both black squares advance aggressively on the right.'
    },
    {
        name: '2 Square Advance',
        rpn: '6/T0S3st0/C6h0/R7r/H06c/T0S3st0/6 b 2 - - - s6-5>5-5;S0-0>1-1;s0-5>1-5;S6-0>5-1 whiteblack - -',
        moves: ['S0-0>1-1', 'S6-0>5-1'],
        description: 'Both white squares advance aggressively on the left.'
    },
    // --- User-supplied and mirrored openings ---
    {
        name: 'Rhombus Roster (Black)',
        rpn: 'r3-8>3-6 c4-7>4-6',
        moves: ['r3-8>3-6', 'c4-7>4-6'],
        description: 'Black rhombus and circle both advance on the right.'
    },
    {
        name: 'Rhombus Roster (White)',
        rpn: 'R3-0>3-2 C2-0>2-1',
        moves: ['R3-0>3-2', 'C2-0>2-1'],
        description: 'White rhombus and circle both advance on the left.'
    },
    {
        name: 'Hexagon Push (Black)',
        rpn: 's6-5>5-5 h2-7>3-6',
        moves: ['s6-5>5-5', 'h2-7>3-6'],
        description: 'Black square and hexagon push forward.'
    },
    {
        name: 'Hexagon Push (White)',
        rpn: 'S0-0>1-1 H4-0>3-2',
        moves: ['S0-0>1-1', 'H4-0>3-2'],
        description: 'White square and hexagon push forward.'
    },
    {
        name: 'Rhombus Straw',
        rpn: 'r3-8>3-6 r3-6>3-4',
        moves: ['r3-8>3-6', 'r3-6>3-4'],
        description: 'Black rhombus advances twice down the center.'
    },
    {
        name: 'Rhombus Straw',
        rpn: 'R3-0>3-2 R3-2>3-4',
        moves: ['R3-0>3-2', 'R3-2>3-4'],
        description: 'White rhombus advances twice up the center.'
    },
        {
            name: 'Triangle Gateway Attack',
            rpn: 'T2-1-3-2 s5-0-5-1',
            moves: ['T2-1-3-2', 's5-0-5-1'],
            description: 'Triangle advances through the gateway, black responds with central square.'
        },
        {
            name: 'Central Hexagon Push',
            rpn: 'H3-2-3-3 t4-1-4-2',
            moves: ['H3-2-3-3', 't4-1-4-2'],
            description: 'Hexagon pushes to the center, triangle responds.'
        },
        {
            name: 'Rhombus Diagonal Entry',
            rpn: 'R3-0-2-1 s1-0-1-1',
            moves: ['R3-0-2-1', 's1-0-1-1'],
            description: 'Rhombus enters diagonally, square advances.'
        },
        {
            name: 'Circle Central Jump',
            rpn: 'C0-2-2-3 h3-2-rotR',
            moves: ['C0-2-2-3', 'h3-2-rotR'],
            description: 'Circle jumps to center, hexagon rotates right.'
        },
        {
            name: 'Square Side Push',
            rpn: 'S1-0-2-0 t4-1-3-2',
            moves: ['S1-0-2-0', 't4-1-3-2'],
            description: 'Square pushes side, triangle advances.'
        },
        {
            name: 'Triangle Flank Advance',
            rpn: 'T4-1-5-2 s1-0-1-1',
            moves: ['T4-1-5-2', 's1-0-1-1'],
            description: 'Triangle advances on the flank, square responds.'
        },
        {
            name: 'Hexagon Diagonal Move',
            rpn: 'H3-2-2-3 c0-2-2-1',
            moves: ['H3-2-2-3', 'c0-2-2-1'],
            description: 'Hexagon moves diagonally, circle jumps.'
        },
        {
            name: 'Rhombus Central Advance',
            rpn: 'R3-0-3-1 h3-2-3-3',
            moves: ['R3-0-3-1', 'h3-2-3-3'],
            description: 'Rhombus advances centrally, hexagon pushes.'
        },
        {
            name: 'Square Central Advance',
            rpn: 'S5-0-5-1 t2-1-2-2',
            moves: ['S5-0-5-1', 't2-1-2-2'],
            description: 'Square advances to center, triangle pushes.'
        },
        {
            name: 'Circle Zone Jump',
            rpn: 'C0-2-1-3 r3-0-4-1',
            moves: ['C0-2-1-3', 'r3-0-4-1'],
            description: 'Circle jumps to zone, rhombus enters.'
        },
        {
            name: 'Hexagon Rotate Left',
            rpn: 'H3-2-rotL t2-1-3-2',
            moves: ['H3-2-rotL', 't2-1-3-2'],
            description: 'Hexagon rotates left, triangle advances.'
        },
        {
            name: 'Triangle Central Push',
            rpn: 'T2-1-2-2 s5-0-4-0',
            moves: ['T2-1-2-2', 's5-0-4-0'],
            description: 'Triangle pushes to center, square flanks.'
        },
        {
            name: 'Square Flank Push',
            rpn: 'S1-0-2-0 h3-2-2-3',
            moves: ['S1-0-2-0', 'h3-2-2-3'],
            description: 'Square flanks, hexagon moves.'
        },
        {
            name: 'Rhombus Flank Entry',
            rpn: 'R3-0-4-1 t4-1-4-2',
            moves: ['R3-0-4-1', 't4-1-4-2'],
            description: 'Rhombus enters on the flank, triangle responds.'
        },
        {
            name: 'Hexagon Rotate Right',
            rpn: 'H3-2-rotR s1-0-1-1',
            moves: ['H3-2-rotR', 's1-0-1-1'],
            description: 'Hexagon rotates right, square advances.'
        },
        {
            name: 'Hexagon Push',
            rpn: 's6-5>5-5 h2-7>3-6',
            moves: ['s6-5>5-5', 'h2-7>3-6'],
            description: 'Square pushes, hexagon advances.'
        },
        {
            name: 'Rhombus Roster',
            rpn: 'r3-8>3-6 c4-7>4-6',
            moves: ['r3-8>3-6', 'c4-7>4-6'],
            description: 'Rhombus and circle both advance.'
        }
    ];

    // Update the small side-panel indicators showing the active base variant
    function updateVariantIndicators() {
        try {
            var label = (window.baseDefenseVariant === 'shape-defense') ? 'BASE: Shape Defence' : 'BASE: Original';
            var w = document.getElementById('white-variant-indicator');
            var b = document.getElementById('black-variant-indicator');
            if (w) w.textContent = label;
            if (b) b.textContent = label;
        } catch (e) {
            // Fail silently if indicators missing
        }
    }

    // Render a mini board for a given RPN (simple static rendering)
    function renderMiniBoardForRPN(rpn) {
        // For now, just show the RPN as text. (Can be replaced with a real mini board renderer)
        return `<div style='font-size: 0.9em; color: #4ecdc4; background: #181b20; border-radius: 6px; padding: 6px 10px; margin: 4px 0;'>${rpn}</div>`;
    }

    function renderOpeningBook() {
        const content = document.getElementById('opening-book-content');
        // Helper: get side from name
        function getSide(name) {
            if (name.toLowerCase().includes('white')) return 'White';
            if (name.toLowerCase().includes('black')) return 'Black';
            return 'Both';
        }
        // Helper: piece icon
        function pieceIcon(move) {
            const p = move[0].toLowerCase();
            if (p === 's') return '‚ñ†';
            if (p === 't') return '‚ñ≤';
            if (p === 'r') return '‚óÜ';
            if (p === 'c') return '‚óè';
            if (p === 'h') return '‚¨°';
            return '';
        }
        // Helper: color for side
        function sideColor(side) {
            if (side === 'White') return '#4ecdc4';
            if (side === 'Black') return '#ffd700';
            return '#aaa';
        }
        let html = `<table style='width:100%; border-collapse:collapse; margin-top:10px;'>
            <thead>
                <tr style='background:#23272e; color:#4ecdc4;'>
                    <th style='padding:8px 4px; text-align:left;'>Opening Name</th>
                    <th style='padding:8px 4px; text-align:left;'>Side</th>
                    <th style='padding:8px 4px; text-align:left;'>Moves</th>
                    <th style='padding:8px 4px; text-align:left;'>Description</th>
                </tr>
            </thead>
            <tbody>`;
        for (const opening of OPENING_BOOK) {
            const side = getSide(opening.name);
            html += `<tr style='border-bottom:1px solid #333;'>
                <td style='padding:8px 4px; font-weight:bold; color:#fff;'>${opening.name.replace(/ \((White|Black)\)/,'')}</td>
                <td style='padding:8px 4px; color:${sideColor(side)}; font-weight:bold;'>${side}</td>
                <td style='padding:8px 4px; color:#fff;'>
                    ${opening.moves.map(m => `<span style='font-family:monospace; margin-right:8px;'>${pieceIcon(m)} <span style='color:#4ecdc4;'>${m}</span></span>`).join('<br>')}
                </td>
                <td style='padding:8px 4px; color:#aaa;'>${opening.description}</td>
            </tr>`;
        }
        html += '</tbody></table>';
        content.innerHTML = html;
    }
    </script>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.5, maximum-scale=2.0, user-scalable=yes">
    <title>ROMGON</title>
    <!-- Socket.IO Client for Multiplayer -->
    <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
    <style>
        :root { /* CSS variables - LIGHT MODE (Default) */
            --hex-size: 48px;
            --hex-gap: 1px;
            
            /* Light Mode Colors */
            --body-bg: #f0f0f0;
            --board-bg: #ffffff;
            --text-color: #333333;
            --hex-bg: #e8e8e8;
            --hex-border: #cccccc;
            --modal-bg: #ffffff;
            --modal-overlay: rgba(0, 0, 0, 0.7);
            --button-bg: #4ecdc4;
            --button-text: #ffffff;
            --turn-indicator-bg: rgba(255, 255, 255, 0.95);
            --turn-indicator-text: #333333;
            
            /* Legacy colors (kept for compatibility) */
            --bg-color: #1a1a1a;
            --color-dark-brown: #6d3a13;
            --color-orange-med: #f57d2d;
            --color-orange-light: #fcc49c;
            --hex-coords-color: rgba(100, 100, 100, 0.8);
            --vertical-shift: 18px;

            /* Calculated values */
            --hex-height: calc(var(--hex-size) * 2);
            --hex-width: calc(var(--hex-size) * 1.73205); /* sqrt(3) */
            --hex-margin-top: calc(var(--hex-height) * -0.1 - var(--hex-gap) * 0.5);
            --hex-row-offset: calc(var(--hex-width) / 2 + var(--hex-gap) * 0.866 / 2);
            --hex-horizontal-spacing: calc(var(--hex-gap) * 3.866 / 1);
        }

        /* Zoom & Aspect Ratio Fixes */
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        body {
            font-size: clamp(12px, 1.5vw, 16px);
            line-height: 1.6;
        }

        #start-menu {
            min-height: 100vh !important;
            transform-origin: center center !important;
            transform: scale(1) !important;
        }

        /* Dark Mode Theme */
        body.dark-mode {
            --body-bg: #11141a;
            background: #11141a;
            --board-bg: #262421;
            --text-color: #ffffff;
            --hex-bg: #2d2a27;
            --hex-border: #4a4641;
            --modal-bg: #262421;
            --modal-overlay: rgba(0, 0, 0, 0.9);
            --button-bg: #4ecdc4;
            --button-text: #ffffff;
            --turn-indicator-bg: rgba(38, 36, 33, 0.95);
            --turn-indicator-text: #ffffff;
            --hex-coords-color: rgba(255, 255, 255, 0.8);
        }

        /* Wooden Board Theme */
        body.wooden-theme .hexagon {
            /* Remove solid background colors */
            background-color: transparent !important;
            /* Use wooden texture images */
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }
        
        /* Wooden hexagon variants - map to different wood tones */
        body.wooden-theme .color-dark-brown {
            background-image: url('ASSETS/hexagons/hex-wood-light.png') !important;
        }
        
        body.wooden-theme .color-brown-med {
            background-image: url('ASSETS/hexagons/hex-wood-brown.png') !important;
        }
        
        body.wooden-theme .color-brown-light {
            background-image: url('ASSETS/hexagons/hex-wood-tan.png') !important;
        }
        
        body.wooden-theme .color-orange-dark {
            background-image: url('ASSETS/hexagons/hex-wood-reddish.png') !important;
        }
        
        body.wooden-theme .color-orange-med {
            background-image: url('ASSETS/hexagons/hex-wood-brown.png') !important;
        }
        
        body.wooden-theme .color-orange-light {
            background-image: url('ASSETS/hexagons/hex-wood-light.png') !important;
        }
        
        body.wooden-theme .color-yellow {
            background-image: url('ASSETS/hexagons/hex-wood-light.png') !important;
        }
        
        /* Wooden theme body background */
        body.wooden-theme {
            background: url('ASSETS/backgrounds/wooden background.png');
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
        }
        
        /* Wooden theme highlights - use box-shadow and borders instead of background */
        body.wooden-theme .highlight-green {
            box-shadow: inset 0 0 30px rgba(0, 255, 0, 0.7), 0 0 20px rgba(0, 255, 0, 0.8), inset 0 0 0 3px #00ff00 !important;
            animation: none !important;
        }
        
        body.wooden-theme .highlight-red {
            box-shadow: inset 0 0 30px rgba(255, 68, 68, 0.7), 0 0 20px rgba(255, 68, 68, 0.8), inset 0 0 0 3px #ff4444 !important;
            animation: none !important;
        }
        
        body.wooden-theme .highlight-danger {
            box-shadow: inset 0 0 30px rgba(255, 107, 107, 0.7), 0 0 20px rgba(255, 107, 107, 0.8), inset 0 0 0 2px #ff6b6b !important;
            animation: none !important;
        }
        
        body.wooden-theme .highlight-gray {
            box-shadow: inset 0 0 30px rgba(128, 128, 128, 0.7), 0 0 20px rgba(128, 128, 128, 0.8), inset 0 0 0 3px #808080 !important;
            animation: none !important;
        }
        
        body.wooden-theme .highlight-diagonal {
            box-shadow: inset 0 0 30px rgba(155, 89, 182, 0.7), 0 0 20px rgba(155, 89, 182, 0.8), inset 0 0 0 3px #9b59b6 !important;
            animation: none !important;
        }
        
        body.wooden-theme .highlight-under-attack {
            box-shadow: inset 0 0 30px rgba(255, 68, 68, 0.9), 0 0 25px rgba(255, 68, 68, 1), inset 0 0 0 4px #ff4444 !important;
            animation: none !important;
        }
        
        body.wooden-theme .highlight-rhombus-check {
            box-shadow: inset 0 0 30px rgba(255, 215, 0, 0.8), 0 0 25px rgba(255, 215, 0, 1), inset 0 0 0 4px #ffd700 !important;
            animation: none !important;
        }
        
        body.wooden-theme .highlight-selected {
            box-shadow: inset 0 0 30px rgba(255, 215, 0, 0.7), 0 0 20px rgba(255, 215, 0, 0.8), inset 0 0 0 3px #ffd700 !important;
            animation: none !important;
        }

        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        body {
            background: var(--body-bg);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 0;
            margin: 0;
            color: var(--text-color);
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        /* Board container - centered in game area */
        #board-display-container {
             position: fixed;
             top: 0;
             left: 0;
             display: flex;
             justify-content: center;
             align-items: center;
             width: 100%;
             height: 100%;
             padding-top: 16vh;
             padding-bottom: calc(10vh - 200px);
             padding-left: 2vw;
             padding-right: 2vw;
             box-sizing: border-box;
             overflow: visible;
             z-index: 3000;
             background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 25%, #0f1923 50%, #1a1f3a 75%, #0a0e27 100%);
        }

        .board {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0;
            transform: rotate(90deg) scale(0.85);
            transform-origin: center center;
            margin: 0 auto;
            flex-shrink: 1;
            width: auto;
            height: auto;
            max-width: 80vmin;
            max-height: 80vh;
            transition: transform 0.3s ease;
        }
        
        /* Board flip for white player perspective */
        .board.flipped {
            transform: rotate(270deg) scale(0.85);
            transform-origin: center center;
        }

        /* Mini Board for Analysis Modal */
        .mini-board {
            --mini-hex-size: 28px;
            --mini-hex-gap: 0.5px;
            --mini-hex-height: calc(var(--mini-hex-size) * 2);
            --mini-hex-width: calc(var(--mini-hex-size) * 1.73205);
            --mini-hex-margin-top: calc(var(--mini-hex-height) * -0.25 - var(--mini-hex-gap) * 0.5);
            --mini-hex-row-offset: calc(var(--mini-hex-width) / 2 + var(--mini-hex-gap) * 0.866 / 2);
            --mini-hex-horizontal-spacing: calc(var(--mini-hex-gap) * 3.866 / 1);
            
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transform: rotate(90deg) scale(1);
            transform-origin: center center;
            margin: 0 auto;
            min-width: 500px;
            min-height: 500px;
        }
        
        .mini-board .row {
            display: flex;
            margin-top: var(--mini-hex-margin-top);
            justify-content: center;
        }
        
        .mini-board .row:first-child {
            margin-top: 0;
        }
        
        .mini-board .row:nth-child(odd) {
            margin-left: var(--mini-hex-row-offset);
        }
        
        .mini-board .hexagon {
            position: relative;
            width: var(--mini-hex-width);
            height: var(--mini-hex-height);
            background-color: var(--color-orange-med);
            margin-left: var(--mini-hex-horizontal-spacing);
            margin-right: var(--mini-hex-horizontal-spacing);
            cursor: default;
            flex-shrink: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            box-shadow: inset 0 0 4px rgba(0,0,0,0.5);
        }
        
        .mini-board .piece {
            width: calc(var(--mini-hex-size) * 1.8);
            height: calc(var(--mini-hex-size) * 1.8);
            pointer-events: none;
            transform: rotate(-90deg); /* Counter-rotate to keep pieces upright */
        }

        .row {
            display: flex;
            margin-top: var(--hex-margin-top);
            justify-content: center;
        }
        .row:first-child {
            margin-top: 0;
        }
        .row:nth-child(even) {
            margin-left: var(--hex-row-offset); /* Stagger even rows */
        }

        .hexagon {
            position: relative;
            width: var(--hex-width);
            height: var(--hex-height);
            background-color: var(--color-orange-med); /* Default color */
            margin-left: var(--hex-horizontal-spacing);
            margin-right: var(--hex-horizontal-spacing);
            cursor: pointer;
            flex-shrink: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            box-shadow: inset 0 0 8px rgba(0,0,0,0.5); /* Inner shadow */
            transition: none;
        }

        /* Color override classes */
        .color-dark-brown { background-color: var(--color-dark-brown); }
        .color-orange-med { background-color: var(--color-orange-med); }
        .color-orange-light { background-color: var(--color-orange-light); }

        /* Highlight for movement pattern */
        .highlight-green {
            background-color: #4ecdc4 !important;
            box-shadow: none !important;
            z-index: 10;
            position: relative;
        }
        
        /* Highlight for diagonal rhombus moves (special ability) */
        .highlight-diagonal {
            background-color: #9b59b6 !important;
            box-shadow: none !important;
            z-index: 10;
            position: relative;
        }
        
        /* Highlight for attack pattern */
        .highlight-red {
            background-color: rgba(255, 68, 68, 0.8) !important;
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.9), inset 0 0 15px rgba(255, 0, 0, 0.6) !important;
            z-index: 10;
            position: relative;
            border: 2px solid #ff0000 !important;
        }
        
        /* Highlight for defensive positions (friendly protecting friendly) */
        .highlight-gray {
            background-color: rgba(128, 128, 128, 0.5) !important;
            box-shadow: none !important;
            z-index: 9;
            position: relative;
        }
        
        /* NEW: Highlight for piece that just moved and is under attack */
        .highlight-under-attack {
            background-color: #ff4444 !important;
            box-shadow: none !important;
            animation: none !important;
            transition: none !important;
        }
        
        /* NEW: Special yellow highlight for RHOMBUS under attack (CHECK/DEADLOCK warning) */
        .highlight-rhombus-check {
            background-color: #ffd700 !important;
            box-shadow: none !important;
            animation: none !important;
            transition: none !important;
        }
        
        @keyframes pulse-red {
            0%, 100% { box-shadow: inset 0 0 10px rgba(0,0,0,0.6), 0 0 20px rgba(255, 68, 68, 0.9); }
            50% { box-shadow: inset 0 0 10px rgba(0,0,0,0.6), 0 0 30px rgba(255, 68, 68, 1); }
        }
        
        /* Highlight for danger zone (where piece would be vulnerable) */
        .highlight-danger {
            background-color: #ff6b6b !important;
            box-shadow: none !important;
            z-index: 10;
            position: relative;
        }
        
        /* Highlight for pieces defended by friendly pieces */
        .highlight-defended {
            background-color: #3498db !important;
            box-shadow: none !important;
            z-index: 10;
            position: relative;
        }
        
        /* Highlight for last move - source hex */
        .highlight-last-move-from {
            background-color: rgba(255, 215, 0, 0.25) !important;
        }
        
        /* Highlight for last move - destination hex */
        .highlight-last-move-to {
            background-color: rgba(255, 215, 0, 0.4) !important;
        }
        
        /* Highlight for pieces under threat (centered warning circle) */
        .hexagon.highlight-threat::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 12px;
            height: 12px;
            background-color: #ff4444 !important;
            border-radius: 50%;
            z-index: 5;
            border: 2px solid #fff;
            box-shadow: 0 0 4px rgba(255, 68, 68, 0.8);
            pointer-events: none; /* Don't block clicks! */
        }
        
        /* Ensure the hexagon has relative positioning for absolute child */
        .hexagon.highlight-threat {
            position: relative;
        }

        /* FOG OF WAR EFFECTS */
        .hexagon.fog-hidden {
            background-color: rgba(40, 40, 40, 0.85) !important;
            background-image: repeating-linear-gradient(
                45deg,
                transparent,
                transparent 10px,
                rgba(0, 0, 0, 0.3) 10px,
                rgba(0, 0, 0, 0.3) 20px
            ) !important;
            filter: brightness(0.4) blur(1px);
            transition: all 0.3s ease;
        }
        
        body.dark-mode .hexagon.fog-hidden {
            background-color: rgba(10, 10, 10, 0.9) !important;
            filter: brightness(0.2) blur(2px);
        }
        
        body.wooden-theme .hexagon.fog-hidden {
            filter: brightness(0.3) blur(2px) grayscale(0.7);
        }
        
        .hexagon.fog-dimmed {
            opacity: 0.6;
            filter: grayscale(0.5);
        }
        
        .hexagon.fog-revealed-temp {
            animation: fogRevealFlash 0.5s ease-out;
        }
        
        @keyframes fogRevealFlash {
            0% { box-shadow: 0 0 0 rgba(255, 215, 0, 0); }
            50% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.8), inset 0 0 20px rgba(255, 215, 0, 0.4); }
            100% { box-shadow: 0 0 0 rgba(255, 215, 0, 0); }
        }
        
        @keyframes fogRevealPulse {
            0%, 100% { transform: scale(1); filter: brightness(1); }
            50% { transform: scale(1.1); filter: brightness(1.3); }
        }

        /* Shift class for specific rows (applied based on index in HTML) */
        .hexagon.shift-down {
            /* Because the board is rotated 90deg, translateX moves visually down */
            transform: translateX(var(--vertical-shift));
        }

        .hex-coords {
            position: absolute;
            top: 50%;
            left: 50%;
            color: var(--hex-coords-color);
            transform: translate(-50%, -50%) rotate(-90deg); /* Center and counter-rotate */
            font-size: 9px;
            pointer-events: none;
            z-index: 0;
            font-weight: bold;
            white-space: nowrap;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7); /* Shadow for readability */
        }
        
        /* Counter-rotate coords when board is flipped */
        .board.flipped .hex-coords {
            transform: translate(-50%, -50%) rotate(-90deg) rotate(-180deg);
        }

        /* Visual markers for circle zone-change gateways */
        .hexagon.gateway-highlight {
            position: relative;
        }
        .hexagon.gateway-highlight::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255, 215, 0, 0.28); /* warm gold tint */
            border: 2px dashed rgba(255, 215, 0, 0.8);
            border-radius: inherit;
            z-index: 1;
            pointer-events: none;
        }

        /* Square piece */
        .square-piece {
            position: absolute;
            width: 56px;
            height: 56px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(90deg);
            z-index: 2;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        /* Black square piece */
        .square-piece:not(.white-piece) {
            background-image: url('ASSETS/square black front.png');
        }

        /* White square piece variant */
        .square-piece.white-piece {
            background-image: url('ASSETS/square white Front.png');
        }

        /* Triangle piece */
        .triangle-piece {
            position: absolute;
            width: 56px;
            height: 56px;
            top: 50%;
            left: 50%;
            /* Default orientation 0 = 270deg (pointing up) for BOTH colors */
            transform: translate(-50%, -50%) rotate(270deg);
            z-index: 2;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        /* Black triangle piece - same default as white */
        .triangle-piece:not(.white-triangle) {
            background-image: url('ASSETS/Triangle black front.png');
            /* Inherit default 270deg from base .triangle-piece */
        }

        /* White triangle piece - same default as black */
        .triangle-piece.white-triangle {
            background-image: url('ASSETS/Triangle white front.png');
            /* Inherit default 270deg from base .triangle-piece */
        }

        /* Rhombus piece */
        .rhombus-piece {
            position: absolute;
            width: 60px;
            height: 60px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(90deg);
            z-index: 2;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        /* Black rhombus piece */
        .rhombus-piece:not(.white-rhombus) {
            background-image: url('ASSETS/Rhombus black front.png');
        }

        /* White rhombus piece variant */
        .rhombus-piece.white-rhombus {
            background-image: url('ASSETS/Rhombus white front.png');
        }

        /* Circle piece */
        .circle-piece {
            position: absolute;
            width: 60px;
            height: 60px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(90deg);
            z-index: 2;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        /* Black circle */
        .circle-piece:not(.white-circle) {
            background-image: url('ASSETS/circle black front.png');
        }

        /* White circle */
        .circle-piece.white-circle {
            background-image: url('ASSETS/circle white front.png');
        }

        /* Hexgon piece (board hexagon piece shape) */
        .hexgon-piece {
            position: absolute;
            width: 60px;
            height: 60px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(90deg);
            z-index: 2;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        .hexgon-piece:not(.white-hexgon) {
            background-image: url('ASSETS/hexagon black front.png');
        }

        .hexgon-piece.white-hexgon {
            background-image: url('ASSETS/hexagon white front.png');
        }

        /* Eliminated pieces display - Chess.com style */
        #eliminated-pieces-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            justify-content: space-between;
            gap: 550px;
            z-index: 10;
            pointer-events: none;
            align-items: center;
            height: auto;
            width: auto;
            max-width: 90vw;
        }
        .variant-indicator {
            background-color: #2d2d2d;
            color: #fff;
            padding: 6px 10px;
            border-radius: 8px;
            font-weight: 700;
            font-size: 12px;
            text-align: center;
            margin-bottom: 8px;
            border: 1px solid #444;
        }

        /* Guest indicator badge and tooltip */
        .guest-indicator-badge { user-select: none; }
        .guest-indicator-badge:focus { outline: none; box-shadow: 0 0 0 3px rgba(255,107,107,0.15); }
        .guest-tooltip { pointer-events: none; }

        .eliminated-section {
            width: 180px;
            text-align: center;
            background-color: #262421; /* Chess.com panel color */
            border-radius: 8px;
            border: 1px solid #3d3935;
            padding: 15px;
            pointer-events: auto;
            /* Let the whole panel size naturally; only the moves list should scroll.
               This keeps the variant indicator and opening name visible and fixed. */
            max-height: none;
            overflow: visible;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
        }

        .eliminated-section h3 {
            color: #b8b6b3;
            margin: 0 0 10px 0;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
        }

        /* Embedded movement-section inside each eliminated panel */
        .movement-section {
            width: 100%;
            text-align: left;
            background-color: transparent;
            border-radius: 6px;
            padding: 8px 0 0 0;
            max-height: 220px;
            overflow-y: auto;
            overflow-x: hidden;
            scroll-behavior: smooth;
            pointer-events: auto;
            box-shadow: none;
            margin-top: 8px;
            border-top: 1px solid rgba(255,255,255,0.03);
        }

        .movement-section h3 {
            color: #ddd;
            margin: 0 0 6px 0;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            padding: 4px 0;
            font-weight: 700;
        }

        .movement-list { list-style: none; padding: 0; margin: 0; }
        .movement-item { color: #ccc; font-size: 11px; margin: 3px 0; padding: 4px 6px; background-color: #1f1f1f; border-radius: 4px; font-family: monospace; word-wrap: break-word; }
        .movement-item.white-move { color: #fff; background-color: #2b2b2b; }
        .movement-item.black-move { color: #ddd; background-color: #2f2f2f; }

        /* Eliminated circle sizes */
        .eliminated-piece.circle-piece {
            width: 40px;
            height: 40px;
            transform: rotate(90deg);
        }
        
        /* Movement tracking container removed (styles for .movement-section will be applied in-panel) */

        .eliminated-pieces {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 5px;
            min-height: 40px;
            padding: 10px;
            background-color: #1a1a1a;
            border-radius: 5px;
            border: 1px solid #555;
        }

        .eliminated-piece {
            width: 25px;
            height: 25px;
            margin: 2px;
            opacity: 0.7;
            filter: grayscale(0.3);
            position: relative;
            display: inline-block;
        }

        .eliminated-piece.square-piece {
            width: 28px;
            height: 28px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            margin: 2px 5px;
            transform: rotate(90deg);
        }

        .eliminated-piece.square-piece:not(.white-piece) {
            background-image: url('ASSETS/square black front.png');
        }

        .eliminated-piece.square-piece.white-piece {
            background-image: url('ASSETS/square white Front.png');
        }

        .eliminated-piece.triangle-piece {
            width: 40px;
            height: 40px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            margin: 2px 5px;
            transform: rotate(90deg);
        }

        .eliminated-piece.triangle-piece:not(.white-triangle) {
            background-image: url('ASSETS/Triangle black front.png');
            transform: rotate(90deg) rotate(180deg);
        }

        .eliminated-piece.triangle-piece.white-triangle {
            background-image: url('ASSETS/Triangle white front.png');
            transform: rotate(270deg);
        }

        .eliminated-piece.rhombus-piece {
            width: 40px;
            height: 40px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            margin: 2px 5px;
            transform: rotate(90deg);
        }

        .eliminated-piece.rhombus-piece:not(.white-rhombus) {
            background-image: url('ASSETS/Rhombus black front.png');
        }

        .eliminated-piece.rhombus-piece.white-rhombus {
            background-image: url('ASSETS/Rhombus white front.png');
        }

        .eliminated-piece.circle-piece {
            width: 32px;
            height: 32px;
            transform: rotate(90deg);
        }

        .eliminated-piece.hexgon-piece {
            width: 40px;
            height: 40px;
            transform: rotate(90deg);
        }

        /* Responsive design for mobile */
        @media (max-width: 768px) {
            #board-display-container {
                padding: 100px 10px 60px 10px !important;
            }
            
            :root {
                --hex-size: 28px; /* Smaller hexagons on mobile */
            }
            
            #start-menu > div {
                padding: 15px !important;
                margin: 5px !important;
                max-width: 95vw !important;
            }
            
            #start-menu h1 {
                font-size: 1.8em !important;
            }
            
            #start-menu h2 {
                font-size: 1em !important;
            }
            
            #start-menu h3 {
                font-size: 0.85em !important;
            }
            
            #start-menu .grid {
                grid-template-columns: 1fr !important;
                gap: 8px !important;
            }
            
            #start-menu ul {
                font-size: 0.75em !important;
            }
            
            #start-menu p {
                font-size: 0.8em !important;
            }
        }

        /* Multiplayer Modal Styles */
        #multiplayer-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }

        #multiplayer-modal.active {
            display: flex;
        }

        .multiplayer-container {
            background: #262421; /* Chess.com panel color */
            border: 2px solid #f57d2d;
            border-radius: 12px;
            padding: 40px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .multiplayer-container h2 {
            color: #f57d2d;
            text-align: center;
            margin-bottom: 30px;
            font-size: 28px;
        }

        .multiplayer-options {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .mp-button {
            background: linear-gradient(135deg, #f57d2d 0%, #d45a1f 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(245, 125, 45, 0.4);
        }

        .mp-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(245, 125, 45, 0.6);
        }

        .mp-button.secondary {
            background: linear-gradient(135deg, #4ecdc4 0%, #3aa89f 100%);
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.4);
        }

        .mp-button.secondary:hover {
            box-shadow: 0 6px 20px rgba(78, 205, 196, 0.6);
        }

        .mp-input {
            background-color: #333;
            border: 2px solid #555;
            color: white;
            padding: 12px;
            border-radius: 8px;
            font-size: 16px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .mp-input:focus {
            outline: none;
            border-color: #f57d2d;
            box-shadow: 0 0 10px rgba(245, 125, 45, 0.5);
        }

        .room-code-display {
            background-color: #333;
            border: 2px solid #4ecdc4;
            color: #4ecdc4;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            margin: 20px 0;
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 4px;
            font-family: 'Courier New', monospace;
        }

        .waiting-message {
            color: #fcc49c;
            text-align: center;
            font-size: 16px;
            margin: 15px 0;
        }

        .multiplayer-status {
            position: fixed;
            top: 80px;
            left: 20px;
            background-color: #262421; /* Chess.com panel color */
            border: 1px solid #3d3935;
            border-radius: 8px;
            padding: 15px;
            color: white;
            z-index: 9999;
            min-width: 200px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
        }
        
        /* Player Timers - Chess.com style */
        .player-timers {
            position: fixed;
            top: 20px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 100;
            pointer-events: none;
        }
        
        .timer-display {
            background-color: #262421;
            border: 2px solid #3d3935;
            border-radius: 8px;
            padding: 8px 16px;
            width: 180px; /* Match eliminated panel width */
            text-align: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            transition: all 0.3s ease;
            pointer-events: auto;
        }
        
        .timer-display.active {
            border-color: #4ecdc4;
            background-color: #2a3a38;
            box-shadow: 0 4px 16px rgba(78, 205, 196, 0.4);
        }
        
        .timer-display.low-time {
            border-color: #ff6b6b;
            background-color: #3a2626;
            animation: pulse-timer 1s infinite;
        }
        
        @keyframes pulse-timer {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .timer-label {
            font-size: 10px;
            color: #b8b6b3;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 3px;
            font-weight: 600;
        }
        
        .timer-time {
            font-size: 20px;
            font-weight: bold;
            color: #fff;
            font-family: 'Courier New', monospace;
        }
        
        .timer-display.low-time .timer-time {
            color: #ff6b6b;
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-indicator.connected {
            background-color: #4ecdc4;
            box-shadow: 0 0 10px #4ecdc4;
        }

        .status-indicator.disconnected {
            background-color: #ff4444;
            box-shadow: 0 0 10px #ff4444;
        }

        .status-indicator.waiting {
            background-color: #ffa502;
            box-shadow: 0 0 10px #ffa502;
        }

        .mp-error {
            color: #ff4444;
            text-align: center;
            margin: 10px 0;
            font-size: 14px;
        }

        .mp-back-button {
            background-color: #555;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 15px;
            width: 100%;
        }

        .mp-back-button:hover {
            background-color: #666;
        }

    </style>
</head>
<body>

    <!-- Splash Page -->
    <div id="splash-page" style="
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, #0f1923 0%, #1a2332 50%, #0f1923 100%);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 3000;
        color: white;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        overflow-y: auto;
        padding: 20px;
        box-sizing: border-box;
    ">
        <!-- Logo Section -->
        <div style="
            text-align: center;
            margin-bottom: 40px;
        ">
            <h1 style="
                font-size: 4em;
                font-weight: 800;
                margin: 0;
                background: linear-gradient(135deg, #f57d2d 0%, #fcc49c 100%);
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                background-clip: text;
                letter-spacing: 8px;
                text-shadow: 0 0 40px rgba(245, 125, 45, 0.5);
                animation: logoGlow 2s ease-in-out infinite alternate;
            ">ROMGON</h1>
            <p style="
                font-size: 1.2em;
                margin: 10px 0 0 0;
                color: #fcc49c;
                font-weight: 300;
                letter-spacing: 3px;
            ">HEXAGONAL STRATEGY GAME</p>
        </div>

        <!-- Game Description -->
        <div style="
            max-width: 600px;
            text-align: center;
            margin-bottom: 50px;
            padding: 0 20px;
        ">
            <p style="
                font-size: 1.1em;
                line-height: 1.6;
                color: #ddd;
                margin: 0 0 20px 0;
            ">
                Master the hexagonal battlefield in this strategic masterpiece. Command unique pieces with rotational abilities,
                navigate complex zone systems, and outmaneuver your opponent in a game of tactical brilliance.
            </p>
            <div style="
                display: flex;
                justify-content: center;
                gap: 30px;
                margin-top: 30px;
            ">
                <div style="text-align: center;">
                    <div style="font-size: 2em; margin-bottom: 5px;">‚ôüÔ∏è</div>
                    <div style="font-size: 0.9em; color: #4ecdc4; font-weight: 600;">7 Unique Pieces</div>
                </div>
                <div style="text-align: center;">
                    <div style="font-size: 2em; margin-bottom: 5px;">üîÑ</div>
                    <div style="font-size: 0.9em; color: #a55eea; font-weight: 600;">Rotational Tactics</div>
                </div>
                <div style="text-align: center;">
                    <div style="font-size: 2em; margin-bottom: 5px;">üéØ</div>
                    <div style="font-size: 0.9em; color: #ffd700; font-weight: 600;">Strategic Depth</div>
                </div>
            </div>
        </div>

        <!-- Login Options -->
        <div style="
            display: flex;
            flex-direction: column;
            gap: 20px;
            min-width: 300px;
            max-width: 400px;
        ">
            <!-- Google Login Button -->
            <button id="google-login-btn" style="
                background: linear-gradient(135deg, #4285f4 0%, #34a853 50%, #ea4335 100%);
                color: white;
                border: none;
                padding: 18px 30px;
                border-radius: 50px;
                cursor: pointer;
                font-weight: 700;
                font-size: 1.1em;
                box-shadow: 0 6px 20px rgba(66, 133, 244, 0.4);
                transition: all 0.3s ease;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 12px;
                letter-spacing: 0.5px;
            " onmouseover="this.style.transform='translateY(-3px)'; this.style.boxShadow='0 10px 30px rgba(66, 133, 244, 0.6)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 6px 20px rgba(66, 133, 244, 0.4)'">
                <svg width="20" height="20" viewBox="0 0 24 24">
                    <path fill="currentColor" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                    <path fill="currentColor" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                    <path fill="currentColor" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                    <path fill="currentColor" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                </svg>
                Sign in with Google
            </button>

            <!-- Guest Login Button -->
            <button id="guest-login-btn" style="
                background: linear-gradient(135deg, rgba(78, 205, 196, 0.2), rgba(78, 205, 196, 0.1));
                color: #4ecdc4;
                border: 2px solid #4ecdc4;
                padding: 18px 30px;
                border-radius: 50px;
                cursor: pointer;
                font-weight: 700;
                font-size: 1.1em;
                box-shadow: 0 4px 15px rgba(78, 205, 196, 0.2);
                transition: all 0.3s ease;
                letter-spacing: 0.5px;
            " onmouseover="this.style.transform='translateY(-3px)'; this.style.boxShadow='0 8px 25px rgba(78, 205, 196, 0.4)'; this.style.background='linear-gradient(135deg, rgba(78, 205, 196, 0.3), rgba(78, 205, 196, 0.2))'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(78, 205, 196, 0.2)'; this.style.background='linear-gradient(135deg, rgba(78, 205, 196, 0.2), rgba(78, 205, 196, 0.1))'">
                üéÆ Continue as Guest
            </button>
        </div>

        <!-- Footer Info -->
        <div style="
            position: absolute;
            bottom: 30px;
            text-align: center;
            color: #888;
            font-size: 0.9em;
        ">
            <p style="margin: 0;">¬© 2025 ROMGON - Strategic Hexagonal Gaming</p>
        </div>
    </div>

    <!-- User Home Page (shown after login) -->
    <div id="user-home" style="
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, #0f1923 0%, #1a2332 50%, #0f1923 100%);
        display: none;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 3000;
        color: white;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        padding: 40px 20px;
        box-sizing: border-box;
    ">
        <!-- Header with profile badge -->
        <div style="
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        ">
            <h1 style="
                margin: 0;
                font-size: 2.5em;
                background: linear-gradient(135deg, #f57d2d 0%, #fcc49c 100%);
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                background-clip: text;
                letter-spacing: 3px;
            ">ROMGON</h1>
            <div style="font-size: 2em; cursor: pointer;" onclick="handleSignOut();">√ó</div>
        </div>

        <!-- Welcome Card -->
        <div style="
            background: rgba(38, 36, 33, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 50px 40px;
            max-width: 500px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 204, 156, 0.2);
        ">
            <!-- Avatar -->
            <div id="user-home-avatar" style="
                width: 100px;
                height: 100px;
                border-radius: 50%;
                background: linear-gradient(135deg, #4ecdc4, #a55eea);
                margin: 0 auto 20px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 48px;
                font-weight: bold;
                color: #fff;
                box-shadow: 0 10px 30px rgba(78, 205, 196, 0.3);
            ">G</div>

            <!-- Player Name -->
            <h2 id="user-home-name" style="
                margin: 0 0 10px 0;
                font-size: 28px;
                font-weight: 700;
                color: #fff;
            ">Welcome Player</h2>

            <!-- Email / Status -->
            <p id="user-home-email" style="
                margin: 0 0 30px 0;
                color: #aaa;
                font-size: 14px;
            ">guest@example.com</p>

            <!-- Start Game Button -->
            <button onclick="hideSplashPage(); document.getElementById('user-home').style.display='none';" style="
                background: linear-gradient(135deg, #4ecdc4 0%, #45b7aa 100%);
                color: #fff;
                border: none;
                padding: 16px 40px;
                border-radius: 50px;
                cursor: pointer;
                font-weight: 700;
                font-size: 1.1em;
                box-shadow: 0 6px 20px rgba(78, 205, 196, 0.4);
                transition: all 0.3s ease;
                margin-bottom: 12px;
            " onmouseover="this.style.transform='translateY(-3px)'; this.style.boxShadow='0 10px 30px rgba(78, 205, 196, 0.6)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 6px 20px rgba(78, 205, 196, 0.4)'">
                üéÆ Start Game
            </button>

            <!-- Sign Out Button -->
            <button onclick="handleSignOut();" style="
                background: transparent;
                color: #ff6b6b;
                border: 2px solid #ff6b6b;
                padding: 12px 30px;
                border-radius: 50px;
                cursor: pointer;
                font-weight: 600;
                font-size: 1em;
                transition: all 0.3s ease;
            " onmouseover="this.style.background='rgba(255, 107, 107, 0.1)'" onmouseout="this.style.background='transparent'">
                Sign Out
            </button>
        </div>

        <!-- Stats Footer (optional) -->
        <div style="
            position: absolute;
            bottom: 30px;
            left: 0;
            right: 0;
            text-align: center;
            color: #888;
            font-size: 0.9em;
        ">
            <p style="margin: 0;">Ready to strategize? Your game awaits!</p>
        </div>
    </div>

    <style>
        @keyframes logoGlow {
            0% { text-shadow: 0 0 20px rgba(245, 125, 45, 0.3); }
            100% { text-shadow: 0 0 40px rgba(245, 125, 45, 0.7); }
        }

        @media (max-width: 768px) {
            #splash-page h1 {
                font-size: 3em !important;
                letter-spacing: 4px !important;
            }

            #splash-page {
                padding: 15px !important;
            }

            .login-options {
                min-width: 280px !important;
                max-width: 350px !important;
            }

            #user-home {
                padding: 20px !important;
            }
        }
    </style>

    <!-- Compact Professional Start Menu -->
    <div id="start-menu" style="
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, #0f1419 0%, #1a1f2e 50%, #0f1419 100%);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 2000;
        color: white;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        overflow-y: auto;
        padding: 40px 20px;
        box-sizing: border-box;
    ">
        <!-- Logo/Title Section -->
        <div style="
            text-align: center;
            margin-bottom: 60px;
            max-width: 800px;
        ">
            <h1 style="
                font-size: 3.5em;
                font-weight: 900;
                margin: 0 0 10px 0;
                background: linear-gradient(135deg, #f57d2d 0%, #ffa500 100%);
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                background-clip: text;
                letter-spacing: 8px;
            ">ROMGON</h1>
            <p style="
                font-size: 0.9em;
                margin: 0;
                color: #999;
                font-weight: 300;
                letter-spacing: 3px;
            ">HEXAGONAL STRATEGY GAME</p>
        </div>
        
        <!-- Return to Game Link (shown when in active game) -->
        <div id="return-to-game-container" style="
            display: none;
            text-align: center;
            margin-bottom: 50px;
        ">
            <a onclick="returnToGame()" style="
                color: #ff6b6b;
                font-size: 1.2em;
                font-weight: 700;
                cursor: pointer;
                text-decoration: none;
                letter-spacing: 2px;
                padding: 10px 20px;
                border-bottom: 2px solid #ff6b6b;
                transition: all 0.3s ease;
                display: inline-block;
            " onmouseover="this.style.color='#ff8a8a'; this.style.textShadow='0 0 20px rgba(255, 107, 107, 0.5)'" onmouseout="this.style.color='#ff6b6b'; this.style.textShadow='none'">
                ‚Üê RETURN TO GAME
            </a>
        </div>
        
        <!-- Main Menu - Text-Based Interface -->
        <div style="
            max-width: 900px;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 50px;
        ">
            <!-- Game Modes Section -->
            <div>
                <h2 style="
                    color: #f57d2d;
                    font-size: 1.5em;
                    margin: 0 0 30px 0;
                    font-weight: 700;
                    letter-spacing: 3px;
                    border-bottom: 2px solid #f57d2d;
                    padding-bottom: 10px;
                ">GAME MODES</h2>
                
                <div style="
                    display: flex;
                    flex-direction: column;
                    gap: 20px;
                ">
                    <div style="display: flex; align-items: center; gap: 20px;">
                        <span style="color: #4ecdc4; font-size: 1.8em;">üë•</span>
                        <a id="start-game-btn" onclick="startGameWithTime(10)" style="
                            color: #4ecdc4;
                            font-size: 1.2em;
                            font-weight: 600;
                            cursor: pointer;
                            text-decoration: none;
                            letter-spacing: 1px;
                            transition: all 0.3s ease;
                            display: inline-block;
                        " onmouseover="this.style.color='#5eddd4'; this.style.textShadow='0 0 15px rgba(78, 205, 196, 0.5)'" onmouseout="this.style.color='#4ecdc4'; this.style.textShadow='none'">LOCAL PVP</a>
                        <span style="color: #666; font-size: 0.9em; margin-left: auto;">Two players ‚Ä¢ Same device</span>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 20px;">
                        <span style="color: #26de81; font-size: 1.8em;">üåê</span>
                        <a id="start-multiplayer-btn" style="
                            color: #26de81;
                            font-size: 1.2em;
                            font-weight: 600;
                            cursor: pointer;
                            text-decoration: none;
                            letter-spacing: 1px;
                            transition: all 0.3s ease;
                            display: inline-block;
                        " onmouseover="this.style.color='#3bed92'; this.style.textShadow='0 0 15px rgba(38, 222, 129, 0.5)'" onmouseout="this.style.color='#26de81'; this.style.textShadow='none'">ONLINE</a>
                        <span style="color: #666; font-size: 0.9em; margin-left: auto;">Play online ‚Ä¢ With friends</span>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 20px;">
                        <span style="color: #a55eea; font-size: 1.8em;">ü§ñ</span>
                        <a id="start-ai-mode-btn" style="
                            color: #a55eea;
                            font-size: 1.2em;
                            font-weight: 600;
                            cursor: pointer;
                            text-decoration: none;
                            letter-spacing: 1px;
                            transition: all 0.3s ease;
                            display: inline-block;
                        " onmouseover="this.style.color='#b075ff'; this.style.textShadow='0 0 15px rgba(165, 94, 234, 0.5)'" onmouseout="this.style.color='#a55eea'; this.style.textShadow='none'">VS AI</a>
                        <span style="color: #666; font-size: 0.9em; margin-left: auto;">Smart AI ‚Ä¢ Opponent</span>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 20px;">
                        <span style="color: #ffd700; font-size: 1.8em;">üß©</span>
                        <a id="start-puzzles-btn" style="
                            color: #ffd700;
                            font-size: 1.2em;
                            font-weight: 600;
                            cursor: pointer;
                            text-decoration: none;
                            letter-spacing: 1px;
                            transition: all 0.3s ease;
                            display: inline-block;
                        " onmouseover="this.style.color='#ffed4e'; this.style.textShadow='0 0 15px rgba(255, 215, 0, 0.5)'" onmouseout="this.style.color='#ffd700'; this.style.textShadow='none'">PUZZLES</a>
                        <span style="color: #666; font-size: 0.9em; margin-left: auto;">Train skills ‚Ä¢ Solve challenges</span>
                    </div>
                </div>
            </div>
            
            <!-- Reference Section -->
            <div>
                <h2 style="
                    color: #00d2ff;
                    font-size: 1.5em;
                    margin: 0 0 30px 0;
                    font-weight: 700;
                    letter-spacing: 3px;
                    border-bottom: 2px solid #00d2ff;
                    padding-bottom: 10px;
                ">REFERENCE & LEARNING</h2>
                
                <div style="
                    display: flex;
                    flex-direction: column;
                    gap: 20px;
                ">
                    <div style="display: flex; align-items: center; gap: 20px;">
                        <span style="color: #f1c40f; font-size: 1.8em;">üìä</span>
                        <a onclick="showStatsDashboard()" style="
                            color: #f1c40f;
                            font-size: 1.2em;
                            font-weight: 600;
                            cursor: pointer;
                            text-decoration: none;
                            letter-spacing: 1px;
                            transition: all 0.3s ease;
                            display: inline-block;
                        " onmouseover="this.style.color='#ffd700'; this.style.textShadow='0 0 15px rgba(241, 196, 15, 0.5)'" onmouseout="this.style.color='#f1c40f'; this.style.textShadow='none'">STATISTICS DASHBOARD</a>
                        <span style="color: #666; font-size: 0.9em; margin-left: auto;">Track wins ‚Ä¢ Piece stats</span>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 20px;">
                        <span style="color: #4ecdc4; font-size: 1.8em;">üìñ</span>
                        <a onclick="showOpeningBook()" style="
                            color: #4ecdc4;
                            font-size: 1.2em;
                            font-weight: 600;
                            cursor: pointer;
                            text-decoration: none;
                            letter-spacing: 1px;
                            transition: all 0.3s ease;
                            display: inline-block;
                        " onmouseover="this.style.color='#5eddd4'; this.style.textShadow='0 0 15px rgba(78, 205, 196, 0.5)'" onmouseout="this.style.color='#4ecdc4'; this.style.textShadow='none'">OPENING BOOK</a>
                        <span style="color: #666; font-size: 0.9em; margin-left: auto;">Standard openings ‚Ä¢ Diagrams</span>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 20px;">
                        <span style="color: #a55eea; font-size: 1.8em;">üß†</span>
                        <a onclick="openTheoryModal()" style="
                            color: #a55eea;
                            font-size: 1.2em;
                            font-weight: 600;
                            cursor: pointer;
                            text-decoration: none;
                            letter-spacing: 1px;
                            transition: all 0.3s ease;
                            display: inline-block;
                        " onmouseover="this.style.color='#b075ff'; this.style.textShadow='0 0 15px rgba(165, 94, 234, 0.5)'" onmouseout="this.style.color='#a55eea'; this.style.textShadow='none'">THEORY & ENDGAMES</a>
                        <span style="color: #666; font-size: 0.9em; margin-left: auto;">Strategy ‚Ä¢ Complexity analysis</span>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 20px;">
                        <span style="color: #f57d2d; font-size: 1.8em;">üìú</span>
                        <a onclick="openRulebookModal()" style="
                            color: #f57d2d;
                            font-size: 1.2em;
                            font-weight: 600;
                            cursor: pointer;
                            text-decoration: none;
                            letter-spacing: 1px;
                            transition: all 0.3s ease;
                            display: inline-block;
                        " onmouseover="this.style.color='#ffa500'; this.style.textShadow='0 0 15px rgba(245, 125, 45, 0.5)'" onmouseout="this.style.color='#f57d2d'; this.style.textShadow='none'">RULEBOOK</a>
                        <span style="color: #666; font-size: 0.9em; margin-left: auto;">Full rules ‚Ä¢ How to play</span>
                    </div>
                </div>
            </div>
            
            <!-- Game Info -->
            <div style="
                text-align: center;
                color: #999;
                font-size: 0.85em;
                max-width: 600px;
                margin: 0 auto;
                line-height: 1.6;
                padding-top: 30px;
                border-top: 1px solid #333;
            ">
                <p style="margin: 0 0 10px 0;">
                    <strong style="color: #f57d2d;">Objective:</strong> Move your rhombus to opponent's base or trap theirs
                </p>
                <p style="margin: 0;">
                    <strong style="color: #4ecdc4;">Tip:</strong> Start with Local PVP to learn the basics
                </p>
            </div>
        </div>
    <!-- Theory Modal -->
    <div id="theory-modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.92); z-index:10001; justify-content:center; align-items:center; overflow-y:auto;">
        <div style="background:#262421; border:3px solid #a55eea; border-radius:20px; padding:40px 30px; max-width:900px; width:95vw; margin:40px auto; box-shadow:0 10px 50px rgba(165,94,234,0.2); position:relative; color:#fff;">
            <h2 style="color:#a55eea; text-align:center; margin-bottom:24px; font-size:2em;">üß† ROMGON Theory & Endgame Guide</h2>
            <div id="theory-content" style="max-height:65vh; overflow-y:auto; color:#eee; font-size:1.08em; line-height:1.7; background:rgba(0,0,0,0.10); padding:18px; border-radius:10px; border:1px solid #444; white-space:pre-wrap;"></div>
            <button onclick="closeTheoryModal()" style="margin-top:28px; background:#a55eea; color:#fff; border:none; padding:12px 32px; border-radius:8px; font-size:1.1em; font-weight:600; cursor:pointer; width:100%; transition:all 0.2s;" onmouseover="this.style.background='#8e44ad'" onmouseout="this.style.background='#a55eea'">Close</button>
        </div>
    </div>
    <script>
    // THEORY MODAL LOGIC
    function openTheoryModal() {
                const modal = document.getElementById('theory-modal');
                const contentDiv = document.getElementById('theory-content');
                if (!contentDiv.dataset.loaded) {
                                                contentDiv.innerHTML = `
<div style="color:#eee; font-size:1.08em; line-height:1.7;">
    <h2 style="color:#a55eea; text-align:center; margin-top:0;">üß† ROMGON Theoretical Aspects</h2>
    <div style="text-align:center; color:#ffd700; font-size:1em; margin-bottom:18px;">Last updated: October 12, 2025</div>
    <hr style="border:1px solid #444; margin:18px 0;"/>

    <h3 style="color:#4ecdc4;">1. State Space Complexity</h3>
    <ul>
        <li>The board has <span style="color:#ffd700; font-weight:bold;">51 hexes</span> (variable per row, with central symmetry).</li>
        <li>Each player has <span style="color:#ffd700; font-weight:bold;">7 pieces</span> (2 Triangles, 2 Squares, 1 Rhombus, 1 Circle, 1 Hexagon), all distinguishable by type and color.</li>
        <li>Piece orientation (for triangles/hexagons) increases the number of unique positions.</li>
        <li><b>Estimated arrangements:</b> <span style="color:#fdcb6e;">C(51,14) √ó 7! √ó 7! ‚âà 10<sup>18</sup></span>. Including empty hexes, captures, and orientation, the true number is much higher‚Äîlikely <span style="color:#fdcb6e; font-weight:bold;">10<sup>25</sup> to 10<sup>32</sup></span>.</li>
        <li><b>Comparison:</b> Similar to or greater than chess, but less than Go.</li>
    </ul>

    <h3 style="color:#a55eea;">2. Game Tree Complexity</h3>
    <ul>
        <li>Each turn: <span style="color:#ffd700;">10‚Äì40 legal moves</span> (varies by position, phase, and piece count).</li>
        <li>Rotations and zone transitions add to the branching factor.</li>
        <li>Average game length: <span style="color:#4ecdc4;">60‚Äì120 moves</span> (30‚Äì60 per player).</li>
        <li><b>Estimated total possible games:</b> <span style="color:#fdcb6e;">10<sup>80</sup> to 10<sup>120</sup></span>.</li>
        <li><b>Longest forced win:</b> Likely hundreds of moves in fortress/blockade endgames.</li>
    </ul>

    <h3 style="color:#ffd700;">3. Move Types and Branching</h3>
    <ul>
        <li><b>Move types:</b> Standard moves, rotations, captures, special moves (gateway, base entry, deadlock escapes).</li>
        <li><b>Branching factor:</b> Early: <span style="color:#4ecdc4;">20‚Äì40</span>, Midgame: <span style="color:#4ecdc4;">10‚Äì30</span>, Endgame: <span style="color:#4ecdc4;">2‚Äì10</span>.</li>
        <li>Rotational moves and zone transitions make Romgon's branching factor more volatile than chess.</li>
    </ul>

    <h3 style="color:#fdcb6e;">4. Symmetry and Redundancy</h3>
    <ul>
        <li><b>Hexagonal symmetry:</b> 6-fold, but piece orientation and color break most symmetries.</li>
        <li>Some positions are equivalent under rotation/reflection, but most are unique.</li>
        <li><b>Redundancy:</b> Many positions are theoretically possible but illegal (e.g., two pieces on one hex).</li>
        <li>Symmetry can reduce AI search space, but only partially.</li>
    </ul>

    <h3 style="color:#4ecdc4;">5. Draws, Forced Wins, and Zugzwang</h3>
    <ul>
        <li><b>No draws by repetition:</b> <span style="color:#ff6b6b;">Threefold repetition and fivefold shuttle are losses</span>, not draws.</li>
        <li><b>Forced wins:</b> Endgames with only rhombuses are often races; fortress variant allows for blockades and forced wins by attrition.</li>
        <li><b>Zugzwang:</b> Forced loss by moving is common, especially in endgames with few pieces.</li>
        <li><b>Deadlock:</b> Opponent's rhombus under attack with no legal moves is a win.</li>
        <li><b>Draglock:</b> No legal moves at all is a loss.</li>
    </ul>

    <h3 style="color:#a55eea;">6. Opening Theory</h3>
    <ul>
        <li><b>Opening book:</b> Still developing; few forced lines, but early mistakes can be decisive.</li>
        <li>Central control, base defense, and piece development are key.</li>
        <li>Early circle and hexagon moves can create threats or open gateways.</li>
        <li>Triangles are flexible but vulnerable to poor orientation.</li>
        <li><b>Typical themes:</b> Control of the Dead Zone and gateways, early base defense, avoiding congestion, maximizing mobility.</li>
    </ul>

    <h3 style="color:#ffd700;">7. Endgame Theory</h3>
    <ul>
        <li><b>Rhombus endgames:</b> Often races to the base or blockades; fortress variant increases defensive resources.</li>
        <li>Sacrifices and forced shuttles are common.</li>
        <li>Endgames can be very deep, with forced wins requiring precise calculation.</li>
        <li><b>Piece value:</b> Triangles and hexagons become more valuable for their mobility and rotation; circles can be decisive in zone transitions.</li>
    </ul>

    <h3 style="color:#fdcb6e;">8. Computational Complexity</h3>
    <ul>
        <li><b>Solving Romgon:</b> Likely <span style="color:#4ecdc4;">EXPTIME-complete</span> (like chess and hex), due to large state and game tree complexity.</li>
        <li>No known perfect play algorithm; AI uses heuristics, alpha-beta search, and Monte Carlo methods.</li>
        <li>Tablebases for small endgames are possible but would be very large.</li>
        <li><b>AI challenges:</b> Rotational moves and zone transitions make evaluation and search more difficult than in chess.</li>
        <li>Threat detection and deadlock/draglock recognition are nontrivial.</li>
    </ul>

    <h3 style="color:#a55eea;">Endgame and Base Defense Rules in Romgon</h3>
        <div style="margin-bottom:10px; color:#ffd700; font-weight:bold;">Romgon endgames can reach rare situations where a lone rhombus is blocked by non-rhombus pieces, creating a fortress or blockade. The game supports two base-defense variants to handle these:</div>
    <ol style="margin-left:18px;">
        <li><b style="color:#4ecdc4;">Repetition Rule (Default):</b> If the same position occurs three times, the player who repeats <span style="color:#ff6b6b;">loses</span>. Prevents endless blockades. <span style="color:#4ecdc4;">Pros:</span> Familiar, fair. <span style="color:#ff6b6b;">Cons:</span> Sometimes a player with a big advantage cannot win if blocked by a fortress.</li>
        <li><b style="color:#a55eea;">Unstoppable Rhombus Wins (Variant):</b> If a rhombus is one move from the goal and cannot be stopped or captured, that player wins immediately. <span style="color:#4ecdc4;">Pros:</span> Dramatic, rewards skillful play. <span style="color:#ff6b6b;">Cons:</span> Requires clear adjudication.</li>
        <li><b style="color:#ffd700;">Last Non-Rhombus Piece Lost = Game Over (Optional):</b> If a player loses their last non-rhombus piece, they lose. <span style="color:#4ecdc4;">Pros:</span> Simple. <span style="color:#ff6b6b;">Cons:</span> Removes rhombus-only races and can feel abrupt.</li>
    </ol>
    <div style="margin:10px 0; color:#4ecdc4; font-weight:bold;">Recommendation:</div>
    <ul>
        <li>The default Romgon rules use the repetition rule to resolve fortress/blockade situations.</li>
        <li>For advanced or tournament play, you may use the "Unstoppable Rhombus Wins" rule to reward decisive play and avoid unsatisfying blockades.</li>
        <li>The "Last Non-Rhombus Piece Lost" rule is not recommended for standard play, but may be used as a fast-paced variant.</li>
    </ul>
    <div style="color:#ffd700; font-weight:bold; margin-top:10px;">Players should agree on which rule to use before the game begins.</div>

    <hr style="border:1px solid #444; margin:18px 0;"/>
    <div style="color:#eee; font-size:1.08em; text-align:center; margin-top:18px;">
        Romgon is a deep, complex game with rich theoretical possibilities. Its combination of hex geometry, piece rotation, and unique rules creates a vast landscape for exploration, analysis, and creative play.<br>
        <span style="color:#4ecdc4;">Ongoing research may reveal new forced wins, opening traps, and endgame studies in the years to come!</span>
    </div>
</div>
    - Zugzwang (forced loss by moving) is common, especially in endgames with few pieces.
    - Some positions are mutual zugzwang, where either player to move loses.
- **Deadlock and draglock:**
    - Deadlock (opponent's rhombus under attack with no legal moves) is a win.
    - Draglock (no legal moves at all) is a loss.

## 6. Opening Theory
- **Opening book:**
    - Still developing; few forced lines, but early mistakes can be decisive.
    - Central control, base defense, and piece development are key.
    - Early circle and hexagon moves can create threats or open gateways.
    - Triangles are flexible but vulnerable to poor orientation.
- **Typical themes:**
    - Control of the Dead Zone and gateways
    - Early base defense (especially in fortress variant)
    - Avoiding piece congestion and maximizing mobility

## 7. Endgame Theory
- **Rhombus endgames:**
    - Often races to the base or blockades; fortress variant increases defensive resources.
    - Sacrifices and forced shuttles are common.
    - Endgames can be very deep, with forced wins requiring precise calculation.
- **Piece value:**
    - Value of pieces changes in the endgame; triangles and hexagons become more valuable for their mobility and rotation.
    - Circles can be decisive in zone transitions.

## 8. Computational Complexity
- **Solving Romgon:**
    - Likely EXPTIME-complete (like chess and hex), due to large state and game tree complexity.
    - No known perfect play algorithm; AI uses heuristics, alpha-beta search, and Monte Carlo methods.
    - Tablebases for small endgames are possible but would be very large.
- **AI challenges:**
    - Rotational moves and zone transitions make evaluation and search more difficult than in chess.
    - Threat detection and deadlock/draglock recognition are nontrivial.

## Fortress, Blockade, and Endgame Rules in Romgon

Romgon endgames can sometimes reach rare situations where a lone rhombus is blocked by non-rhombus pieces (such as two squares), creating a fortress or blockade. There are several ways to resolve these situations, each with different strategic implications:

### 1. Repetition Rule (Default)
- If the same position occurs three times (threefold repetition), the player who repeats loses.
- This prevents endless blockades: if the advanced rhombus cannot break through, the defender can force a repetition and win.
- **Pros:** Familiar, fair, and prevents infinite games.
- **Cons:** Sometimes a player with a big advantage cannot win if blocked by a fortress.

### 2. Unstoppable Rhombus Wins (Variant)
- If a rhombus is one move away from the goal and cannot be stopped or captured by any legal move, that player wins immediately.
- This rewards the player who creates an unstoppable threat, even if they have lost all other pieces.
- **Pros:** Dramatic finishes, rewards skillful play, avoids fortress draws.
- **Cons:** Requires clear adjudication; may not be suitable for all players.

### 3. Last Non-Rhombus Piece Lost = Game Over (Optional Variant)
- If a player loses their last non-rhombus piece, they lose the game.
- **Pros:** Simple, prevents fortress problems entirely.
- **Cons:** Removes rhombus-only races and can feel abrupt.

### Recommendation
- The default Romgon rules use the repetition rule to resolve fortress/blockade situations.
- For advanced or tournament play, you may use the "Unstoppable Rhombus Wins" rule to reward decisive play and avoid unsatisfying blockades.
- The "Last Non-Rhombus Piece Lost" rule is not recommended for standard play, but may be used as a fast-paced variant.

**Players should agree on which rule to use before the game begins.**

---

Romgon is a deep, complex game with rich theoretical possibilities. Its combination of hex geometry, piece rotation, and unique rules creates a vast landscape for exploration, analysis, and creative play. Ongoing research may reveal new forced wins, opening traps, and endgame studies in the years to come!
</pre>`;
                        contentDiv.dataset.loaded = '1';
                }
                modal.style.display = 'flex';
        }
    function closeTheoryModal() {
        document.getElementById('theory-modal').style.display = 'none';
    }
    </script>
                
                <!-- AI & Advanced Options Section -->
                <div>
                    <h2 style="
                        color: #00d2ff;
                        font-size: 1.5em;
                        margin: 0 0 30px 0;
                        font-weight: 700;
                        letter-spacing: 3px;
                        border-bottom: 2px solid #00d2ff;
                        padding-bottom: 10px;
                    ">ADVANCED OPTIONS</h2>
                    
                    <div style="
                        display: flex;
                        flex-direction: column;
                        gap: 20px;
                    ">
                        <div style="display: flex; align-items: center; gap: 20px;">
                            <span style="color: #00d2ff; font-size: 1.8em;">üß†</span>
                            <a id="start-llm-mode-btn" onclick="openGameVariantsModal('llm')" style="
                                color: #00d2ff;
                                font-size: 1.2em;
                                font-weight: 600;
                                cursor: pointer;
                                text-decoration: none;
                                letter-spacing: 1px;
                                transition: all 0.3s ease;
                                display: inline-block;
                            " onmouseover="this.style.color='#00ffff'; this.style.textShadow='0 0 15px rgba(0, 210, 255, 0.5)'" onmouseout="this.style.color='#00d2ff'; this.style.textShadow='none'">AI REASONING</a>
                            <span style="color: #666; font-size: 0.9em; margin-left: auto;">Advanced AI ‚Ä¢ With explanations</span>
                        </div>
                        
                        <div style="display: flex; align-items: center; gap: 20px;">
                            <span style="color: #ff6b6b; font-size: 1.8em;">üéØ</span>
                            <a id="start-game-modes-btn" onclick="openGameModesModal()" style="
                                color: #ff6b6b;
                                font-size: 1.2em;
                                font-weight: 600;
                                cursor: pointer;
                                text-decoration: none;
                                letter-spacing: 1px;
                                transition: all 0.3s ease;
                                display: inline-block;
                            " onmouseover="this.style.color='#ff8a8a'; this.style.textShadow='0 0 15px rgba(255, 107, 107, 0.5)'" onmouseout="this.style.color='#ff6b6b'; this.style.textShadow='none'">GAME MODES</a>
                            <span style="color: #666; font-size: 0.9em; margin-left: auto;">Alternative ‚Ä¢ Variants</span>
                        </div>
                        
                        <div style="display: flex; align-items: center; gap: 20px;">
                            <span style="color: #f57d2d; font-size: 1.8em;">üìú</span>
                            <a id="start-rulebook-btn" onclick="openRulebookModal()" style="
                                color: #f57d2d;
                                font-size: 1.2em;
                                font-weight: 600;
                                cursor: pointer;
                                text-decoration: none;
                                letter-spacing: 1px;
                                transition: all 0.3s ease;
                                display: inline-block;
                            " onmouseover="this.style.color='#ffa500'; this.style.textShadow='0 0 15px rgba(245, 125, 45, 0.5)'" onmouseout="this.style.color='#f57d2d'; this.style.textShadow='none'">RULEBOOK</a>
                            <span style="color: #666; font-size: 0.9em; margin-left: auto;">Full rules ‚Ä¢ How to play</span>
                        </div>
                        
                        <div style="display: flex; align-items: center; gap: 20px;">
                            <span style="color: #4ecdc4; font-size: 1.8em;">üìä</span>
                            <a onclick="openAnalysisModal()" style="
                                color: #4ecdc4;
                                font-size: 1.2em;
                                font-weight: 600;
                                cursor: pointer;
                                text-decoration: none;
                                letter-spacing: 1px;
                                transition: all 0.3s ease;
                                display: inline-block;
                            " onmouseover="this.style.color='#5eddd4'; this.style.textShadow='0 0 15px rgba(78, 205, 196, 0.5)'" onmouseout="this.style.color='#4ecdc4'; this.style.textShadow='none'">ANALYSIS</a>
                            <span style="color: #666; font-size: 0.9em; margin-left: auto;">Load RMN ‚Ä¢ Review games</span>
                        </div>
                    </div>
                </div>
            </div>
    <!-- Rulebook Modal -->
    <div id="rulebook-modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.92); z-index:10001; justify-content:center; align-items:center; overflow-y:auto;">
        <div style="background:#262421; border:3px solid #f57d2d; border-radius:20px; padding:40px 30px; max-width:900px; width:95vw; margin:40px auto; box-shadow:0 10px 50px rgba(245,125,45,0.2); position:relative; color:#fff;">
            <h2 style="color:#f57d2d; text-align:center; margin-bottom:24px; font-size:2em;">üìú ROMGON Official Rulebook</h2>
            <div id="rulebook-content" style="max-height:65vh; overflow-y:auto; color:#eee; font-size:1.08em; line-height:1.7; background:rgba(0,0,0,0.10); padding:18px; border-radius:10px; border:1px solid #444; white-space:pre-wrap;"></div>
            <button onclick="closeRulebookModal()" style="margin-top:28px; background:#f57d2d; color:#fff; border:none; padding:12px 32px; border-radius:8px; font-size:1.1em; font-weight:600; cursor:pointer; width:100%; transition:all 0.2s;" onmouseover="this.style.background='#e67e22'" onmouseout="this.style.background='#f57d2d'">Close</button>
        </div>
    </div>
    <script>
    // RULEBOOK MODAL LOGIC
    function openRulebookModal() {
        // If already loaded, just show
        const modal = document.getElementById('rulebook-modal');
        const contentDiv = document.getElementById('rulebook-content');
        if (!contentDiv.dataset.loaded) {
            // Insert the rulebook content as HTML (converted from markdown)
            contentDiv.innerHTML = `
<h3>ROMGON Official Rulebook</h3>
<p><em>Last updated: October 12, 2025</em></p>
<hr/>
<ol>
<li>Game Overview</li>
<li>Board Layout</li>
<li>Piece Types & Movement</li>
<li>Turn Structure</li>
<li>Special Rules</li>
        }
<li>Notation System</li>
<li>Advanced Features</li>
<li>Game Modes & Variants</li>
<li>FAQ & Tips</li>
<li>Base Defense Rule</li>
</ol>
<h4>1. Game Overview</h4>
<p>Romgon is a strategic hexagonal board game. Each player controls <b>7 pieces</b>:<br>- 5 unique types (Square, Triangle, Rhombus, Circle, Hexagon)<br>- <b>Plus 1 extra Triangle and 1 extra Square</b> (total: 2 Triangles, 2 Squares, 1 Rhombus, 1 Circle, 1 Hexagon per player)</p>
<p>The objective is to advance your rhombus to the opponent's base or create a deadlock (see below).</p>
<h4>2. Board Layout</h4>
<ul><li><b>Hexagonal grid</b>: 7 rows (0-6), variable columns per row</li><li><b>Zones</b>: Dead Zone (center), Inner, Middle, Outer Perimeter</li><li><b>Coordinates</b>: Each hex is labeled (e.g., 3-4)</li></ul>
<h4>3. Piece Types & Movement</h4>
<b>Square</b>: Moves orthogonally (adjacent hexes), attacks in same directions<br>
<b>Triangle</b>: 6 unique movement patterns (one for each orientation), can rotate left/right after moving (not after attacking), each orientation has its own movement pattern (no repeats)<br>
<b>Rhombus</b>: Must reach opponent's base to win (White: 3-8, Black: 3-0), moves orthogonally, special diagonal move between Dead Zone and Inner Perimeter (cannot capture), cannot capture other rhombuses, cannot move into deadlock (unless capturing attacker)<br>
<b>Circle</b>: Moves within current perimeter zone, uses gateways to change zones (ends turn), cannot jump friendly pieces<br>
<b>Hexagon</b>: 6 orientations (rotatable), 3 unique movement patterns, can rotate left/right after moving<br>
<h4>4. Turn Structure</h4>
<ul><li>Black moves first</li><li>One piece may move (and/or rotate) per turn</li><li>Triangles/Hexagons may rotate after moving (not after attacking)</li><li>Captures: Move to opponent's hex to capture</li><li>Cannot move to a hex occupied by a friendly piece</li></ul>
<h4>5. Special Rules</h4>
<ul><li><b>Base Defense</b>: Rhombus at base blocks opponent's win</li><li><b>Deadlock</b>: Win if opponent's rhombus is under attack with no legal moves</li><li><b>Draglock</b>: Lose if you have no legal moves (must resign)</li><li><b>Escape Race</b>: When only rhombuses remain, first to goal wins (Base Defense disabled)</li><li><b>Three-fold Repetition</b>: Loss if same position occurs three times (no draws in Romgon)</li><li><b>Five-fold Shuttle</b>: Lose if you repeat a shuttle pattern (A‚ÜíB‚ÜíA) five times</li><li><b>Undo/Redo</b>: Allowed unless playing online or in tournament</li></ul>
<h4>6. Victory Conditions</h4>
<ul><li>Move your rhombus to the opponent's base (3-0 for Black, 3-8 for White)</li><li>Create a deadlock (opponent's rhombus is under attack with no legal moves)</li><li>Opponent resigns or runs out of time (in timed modes)</li><li>Loss by three-fold repetition</li><li>Loss by five-fold shuttle</li></ul>
<h4>7. Notation System</h4>
<ul><li><b>RPN</b>: Romgon Position Notation (custom format)</li><li><b>RMN</b>: Romgon Move Notation (custom format)</li><li>Clipboard integration for import/export</li><li>Move history and game archiving supported</li></ul>
<h4>8. Advanced Features</h4>
<ul><li><b>Repetition Detection</b>: Three-fold repetition rule, visual warnings (loss, not draw)</li><li><b>Base Defense System</b>: Prevents early base captures, toggleable in settings</li><li><b>Threat Analysis</b>: Real-time threat and deadlock detection, highlights threatened pieces</li><li><b>Show All Moves</b>: Toggle to display all legal moves and rotations</li><li><b>Defense Highlights</b>: Highlights defended pieces, optional toggle</li><li><b>Dark Mode</b>: Switch between light/dark themes</li><li><b>Game Variants</b>: Blitz, Fog of War, King of the Hill (see Quick Reference)</li><li><b>Statistics Dashboard</b>: Win/loss, piece stats, move quality, opening repertoire, tactical success</li></ul>
<h4>9. Game Modes & Variants</h4>
<ul><li><b>Standard</b>: All 5 piece types</li><li><b>Square Attack</b>: Only Squares and Rhombuses</li><li><b>Blitz</b>: Timed games</li><li><b>Fog of War</b>: Limited visibility</li><li><b>King of the Hill</b>: Control the center</li><li><b>Custom</b>: User-defined setups</li></ul>
<h4>10. FAQ & Tips</h4>
<ul><li><b>Q: Can I rotate a triangle after attacking?</b><br>A: No, rotation is only allowed after a non-capturing move.</li><li><b>Q: What happens if both rhombuses reach the goal at the same time?</b><br>A: The first to reach wins; if simultaneous, the player who moved first wins.</li><li><b>Q: Can I undo moves?</b><br>A: Yes, unless in online/tournament mode.</li><li><b>Q: How do I export my game?</b><br>A: Use the export button in the analysis modal or copy RPN/RMN.</li><li><b>Q: Where can I find more strategy?</b><br>A: See the Opening Book and Analysis Features in the main menu.</li></ul>
<h4>11. Base Defense Rule</h4>
<ul><li><b>Original:</b> Only the defending rhombus (on its own base) can prevent the opponent‚Äôs rhombus from entering the base. This is the classic, casual rule where rhombus escapes are allowed unless the defending rhombus itself defends the base.<ul><li>If the defending rhombus is not present, the opponent‚Äôs rhombus may enter and win.</li></ul></li><li><b>Shape Defence:</b> Any attacking shape that threatens the base hex can prevent the opponent‚Äôs rhombus from entering until it is eliminated or moved. This enforces more tactical base defense.</li></ul>
<hr/>
<p>Enjoy playing Romgon! For more, see the in-game help, analysis, and statistics dashboards.</p>
            `;
            contentDiv.dataset.loaded = '1';
        }
        modal.style.display = 'flex';
    }
    function closeRulebookModal() {
        document.getElementById('rulebook-modal').style.display = 'none';
    }
    </script>
            </div>
                    
            <!-- Quick Info -->
            <div style="
                text-align: center;
                color: #888;
                font-size: 0.8em;
                max-width: 550px;
                margin: 0 auto;
                line-height: 1.5;
            ">
                <p style="margin: 0 0 5px 0;">
                    <strong style="color: #f57d2d;">Objective:</strong> Move rhombus to opponent's base or trap theirs
                </p>
                <p style="margin: 0; color: #666;">
                    Press ‚ùì HELP in-game for rules
                </p>
                    </div>
                </div>
                    </div>
                    
    <!-- Puzzles Modal -->
    <div id="puzzles-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.9); z-index: 10000; justify-content: center; align-items: center;">
        <div style="background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%); border: 3px solid #ffd700; border-radius: 20px; padding: 40px; max-width: 600px; width: 90%; box-shadow: 0 10px 50px rgba(255, 215, 0, 0.3);">
            <h2 style="color: #ffd700; text-align: center; margin-bottom: 30px; font-size: 28px;">üß© Puzzle Challenges</h2>
            
            <!-- Puzzle Categories -->
            <div style="display: grid; gap: 15px; margin-bottom: 20px;">
                
                <!-- Escape Puzzles -->
                <div style="background: rgba(255, 215, 0, 0.1); border: 2px solid #ffd700; border-radius: 12px; padding: 20px;">
                    <h3 style="color: #ffd700; margin: 0 0 15px 0; font-size: 1.3em;">üèÉ Escape Rhombus</h3>
                    <p style="color: #ccc; margin: 0 0 15px 0; font-size: 0.9em;">Move your rhombus to the goal position within the move limit</p>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <button class="puzzle-btn" onclick="startPuzzle('escape-easy-1')" style="
                            background: linear-gradient(45deg, #4ecdc4, #44a08d);
                            color: white;
                            border: none;
                            padding: 10px 20px;
                            border-radius: 8px;
                            cursor: pointer;
                            font-weight: 600;
                            transition: all 0.3s ease;
                        " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                            ‚≠ê Easy #1 (2 moves)
                        </button>
                        <button class="puzzle-btn" onclick="alert('Coming soon!')" style="
                            background: #555;
                            color: #999;
                            border: none;
                            padding: 10px 20px;
                            border-radius: 8px;
                            cursor: not-allowed;
                            font-weight: 600;
                        ">
                            üîí More coming soon
                        </button>
                    </div>
                </div>
                
                <!-- Capture Puzzles -->
                <div style="background: rgba(255, 107, 107, 0.1); border: 2px solid #ff6b6b; border-radius: 12px; padding: 20px;">
                    <h3 style="color: #ff6b6b; margin: 0 0 15px 0; font-size: 1.3em;">‚öîÔ∏è Capture Challenge</h3>
                    <p style="color: #ccc; margin: 0 0 15px 0; font-size: 0.9em;">Capture the target piece within the move limit</p>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <button class="puzzle-btn" onclick="alert('Coming soon!')" style="
                            background: #555;
                            color: #999;
                            border: none;
                            padding: 10px 20px;
                            border-radius: 8px;
                            cursor: not-allowed;
                            font-weight: 600;
                        ">
                            üîí Coming soon
                        </button>
                        </div>
                        </div>
                
                <!-- Checkmate Puzzles -->
                <div style="background: rgba(165, 94, 234, 0.1); border: 2px solid #a55eea; border-radius: 12px; padding: 20px;">
                    <h3 style="color: #a55eea; margin: 0 0 15px 0; font-size: 1.3em;">‚ôüÔ∏è Checkmate in N</h3>
                    <p style="color: #ccc; margin: 0 0 15px 0; font-size: 0.9em;">Trap the opponent's rhombus for checkmate</p>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <button class="puzzle-btn" onclick="startPuzzle('checkmate-1')" style="
                            background: linear-gradient(45deg, #a55eea, #8b3fd4);
                            color: white;
                            border: none;
                            padding: 10px 20px;
                            border-radius: 8px;
                            cursor: pointer;
                            font-weight: 600;
                            transition: all 0.3s ease;
                        " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                            ‚≠ê Tactical #1 (3 moves)
                        </button>
                        <button class="puzzle-btn" onclick="alert('Coming soon!')" style="
                            background: #555;
                            color: #999;
                            border: none;
                            padding: 10px 20px;
                            border-radius: 8px;
                            cursor: not-allowed;
                            font-weight: 600;
                        ">
                            üîí More coming soon
                        </button>
                        </div>
                    </div>
                
            </div>
            
            <button onclick="closePuzzlesModal()" style="
                background-color: #555;
                color: white;
                border: none;
                padding: 12px 24px;
                border-radius: 8px;
                cursor: pointer;
                width: 100%;
                font-weight: 600;
                transition: all 0.3s ease;
            " onmouseover="this.style.background='#666'" onmouseout="this.style.background='#555'">
                ‚Üê Back to Menu
            </button>
                </div>
            </div>
            
    <!-- Game Variants Modal -->
    <div id="game-variants-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.9); z-index: 10000; justify-content: center; align-items: center;">
        <div style="background: #262421; border: 3px solid #4ecdc4; border-radius: 20px; padding: 40px; max-width: 500px; width: 90%; box-shadow: 0 10px 50px rgba(78, 205, 196, 0.3); position:relative;">
            <h2 style="color: #4ecdc4; text-align: center; margin-bottom: 30px; font-size: 28px;">üé≤ Game Variants</h2>
            <div style="display:flex;justify-content:center;align-items:center;margin-bottom:18px;gap:12px;">
                <label for="base-defense-variant-tc" style="color:#ffd700;font-size:1.08em;">Base Defense:</label>
                <select id="base-defense-variant-tc" style="font-size:1em;padding:4px 10px;border-radius:6px;">
                    <option value="original">Original (Only Rhombus)</option>
                    <option value="shape-defense">Shape Defence</option>
                </select>
                <span id="base-defense-variant-tc-desc" style="color:#aaa;font-size:0.95em;margin-left:10px;"></span>
            </div>
            <div style="display:flex;justify-content:center;align-items:center;margin-bottom:18px;gap:12px;">
                <label for="fog-of-war-variant-tc" style="color:#4ecdc4;font-size:1.08em;">Fog of War:</label>
                <input type="checkbox" id="fog-of-war-variant-tc" style="transform:scale(1.3);margin-left:8px;" />
                <span id="fog-of-war-variant-tc-desc" style="color:#aaa;font-size:0.95em;margin-left:10px;">Hide enemy pieces outside vision range.</span>
            </div>
            <script>
            // Set dropdown and fog of war to current value and update desc
            setTimeout(() => {
                const sel = document.getElementById('base-defense-variant-tc');
                const desc = document.getElementById('base-defense-variant-tc-desc');
                const fogCheckbox = document.getElementById('fog-of-war-variant-tc');
                if (sel) {
                    // Initialize dropdown from saved settings, or fallback to runtime value
                    sel.value = (window.gameSettings && window.gameSettings.baseDefenseVariant) || window.baseDefenseVariant || 'original';
                    function updateDesc() {
                        if (sel.value === 'original') desc.textContent = 'Original rules: only the rhombus defends the base (casual mode).';
                        else if (sel.value === 'shape-defense') desc.textContent = "Shape Defence: rhombus can only escape if the opponent's base is not under attack.";
                    }
                    sel.addEventListener('change', function() {
                        if (!window.gameSettings) window.gameSettings = {};
                        window.gameSettings.baseDefenseVariant = sel.value;
                        window.baseDefenseVariant = sel.value;
                        updateBaseDefenceDisplay();
                        updateDesc();
                        saveSettings();
                    });
                    updateDesc();
                }
                if (fogCheckbox) {
                    if (!window.gameSettings) window.gameSettings = {};
                    fogCheckbox.checked = !!(window.gameSettings && window.gameSettings.fogOfWar);
                    fogCheckbox.addEventListener('change', function() {
                        if (!window.gameSettings) window.gameSettings = {};
                        window.gameSettings.fogOfWar = fogCheckbox.checked;
                        fogOfWarEnabled = fogCheckbox.checked;
                        saveSettings();
                    });
                }
            }, 0);
            </script>
            <p style="color: #ccc; text-align: center; margin-bottom: 25px;">Select your preferred game variants:</p>
            <div style="display: grid; gap: 15px; margin-bottom: 20px;">
                <button onclick="startGameWithTime(10)" style="
                    background: linear-gradient(45deg, #4ecdc4, #44a08d);
                    color: white;
                    border: none;
                    padding: 18px;
                    border-radius: 12px;
                    cursor: pointer;
                    font-weight: 600;
                    font-size: 18px;
                    transition: all 0.3s ease;
                " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                    ‚ö° 10 Minutes
                </button>
                
                <button onclick="startGameWithTime(20)" style="
                    background: linear-gradient(45deg, #ffd700, #f0ad4e);
                    color: white;
                    border: none;
                    padding: 18px;
                    border-radius: 12px;
                    cursor: pointer;
                    font-weight: 600;
                    font-size: 18px;
                    transition: all 0.3s ease;
                " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                    üïê 20 Minutes
                </button>
                
                <button onclick="startGameWithTime(30)" style="
                    background: linear-gradient(45deg, #a55eea, #8e44ad);
                    color: white;
                    border: none;
                    padding: 18px;
                    border-radius: 12px;
                    cursor: pointer;
                    font-weight: 600;
                    font-size: 18px;
                    transition: all 0.3s ease;
                " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                    ‚è≥ 30 Minutes
                </button>
                
                <button onclick="startGameWithTime(0)" style="
                    background: linear-gradient(45deg, #95a5a6, #7f8c8d);
                    color: white;
                    border: none;
                    padding: 18px;
                    border-radius: 12px;
                    cursor: pointer;
                    font-weight: 600;
                    font-size: 18px;
                    transition: all 0.3s ease;
                " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                    ‚àû No Time Limit
                </button>
            </div>
            
            <button onclick="closeGameVariantsModal()" style="
                background-color: #555;
                color: white;
                border: none;
                padding: 12px 24px;
                border-radius: 8px;
                cursor: pointer;
                width: 100%;
                font-weight: 600;
                transition: all 0.3s ease;
            " onmouseover="this.style.background='#666'" onmouseout="this.style.background='#555'">
                ‚Üê Back
            </button>
        </div>
    </div>

    <!-- Learning Modal -->
    <div id="learning-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.9); z-index: 10000; overflow-y: auto;">
        <div style="background: #262421; border: 3px solid #4ecdc4; border-radius: 20px; padding: 40px; max-width: 800px; width: 90%; margin: 50px auto; box-shadow: 0 10px 50px rgba(78, 205, 196, 0.3);">
            <h2 style="color: #4ecdc4; text-align: center; margin-bottom: 30px; font-size: 32px;">üìö Learn ROMGON</h2>
            
            <!-- Objective -->
            <div style="background: rgba(78, 205, 196, 0.1); border-left: 4px solid #4ecdc4; padding: 20px; margin-bottom: 25px; border-radius: 8px;">
                <h3 style="color: #4ecdc4; margin: 0 0 15px 0;">üéØ Objective</h3>
                <p style="color: #ddd; margin: 0; line-height: 1.6;">
                    Move your <strong>Rhombus</strong> to your opponent's base OR trap their rhombus so it cannot move (checkmate).
                </p>
            </div>
            
            <!-- Pieces Guide -->
            <div style="background: rgba(255, 215, 0, 0.1); border-left: 4px solid #ffd700; padding: 20px; margin-bottom: 25px; border-radius: 8px;">
                <h3 style="color: #ffd700; margin: 0 0 15px 0;">‚ôüÔ∏è Pieces & Movement</h3>
                
                <div style="color: #ddd; line-height: 1.8;">
                    <p style="margin: 0 0 12px 0;"><strong style="color: #f57d2d;">üî∂ Rhombus (King):</strong> Moves 1 hex in any direction. Goal piece!</p>
                    
                    <p style="margin: 0 0 12px 0;"><strong style="color: #f57d2d;">‚¨ü Hexagon:</strong> Moves 1-3 hexes in any direction. Can rotate 60¬∞ left/right.</p>
                    
                    <p style="margin: 0 0 12px 0;"><strong style="color: #f57d2d;">‚ñ≤ Triangle:</strong> Moves 1-3 hexes forward (directional). Can rotate and move in same turn. Cannot rotate after attacking!</p>
                    
                    <p style="margin: 0 0 12px 0;"><strong style="color: #f57d2d;">‚ñ† Square:</strong> Moves 1-2 hexes in any direction.</p>
                    
                    <p style="margin: 0;"><strong style="color: #f57d2d;">‚óè Circle:</strong> Moves like a knight - jumps in L-shape pattern.</p>
                </div>
            </div>
            
            <!-- Basic Rules -->
            <div style="background: rgba(255, 107, 107, 0.1); border-left: 4px solid #ff6b6b; padding: 20px; margin-bottom: 25px; border-radius: 8px;">
                <h3 style="color: #ff6b6b; margin: 0 0 15px 0;">‚öñÔ∏è Basic Rules</h3>
                
                <ul style="color: #ddd; line-height: 1.8; padding-left: 20px;">
                    <li><strong>Turn-based:</strong> Players alternate turns (Black starts first)</li>
                    <li><strong>One action per turn:</strong> Move OR attack, then end turn</li>
                    <li><strong>Capturing:</strong> Land on opponent's piece to capture it</li>
                    <li><strong>Base Defence:</strong> Pieces at your base give you strength</li>
                    <li><strong>No Repeating:</strong> Cannot repeat the same position 3 times</li>
                    <li><strong>Escape Race:</strong> When both rhombuses reach opponent bases, first to move wins!</li>
                        </ul>
                    </div>
                    
            <!-- Special Features -->
            <div style="background: rgba(165, 94, 234, 0.1); border-left: 4px solid #a55eea; padding: 20px; margin-bottom: 25px; border-radius: 8px;">
                <h3 style="color: #a55eea; margin: 0 0 15px 0;">‚ú® Special Features</h3>
                
                <ul style="color: #ddd; line-height: 1.8; padding-left: 20px;">
                    <li><strong>Triangle Rotation:</strong> Press LEFT/RIGHT to rotate after moving</li>
                    <li><strong>Threat Highlights:</strong> Red glow shows pieces under attack</li>
                    <li><strong>Move History:</strong> Track all moves in side panels</li>
                    <li><strong>Coordinate Display:</strong> Toggle hex coordinates on/off</li>
                    <li><strong>Help System:</strong> Click ‚ùì HELP in-game for detailed rules</li>
                        </ul>
            </div>
            
            <!-- Tips -->
            <div style="background: rgba(38, 222, 129, 0.1); border-left: 4px solid #26de81; padding: 20px; margin-bottom: 25px; border-radius: 8px;">
                <h3 style="color: #26de81; margin: 0 0 15px 0;">üí° Pro Tips</h3>
                
                <ul style="color: #ddd; line-height: 1.8; padding-left: 20px;">
                    <li>Protect your rhombus - it's your most important piece!</li>
                    <li>Use triangles and hexagons for early game control</li>
                    <li>Circles are great for surprise attacks (knight-like movement)</li>
                    <li>Keep pieces on your base for defence bonus</li>
                    <li>Watch for checkmate opportunities when opponent's rhombus is trapped</li>
                        </ul>
            </div>
            
            <button onclick="closeLearningModal()" style="
                background: linear-gradient(45deg, #4ecdc4, #44a08d);
                color: white;
                border: none;
                padding: 15px 30px;
                border-radius: 8px;
                cursor: pointer;
                width: 100%;
                font-weight: 600;
                font-size: 16px;
                transition: all 0.3s ease;
            " onmouseover="this.style.transform='scale(1.02)'" onmouseout="this.style.transform='scale(1)'">
                ‚úì Got it! Let's Play
            </button>
                    </div>
                </div>
                
    <!-- Leaderboard Modal -->
    <div id="leaderboard-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.9); z-index: 10000; overflow-y: auto;">
        <div style="background: #262421; border: 3px solid #f1c40f; border-radius: 20px; padding: 40px; max-width: 700px; width: 90%; margin: 50px auto; box-shadow: 0 10px 50px rgba(241, 196, 15, 0.3);">
            <h2 style="color: #f1c40f; text-align: center; margin-bottom: 30px; font-size: 32px;">üèÜ Leaderboard</h2>
            
            <!-- Filter Tabs -->
            <div style="display: flex; gap: 10px; justify-content: center; margin-bottom: 25px; flex-wrap: wrap;">
                <button onclick="switchLeaderboardTab('daily')" id="lb-tab-daily" style="
                    background: #f1c40f;
                    color: #262421;
                    border: none;
                    padding: 10px 20px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-weight: 600;
                    transition: all 0.3s ease;
                ">Daily</button>
                <button onclick="switchLeaderboardTab('weekly')" id="lb-tab-weekly" style="
                    background: #444;
                    color: #ccc;
                    border: none;
                    padding: 10px 20px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-weight: 600;
                    transition: all 0.3s ease;
                ">Weekly</button>
                <button onclick="switchLeaderboardTab('alltime')" id="lb-tab-alltime" style="
                    background: #444;
                    color: #ccc;
                    border: none;
                    padding: 10px 20px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-weight: 600;
                    transition: all 0.3s ease;
                ">All Time</button>
                    </div>
                    
            <!-- Leaderboard Content -->
            <div id="leaderboard-content" style="background: rgba(0, 0, 0, 0.3); border-radius: 12px; padding: 20px; margin-bottom: 25px;">
                <!-- Table Header -->
                <div style="display: grid; grid-template-columns: 60px 1fr 100px 100px; gap: 10px; padding: 10px; border-bottom: 2px solid #444; margin-bottom: 15px; font-weight: 600; color: #f1c40f;">
                    <div>Rank</div>
                    <div>Player</div>
                    <div>Wins</div>
                    <div>Rating</div>
                    </div>
                    
                <!-- Top Players List -->
                <div id="leaderboard-list">
                    <!-- Rank 1 -->
                    <div style="display: grid; grid-template-columns: 60px 1fr 100px 100px; gap: 10px; padding: 12px; background: rgba(241, 196, 15, 0.1); border-radius: 8px; margin-bottom: 8px; align-items: center;">
                        <div style="font-size: 1.5em;">ü•á</div>
                        <div style="color: #fff; font-weight: 600;">ChessMaster2000</div>
                        <div style="color: #4ecdc4;">147</div>
                        <div style="color: #f1c40f; font-weight: 700;">2450</div>
                    </div>
                    
                    <!-- Rank 2 -->
                    <div style="display: grid; grid-template-columns: 60px 1fr 100px 100px; gap: 10px; padding: 12px; background: rgba(192, 192, 192, 0.1); border-radius: 8px; margin-bottom: 8px; align-items: center;">
                        <div style="font-size: 1.5em;">ü•à</div>
                        <div style="color: #fff; font-weight: 600;">StrategyKing</div>
                        <div style="color: #4ecdc4;">132</div>
                        <div style="color: #ccc; font-weight: 700;">2380</div>
                </div>
                
                    <!-- Rank 3 -->
                    <div style="display: grid; grid-template-columns: 60px 1fr 100px 100px; gap: 10px; padding: 12px; background: rgba(205, 127, 50, 0.1); border-radius: 8px; margin-bottom: 8px; align-items: center;">
                        <div style="font-size: 1.5em;">ü•â</div>
                        <div style="color: #fff; font-weight: 600;">TacticalGenius</div>
                        <div style="color: #4ecdc4;">128</div>
                        <div style="color: #cd7f32; font-weight: 700;">2310</div>
                    </div>
                    
                    <!-- Rank 4-10 -->
                    <div style="display: grid; grid-template-columns: 60px 1fr 100px 100px; gap: 10px; padding: 10px; border-bottom: 1px solid #333; margin-bottom: 5px; align-items: center;">
                        <div style="color: #888; font-weight: 600;">4</div>
                        <div style="color: #ddd;">HexagonHero</div>
                        <div style="color: #4ecdc4;">115</div>
                        <div style="color: #ddd;">2245</div>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 60px 1fr 100px 100px; gap: 10px; padding: 10px; border-bottom: 1px solid #333; margin-bottom: 5px; align-items: center;">
                        <div style="color: #888; font-weight: 600;">5</div>
                        <div style="color: #ddd;">RhombusMaster</div>
                        <div style="color: #4ecdc4;">108</div>
                        <div style="color: #ddd;">2198</div>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 60px 1fr 100px 100px; gap: 10px; padding: 10px; border-bottom: 1px solid #333; margin-bottom: 5px; align-items: center;">
                        <div style="color: #888; font-weight: 600;">6</div>
                        <div style="color: #ddd;">GameChampion</div>
                        <div style="color: #4ecdc4;">95</div>
                        <div style="color: #ddd;">2145</div>
                </div>
                
                    <div style="display: grid; grid-template-columns: 60px 1fr 100px 100px; gap: 10px; padding: 10px; border-bottom: 1px solid #333; margin-bottom: 5px; align-items: center;">
                        <div style="color: #888; font-weight: 600;">7</div>
                        <div style="color: #ddd;">BoardPro</div>
                        <div style="color: #4ecdc4;">87</div>
                        <div style="color: #ddd;">2089</div>
                        </div>
                    
                    <div style="display: grid; grid-template-columns: 60px 1fr 100px 100px; gap: 10px; padding: 10px; border-bottom: 1px solid #333; margin-bottom: 5px; align-items: center;">
                        <div style="color: #888; font-weight: 600;">8</div>
                        <div style="color: #ddd;">SquareWarrior</div>
                        <div style="color: #4ecdc4;">78</div>
                        <div style="color: #ddd;">2034</div>
                        </div>
                    
                    <div style="display: grid; grid-template-columns: 60px 1fr 100px 100px; gap: 10px; padding: 10px; border-bottom: 1px solid #333; margin-bottom: 5px; align-items: center;">
                        <div style="color: #888; font-weight: 600;">9</div>
                        <div style="color: #ddd;">CircleChaser</div>
                        <div style="color: #4ecdc4;">72</div>
                        <div style="color: #ddd;">1987</div>
                        </div>
                    
                    <div style="display: grid; grid-template-columns: 60px 1fr 100px 100px; gap: 10px; padding: 10px; border-bottom: 1px solid #333; margin-bottom: 5px; align-items: center;">
                        <div style="color: #888; font-weight: 600;">10</div>
                        <div style="color: #ddd;">TriangleTitan</div>
                        <div style="color: #4ecdc4;">65</div>
                        <div style="color: #ddd;">1925</div>
                    </div>
                </div>
                
                <!-- Your Rank (if logged in) -->
                <div style="margin-top: 20px; padding: 15px; background: rgba(78, 205, 196, 0.1); border: 2px solid #4ecdc4; border-radius: 8px;">
                    <div style="display: grid; grid-template-columns: 60px 1fr 100px 100px; gap: 10px; align-items: center;">
                        <div style="color: #4ecdc4; font-weight: 600;">---</div>
                        <div style="color: #fff; font-weight: 600;">LOGGED IN AS GUEST</div>
                        <div style="color: #4ecdc4;">0</div>
                        <div style="color: #4ecdc4; font-weight: 700;">1200</div>
                    </div>
                    <p style="color: #888; font-size: 0.85em; margin: 10px 0 0 0; text-align: center;">
                        üîê Create an account to save your progress and compete!
                    </p>
                </div>
            </div>
            
            <button onclick="closeLeaderboardModal()" style="
                background: linear-gradient(45deg, #f1c40f, #f39c12);
                color: #262421;
                border: none;
                padding: 15px 30px;
                border-radius: 8px;
                cursor: pointer;
                width: 100%;
                font-weight: 600;
                font-size: 16px;
                transition: all 0.3s ease;
            " onmouseover="this.style.transform='scale(1.02)'" onmouseout="this.style.transform='scale(1)'">
                ‚Üê Back to Menu
            </button>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.95); z-index: 10000; overflow-y: auto;">
        <div style="background: #000000; border: none; border-radius: 0; padding: 40px; max-width: 100%; width: 100%; min-height: 100vh; margin: 0; box-shadow: none;">
            <h2 style="color: #95a5a6; text-align: center; margin-bottom: 30px; font-size: 32px;">‚öôÔ∏è Settings</h2>
            
            <!-- Audio Settings -->
            <div style="padding: 20px 0; margin-bottom: 20px;">
                <h3 style="color: #4ecdc4; margin: 0 0 15px 0; font-size: 1.3em;">üîä Audio</h3>
                
                <!-- Sound Effects -->
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <div>
                        <div style="color: #fff; font-weight: 600; margin-bottom: 3px;">Sound Effects</div>
                        <div style="color: #888; font-size: 0.85em;">Piece movement & capture sounds</div>
                    </div>
                    <div onclick="toggleSetting('sound-effects')" style="position: relative; display: inline-block; width: 60px; height: 30px; cursor: pointer;">
                        <input type="checkbox" id="setting-sound-effects" checked style="opacity: 0; width: 0; height: 0; pointer-events: none;">
                        <span style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: #4ecdc4; border-radius: 30px; transition: 0.3s;"></span>
                        <span style="position: absolute; height: 22px; width: 22px; left: 34px; bottom: 4px; background-color: white; border-radius: 50%; transition: 0.3s;"></span>
                    </div>
                </div>
                
                <!-- Music -->
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <div>
                        <div style="color: #fff; font-weight: 600; margin-bottom: 3px;">Background Music</div>
                        <div style="color: #888; font-size: 0.85em;">Ambient game music</div>
                    </div>
                    <div onclick="toggleSetting('music')" style="position: relative; display: inline-block; width: 60px; height: 30px; cursor: pointer;">
                        <input type="checkbox" id="setting-music" style="opacity: 0; width: 0; height: 0; pointer-events: none;">
                        <span style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: #555; border-radius: 30px; transition: 0.3s;"></span>
                        <span style="position: absolute; height: 22px; width: 22px; left: 4px; bottom: 4px; background-color: white; border-radius: 50%; transition: 0.3s;"></span>
                    </div>
                </div>
                
                <!-- Music Track Selector -->
                <div style="margin-bottom: 15px;">
                    <div style="color: #fff; font-weight: 600; margin-bottom: 8px;">Music Track</div>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <button onclick="playBackgroundMusic(1)" style="background: rgba(78, 205, 196, 0.2); border: 1px solid #4ecdc4; color: #4ecdc4; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 0.85em;">Track 1</button>
                        <button onclick="playBackgroundMusic(2)" style="background: rgba(78, 205, 196, 0.2); border: 1px solid #4ecdc4; color: #4ecdc4; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 0.85em;">Track 2</button>
                        <button onclick="playBackgroundMusic(3)" style="background: rgba(78, 205, 196, 0.2); border: 1px solid #4ecdc4; color: #4ecdc4; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 0.85em;">Track 3</button>
                        <button onclick="stopBackgroundMusic()" style="background: rgba(255, 107, 107, 0.2); border: 1px solid #ff6b6b; color: #ff6b6b; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 0.85em;">Stop</button>
                    </div>
                </div>
            </div>
            
            <!-- Display Settings -->
            <div style="padding: 20px 0; margin-bottom: 20px;">
                <h3 style="color: #ffd700; margin: 0 0 15px 0; font-size: 1.3em;">üé® Display</h3>
                
                <!-- Show Coordinates -->
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <div>
                        <div style="color: #fff; font-weight: 600; margin-bottom: 3px;">Show Coordinates</div>
                        <div style="color: #888; font-size: 0.85em;">Display hex coordinates on board</div>
                    </div>
                    <div onclick="toggleSetting('coordinates')" style="position: relative; display: inline-block; width: 60px; height: 30px; cursor: pointer;">
                        <input type="checkbox" id="setting-coordinates" style="opacity: 0; width: 0; height: 0; pointer-events: none;">
                        <span style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: #555; border-radius: 30px; transition: 0.3s;"></span>
                        <span style="position: absolute; height: 22px; width: 22px; left: 4px; bottom: 4px; background-color: white; border-radius: 50%; transition: 0.3s;"></span>
                    </div>
                </div>
                
                <!-- Highlight Valid Moves -->
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <div>
                        <div style="color: #fff; font-weight: 600; margin-bottom: 3px;">Highlight Valid Moves</div>
                        <div style="color: #888; font-size: 0.85em;">Show possible moves when selecting piece</div>
                    </div>
                    <div onclick="toggleSetting('highlight-moves')" style="position: relative; display: inline-block; width: 60px; height: 30px; cursor: pointer;">
                        <input type="checkbox" id="setting-highlight-moves" checked style="opacity: 0; width: 0; height: 0; pointer-events: none;">
                        <span style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: #ffd700; border-radius: 30px; transition: 0.3s;"></span>
                        <span style="position: absolute; height: 22px; width: 22px; left: 34px; bottom: 4px; background-color: white; border-radius: 50%; transition: 0.3s;"></span>
                    </div>
                </div>
                
                <!-- Animation Speed -->
                <div style="margin-bottom: 0;">
                    <div style="color: #fff; font-weight: 600; margin-bottom: 8px;">Animation Speed</div>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <span style="color: #888; font-size: 0.85em;">Slow</span>
                        <input type="range" id="setting-animation-speed" min="1" max="3" value="2" style="flex: 1; height: 6px; background: #555; border-radius: 5px; outline: none;">
                        <span style="color: #888; font-size: 0.85em;">Fast</span>
                    </div>
                </div>
            </div>
            
            <!-- Gameplay Settings -->
            <div style="padding: 20px 0; margin-bottom: 20px;">
                <h3 style="color: #a55eea; margin: 0 0 15px 0; font-size: 1.3em;">üéÆ Gameplay</h3>
                
                <!-- Auto-end Turn -->
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <div>
                        <div style="color: #fff; font-weight: 600; margin-bottom: 3px;">Confirm Moves</div>
                        <div style="color: #888; font-size: 0.85em;">Require confirmation before move</div>
                    </div>
                    <div onclick="toggleSetting('confirm-moves')" style="position: relative; display: inline-block; width: 60px; height: 30px; cursor: pointer;">
                        <input type="checkbox" id="setting-confirm-moves" style="opacity: 0; width: 0; height: 0; pointer-events: none;">
                        <span style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: #555; border-radius: 30px; transition: 0.3s;"></span>
                        <span style="position: absolute; height: 22px; width: 22px; left: 4px; bottom: 4px; background-color: white; border-radius: 50%; transition: 0.3s;"></span>
                    </div>
                </div>
                
                <!-- Show Threats -->
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <div>
                        <div style="color: #fff; font-weight: 600; margin-bottom: 3px;">Show Threats</div>
                        <div style="color: #888; font-size: 0.85em;">Highlight pieces under attack</div>
                    </div>
                    <div onclick="toggleSetting('show-threats')" style="position: relative; display: inline-block; width: 60px; height: 30px; cursor: pointer;">
                        <input type="checkbox" id="setting-show-threats" checked style="opacity: 0; width: 0; height: 0; pointer-events: none;">
                        <span style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: #a55eea; border-radius: 30px; transition: 0.3s;"></span>
                        <span style="position: absolute; height: 22px; width: 22px; left: 34px; bottom: 4px; background-color: white; border-radius: 50%; transition: 0.3s;"></span>
                    </div>
                </div>
                
                <!-- Show Last Move -->
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <div style="color: #fff; font-weight: 600; margin-bottom: 3px;">Show Last Move</div>
                        <div style="color: #888; font-size: 0.85em;">Highlight the previous move</div>
                    </div>
                    <div onclick="toggleSetting('show-last-move')" style="position: relative; display: inline-block; width: 60px; height: 30px; cursor: pointer;">
                        <input type="checkbox" id="setting-show-last-move" checked style="opacity: 0; width: 0; height: 0; pointer-events: none;">
                        <span style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: #a55eea; border-radius: 30px; transition: 0.3s;"></span>
                        <span style="position: absolute; height: 22px; width: 22px; left: 34px; bottom: 4px; background-color: white; border-radius: 50%; transition: 0.3s;"></span>
                    </div>
                </div>
            </div>
            
            <!-- Reset Button -->
            <button onclick="resetSettings()" style="
                background: #ff6b6b;
                color: white;
                border: none;
                padding: 12px 24px;
                border-radius: 8px;
                cursor: pointer;
                width: 100%;
                font-weight: 600;
                margin-bottom: 10px;
                transition: all 0.3s ease;
            " onmouseover="this.style.background='#ff5252'" onmouseout="this.style.background='#ff6b6b'">
                üîÑ Reset to Defaults
            </button>
                
            <button onclick="closeSettingsModal()" style="
                background: linear-gradient(45deg, #95a5a6, #7f8c8d);
                color: white;
                border: none;
                padding: 15px 30px;
                border-radius: 8px;
                cursor: pointer;
                width: 100%;
                font-weight: 600;
                font-size: 16px;
                transition: all 0.3s ease;
            " onmouseover="this.style.transform='scale(1.02)'" onmouseout="this.style.transform='scale(1)'">
                ‚úì Save & Close
            </button>
        </div>
    </div>

    <!-- Game Modes Modal -->
    <div id="game-modes-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.9); z-index: 10000; justify-content: center; align-items: center;">
        <div style="background: #262421; border: 3px solid #ff6b6b; border-radius: 20px; padding: 40px; max-width: 700px; width: 90%; box-shadow: 0 10px 50px rgba(255, 107, 107, 0.3);">
            <h2 style="color: #ff6b6b; text-align: center; margin-bottom: 30px; font-size: 32px;">üéØ Game Modes</h2>
            
            <p style="color: #ccc; text-align: center; margin-bottom: 25px;">Choose an alternative game variant:</p>
            
            <!-- Game Modes Grid -->
            <div style="display: grid; gap: 20px; margin-bottom: 25px;">
                
                <!-- Square Attack Mode -->
                <div style="background: rgba(255, 107, 107, 0.1); border: 2px solid #ff6b6b; border-radius: 12px; padding: 25px; cursor: pointer; transition: all 0.3s ease;" 
                     onclick="startGameMode('square-attack')" 
                     onmouseover="this.style.transform='translateY(-3px)'; this.style.boxShadow='0 8px 25px rgba(255, 107, 107, 0.3)'" 
                     onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                    <div style="display: flex; align-items: center; gap: 20px;">
                        <div style="font-size: 3em;">‚öîÔ∏è</div>
                        <div style="flex: 1;">
                            <h3 style="color: #ff6b6b; margin: 0 0 10px 0; font-size: 1.4em;">Square Attack</h3>
                            <p style="color: #ddd; margin: 0 0 10px 0; line-height: 1.5;">
                                Simplified mode with <strong>squares only</strong> plus rhombus. Fast-paced tactical gameplay.
                            </p>
                            <div style="display: flex; gap: 15px; color: #aaa; font-size: 0.9em;">
                                <span>‚ñ† 4 Squares each</span>
                                <span>üî∂ 1 Rhombus each</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Hexagon Siege Mode -->
                <div style="background: rgba(78, 205, 196, 0.1); border: 2px solid #4ecdc4; border-radius: 12px; padding: 25px; cursor: pointer; transition: all 0.3s ease;" 
                     onclick="startGameMode('hexagon-siege')" 
                     onmouseover="this.style.transform='translateY(-3px)'; this.style.boxShadow='0 8px 25px rgba(78, 205, 196, 0.3)'" 
                     onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                    <div style="display: flex; align-items: center; gap: 20px;">
                        <div style="font-size: 3em;">‚¨°</div>
                        <div style="flex: 1;">
                            <h3 style="color: #4ecdc4; margin: 0 0 10px 0; font-size: 1.4em;">Hexagon Siege</h3>
                            <p style="color: #ddd; margin: 0 0 10px 0; line-height: 1.5;">
                                Rotating powerhouses! <strong>Hexagons only</strong> plus rhombus. Master rotation strategy.
                            </p>
                            <div style="display: flex; gap: 15px; color: #aaa; font-size: 0.9em;">
                                <span>‚¨° 4 Hexagons each</span>
                                <span>üî∂ 1 Rhombus each</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- More modes placeholder -->
                <div style="background: rgba(149, 165, 166, 0.1); border: 2px dashed #95a5a6; border-radius: 12px; padding: 25px; opacity: 0.6;">
                    <div style="display: flex; align-items: center; gap: 20px;">
                        <div style="font-size: 3em;">üîí</div>
                        <div style="flex: 1;">
                            <h3 style="color: #95a5a6; margin: 0 0 10px 0; font-size: 1.4em;">More Modes Coming Soon!</h3>
                            <p style="color: #999; margin: 0; line-height: 1.5;">
                                Triangle Rush, Circle Chaos, and more variants in development...
                            </p>
                        </div>
                    </div>
                </div>
                
            </div>
            
            <button onclick="closeGameModesModal()" style="
                background-color: #555;
                    color: white;
                    border: none;
                padding: 15px 30px;
                border-radius: 8px;
                    cursor: pointer;
                width: 100%;
                font-weight: 600;
                font-size: 16px;
                    transition: all 0.3s ease;
            " onmouseover="this.style.background='#666'" onmouseout="this.style.background='#555'">
                ‚Üê Back to Menu
                </button>
                
            <!-- Debug AI Button -->
            <button onclick="testAI()" style="
                background-color: #ff6b6b;
                    color: white;
                    border: none;
                padding: 10px 20px;
                border-radius: 8px;
                    cursor: pointer;
                width: 100%;
                font-weight: 600;
                font-size: 14px;
                margin-top: 10px;
                    transition: all 0.3s ease;
            " onmouseover="this.style.background='#ff5252'" onmouseout="this.style.background='#ff6b6b'">
                üß™ Test AI Move
            </button>
            
            <!-- Debug Triangle Button -->
            <button onclick="testTriangleRotation()" style="
                background-color: #4ecdc4;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 8px;
                cursor: pointer;
                width: 100%;
                font-weight: 600;
                font-size: 14px;
                margin-top: 10px;
                transition: all 0.3s ease;
            " onmouseover="this.style.background='#26d0ce'" onmouseout="this.style.background='#4ecdc4'">
                üî∫ Test Triangle Rotation
                </button>
        </div>
            </div>
            
    <!-- Game Analysis Modal -->
    <div id="analysis-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.95); z-index: 10000; overflow-y: auto;">
        <div style="background: #262421; border: 3px solid #4ecdc4; border-radius: 20px; padding: 30px; max-width: 1000px; width: 95%; margin: 30px auto; box-shadow: 0 10px 50px rgba(78, 205, 196, 0.3);">
            <h2 style="color: #4ecdc4; text-align: center; margin-bottom: 20px; font-size: 28px;">üìä Game Analysis</h2>
            
            <!-- File Upload Section -->
            <div style="background: rgba(78, 205, 196, 0.1); border: 2px dashed #4ecdc4; border-radius: 12px; padding: 25px; margin-bottom: 25px; text-align: center;">
                <h3 style="color: #4ecdc4; margin: 0 0 15px 0;">üìÅ Load RMN File</h3>
                <p style="color: #ccc; margin-bottom: 15px;">Upload a saved RMN game file to analyze</p>
                <input type="file" id="rmn-file-input" accept=".rmn,.txt" style="display: none;" onchange="loadRMNFile(event)">
                <button onclick="document.getElementById('rmn-file-input').click()" style="
                    background: linear-gradient(135deg, #4ecdc4, #26d0ce);
                    color: #262421;
                    border: none;
                    padding: 12px 30px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-weight: 700;
                    font-size: 16px;
                    transition: all 0.3s ease;
                    margin-right: 10px;
                " onmouseover="this.style.transform='translateY(-2px)'" onmouseout="this.style.transform='translateY(0)'">
                    üìÇ Choose File
                </button>
                <button onclick="loadCurrentGame()" style="
                    background: linear-gradient(135deg, #ffd700, #ffa500);
                    color: #262421;
                    border: none;
                    padding: 12px 30px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-weight: 700;
                    font-size: 16px;
                    transition: all 0.3s ease;
                " onmouseover="this.style.transform='translateY(-2px)'" onmouseout="this.style.transform='translateY(0)'">
                    üéÆ Analyze Current Game
                </button>
                <button onclick="debugCurrentPosition()" style="
                    background: linear-gradient(135deg, #9b59b6, #8e44ad);
                    color: white;
                    border: none;
                    padding: 12px 30px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-weight: 700;
                    font-size: 16px;
                    transition: all 0.3s ease;
                " onmouseover="this.style.transform='translateY(-2px)'" onmouseout="this.style.transform='translateY(0)'">
                    üîç Debug Position
                </button>
            </div>
            
            <!-- Game Info Section -->
            <div id="analysis-info" style="display: none; background: rgba(255, 215, 0, 0.1); border-left: 4px solid #ffd700; padding: 20px; margin-bottom: 20px; border-radius: 8px;">
                <h3 style="color: #ffd700; margin: 0 0 10px 0;">‚ÑπÔ∏è Game Information</h3>
                <div id="analysis-metadata" style="color: #ddd; line-height: 1.8;"></div>
            </div>
            
            <!-- Move Navigator -->
            <div id="analysis-navigator" style="display: none; background: rgba(78, 205, 196, 0.1); padding: 20px; margin-bottom: 20px; border-radius: 8px;">
                <h3 style="color: #4ecdc4; margin: 0 0 15px 0;">üé¨ Move Navigator</h3>
                <div style="display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap;">
                    <button onclick="goToStart()" style="
                        background: #555;
                        color: white;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 6px;
                        cursor: pointer;
                        font-weight: 600;
                    ">‚èÆÔ∏è Start</button>
                    <button onclick="previousMove()" style="
                        background: #555;
                        color: white;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 6px;
                        cursor: pointer;
                        font-weight: 600;
                    ">‚óÄÔ∏è Previous</button>
                    <button onclick="nextMove()" style="
                        background: #555;
                        color: white;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 6px;
                        cursor: pointer;
                        font-weight: 600;
                    ">‚ñ∂Ô∏è Next</button>
                    <button onclick="goToEnd()" style="
                        background: #555;
                        color: white;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 6px;
                        cursor: pointer;
                        font-weight: 600;
                    ">‚è≠Ô∏è End</button>
                    <button onclick="toggleAutoPlay()" id="autoplay-btn" style="
                        background: #4ecdc4;
                        color: #262421;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 6px;
                        cursor: pointer;
                        font-weight: 600;
                    ">‚ñ∂Ô∏è Auto Play</button>
                    <button onclick="annotateCurrentMove()" style="
                        background: #9b59b6;
                        color: white;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 6px;
                        cursor: pointer;
                        font-weight: 600;
                    ">üìù Annotate</button>
                </div>
                <div style="color: #fff; margin-bottom: 10px; font-weight: 600;">
                    Move: <span id="current-move-number">0</span> / <span id="total-moves">0</span>
                </div>
                <input type="range" id="move-slider" min="0" max="0" value="0" style="width: 100%; margin-bottom: 10px;" oninput="jumpToMove(parseInt(this.value))">
                <div id="current-move-info" style="color: #ccc; font-size: 14px;"></div>
            </div>
            
            <!-- Mini Board Display -->
            <div id="analysis-board-container" style="display: none; background: rgba(0, 0, 0, 0.3); padding: 20px; margin-bottom: 20px; border-radius: 8px; overflow: visible;">
                <h3 style="color: #4ecdc4; margin: 0 0 15px 0; text-align: center;">‚ôüÔ∏è Position View</h3>
                <div style="display: flex; justify-content: center; align-items: center; min-height: 500px; width: 100%;">
                    <div id="analysis-mini-board" class="mini-board"></div>
                </div>
            </div>
            
            <!-- Move List -->
            <div id="analysis-moves" style="display: none; background: rgba(255, 255, 255, 0.05); padding: 20px; margin-bottom: 20px; border-radius: 8px; max-height: 300px; overflow-y: auto;">
                <h3 style="color: #ffd700; margin: 0 0 15px 0;">üìú Move List</h3>
                <div id="analysis-move-list" style="color: #ddd; font-family: monospace; line-height: 2;"></div>
            </div>
            
            <!-- Statistics -->
            <div id="analysis-stats" style="display: none; background: rgba(255, 107, 107, 0.1); padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                <h3 style="color: #ff6b6b; margin: 0 0 15px 0;">üìà Game Statistics</h3>
                <div id="analysis-statistics" style="color: #ddd; line-height: 1.8;"></div>
            </div>
            
            <!-- Action Buttons -->
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                <button onclick="closeAnalysisModal()" style="
                    background: linear-gradient(135deg, #4ecdc4, #26d0ce);
                    color: #262421;
                    border: none;
                    padding: 15px 30px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-weight: 700;
                    font-size: 16px;
                    transition: all 0.3s ease;
                " onmouseover="this.style.transform='scale(1.02)'" onmouseout="this.style.transform='scale(1)'">
                    ‚Üê Back to Game
                </button>
                <button onclick="closeAnalysisModal()" style="
                    background: linear-gradient(45deg, #95a5a6, #7f8c8d);
                    color: white;
                    border: none;
                    padding: 15px 30px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-weight: 600;
                    font-size: 16px;
                    transition: all 0.3s ease;
                " onmouseover="this.style.transform='scale(1.02)'" onmouseout="this.style.transform='scale(1)'">
                    ‚úì Close
                </button>
            </div>
        </div>
    </div>
            
    <!--Multiplayer Modal -->
    <div id="multiplayer-modal">
        <div class="multiplayer-container" id="mp-main-menu">
            <h2>üåê Multiplayer Mode</h2>
            <div class="multiplayer-options">
                <button class="mp-button" onclick="createMultiplayerRoom()">
                    üéÆ Create Game Room
                </button>
                <button class="mp-button secondary" onclick="showJoinRoom()">
                    üîó Join Game Room
                </button>
                <button class="mp-button" onclick="startDevMode()" style="background: linear-gradient(135deg, #ffa502 0%, #ff6348 100%);">
                    üîß Dev Mode (Local Test)
                </button>
                <button class="mp-back-button" onclick="closeMultiplayerModal()">
                    ‚Üê Back to Menu
                </button>
            </div>
        </div>

        <!-- Create Room View -->
        <div class="multiplayer-container" id="mp-create-room" style="display: none;">
            <h2>üéÆ Hosting Game Room</h2>
            <div class="room-code-display" id="room-code-display">------</div>
            <p class="waiting-message">Waiting for opponent to join...</p>
            <p style="color: #888; font-size: 14px; text-align: center;">
                Share this room code with your opponent
            </p>
            <button class="mp-back-button" onclick="cancelCreateRoom()">
                Cancel
            </button>
        </div>

        <!-- Join Room View -->
        <div class="multiplayer-container" id="mp-join-room" style="display: none;">
            <h2>üîó Join Game Room</h2>
            <input 
                type="text" 
                id="room-code-input" 
                class="mp-input" 
                placeholder="Enter Room Code" 
                maxlength="6"
            />
            <div id="mp-error-message" class="mp-error"></div>
            <button class="mp-button" onclick="joinMultiplayerRoom()">
                Join Game
            </button>
            <button class="mp-back-button" onclick="backToMultiplayerMenu()">
                ‚Üê Back
            </button>
        </div>
    </div>

    <!-- Multiplayer Status Indicator -->
    <div id="multiplayer-status" class="multiplayer-status" style="display: none;">
        <div style="margin-bottom: 10px;">
            <span class="status-indicator" id="connection-indicator"></span>
            <span id="connection-text">Disconnected</span>
        </div>
        <div style="font-size: 12px; color: #ccc;">
            <div id="room-info" style="display: none;">
                Room: <span id="current-room-code" style="color: #4ecdc4; font-weight: bold;">------</span>
            </div>
            <div id="player-role">Role: <span id="player-color-display" style="font-weight: bold;">-</span></div>
        </div>
    </div>

    <!-- AI Reasoning Display Panel - Compact Version -->
    <div id="ai-reasoning-panel" style="
        display: none;
        position: fixed;
        bottom: 20px;
        left: 220px;
        background: rgba(0, 0, 0, 0.9);
        border: 2px solid #00d2ff;
        border-radius: 10px;
        padding: 12px;
        max-width: 320px;
        width: 320px;
        color: white;
        font-family: 'Courier New', monospace;
        z-index: 1500;
        box-shadow: 0 4px 20px rgba(0, 210, 255, 0.4);
        backdrop-filter: blur(10px);
    ">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <div style="display: flex; align-items: center; gap: 8px;">
                <span id="ai-model-icon" style="font-size: 1.2em;">üß†</span>
                <span id="ai-model-name" style="color: #00d2ff; font-size: 0.9em; font-weight: bold;">Claude</span>
            </div>
            <div id="ai-thinking-status" style="color: #ffd93d; font-size: 0.75em;">
                ‚è≥
            </div>
        </div>
        
        <div id="ai-reasoning-content" style="
            background: rgba(0, 210, 255, 0.1);
            border-left: 2px solid #00d2ff;
            padding: 8px;
            border-radius: 5px;
            font-size: 0.75em;
            line-height: 1.4;
            max-height: 120px;
            overflow-y: auto;
        ">
            <div id="ai-reasoning-text" style="color: #e0e0e0;">
                Thinking...
            </div>
        </div>
        
        <div id="ai-move-display" style="
            margin-top: 8px;
            padding: 6px;
            background: linear-gradient(45deg, #00d2ff22, #3a7bd522);
            border-radius: 5px;
            text-align: center;
            font-size: 0.85em;
            font-weight: bold;
            color: #00d2ff;
        ">
            <span id="ai-move-text">‚ö° Calculating...</span>
        </div>
    </div>

    <div id="board-display-container" style="display: none;">
        <!-- Top Left Controls (Quit Button Only) -->
        <div style="position: absolute; top: 18px; left: 18px; z-index: 20; display: flex; gap: 12px;">
            <button id="quit-game-btn" style="background:linear-gradient(135deg,#ff6b6b,#ff5252);color:white;border:none;padding:12px 28px;border-radius:18px;cursor:pointer;font-weight:700;font-size:1.05em;box-shadow:0 2px 8px rgba(255,107,107,0.25);transition:all 0.2s;letter-spacing:1px;white-space:nowrap;min-width:180px;" onclick="quitAndLogout()" onmouseover="this.style.transform='translateY(-2px)';this.style.boxShadow='0 4px 16px rgba(255,107,107,0.4)'" onmouseout="this.style.transform='translateY(0)';this.style.boxShadow='0 2px 8px rgba(255,107,107,0.25)';">Quit & Logout</button>
        </div>
        
        <!-- Player Timers -->
        <div id="player-timers" class="player-timers" style="display: none;">
            <div id="white-timer" class="timer-display">
                <div class="timer-label">White</div>
                <div class="timer-time">10:00</div>
            </div>
            <div id="black-timer" class="timer-display active">
                <div class="timer-label">Black</div>
                <div class="timer-time">10:00</div>
            </div>
        </div>
        
        <!-- Eliminated pieces display -->
        <div id="eliminated-pieces-container">
            <div class="eliminated-section">
                <h3>White Eliminated</h3>
                <div id="white-eliminated" class="eliminated-pieces"></div>
                <!-- Base defence indicator placeholder will be inserted here by updateBaseDefenceDisplay() -->
                <div id="white-base-defence-placeholder"></div>
                <div id="white-variant-indicator" class="variant-indicator" style="margin-top:6px;">BASE: Original</div>
                <div id="white-opening-name" style="margin-top:6px;text-align:center;color:#4ecdc4;font-size:0.95em;font-weight:600;"></div>
                <div class="movement-section">
                    <h3>White Moves</h3>
                    <ul id="white-moves" class="movement-list"></ul>
                </div>
            </div>
            <div class="eliminated-section">
                <h3>Black Eliminated</h3>
                <div id="black-eliminated" class="eliminated-pieces"></div>
                <!-- Base defence indicator placeholder will be inserted here by updateBaseDefenceDisplay() -->
                <div id="black-base-defence-placeholder"></div>
                <div id="black-variant-indicator" class="variant-indicator" style="margin-top:6px;">BASE: Original</div>
                <div id="black-opening-name" style="margin-top:6px;text-align:center;color:#ffd700;font-size:0.95em;font-weight:600;"></div>
                <div class="movement-section">
                    <h3>Black Moves</h3>
                    <ul id="black-moves" class="movement-list"></ul>
                </div>
    <script>
    // --- Opening Recognition Logic ---
    // List of all named openings from openings.md
    const ROMGON_OPENINGS = [
        { name: 'Triangle Coop', moves: ['t5-6>5-5','t1-6>2-6'] },
        { name: 'Triangle Coop', moves: ['T1-0>1-1','T5-0>4-1'] },
        { name: 'Rhombus Straw', moves: ['r3-8>3-6','r3-6>3-4'] },
        { name: 'Rhombus Straw', moves: ['R3-0>3-2','R3-2>3-4'] },
        { name: '2 Square Advance', moves: ['s6-5>5-5','s0-5>1-5'] },
        { name: '2 Square Advance', moves: ['S0-0>1-1','S6-0>5-1'] },
        { name: 'Triangle Gateway Attack', moves: ['T2-1-3-2','s5-0-5-1'] },
        { name: 'Central Hexagon Push', moves: ['H3-2-3-3','t4-1-4-2'] },
        { name: 'Rhombus Diagonal Entry', moves: ['R3-0-2-1','s1-0-1-1'] },
        { name: 'Circle Central Jump', moves: ['C0-2-2-3','h3-2-rotR'] },
        { name: 'Square Side Push', moves: ['S1-0-2-0','t4-1-3-2'] },
        { name: 'Triangle Flank Advance', moves: ['T4-1-5-2','s1-0-1-1'] },
        { name: 'Hexagon Diagonal Move', moves: ['H3-2-2-3','c0-2-2-1'] },
        { name: 'Rhombus Central Advance', moves: ['R3-0-3-1','h3-2-3-3'] },
        { name: 'Square Central Advance', moves: ['S5-0-5-1','t2-1-2-2'] },
        { name: 'Circle Zone Jump', moves: ['C0-2-1-3','r3-0-4-1'] },
        { name: 'Hexagon Rotate Left', moves: ['H3-2-rotL','t2-1-3-2'] },
        { name: 'Triangle Central Push', moves: ['T2-1-2-2','s5-0-4-0'] },
        { name: 'Square Flank Push', moves: ['S1-0-2-0','h3-2-2-3'] },
        { name: 'Rhombus Flank Entry', moves: ['R3-0-4-1','t4-1-4-2'] },
        { name: 'Hexagon Rotate Right', moves: ['H3-2-rotR','s1-0-1-1'] },
        { name: 'Black Square Side Push', moves: ['s6-5>5-5'] },
        { name: 'Hexagon Push', moves: ['s6-5>5-5','h2-7>3-6'] },
        { name: 'Hexagon Push', moves: ['S0-0>1-1','H4-0>3-2'] },
        { name: 'Rhombus Roster', moves: ['r3-8>3-6','c4-7>4-6'] },
        { name: 'Rhombus Roster', moves: ['R3-0>3-2','C2-0>2-1'] }
    ];

    // --- Quit Game Handler (old - kept for backward compatibility) ---
    function quitGame() {
        // This function is kept for backward compatibility
        // The new function quitAndLogout() is now used instead
        quitAndLogout();
    }

    // --- Quit Game To User Screen (old - kept for backward compatibility) ---
    function quitGameToUserScreen() {
        // This function is kept for backward compatibility
        // The new function quitAndLogout() is now used instead
        quitAndLogout();
    }

    // --- Quit Game And Logout ---
    function quitAndLogout() {
        // Hide board container and all its children (including buttons)
        const boardDisplayEl = document.getElementById('board-display-container');
        if (boardDisplayEl) {
            boardDisplayEl.style.display = 'none';
            // Also hide all child elements to ensure nothing shows
            const allChildren = boardDisplayEl.querySelectorAll('*');
            allChildren.forEach(child => {
                if (child.style) {
                    // Don't override if already hidden, but ensure visibility
                }
            });
        }
        
        // Hide turn indicator (the circular buttons toolbar at the top)
        const turnIndicatorEl = document.getElementById('turn-indicator');
        if (turnIndicatorEl) {
            turnIndicatorEl.style.display = 'none';
        }
        
        // Hide AI panel if present
        const aiPanelEl = document.getElementById('ai-reasoning-panel');
        if (aiPanelEl) aiPanelEl.style.display = 'none';
        
        // Hide user home 
        const userHomeEl = document.getElementById('user-home');
        if (userHomeEl) userHomeEl.style.display = 'none';
        
        // Hide start menu (important!)
        const startMenuEl = document.getElementById('start-menu');
        if (startMenuEl) startMenuEl.style.display = 'none';
        
        // Clear session and user data
        window.currentUser = null;
        try { localStorage.removeItem('romgon-user'); } catch (e) {}
        try { sessionStorage.clear(); } catch (e) {}
        
        // Disable Google auto-select
        try { 
            if (window.google && window.google.accounts && window.google.accounts.id) {
                google.accounts.id.disableAutoSelect(); 
            } 
        } catch (e) {}
        
        // Remove logged-in user UI
        try { removeLoggedInUserUI(); } catch (e) {}
        
        // Reset game state flags
        gameInProgress = false;
        aiEnabled = false;
        
        // Show splash page (login screen) LAST so it's on top
        const splashPage = document.getElementById('splash-page');
        if (splashPage) {
            splashPage.style.display = 'flex';
            splashPage.style.zIndex = '3000'; // Ensure it's on top
        }
    }

    function normalizeMoveNotation(move) {
        // Normalize move notation for comparison: remove spaces, unify > and -
        if (!move) return '';
        // Remove any trailing capture/rotation/special flags (x, @, d)
        const stripped = move.replace(/[x@d]+$/i, '');
        return stripped.toLowerCase().replace(/\s+/g, '').replace(/>/g, '-');
    }

    function getOpeningNameForPlayer(player) {
        // Get the first two moves played in the game (regardless of player)
    // Get first two moves by the specified player
    const playerMoves = window.rpnMoveHistory.filter(m => m.player === player).slice(0,2);
    const rawMoves = playerMoves.map(m => m.notation);
    const moves = rawMoves.map(m => normalizeMoveNotation(m));
    // Also get the first two moves in the game (for backward compatibility)
    const firstTwoMoves = window.rpnMoveHistory.slice(0,2).map(m => normalizeMoveNotation(m.notation));
        // Prefer 4-move opening only if all 4 moves match
        for (const opening of ROMGON_OPENINGS) {
            if (opening.moves.length === 4) {
                const firstFourMoves = window.rpnMoveHistory.slice(0,4).map(m => normalizeMoveNotation(m.notation));
                if (firstFourMoves.length === 4 &&
                    firstFourMoves[0] === normalizeMoveNotation(opening.moves[0]) &&
                    firstFourMoves[1] === normalizeMoveNotation(opening.moves[1]) &&
                    firstFourMoves[2] === normalizeMoveNotation(opening.moves[2]) &&
                    firstFourMoves[3] === normalizeMoveNotation(opening.moves[3])) {
                    return opening.name;
                }
            }
        }
        // Otherwise, check for 2-move openings for this player
        for (const opening of ROMGON_OPENINGS) {
            if (opening.moves.length === 2) {
                const o0 = normalizeMoveNotation(opening.moves[0]);
                const o1 = normalizeMoveNotation(opening.moves[1]);
                if (moves[0] && moves[1] && ((moves[0] === o0 && moves[1] === o1) || (moves[0] === o1 && moves[1] === o0))) {
                    return opening.name;
                }
                if (firstTwoMoves[0] && firstTwoMoves[1] && ((firstTwoMoves[0] === o0 && firstTwoMoves[1] === o1) || (firstTwoMoves[0] === o1 && firstTwoMoves[1] === o0))) {
                    return opening.name;
                }
            }
        }
        return '';
    }



    function updateOpeningDisplay() {
    // Opening detection reads from window.rpnMoveHistory (first two moves per player)
        // Show opening name for each player if their first two moves match an opening
        let whiteName = getOpeningNameForPlayer('white');
        let blackName = getOpeningNameForPlayer('black');
        if (!whiteName) whiteName = 'No opening played';
        if (!blackName) blackName = 'No opening played';
        document.getElementById('white-opening-name').textContent = whiteName;
        document.getElementById('black-opening-name').textContent = blackName;

        // ...existing code for debug panel...

        // Remove Opening Recognition debug window if present
        const debugPanel = document.getElementById('opening-debug-panel');
        if (debugPanel) debugPanel.remove();
    }



    // Call updateOpeningDisplay after each move (robust)
    function alwaysUpdateOpeningDisplay() {
        setTimeout(updateOpeningDisplay, 0);
    }
    const origRecordMoveRPN = window.recordMoveRPN;
    window.recordMoveRPN = function(...args) {
        if (origRecordMoveRPN) origRecordMoveRPN.apply(this, args);
        alwaysUpdateOpeningDisplay();
    };
    const origImportPositionRPN = window.importPositionRPN;
    window.importPositionRPN = function(...args) {
        const result = origImportPositionRPN ? origImportPositionRPN.apply(this, args) : null;
        alwaysUpdateOpeningDisplay();
        return result;
    };
    // Also update after any click on the board (in case of missed hooks)
    document.addEventListener('click', alwaysUpdateOpeningDisplay);
    // Initial call
    setTimeout(updateOpeningDisplay, 500);
    // --- Move panels spacing fix ---
    // Move the move panels slightly further down to avoid overlap
    document.addEventListener('DOMContentLoaded', function() {
        var whiteMoves = document.getElementById('white-moves');
        var blackMoves = document.getElementById('black-moves');
        if (whiteMoves) whiteMoves.parentElement.style.marginTop = '80px';
        if (blackMoves) blackMoves.parentElement.style.marginTop = '80px';
    });
    </script>
            </div>
        </div>
        
        <!-- Movement tracking display removed (moves lists are embedded into each side panel) -->
        
        <div class="board" id="game-board">
             <!-- Board Rows 0-6 with coordinates and classes -->
             <div class="row" id="row-0">
                 <div class="hexagon shift-down color-orange-med" id="hex-0-0">
                     <span class="hex-coords">0-0</span>
                     <div class="square-piece white-piece"></div>
                 </div>
                 <div class="hexagon shift-down color-orange-med" id="hex-0-1"><span class="hex-coords">0-1</span></div>
                 <div class="hexagon shift-down color-orange-med" id="hex-0-2"><span class="hex-coords">0-2</span></div>
                 <div class="hexagon shift-down color-orange-med" id="hex-0-3"><span class="hex-coords">0-3</span></div>
                 <div class="hexagon shift-down color-orange-med" id="hex-0-4"><span class="hex-coords">0-4</span></div>
                 <div class="hexagon shift-down color-orange-med" id="hex-0-5">
                     <span class="hex-coords">0-5</span>
                     <div class="square-piece"></div>
                 </div>
             </div>
             <div class="row" id="row-1">
                 <div class="hexagon color-orange-med" id="hex-1-0">
                     <span class="hex-coords">1-0</span>
                     <div class="triangle-piece white-triangle"></div>
                 </div>
                 <div class="hexagon color-orange-light" id="hex-1-1"><span class="hex-coords">1-1</span></div>
                 <div class="hexagon color-orange-light" id="hex-1-2"><span class="hex-coords">1-2</span></div>
                 <div class="hexagon color-orange-light" id="hex-1-3"><span class="hex-coords">1-3</span></div>
                 <div class="hexagon color-orange-light" id="hex-1-4"><span class="hex-coords">1-4</span></div>
                 <div class="hexagon color-orange-light" id="hex-1-5"><span class="hex-coords">1-5</span></div>
                 <div class="hexagon color-orange-med" id="hex-1-6">
                     <span class="hex-coords">1-6</span>
                     <div class="triangle-piece"></div>
                 </div>
             </div>
             <div class="row" id="row-2">
                 <div class="hexagon shift-down color-orange-med" id="hex-2-0">
                     <span class="hex-coords">2-0</span>
                     <div class="circle-piece white-circle" draggable="true"></div>
                 </div>
                 <div class="hexagon shift-down color-orange-light" id="hex-2-1"><span class="hex-coords">2-1</span></div>
                 <div class="hexagon shift-down color-orange-med" id="hex-2-2"><span class="hex-coords">2-2</span></div>
                 <div class="hexagon shift-down color-orange-med" id="hex-2-3"><span class="hex-coords">2-3</span></div>
                 <div class="hexagon shift-down color-orange-med" id="hex-2-4"><span class="hex-coords">2-4</span></div>
                 <div class="hexagon shift-down color-orange-med" id="hex-2-5"><span class="hex-coords">2-5</span></div>
                 <div class="hexagon shift-down color-orange-light" id="hex-2-6"><span class="hex-coords">2-6</span></div>
                  <div class="hexagon shift-down color-orange-med" id="hex-2-7">
                      <span class="hex-coords">2-7</span>
                      <div class="hexgon-piece" draggable="true"></div>
                  </div>
             </div>
             <div class="row" id="row-3">
                 <div class="hexagon color-dark-brown" id="hex-3-0">
                     <span class="hex-coords">3-0</span>
                     <div class="rhombus-piece white-rhombus"></div>
                 </div>
                 <div class="hexagon color-orange-light" id="hex-3-1"><span class="hex-coords">3-1</span></div>
                 <div class="hexagon color-orange-med" id="hex-3-2"><span class="hex-coords">3-2</span></div>
                 <div class="hexagon color-dark-brown" id="hex-3-3"><span class="hex-coords">3-3</span></div>
                 <div class="hexagon color-dark-brown" id="hex-3-4">
                     <span class="hex-coords">3-4</span>
                 </div>
                 <div class="hexagon color-dark-brown" id="hex-3-5"><span class="hex-coords">3-5</span></div>
                 <div class="hexagon color-orange-med" id="hex-3-6"><span class="hex-coords">3-6</span></div>
                 <div class="hexagon color-orange-light" id="hex-3-7"><span class="hex-coords">3-7</span></div>
                 <div class="hexagon color-dark-brown" id="hex-3-8">
                     <span class="hex-coords">3-8</span>
                     <div class="rhombus-piece"></div>
                 </div>
             </div>
             <div class="row" id="row-4">
                 <div class="hexagon shift-down color-orange-med" id="hex-4-0">
                     <span class="hex-coords">4-0</span>
                     <div class="hexgon-piece white-hexgon" draggable="true"></div>
                 </div>
                 <div class="hexagon shift-down color-orange-light" id="hex-4-1"><span class="hex-coords">4-1</span></div>
                 <div class="hexagon shift-down color-orange-med" id="hex-4-2"><span class="hex-coords">4-2</span></div>
                 <div class="hexagon shift-down color-orange-med" id="hex-4-3"><span class="hex-coords">4-3</span></div>
                 <div class="hexagon shift-down color-orange-med" id="hex-4-4"><span class="hex-coords">4-4</span></div>
                 <div class="hexagon shift-down color-orange-med" id="hex-4-5"><span class="hex-coords">4-5</span></div>
                 <div class="hexagon shift-down color-orange-light" id="hex-4-6"><span class="hex-coords">4-6</span></div>
                <div class="hexagon shift-down color-orange-med" id="hex-4-7">
                    <span class="hex-coords">4-7</span>
                    <div class="circle-piece" draggable="true"></div>
                </div>
             </div>
             <div class="row" id="row-5">
                 <div class="hexagon color-orange-med" id="hex-5-0">
                     <span class="hex-coords">5-0</span>
                     <div class="triangle-piece white-triangle"></div>
                 </div>
                 <div class="hexagon color-orange-light" id="hex-5-1"><span class="hex-coords">5-1</span></div>
                 <div class="hexagon color-orange-light" id="hex-5-2"><span class="hex-coords">5-2</span></div>
                 <div class="hexagon color-orange-light" id="hex-5-3"><span class="hex-coords">5-3</span></div>
                 <div class="hexagon color-orange-light" id="hex-5-4"><span class="hex-coords">5-4</span></div>
                 <div class="hexagon color-orange-light" id="hex-5-5"><span class="hex-coords">5-5</span></div>
                 <div class="hexagon color-orange-med" id="hex-5-6">
                     <span class="hex-coords">5-6</span>
                     <div class="triangle-piece"></div>
                 </div>
             </div>
             <div class="row" id="row-6">
                 <div class="hexagon shift-down color-orange-med" id="hex-6-0">
                     <span class="hex-coords">6-0</span>
                     <div class="square-piece white-piece"></div>
                 </div>
                 <div class="hexagon shift-down color-orange-med" id="hex-6-1"><span class="hex-coords">6-1</span></div>
                 <div class="hexagon shift-down color-orange-med" id="hex-6-2"><span class="hex-coords">6-2</span></div>
                 <div class="hexagon shift-down color-orange-med" id="hex-6-3"><span class="hex-coords">6-3</span></div>
                 <div class="hexagon shift-down color-orange-med" id="hex-6-4"><span class="hex-coords">6-4</span></div>
                 <div class="hexagon shift-down color-orange-med" id="hex-6-5">
                     <span class="hex-coords">6-5</span>
                     <div class="square-piece"></div>
                 </div>
            </div>
        </div>
    </div>

    <script>
        // Audio setup
        let clickSound = null;
        let capturedSound = null;
        let winSound = null;
        let lockRhombusSound = null;
        let flipboardSound = null;
        
        // Background music
        let backgroundMusic1 = null;
        let backgroundMusic2 = null;
        let backgroundMusic3 = null;
        let currentMusicTrack = 0; // 0 = none, 1 = track1, 2 = track2, 3 = track3
        let backgroundMusicTracks = [];
        
        // Track move history for RPN game export (separate from undo moveHistory)
        window.rpnMoveHistory = [];
        
        // Initialize audio when page loads
        function initAudio() {
            try {
                clickSound = new Audio('ASSETS/click.mp3');
                clickSound.volume = 0.3; // Set volume to 30%
                clickSound.preload = 'auto';
                
                capturedSound = new Audio('ASSETS/captured.mp3');
                capturedSound.volume = 0.4; // Set volume to 40% for capture sound
                capturedSound.preload = 'auto';
                
                winSound = new Audio('ASSETS/win.mp3');
                winSound.volume = 0.5; // Set volume to 50% for win sound
                winSound.preload = 'auto';
                
                lockRhombusSound = new Audio('ASSETS/lock rhombus.mp3');
                lockRhombusSound.volume = 0.5; // Set volume to 50% for check/lock sound
                lockRhombusSound.preload = 'auto';
                
                flipboardSound = new Audio('ASSETS/flipboard.mp3');
                flipboardSound.volume = 0.4; // Set volume to 40% for board flip sound
                flipboardSound.preload = 'auto';
                
                // Background music tracks
                backgroundMusic1 = new Audio('ASSETS/background1.mp3');
                backgroundMusic1.volume = 0.2; // Set volume to 20%
                backgroundMusic1.preload = 'auto';
                backgroundMusic1.loop = true; // Loop the music
                
                backgroundMusic2 = new Audio('ASSETS/background2.mp3');
                backgroundMusic2.volume = 0.2;
                backgroundMusic2.preload = 'auto';
                backgroundMusic2.loop = true;
                
                backgroundMusic3 = new Audio('ASSETS/background3.mp3');
                backgroundMusic3.volume = 0.2;
                backgroundMusic3.preload = 'auto';
                backgroundMusic3.loop = true;
                
                backgroundMusicTracks = [backgroundMusic1, backgroundMusic2, backgroundMusic3];
            } catch (error) {
                console.log('Audio not available:', error);
            }
        }
        
        // Play click sound
        function playClickSound() {
            if (clickSound) {
                try {
                    clickSound.currentTime = 0; // Reset to beginning
                    clickSound.play().catch(error => {
                        console.log('Could not play click sound:', error);
                    });
                } catch (error) {
                    console.log('Click audio play error:', error);
                }
            }
        }
        
        // Play captured sound
        function playCapturedSound() {
            if (capturedSound) {
                try {
                    capturedSound.currentTime = 0; // Reset to beginning
                    capturedSound.play().catch(error => {
                        console.log('Could not play captured sound:', error);
                    });
                } catch (error) {
                    console.log('Captured audio play error:', error);
                }
            }
        }
        
        // Play win sound
        function playWinSound() {
            if (winSound) {
                try {
                    winSound.currentTime = 0; // Reset to beginning
                    winSound.play().catch(error => {
                        console.log('Win audio play error:', error);
                    });
                } catch (error) {
                    console.log('Win audio play error:', error);
                }
            }
        }
        
        // Play lock rhombus sound (when rhombus is under attack/check)
        function playLockRhombusSound() {
            if (lockRhombusSound) {
                try {
                    lockRhombusSound.currentTime = 0; // Reset to beginning
                    lockRhombusSound.play().catch(error => {
                        console.log('Lock rhombus audio play error:', error);
                    });
                } catch (error) {
                    console.log('Lock rhombus audio play error:', error);
                }
            }
        }
        
        // Play flipboard sound (when board flips)
        function playFlipboardSound() {
            if (flipboardSound) {
                try {
                    flipboardSound.currentTime = 0; // Reset to beginning
                    flipboardSound.play().catch(error => {
                        console.log('Flipboard audio play error:', error);
                    });
                } catch (error) {
                    console.log('Flipboard audio play error:', error);
                }
            }
        }
        
        // Background music functions
        function playBackgroundMusic(trackNumber) {
            if (!backgroundMusicTracks[trackNumber - 1]) return;
            
            // Stop current music
            stopBackgroundMusic();
            
            // Play new track
            const track = backgroundMusicTracks[trackNumber - 1];
            track.play().catch(error => {
                console.log('Background music play error:', error);
            });
            currentMusicTrack = trackNumber;
            window.gameSettings.currentMusicTrack = trackNumber;
            updateMusicButtonDisplay();
        }
        
        function stopBackgroundMusic() {
            backgroundMusicTracks.forEach(track => {
                if (track) {
                    track.pause();
                    track.currentTime = 0;
                }
            });
            currentMusicTrack = 0;
            window.gameSettings.currentMusicTrack = 0;
            updateMusicButtonDisplay();
        }
        
        function toggleBackgroundMusic() {
            if (currentMusicTrack === 0) {
                // Start with track 1
                playBackgroundMusic(1);
            } else {
                stopBackgroundMusic();
            }
        }
        
        function nextBackgroundTrack() {
            if (currentMusicTrack === 0) {
                playBackgroundMusic(1);
            } else {
                const nextTrack = (currentMusicTrack % 3) + 1;
                playBackgroundMusic(nextTrack);
            }
        }
        
        // Function to update music button display
        function updateMusicButtonDisplay() {
            const turnIndicator = document.getElementById('turn-indicator');
            if (!turnIndicator) return;
            
            const buttons = turnIndicator.querySelectorAll('button');
            for (const button of buttons) {
                if (button.innerHTML.includes('MUSIC')) {
                    const isMusicOn = window.gameSettings.music && currentMusicTrack > 0;
                    button.innerHTML = isMusicOn ? 'üîä MUSIC' : 'üîá MUSIC';
                    button.style.backgroundColor = isMusicOn ? '#8B4513' : '#654321';
                    button.style.boxShadow = isMusicOn ? '0 2px 8px rgba(139, 69, 19, 0.4)' : '0 2px 8px rgba(101, 67, 33, 0.3)';
                    break;
                }
            }
        }
        
        // Track movement history
        let moveCount = 0;
        
        // Track move repetitions for three-fold repetition loss rule
        // Structure: { "pieceId-fromPos-toPos": count }
        // Example: { "hex-3-4-to-3-5": 2 } means this move happened 2 times consecutively
        const moveRepetitions = new Map();
        
        // Track last move for each player to detect when pattern breaks
        let lastWhiteMove = null;
        let lastBlackMove = null;
        
        function recordMove(fromRow, fromCol, toRow, toCol, pieceType, isWhite, isCapture = false, repetitionCount = 0) {
            moveCount++;
            const moveList = isWhite ? document.getElementById('white-moves') : document.getElementById('black-moves');
            const moveItem = document.createElement('li');
            moveItem.className = `movement-item ${isWhite ? 'white-move' : 'black-move'}`;
            
            const pieceSymbol = pieceType === 'square' ? '‚ñ†' : 
                               pieceType === 'triangle' ? '‚ñ≤' : 
                               pieceType === 'rhombus' ? '‚óÜ' : 
                               pieceType === 'circle' ? '‚óè' : '‚¨°';
            const captureSymbol = isCapture ? ' (capture)' : '';
            
            // Color-code based on repetition count (shuttle limit: 5)
            let repetitionDisplay = '';
            let backgroundColor = '';
            let textColor = 'white';
            
            if (repetitionCount === 3) {
                repetitionDisplay = ' ‚ö†Ô∏è (3/5 Warning)';
                backgroundColor = '#f39c12'; // Orange warning
                textColor = 'black';
            } else if (repetitionCount === 4) {
                repetitionDisplay = ' üî• (4/5 DANGER!)';
                backgroundColor = '#e67e22'; // Dark orange danger
                textColor = 'white';
            } else if (repetitionCount >= 5) {
                repetitionDisplay = ' üíÄ (5/5 LOSS!)';
                backgroundColor = '#e74c3c'; // Red loss
                textColor = 'white';
            }
            
            moveItem.textContent = `${moveCount}. ${pieceSymbol} ${fromRow}-${fromCol} ‚Üí ${toRow}-${toCol}${captureSymbol}${repetitionDisplay}`;
            
            if (backgroundColor) {
                moveItem.style.backgroundColor = backgroundColor;
                moveItem.style.color = textColor;
                moveItem.style.fontWeight = 'bold';
                moveItem.style.padding = '5px';
                moveItem.style.borderRadius = '3px';
                moveItem.style.marginTop = '3px';
            }
            
            moveList.appendChild(moveItem);
            
            // Auto-scroll to bottom of movement list
            moveList.scrollTop = moveList.scrollHeight;
            
            // Return the repetition count so caller can use it
            return repetitionCount;
        }
        
        // Function to check and track repetition (called BEFORE recordMove)
        function checkRepetition(fromRow, fromCol, toRow, toCol, pieceType, isWhite, isCapture) {
            // Don't track captures
            if (isCapture) return 0;
            
            const playerPrefix = isWhite ? 'white' : 'black';
            
            // Create shuttle key - treats A‚ÜíB and B‚ÜíA as the same pattern
            const fromPos = `${fromRow}${fromCol}`;
            const toPos = `${toRow}${toCol}`;
            const sortedPositions = [fromPos, toPos].sort();
            const shuttleKey = `${playerPrefix}-${pieceType}-shuttle-${sortedPositions[0]}-${sortedPositions[1]}`;
            
            console.log(`Repetition Check: ${playerPrefix} ${pieceType} shuttle ${fromPos}‚Üî${toPos}`);
            
            // Count how many times THIS SHUTTLE PATTERN has been made (never resets!)
            const currentCount = moveRepetitions.get(shuttleKey) || 0;
            const repetitionCount = currentCount + 1;
            moveRepetitions.set(shuttleKey, repetitionCount);
            
            console.log(`Total shuttles for ${shuttleKey}: ${repetitionCount}/5`);
            
            // Check for five-fold repetition
            if (repetitionCount >= 5) {
                // Fifth shuttle - player loses!
                const losingPlayer = isWhite ? 'White' : 'Black';
                const winningPlayer = isWhite ? 'Black' : 'White';
                console.log(`FIVE-FOLD SHUTTLE REPETITION! ${losingPlayer} loses!`);
                // Delay game over slightly so move appears in list first
                setTimeout(() => {
                    showGameOver(winningPlayer, `${losingPlayer} lost by shuttling 5 times between ${sortedPositions[0]} and ${sortedPositions[1]}!`);
                }, 100);
            }
            
            // Update last move for this player (for tracking)
            const moveKey = `${playerPrefix}-${pieceType}-${fromPos}-${toPos}`;
            if (isWhite) {
                lastWhiteMove = moveKey;
            } else {
                lastBlackMove = moveKey;
            }
            
            console.log(`Updated last${playerPrefix === 'white' ? 'White' : 'Black'}Move to: ${moveKey}`);
            
            return repetitionCount;
        }
        
        // Function to clear move repetition tracking (for new games)
        function clearMoveRepetitions() {
            moveRepetitions.clear();
            lastWhiteMove = null;
            lastBlackMove = null;
            // Also remove any existing warning panels
            const existingWarning = document.getElementById('repetition-warning-panel');
            if (existingWarning) {
                existingWarning.remove();
            }
        }
        
        // Function to show repetition warning panel
        function showRepetitionWarning(isWhite, pieceType, fromRow, fromCol, toRow, toCol) {
            // Remove any existing warning first
            const existingWarning = document.getElementById('repetition-warning-panel');
            if (existingWarning) {
                existingWarning.remove();
            }
            
            const playerColor = isWhite ? 'WHITE' : 'BLACK';
            const playerColorHex = isWhite ? '#fff' : '#333';
            const pieceSymbol = pieceType === 'square' ? '‚ñ†' : 
                               pieceType === 'triangle' ? '‚ñ≤' : 
                               pieceType === 'rhombus' ? '‚óÜ' : 
                               pieceType === 'circle' ? '‚óè' : '‚¨°';
            
            // Create warning panel
            const warningPanel = document.createElement('div');
            warningPanel.id = 'repetition-warning-panel';
            warningPanel.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: linear-gradient(135deg, #e74c3c, #c0392b);
                color: white;
                padding: 20px 40px;
                border-radius: 15px;
                border: 3px solid #fff;
                box-shadow: 0 8px 30px rgba(231, 76, 60, 0.6);
                z-index: 1500;
                text-align: center;
                font-family: Arial, sans-serif;
                animation: warningPulse 1s ease-in-out infinite;
                min-width: 300px;
            `;
            
            warningPanel.innerHTML = `
                <div style="display: flex; align-items: center; gap: 15px;">
                    <div style="font-size: 3em;">‚ö†Ô∏è</div>
                    <div style="text-align: left;">
                        <div style="font-size: 1.4em; font-weight: bold; margin-bottom: 5px;">
                            REPETITION WARNING!
                        </div>
                        <div style="font-size: 1em; opacity: 0.95;">
                            <strong style="color: ${playerColorHex}; text-shadow: 1px 1px 2px rgba(0,0,0,0.5);">${playerColor}</strong> repeated:<br>
                            <strong>${pieceSymbol} ${fromRow}-${fromCol} ‚Üí ${toRow}-${toCol}</strong><br>
                            <span style="font-size: 1.2em; font-weight: bold;">ONE MORE TIME = LOSS!</span>
                        </div>
                    </div>
                    <div style="font-size: 3em;">‚ö†Ô∏è</div>
                </div>
            `;
            
            // Add pulsing animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes warningPulse {
                    0%, 100% { 
                        box-shadow: 0 8px 30px rgba(231, 76, 60, 0.6);
                        transform: translateX(-50%) scale(1);
                    }
                    50% { 
                        box-shadow: 0 8px 40px rgba(231, 76, 60, 0.9);
                        transform: translateX(-50%) scale(1.02);
                    }
                }
            `;
            document.head.appendChild(style);
            
            document.body.appendChild(warningPanel);
            
            // Auto-remove after 5 seconds with fade out
            setTimeout(() => {
                warningPanel.style.transition = 'opacity 1s, transform 1s';
                warningPanel.style.opacity = '0';
                warningPanel.style.transform = 'translateX(-50%) translateY(-20px)';
                setTimeout(() => {
                    if (warningPanel.parentElement) {
                        warningPanel.remove();
                    }
                }, 1000);
            }, 5000);
        }
        
        function clearMovementHistory() {
            moveCount = 0;
            document.getElementById('white-moves').innerHTML = '';
            document.getElementById('black-moves').innerHTML = '';
        }
        
        function clearCoordinateLabels() {
            // Hide the existing hex-coords spans without modifying their styling
            const existingCoords = document.querySelectorAll('.hex-coords');
            existingCoords.forEach(coord => {
                coord.style.display = 'none';
            });
            
            // Also remove any dynamically created coordinate labels
            const allCoordLabels = document.querySelectorAll('.coordinate-label');
            allCoordLabels.forEach(label => label.remove());
            
            coordinatesVisible = false;
        }
        
        // Coordinate visibility toggle
        let coordinatesVisible = false;
        
        function toggleCoordinates() {
            coordinatesVisible = !coordinatesVisible;
            
            // Toggle the existing hex-coords spans - show/hide without modifying their styling
            const existingCoords = document.querySelectorAll('.hex-coords');
            
            existingCoords.forEach(coord => {
                if (coordinatesVisible) {
                    coord.style.display = 'block';
                } else {
                    coord.style.display = 'none';
                }
            });
        }
        
        // Check and highlight pieces under threat
        function highlightThreatenedPieces() {
            // DISABLED - We only want to show attack highlights based on actual piece movement patterns
            // when dragging pieces, not a separate threat detection system
            return;
            
            /* ORIGINAL CODE COMMENTED OUT
            // Clear existing threat highlights
            document.querySelectorAll('.hexagon').forEach(hex => {
                hex.classList.remove('highlight-threat');
            });
            
            // Get all pieces on the board (including circles and hexgons)
            const allPieces = document.querySelectorAll('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
            
            allPieces.forEach(piece => {
                const pieceHex = piece.closest('.hexagon');
                if (!pieceHex) return;
                
                const pieceId = pieceHex.id;
                const [, pieceRow, pieceCol] = pieceId.match(/hex-(\d+)-(\d+)/);
                const isWhite = piece.classList.contains('white-piece') || 
                               piece.classList.contains('white-triangle') || 
                               piece.classList.contains('white-rhombus') ||
                               piece.classList.contains('white-circle') ||
                               piece.classList.contains('white-hexgon');
                
                // Check if this piece is under threat
                if (isPieceUnderThreat(parseInt(pieceRow), parseInt(pieceCol), isWhite)) {
                    // Only apply threat highlighting if the piece is not in a valid attack position
                    // (i.e., not already highlighted as red for attack)
                    if (!pieceHex.classList.contains('highlight-red')) {
                        pieceHex.classList.add('highlight-threat');
                    }
                }
            });
            */
        }
        
        // NEW: Highlight ALL pieces that are under attack on the board
        function highlightAllPiecesUnderAttack() {
            // Track which rhombuses were under attack before
            const previousRhombusesUnderAttack = new Set();
            document.querySelectorAll('.hexagon.highlight-rhombus-check').forEach(hex => {
                previousRhombusesUnderAttack.add(hex.id);
            });
            
            // Clear any previous "under attack" highlights (both regular and rhombus-check)
            document.querySelectorAll('.hexagon').forEach(hex => {
                hex.classList.remove('highlight-under-attack', 'highlight-rhombus-check');
            });
            
            // Track if any NEW rhombus comes under attack this turn
            let newRhombusUnderAttack = false;
            
            // Get all pieces on the board
            const allPieces = document.querySelectorAll('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
            
            allPieces.forEach(piece => {
                const pieceHex = piece.closest('.hexagon');
                if (!pieceHex) return;
                
                const pieceId = pieceHex.id;
                const [, row, col] = pieceId.match(/hex-(\d+)-(\d+)/);
                const isWhite = piece.classList.contains('white-piece') || 
                               piece.classList.contains('white-triangle') || 
                               piece.classList.contains('white-rhombus') ||
                               piece.classList.contains('white-circle') ||
                               piece.classList.contains('white-hexgon');
                
                // Check if this piece is under threat
                const underThreat = isPieceUnderThreat(parseInt(row), parseInt(col), isWhite);
                if (underThreat) {
                    // Special yellow highlight for RHOMBUS under attack (CHECK/DEADLOCK warning)
                    if (piece.classList.contains('rhombus-piece')) {
                        pieceHex.classList.add('highlight-rhombus-check');
                        // Check if this is a NEW rhombus under attack (wasn't before)
                        if (!previousRhombusesUnderAttack.has(pieceId)) {
                            newRhombusUnderAttack = true;
                        }
                    } else {
                        // Regular red highlight for other pieces
                        pieceHex.classList.add('highlight-under-attack');
                    }
                }
            });
            
            // Play lock sound if a rhombus just came under attack
            if (newRhombusUnderAttack) {
                playLockRhombusSound();
            }
        }
        
        // Clear previous last move highlights
        function clearLastMoveHighlight() {
            document.querySelectorAll('.hexagon').forEach(hex => {
                hex.classList.remove('highlight-last-move-from', 'highlight-last-move-to');
                // Note: We do NOT clear under-attack highlights here anymore
                // They persist across turns until pieces move or are captured
            });
        }
        
        // Highlight the last move (from and to hexagons)
        function highlightLastMove(fromHexId, toHexId) {
            // Clear any previous last move highlights
            clearLastMoveHighlight();
            
            // Only apply highlights if setting is enabled
            if (!window.gameSettings.showLastMove) {
                lastMoveFrom = fromHexId;
                lastMoveTo = toHexId;
                return;
            }
            
            // Apply new highlights
            const fromHex = document.getElementById(fromHexId);
            const toHex = document.getElementById(toHexId);
            
            if (fromHex) {
                fromHex.classList.add('highlight-last-move-from');
            }
            
            if (toHex) {
                toHex.classList.add('highlight-last-move-to');
            }
            
            // Store the last move for reference
            lastMoveFrom = fromHexId;
            lastMoveTo = toHexId;
        }
        
        // Check if a specific piece is under threat
        function isPieceUnderThreat(pieceRow, pieceCol, isWhite) {
            const targetId = `hex-${pieceRow}-${pieceCol}`;
            console.log(`üîç Checking if ${isWhite ? 'WHITE' : 'BLACK'} piece at ${targetId} is under threat...`);
            
            // Get all opponent pieces (including circles and hexgons)
            const opponentPieceTypes = isWhite ? 
                ['.square-piece:not(.white-piece)', '.triangle-piece:not(.white-triangle)', '.rhombus-piece:not(.white-rhombus)', '.circle-piece:not(.white-circle)', '.hexgon-piece:not(.white-hexgon)'] :
                ['.square-piece.white-piece', '.triangle-piece.white-triangle', '.rhombus-piece.white-rhombus', '.circle-piece.white-circle', '.hexgon-piece.white-hexgon'];
            
            // Check each opponent piece to see if it can attack this position
            for (let pieceType of opponentPieceTypes) {
                const opponentPieces = document.querySelectorAll(pieceType);
                for (let piece of opponentPieces) {
                    // Skip hidden pieces (used during simulation) and temp simulation pieces
                    if (piece.style.display === 'none' || piece.hasAttribute('data-temp-simulation')) {
                        continue;
                    }
                    
                    const pieceHex = piece.closest('.hexagon');
                    if (!pieceHex) continue;
                    
                    const pieceId = pieceHex.id;
                    const [, oppRow, oppCol] = pieceId.match(/hex-(\d+)-(\d+)/);
                    
                    // Use the actual movement pattern functions to check if this piece can attack
                    if (canPieceActuallyAttack(parseInt(oppRow), parseInt(oppCol), pieceRow, pieceCol, piece)) {
                        console.log(`‚ö†Ô∏è THREAT FOUND! Piece at ${targetId} IS under threat`);
                        return true;
                    }
                }
            }
            console.log(`‚úì No threat found for piece at ${targetId}`);
            return false;
        }
        
        // Check if a piece can actually attack using the real movement patterns
        function canPieceActuallyAttack(pieceRow, pieceCol, targetRow, targetCol, piece) {
            // Get the piece type and determine which movement function to use
            if (piece.classList.contains('square-piece')) {
                const canAttack = canSquareAttack(pieceRow, pieceCol, targetRow, targetCol);
                if (canAttack) {
                    console.log(`‚úÖ SQUARE at ${pieceRow}-${pieceCol} CAN attack ${targetRow}-${targetCol}`);
                }
                return canAttack;
            } else if (piece.classList.contains('triangle-piece')) {
                let canAttack;
                if (piece.classList.contains('white-triangle')) {
                    canAttack = canWhiteTriangleAttack(pieceRow, pieceCol, targetRow, targetCol, piece);
                } else {
                    canAttack = canBlackTriangleAttack(pieceRow, pieceCol, targetRow, targetCol, piece);
                }
                if (canAttack) {
                    const color = piece.classList.contains('white-triangle') ? 'WHITE' : 'BLACK';
                    console.log(`‚úÖ ${color} TRIANGLE at ${pieceRow}-${pieceCol} CAN attack ${targetRow}-${targetCol}`);
                }
                return canAttack;
            } else if (piece.classList.contains('rhombus-piece')) {
                const canAttack = canRhombusAttack(pieceRow, pieceCol, targetRow, targetCol);
                if (canAttack) {
                    console.log(`‚úÖ RHOMBUS at ${pieceRow}-${pieceCol} CAN attack ${targetRow}-${targetCol}`);
                }
                return canAttack;
            } else if (piece.classList.contains('circle-piece')) {
                const canAttack = canCircleAttack(pieceRow, pieceCol, targetRow, targetCol, piece);
                if (canAttack) {
                    console.log(`‚úÖ CIRCLE at ${pieceRow}-${pieceCol} CAN attack ${targetRow}-${targetCol}`);
                }
                return canAttack;
            } else if (piece.classList.contains('hexgon-piece')) {
                const canAttack = canHexgonAttack(pieceRow, pieceCol, targetRow, targetCol, piece);
                if (canAttack) {
                    const color = piece.classList.contains('white-hexgon') ? 'WHITE' : 'BLACK';
                    console.log(`‚úÖ ${color} HEXAGON at ${pieceRow}-${pieceCol} CAN attack ${targetRow}-${targetCol}`);
                }
                return canAttack;
            }
            return false;
        }
        
        // Check if a square can attack a position
        function canSquareAttack(pieceRow, pieceCol, targetRow, targetCol) {
            let offsets = [];
            
            if (pieceRow === 0) {
                // Row 0 (even, shift-down): down-left, down-right, up-right, up-left
                offsets = [[1, 0], [1, 1], [-1, 1], [-1, 0]];
            } else if (pieceRow === 1) {
                // Row 1 (odd, no shift): down-left, down-right, up-left, up-right
                offsets = [[1, 0], [1, 1], [-1, -1], [-1, 0]];
            } else if (pieceRow === 2) {
                // Row 2 (even, shift-down): down-left, down-right, up-left, up-right
                offsets = [[1, 0], [1, 1], [-1, -1], [-1, 0]];
            } else if (pieceRow === 3) {
                // Row 3 (odd, no shift): down-left, down-right, up-right, up-left
                offsets = [[1, -1], [1, 0], [-1, 0], [-1, -1]];
            } else if (pieceRow === 4) {
                // Row 4 (even, shift-down): up-left, up-right, down-left, down-right
                offsets = [[-1, 0], [-1, 1], [1, -1], [1, 0]];
            } else if (pieceRow === 5) {
                // Row 5 (odd, no shift): down-left, down-right, up-left, up-right
                offsets = [[1, 0], [1, 1], [-1, -1], [-1, 0]];
            } else if (pieceRow === 6) {
                // Row 6 (even, shift-down): down-left, down-right, up-right, up-left
                offsets = [[1, 0], [1, 1], [-1, 1], [-1, 0]];
            }
            
            for (let [rowOffset, colOffset] of offsets) {
                if (pieceRow + rowOffset === targetRow && pieceCol + colOffset === targetCol) {
                    return true;
                }
            }
            return false;
        }
        
        // Check if a white triangle can attack a position (accounts for rotation)
        function canWhiteTriangleAttack(pieceRow, pieceCol, targetRow, targetCol, piece) {
            // Get the triangle's current orientation from triangleOrientations
            const triangleHex = piece ? piece.closest('.hexagon') : document.getElementById(`hex-${pieceRow}-${pieceCol}`);
            const hexId = triangleHex ? triangleHex.id : `hex-${pieceRow}-${pieceCol}`;
            const orientation = triangleOrientations.get(hexId) || 0;
            
            // Use the rotation-aware function to get attack OFFSETS (relative coordinates)
            const offsets = getRotatedTriangleTargets(pieceRow, pieceCol, orientation, true);
            
            // Check if target position is in the attack pattern (convert offsets to absolute coordinates)
            for (let [dr, dc] of offsets) {
                if (pieceRow + dr === targetRow && pieceCol + dc === targetCol) {
                    return true;
                }
            }
            return false;
        }
        
        // Check if a black triangle can attack a position (accounts for rotation)
        // Check if a black triangle can attack a position (accounts for rotation)
        function canBlackTriangleAttack(pieceRow, pieceCol, targetRow, targetCol, piece) {
            // Get the triangle's current orientation from triangleOrientations
            const triangleHex = piece ? piece.closest('.hexagon') : document.getElementById(`hex-${pieceRow}-${pieceCol}`);
            const hexId = triangleHex ? triangleHex.id : `hex-${pieceRow}-${pieceCol}`;
            const orientation = triangleOrientations.get(hexId) || 0;
            
            // Use the rotation-aware function to get attack OFFSETS (relative coordinates)
            const offsets = getRotatedTriangleTargets(pieceRow, pieceCol, orientation, false);
            
            // Check if target position is in the attack pattern (convert offsets to absolute coordinates)
            for (let [dr, dc] of offsets) {
                if (pieceRow + dr === targetRow && pieceCol + dc === targetCol) {
                    return true;
                }
            }
            return false;
        }
        
        // Helper function to rotate offsets by angle (in degrees, 60-degree increments for hex grid)
        function rotateOffsets(offsets, angleDegrees) {
            // For now, return original offsets (triangle rotation is visual only for threat detection)
            // This is a simplified version - full hex rotation logic would be complex
            return offsets;
        }
        
        // Check if a circle can attack a position (zone-based perimetric attack)
        function canCircleAttack(pieceRow, pieceCol, targetRow, targetCol, piece) {
            // Circles attack ANY opponent on their perimeter ring (not just adjacent hexes)
            const coord = `${pieceRow}-${pieceCol}`;
            const targetCoord = `${targetRow}-${targetCol}`;
            
            // Check if circle is in dead zone - cannot attack from dead zone
            if (circleDeadZone.has(coord)) {
                return false;
            }
            
            // Determine which zone the circle is in
            let zoneSet = null;
            let zoneOrder = null;
            
            if (circleInnerZone.has(coord)) {
                zoneSet = circleInnerZone;
                zoneOrder = circleInnerOrder;
            } else if (circleMiddleZone.has(coord)) {
                zoneSet = circleMiddleZone;
                zoneOrder = circleMiddleOrder;
            } else if (circleOuterZone.has(coord)) {
                zoneSet = circleOuterZone;
                zoneOrder = circleOuterOrder;
            } else {
                return false; // Not in any valid zone
            }
            
            // Check if target is in the same zone (perimeter ring)
            if (!zoneSet.has(targetCoord)) {
                return false; // Target not on same perimeter ring
            }
            
            // Circle can attack ANY position on its perimeter ring
            // Need to check if there's a clear path (no pieces blocking between circle and target)
            const startIdx = zoneOrder.indexOf(coord);
            const targetIdx = zoneOrder.indexOf(targetCoord);
            
            if (startIdx === -1 || targetIdx === -1) {
                return false;
            }
            
            const len = zoneOrder.length;
            // circle attack tracing removed
            
            // Check clockwise direction
            let clockwiseBlocked = false;
            let clockwiseSteps = (targetIdx - startIdx + len) % len;
            const clockwiseBlockedHexes = [];
            for (let step = 1; step < clockwiseSteps; step++) {
                const idx = (startIdx + step) % len;
                const [r, c] = zoneOrder[idx].split('-');
                const hex = document.getElementById(`hex-${r}-${c}`);
                if (hex && hex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece')) {
                    clockwiseBlocked = true;
                    clockwiseBlockedHexes.push(`${r}-${c}`);
                    break;
                }
            }
            // circle attack tracing removed
            
            // Check counter-clockwise direction
            let counterClockwiseBlocked = false;
            let counterClockwiseSteps = (startIdx - targetIdx + len) % len;
            const counterBlockedHexes = [];
            for (let step = 1; step < counterClockwiseSteps; step++) {
                const idx = (startIdx - step + len) % len;
                const [r, c] = zoneOrder[idx].split('-');
                const hex = document.getElementById(`hex-${r}-${c}`);
                if (hex && hex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece')) {
                    counterClockwiseBlocked = true;
                    counterBlockedHexes.push(`${r}-${c}`);
                    break;
                }
            }
            // circle attack tracing removed
            
            // Can attack if at least one direction is clear
            return !clockwiseBlocked || !counterClockwiseBlocked;
        }
        
        // Check if a hexgon can attack a position (accounts for rotation)
        function canHexgonAttack(pieceRow, pieceCol, targetRow, targetCol, piece) {
            // Get the hexgon's current orientation from hexgonOrientations
            const hexgonHex = piece ? piece.closest('.hexagon') : document.getElementById(`hex-${pieceRow}-${pieceCol}`);
            const hexId = hexgonHex ? hexgonHex.id : `hex-${pieceRow}-${pieceCol}`;
            const orientation = hexgonOrientations.get(hexId) || 0;
            
            // Determine if white or black (needed for getRotatedHexgonTargets)
            const isWhite = piece ? 
                (piece.classList.contains('white-hexgon')) : 
                (hexgonHex && hexgonHex.querySelector('.white-hexgon') !== null);
            
            // Use the rotation-aware function to get attack targets
            const targets = getRotatedHexgonTargets(pieceRow, pieceCol, orientation, isWhite);
            
            // Check if target is in the attack list
            for (const [moveRow, moveCol] of targets) {
                if (moveRow === targetRow && moveCol === targetCol) {
                    console.log(`‚úÖ HEXAGON at ${pieceRow}-${pieceCol} CAN attack ${targetRow}-${targetCol} (orientation ${orientation})`);
                    return true;
                }
            }
            return false;
        }
        
        // Check if a rhombus can attack a position (uses hardcoded patterns)
        function canRhombusAttack(pieceRow, pieceCol, targetRow, targetCol) {
            // RULE: Rhombuses cannot attack other rhombuses (cannot check/lock each other)
            const targetHex = document.getElementById(`hex-${targetRow}-${targetCol}`);
            if (targetHex) {
                const targetPiece = targetHex.querySelector('.rhombus-piece');
                if (targetPiece) {
                    // Target is a rhombus - cannot attack
                    return false;
                }
            }
            
            // Use the actual hardcoded rhombus movement patterns
            const moves = getRhombusMoves(pieceRow, pieceCol);
            
            // Define zones for diagonal ability detection
            const deadZone = new Set(["3-3", "3-4", "3-5"]);
            const innerPerimeter = new Set(["4-2", "4-3", "4-4", "4-5", "2-2", "2-3", "2-4", "2-5"]);
            const currentPos = `${pieceRow}-${pieceCol}`;
            const targetPos = `${targetRow}-${targetCol}`;
            
            // Check if target is in the move list
            for (const [moveRow, moveCol] of moves) {
                if (moveRow === targetRow && moveCol === targetCol) {
                    // RULE: Diagonal moves can only be used for MOVEMENT, not ATTACK
                    const isDiagonalMove = (deadZone.has(currentPos) && innerPerimeter.has(targetPos)) || 
                                          (innerPerimeter.has(currentPos) && deadZone.has(targetPos));
                    
                    // If it's a diagonal move, it cannot be used for attack
                    if (isDiagonalMove) {
                        return false;
                    }
                    
                    return true;
                }
            }
            return false;
        }

        // Helper function to check if a position is vulnerable to attack
        function isPositionVulnerable(row, col, isWhite, movingPieceType = null) {
            // Get all opponent pieces (INCLUDING CIRCLES AND HEXAGONS!)
            const opponentPieceTypes = isWhite ? 
                ['.square-piece:not(.white-piece)', '.triangle-piece:not(.white-triangle)', '.rhombus-piece:not(.white-rhombus)', '.circle-piece:not(.white-circle)', '.hexgon-piece:not(.white-hexgon)'] :
                ['.square-piece.white-piece', '.triangle-piece.white-triangle', '.rhombus-piece.white-rhombus', '.circle-piece.white-circle', '.hexgon-piece.white-hexgon'];
            
            // Check each opponent piece to see if it can attack this position
            for (let pieceType of opponentPieceTypes) {
                const opponentPieces = document.querySelectorAll(pieceType);
                for (let piece of opponentPieces) {
                    // SPECIAL CASE: If we're checking for a rhombus moving to this position,
                    // and the opponent piece is also a rhombus, skip it (rhombuses can't attack each other)
                    if (movingPieceType === 'rhombus' && piece.classList.contains('rhombus-piece')) {
                        continue; // Skip rhombus-on-rhombus check
                    }
                    
                    const pieceHex = piece.closest('.hexagon');
                    if (!pieceHex) continue;
                    
                    const pieceId = pieceHex.id;
                    const [, pieceRow, pieceCol] = pieceId.match(/hex-(\d+)-(\d+)/);
                    
                    // Check if this opponent piece can attack the target position
                    if (canPieceActuallyAttack(parseInt(pieceRow), parseInt(pieceCol), row, col, piece)) {
                        return true;
                    }
                }
            }
            return false;
        }
        

        // Helper function to highlight movement patterns
        function highlightMovement(targetHex, isWhite) {
            if (!targetHex) return;
            
            // Check if target hex has a friendly piece
            const friendlyPieceTypes = isWhite 
                ? ['.square-piece.white-piece', '.triangle-piece.white-triangle', '.rhombus-piece.white-rhombus', '.circle-piece.white-circle', '.hexgon-piece.white-hexgon'] 
                : ['.square-piece:not(.white-piece)', '.triangle-piece:not(.white-triangle)', '.rhombus-piece:not(.white-rhombus)', '.circle-piece:not(.white-circle)', '.hexgon-piece:not(.white-hexgon)'];
            let hasFriendlyPiece = false;
            friendlyPieceTypes.forEach(selector => {
                if (targetHex.querySelector(selector)) {
                    hasFriendlyPiece = true;
                }
            });
            
            // Check if target hex has an opponent piece
            const opponentPieceTypes = isWhite 
                ? ['.square-piece:not(.white-piece)', '.triangle-piece:not(.white-triangle)', '.rhombus-piece:not(.white-rhombus)', '.circle-piece:not(.white-circle)', '.hexgon-piece:not(.white-hexgon)'] 
                : ['.square-piece.white-piece', '.triangle-piece.white-triangle', '.rhombus-piece.white-rhombus', '.circle-piece.white-circle', '.hexgon-piece.white-hexgon'];
            let hasOpponentPiece = false;
            opponentPieceTypes.forEach(selector => {
                if (targetHex.querySelector(selector)) {
                    hasOpponentPiece = true;
                }
            });
            
            // Highlight in red if opponent piece, green if empty
            if (hasOpponentPiece) {
                targetHex.classList.add('highlight-red');
            } else if (!hasFriendlyPiece) {
                targetHex.classList.add('highlight-green');
            }
        }

        // Function to show movement pattern for white triangles (opposite of black triangles)
        function showWhiteTriangleMovementPattern(centerRow, centerCol) {
            // Clear any existing highlights (but keep threat highlights)
            document.querySelectorAll('.hexagon').forEach(hex => {
                hex.classList.remove('highlight-green', 'highlight-red', 'highlight-danger', 'highlight-diagonal', 'highlight-gray');
            });

            // White triangle movement pattern - opposite diagonal from black triangles
            let offsets;
            
            if (centerRow === 0) {
                // Row 0 - white triangle movement pattern
                offsets = [
                    [1, 1],  // down-right
                    [-1, 1], // up-right (off-board)
                    [0, 1]   // right
                ];
            } else if (centerRow === 1) {
                // Row 1 - white triangle movement pattern
                offsets = [
                    [1, 1],  // down-right
                    [-1, 0], // up-right
                    [0, 1]   // right
                ];
            } else if (centerRow === 2) {
                // Row 2 - white triangle movement pattern
                offsets = [
                    [1, 1],  // down-right
                    [-1, 0], // up-right
                    [0, 1]   // right
                ];
            } else if (centerRow === 3) {
                // Row 3 - white triangle movement pattern
                offsets = [
                    [1, 0],  // down: 3-2 + [1,0] = 4-2
                    [0, 1],  // right: 3-2 + [0,1] = 3-3
                    [-1, 0]  // up-left: 3-2 + [-1,0] = 2-2
                ];
            } else if (centerRow === 4) {
                // Row 4 - white triangle movement pattern
                offsets = [
                    [1, 0],  // down-right
                    [0, 1],  // right
                    [-1, 1]  // up-right
                ];
            } else if (centerRow === 5) {
                // Row 5 - white triangle movement pattern
                // For 5-0 ‚Üí 6-0, 5-1, 4-1
                offsets = [
                    [1, 0],  // down-right: 5-0 + [1,0] = 6-0
                    [0, 1],  // right: 5-0 + [0,1] = 5-1
                    [-1, 1]  // up-right: 5-0 + [-1,1] = 4-1
                ];
            } else if (centerRow === 6) {
                // Row 6 - white triangle movement pattern
                offsets = [
                    [1, 1],  // down-right (off-board)
                    [0, 1],  // right
                    [-1, 1]  // up-right
                ];
            }

            // Highlight the hexes in the white triangle pattern
            offsets.forEach(([rowOffset, colOffset]) => {
                const targetRow = centerRow + rowOffset;
                const targetCol = centerCol + colOffset;
                const targetHex = document.getElementById(`hex-${targetRow}-${targetCol}`);
                
                // Skip if target hex doesn't exist (off the board)
                if (!targetHex) return;
                
                    // Check if target hex has a friendly piece
                const friendlyPieceTypes = ['.square-piece.white-piece', '.triangle-piece.white-triangle', '.rhombus-piece.white-rhombus', '.circle-piece.white-circle', '.hexgon-piece.white-hexgon'];
                    let hasFriendlyPiece = false;
                    friendlyPieceTypes.forEach(selector => {
                        if (targetHex.querySelector(selector)) {
                            hasFriendlyPiece = true;
                        }
                    });
                    
                // Check if target hex has an opponent piece
                const opponentPieceTypes = ['.square-piece:not(.white-piece)', '.triangle-piece:not(.white-triangle)', '.rhombus-piece:not(.white-rhombus)', '.circle-piece:not(.white-circle)', '.hexgon-piece:not(.white-hexgon)'];
                let hasOpponentPiece = false;
                opponentPieceTypes.forEach(selector => {
                    if (targetHex.querySelector(selector)) {
                        hasOpponentPiece = true;
                    }
                });
                
                // Highlight in red if opponent piece, green if empty, danger if vulnerable
                if (hasOpponentPiece) {
                        targetHex.classList.add('highlight-red');
                } else if (!hasFriendlyPiece) {
                    // Check if this position would be vulnerable to attack
                    if (isPositionVulnerable(targetRow, targetCol, true)) {
                        targetHex.classList.add('highlight-danger');
                    } else {
                        targetHex.classList.add('highlight-green');
                    }
                }
            });
        }
        function showTriangleMovementPattern(centerRow, centerCol) {
            console.log(`üéØ showTriangleMovementPattern called: centerRow=${centerRow}, centerCol=${centerCol}`);
            
            // Clear any existing highlights (but keep threat highlights)
            document.querySelectorAll('.hexagon').forEach(hex => {
                hex.classList.remove('highlight-green', 'highlight-red', 'highlight-danger', 'highlight-diagonal', 'highlight-gray');
            });

            // Get triangle orientation for rotation-aware movement
            const hexId = `hex-${centerRow}-${centerCol}`;
            const orientation = getTriangleOrientation(hexId);
            console.log(`üéØ Triangle orientation: ${orientation}`);
            
            // Determine if it's white or black triangle
            const triangle = document.querySelector(`#${hexId} .triangle-piece`);
            const isWhite = triangle && (triangle.classList.contains('white-triangle') || triangle.classList.contains('white-piece'));
            console.log(`üéØ Triangle isWhite: ${isWhite}`);
            
            // Get rotation-aware movement pattern
            const offsets = getRotatedTriangleTargets(centerRow, centerCol, orientation, isWhite);
            console.log(`üéØ Rotated offsets:`, offsets);

            // Get friendly piece types based on triangle color
            let friendlyPieceTypes;
            const centerHex = document.getElementById(`hex-${centerRow}-${centerCol}`);
            const centerPiece = centerHex.querySelector('.triangle-piece');
            
            if (centerPiece && centerPiece.classList.contains('white-triangle')) {
                // White triangle - friendly with white squares and other white triangles
                friendlyPieceTypes = ['.square-piece.white-piece', '.triangle-piece.white-triangle', '.rhombus-piece.white-rhombus', '.circle-piece.white-circle', '.hexgon-piece.white-hexgon'];
            } else {
                // Black triangle - friendly with black squares and other black triangles
                friendlyPieceTypes = ['.square-piece:not(.white-piece)', '.triangle-piece:not(.white-triangle)', '.rhombus-piece:not(.white-rhombus)', '.circle-piece:not(.white-circle)', '.hexgon-piece:not(.white-hexgon)'];
            }

            // Highlight the hexes in the triangle pattern
            console.log(`üéØ Highlighting ${offsets.length} movement targets:`, offsets);
            offsets.forEach(([rowOffset, colOffset]) => {
                // Apply offsets to get target coordinates
                const targetRow = centerRow + rowOffset;
                const targetCol = centerCol + colOffset;
                const targetHexId = `hex-${targetRow}-${targetCol}`;
                const targetHex = document.getElementById(targetHexId);
                
                console.log(`üéØ Processing target: ${targetHexId} (from ${centerRow}-${centerCol} + [${rowOffset},${colOffset}]), element found:`, !!targetHex);
                
                if (targetHex) {
                    // Check if target hex has a friendly piece
                    let hasFriendlyPiece = false;
                    friendlyPieceTypes.forEach(selector => {
                        if (targetHex.querySelector(selector)) {
                            hasFriendlyPiece = true;
                        }
                    });
                    
                    // Check if target hex has an opponent piece
                    const isWhite = centerPiece && centerPiece.classList.contains('white-triangle');
                    const opponentPieceTypes = isWhite ? 
                        ['.square-piece:not(.white-piece)', '.triangle-piece:not(.white-triangle)', '.rhombus-piece:not(.white-rhombus)'] :
                        ['.square-piece.white-piece', '.triangle-piece.white-triangle', '.rhombus-piece.white-rhombus'];
                    let hasOpponentPiece = false;
                    opponentPieceTypes.forEach(selector => {
                        if (targetHex.querySelector(selector)) {
                            hasOpponentPiece = true;
                        }
                    });
                    
                    console.log(`üéØ Target ${targetHexId}: hasFriendly=${hasFriendlyPiece}, hasOpponent=${hasOpponentPiece}`);
                    
                    // Highlight in red if opponent piece, green if empty (skip friendly pieces)
                    if (hasOpponentPiece) {
                        targetHex.classList.add('highlight-red');
                        console.log(`üéØ Added highlight-red to ${targetHexId}`);
                    } else if (!hasFriendlyPiece) {
                        targetHex.classList.add('highlight-green');
                        console.log(`üéØ Added highlight-green to ${targetHexId}`);
                    }
                } else {
                    console.log(`‚ö†Ô∏è Target hex not found: ${targetHexId}`);
                }
            });
        }
        
        // Triangle rotation pattern functions
        function getTriangleOrientation(hexId) {
            return triangleOrientations.get(hexId) || 0; // Default to 0 (0¬∞)
        }
        
        function setTriangleOrientation(hexId, orientation) {
            triangleOrientations.set(hexId, orientation % 6); // Keep within 0-5
        }
        
        // Hexgon rotation pattern functions
        function getHexgonOrientation(hexId) {
            return hexgonOrientations.get(hexId) || 0; // Default to 0 (0¬∞)
        }
        
        function setHexgonOrientation(hexId, orientation) {
            hexgonOrientations.set(hexId, orientation % 6); // Keep within 0-5
        }
        
        function rotateTriangleLeft(hexId) {
            console.log('Rotating triangle left:', hexId);
            
            // Check if this piece is the active piece for this turn
            console.log('Rotation check - currentTurnPiece:', currentTurnPiece);
            console.log('Rotation check - currentTurnPiece.id:', currentTurnPiece ? currentTurnPiece.id : 'null');
            console.log('Rotation check - hexId:', hexId);
            if (currentTurnPiece && currentTurnPiece.id !== hexId) {
                alert('You can only move or rotate one piece per turn!');
                return;
            }
            
            // Check if piece has already attacked this turn
            const actions = pieceActions.get(hexId) || {moved: false, attacked: false, rotated: false};
            if (actions.attacked) {
                alert('Cannot rotate after attacking!');
                return;
            }
            
            const current = getTriangleOrientation(hexId);
            console.log('Current orientation:', current);
            
            // Handle orientation cycling properly for 6-angle cycle
            let newOrientation = current + 1;
            if (newOrientation >= 6) {
                newOrientation = 0; // Wrap to first angle (30¬∞)
            }
            setTriangleOrientation(hexId, newOrientation);
            updateTriangleVisual(hexId);
            
            console.log('New orientation:', newOrientation);
            const angleMap = [270, 330, 30, 90, 150, 210];
            const rotation = angleMap[newOrientation % 6];
            console.log('Rotation degrees:', rotation);
            
            // Mark as rotated (but don't end turn)
            actions.rotated = true;
            pieceActions.set(hexId, actions);
            
            // Update movement pattern display to show new rotated pattern
            const [, fromRow, fromCol] = hexId.match(/hex-(\d+)-(\d+)/);
            console.log('üîÑ Updating movement pattern for rotated triangle at:', fromRow, fromCol);
            showTriangleMovementPattern(parseInt(fromRow), parseInt(fromCol));
            
            // Check for rhombus deadlock after rotation (rotation might create checkmate)
            if (!gameOver) {
                checkRhombusDeadlock();
            }
            
            // Don't end turn - allow free rotation
            console.log('Rotation complete, turn continues');
        }
        
        function rotateTriangleRight(hexId) {
            console.log('Rotating triangle right:', hexId);
            
            // Check if this piece is the active piece for this turn
            console.log('Rotation check - currentTurnPiece:', currentTurnPiece);
            console.log('Rotation check - currentTurnPiece.id:', currentTurnPiece ? currentTurnPiece.id : 'null');
            console.log('Rotation check - hexId:', hexId);
            if (currentTurnPiece && currentTurnPiece.id !== hexId) {
                alert('You can only move or rotate one piece per turn!');
                return;
            }
            
            // Check if piece has already attacked this turn
            const actions = pieceActions.get(hexId) || {moved: false, attacked: false, rotated: false};
            if (actions.attacked) {
                alert('Cannot rotate after attacking!');
                return;
            }
            
            const current = getTriangleOrientation(hexId);
            console.log('Current orientation:', current);
            
            // Handle negative orientation properly for 6-angle cycle
            let newOrientation = current - 1;
            if (newOrientation < 0) {
                newOrientation = 5; // Wrap to last angle (330¬∞)
            }
            setTriangleOrientation(hexId, newOrientation);
            updateTriangleVisual(hexId);
            
            console.log('New orientation:', newOrientation);
            const angleMap = [270, 330, 30, 90, 150, 210];
            const rotation = angleMap[newOrientation % 6];
            console.log('Rotation degrees:', rotation);
            
            // Mark as rotated (but don't end turn)
            actions.rotated = true;
            pieceActions.set(hexId, actions);
            
            // Update movement pattern display to show new rotated pattern
            const [, fromRow, fromCol] = hexId.match(/hex-(\d+)-(\d+)/);
            console.log('üîÑ Updating movement pattern for rotated triangle at:', fromRow, fromCol);
            showTriangleMovementPattern(parseInt(fromRow), parseInt(fromCol));
            
            // Check for rhombus deadlock after rotation (rotation might create checkmate)
            if (!gameOver) {
                checkRhombusDeadlock();
            }
            
            // Don't end turn - allow free rotation
            console.log('Rotation complete, turn continues');
        }
        
        function updateTriangleVisual(hexId) {
            console.log('Updating triangle visual for:', hexId);
            const triangle = document.querySelector(`#${hexId} .triangle-piece`);
            console.log('Triangle element found:', triangle);
            if (triangle) {
                const orientation = getTriangleOrientation(hexId);
                // Map orientations to specific angles: 270¬∞, 330¬∞, 30¬∞, 90¬∞, 150¬∞, 210¬∞
                // Shifted by 2 positions to match visual appearance
                const angleMap = [270, 330, 30, 90, 150, 210];
                const rotation = angleMap[orientation % 6]; // Cycle through the 6 angles
                console.log('üî∫ Triangle rotation:', {
                    hexId,
                    orientation,
                    rotation,
                    angleMap
                });
                triangle.style.transform = `translate(-50%, -50%) rotate(${rotation}deg)`;
                console.log('Triangle transform set to:', triangle.style.transform);
            } else {
                console.log('No triangle element found for:', hexId);
            }
        }
        
        function rotateHexgonLeft(hexId) {
            console.log('Rotating hexgon left:', hexId);
            
            // Check if this piece is the active piece for this turn
            console.log('Rotation check - currentTurnPiece:', currentTurnPiece);
            console.log('Rotation check - currentTurnPiece.id:', currentTurnPiece ? currentTurnPiece.id : 'null');
            console.log('Rotation check - hexId:', hexId);
            if (currentTurnPiece && currentTurnPiece.id !== hexId) {
                alert('You can only move or rotate one piece per turn!');
                return;
            }
            
            // Check if piece has already attacked this turn
            const actions = pieceActions.get(hexId) || {moved: false, attacked: false, rotated: false};
            if (actions.attacked) {
                alert('Cannot rotate after attacking!');
                return;
            }
            
            const current = getHexgonOrientation(hexId);
            console.log('Current orientation:', current);
            
            // Hexagons only use orientations 0, 2, 4 (120-degree rotations)
            let newOrientation;
            if (current === 0) newOrientation = 2;
            else if (current === 2) newOrientation = 4;
            else newOrientation = 0; // 4 -> 0 or any other -> 0
            
            setHexgonOrientation(hexId, newOrientation);
            updateHexgonVisual(hexId);
            
            // Mark as rotated to track turn actions
            const actions2 = pieceActions.get(hexId) || {moved: false, attacked: false, rotated: false};
            actions2.rotated = true;
            pieceActions.set(hexId, actions2);
            
            // Update movement pattern to show new rotation
            const [, row, col] = hexId.match(/hex-(\d+)-(\d+)/);
            showHexgonMovementPattern(parseInt(row), parseInt(col));
            
            console.log('New orientation:', newOrientation);
            const angleMap = [0, 60, 120, 180, 240, 300];
            const rotation = angleMap[newOrientation % 6];
            console.log('Rotation degrees:', rotation);
            
            // Check for rhombus deadlock after rotation (rotation might create checkmate)
            if (!gameOver) {
                checkRhombusDeadlock();
            }
            
            // Don't end turn - allow free rotation
            console.log('Rotation complete, turn continues');
        }
        
        function rotateHexgonRight(hexId) {
            console.log('Rotating hexgon right:', hexId);
            
            // Check if this piece is the active piece for this turn
            console.log('Rotation check - currentTurnPiece:', currentTurnPiece);
            console.log('Rotation check - currentTurnPiece.id:', currentTurnPiece ? currentTurnPiece.id : 'null');
            console.log('Rotation check - hexId:', hexId);
            if (currentTurnPiece && currentTurnPiece.id !== hexId) {
                alert('You can only move or rotate one piece per turn!');
                return;
            }
            
            // Check if piece has already attacked this turn
            const actions = pieceActions.get(hexId) || {moved: false, attacked: false, rotated: false};
            if (actions.attacked) {
                alert('Cannot rotate after attacking!');
                return;
            }
            
            const current = getHexgonOrientation(hexId);
            console.log('Current orientation:', current);
            
            // Hexagons only use orientations 0, 2, 4 (120-degree rotations)
            let newOrientation;
            if (current === 0) newOrientation = 4;
            else if (current === 4) newOrientation = 2;
            else newOrientation = 0; // 2 -> 0 or any other -> 0
            
            setHexgonOrientation(hexId, newOrientation);
            updateHexgonVisual(hexId);
            
            // Mark as rotated to track turn actions
            const actions2 = pieceActions.get(hexId) || {moved: false, attacked: false, rotated: false};
            actions2.rotated = true;
            pieceActions.set(hexId, actions2);
            
            // Update movement pattern to show new rotation
            const [, row, col] = hexId.match(/hex-(\d+)-(\d+)/);
            showHexgonMovementPattern(parseInt(row), parseInt(col));
            
            console.log('New orientation:', newOrientation);
            const angleMap = [0, 60, 120, 180, 240, 300];
            const rotation = angleMap[newOrientation % 6];
            console.log('Rotation degrees:', rotation);
            
            // Check for rhombus deadlock after rotation (rotation might create checkmate)
            if (!gameOver) {
                checkRhombusDeadlock();
            }
            
            // Don't end turn - allow free rotation
            console.log('Rotation complete, turn continues');
        }
        
        function updateHexgonVisual(hexId) {
            console.log('Updating hexgon visual for:', hexId);
            const hexgon = document.querySelector(`#${hexId} .hexgon-piece`);
            console.log('Hexgon element found:', hexgon);
            if (hexgon) {
                const orientation = getHexgonOrientation(hexId);
                // Map orientations to specific angles: 0¬∞, 60¬∞, 120¬∞, 180¬∞, 240¬∞, 300¬∞
                // Add base 90¬∞ rotation to match other pieces
                const angleMap = [90, 150, 210, 270, 330, 30];
                const rotation = angleMap[orientation % 6]; // Cycle through the 6 angles
                console.log('‚¨° Hexgon rotation:', {
                    hexId,
                    orientation,
                    rotation,
                    angleMap
                });
                hexgon.style.transform = `translate(-50%, -50%) rotate(${rotation}deg)`;
                console.log('Hexgon transform set to:', hexgon.style.transform);
            } else {
                console.log('No hexgon element found for:', hexId);
            }
        }
        
        function getRotatedTrianglePattern(centerRow, centerCol, orientation) {
            // Get base pattern for the position
            const basePattern = getBaseTrianglePattern(centerRow, centerCol);
            if (!basePattern) return [];
            
            // Rotate each offset by orientation * 60 degrees
            return basePattern.map(offset => rotateOffset(offset, orientation));
        }
        
        function rotateOffset(offset, orientation) {
            const [row, col] = offset;
            const angle = orientation * 60 * Math.PI / 180; // Convert to radians
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            
            // Rotate the offset vector
            const newRow = Math.round(row * cos - col * sin);
            const newCol = Math.round(row * sin + col * cos);
            
            return [newRow, newCol];
        }
        
        function getBaseTrianglePattern(centerRow, centerCol) {
            // This will contain the base movement patterns for each position
            // We'll populate this with the existing triangle patterns
            const patterns = {
                // Row 0 patterns
                '0-0': [[1, 0], [0, 1]],
                '0-1': [[1, 0], [1, 1], [0, 1]],
                '0-2': [[1, 0], [1, 1], [0, 1], [0, 2]],
                '0-3': [[1, 1], [1, 2], [0, 1], [0, 2]],
                '0-4': [[1, 1], [1, 2], [0, 2]],
                '0-5': [[1, 2], [0, 2]],
                '0-6': [[1, 2]],
                
                // Row 1 patterns
                '1-0': [[1, 0], [0, 1], [-1, 0]],
                '1-1': [[1, 0], [1, 1], [0, 1], [-1, 0]],
                '1-2': [[1, 0], [1, 1], [0, 1], [0, 2], [-1, 0]],
                '1-3': [[1, 1], [1, 2], [0, 1], [0, 2], [-1, 1]],
                '1-4': [[1, 1], [1, 2], [0, 2], [-1, 1]],
                '1-5': [[1, 2], [0, 2], [-1, 1]],
                '1-6': [[1, 2], [-1, 1]],
                
                // Row 2 patterns
                '2-0': [[1, 0], [0, 1], [-1, 0], [-1, 1]],
                '2-1': [[1, 0], [1, 1], [0, 1], [-1, 0], [-1, 1]],
                '2-2': [[1, 0], [1, 1], [0, 1], [0, 2], [-1, 0], [-1, 1]],
                '2-3': [[1, 1], [1, 2], [0, 1], [0, 2], [-1, 1], [-1, 2]],
                '2-4': [[1, 1], [1, 2], [0, 2], [-1, 1], [-1, 2]],
                '2-5': [[1, 2], [0, 2], [-1, 1], [-1, 2]],
                '2-6': [[1, 2], [-1, 1], [-1, 2]],
                
                // Row 3 patterns
                '3-0': [[1, 0], [0, 1], [-1, 0], [-1, 1]],
                '3-1': [[1, 0], [1, 1], [0, 1], [-1, 0], [-1, 1]],
                '3-2': [[1, 0], [1, 1], [0, 1], [0, 2], [-1, 0], [-1, 1]],
                '3-3': [[1, 1], [1, 2], [0, 1], [0, 2], [-1, 1], [-1, 2]],
                '3-4': [[1, 1], [1, 2], [0, 2], [-1, 1], [-1, 2]],
                '3-5': [[1, 2], [0, 2], [-1, 1], [-1, 2]],
                '3-6': [[1, 2], [-1, 1], [-1, 2]],
                '3-7': [[1, 2], [-1, 2]],
                '3-8': [[-1, 2]],
                
                // Row 4 patterns
                '4-0': [[0, 1], [-1, 0], [-1, 1]],
                '4-1': [[1, 1], [0, 1], [-1, 0], [-1, 1]],
                '4-2': [[1, 1], [0, 1], [0, 2], [-1, 0], [-1, 1]],
                '4-3': [[1, 1], [1, 2], [0, 1], [0, 2], [-1, 1], [-1, 2]],
                '4-4': [[1, 1], [1, 2], [0, 2], [-1, 1], [-1, 2]],
                '4-5': [[1, 2], [0, 2], [-1, 1], [-1, 2]],
                '4-6': [[1, 2], [-1, 1], [-1, 2]],
                '4-7': [[1, 2], [-1, 2]],
                '4-8': [[-1, 2]],
                
                // Row 5 patterns
                '5-0': [[0, 1], [-1, 0], [-1, 1]],
                '5-1': [[1, 1], [0, 1], [-1, 0], [-1, 1]],
                '5-2': [[1, 1], [0, 1], [0, 2], [-1, 0], [-1, 1]],
                '5-3': [[1, 1], [1, 2], [0, 1], [0, 2], [-1, 1], [-1, 2]],
                '5-4': [[1, 1], [1, 2], [0, 2], [-1, 1], [-1, 2]],
                '5-5': [[1, 2], [0, 2], [-1, 1], [-1, 2]],
                '5-6': [[1, 2], [-1, 1], [-1, 2]],
                '5-7': [[1, 2], [-1, 2]],
                '5-8': [[-1, 2]],
                
                // Row 6 patterns
                '6-0': [[0, 1], [-1, 0], [-1, 1]],
                '6-1': [[1, 1], [0, 1], [-1, 0], [-1, 1]],
                '6-2': [[1, 1], [0, 1], [0, 2], [-1, 0], [-1, 1]],
                '6-3': [[1, 1], [1, 2], [0, 1], [0, 2], [-1, 1], [-1, 2]],
                '6-4': [[1, 1], [1, 2], [0, 2], [-1, 1], [-1, 2]],
                '6-5': [[1, 2], [0, 2], [-1, 1], [-1, 2]],
                '6-6': [[1, 2], [-1, 1], [-1, 2]],
                '6-7': [[1, 2], [-1, 2]],
                '6-8': [[-1, 2]]
            };
            
            return patterns[`${centerRow}-${centerCol}`] || [];
        }

        // Function to show movement pattern accounting for hexagonal grid structure
        function showSquareMovementPattern(centerRow, centerCol) {
            console.log(`üéØ showSquareMovementPattern called for ${centerRow}-${centerCol}`);
            // Clear any existing highlights (but keep threat highlights)
            document.querySelectorAll('.hexagon').forEach(hex => {
                hex.classList.remove('highlight-green', 'highlight-red', 'highlight-danger', 'highlight-diagonal', 'highlight-gray');
            });

            // Different offset patterns for each row due to hexagonal grid structure
            let offsets;
            
            if (centerRow === 0) {
                // Row 0 (even, shift-down)
                offsets = [
                    [1, 0],  // down-left
                    [1, 1],  // down-right
                    [-1, 1], // up-right (off-board)
                    [-1, 0]  // up-left (off-board)
                ];
            } else if (centerRow === 1) {
                // Row 1 (odd, no shift)
                // For 1-3 ‚Üí 2-3, 2-4, 0-2, 0-3
                offsets = [
                    [1, 0],  // down-left: 1-3 + [1,0] = 2-3
                    [1, 1],  // down-right: 1-3 + [1,1] = 2-4
                    [-1, -1], // up-left: 1-3 + [-1,-1] = 0-2
                    [-1, 0]  // up-right: 1-3 + [-1,0] = 0-3
                ];
            } else if (centerRow === 2) {
                // Row 2 (even, shift-down)
                // For 2-3 ‚Üí 3-3, 3-4, 1-2, 1-3
                offsets = [
                    [1, 0],  // down-left: 2-3 + [1,0] = 3-3
                    [1, 1],  // down-right: 2-3 + [1,1] = 3-4
                    [-1, -1], // up-left: 2-3 + [-1,-1] = 1-2
                    [-1, 0]  // up-right: 2-3 + [-1,0] = 1-3
                ];
            } else if (centerRow === 3) {
                // Row 3 (odd, no shift) - KEEP ORIGINAL WORKING PATTERN
                // For 3-4 ‚Üí 4-3, 4-4, 2-4, 2-3
                offsets = [
                    [1, -1], // down-left
                    [1, 0],  // down-right
                    [-1, 0], // up-right
                    [-1, -1] // up-left
                ];
            } else if (centerRow === 4) {
                // Row 4 (even, shift-down)
                // For 4-3 ‚Üí 3-3, 3-4, 5-2, 5-3
                offsets = [
                    [-1, 0], // up-left
                    [-1, 1], // up-right
                    [1, -1], // down-left
                    [1, 0]   // down-right
                ];
            } else if (centerRow === 5) {
                // Row 5 (odd, no shift)
                // For 5-1 ‚Üí 6-0, 6-1, 4-1, 4-2
                offsets = [
                    [1, -1], // down-left
                    [1, 0],  // down-right
                    [-1, 0], // up-left  
                    [-1, 1]  // up-right
                ];
            } else if (centerRow === 6) {
                // Row 6 (even, shift-down)
                // For 6-0 ‚Üí should go to 5-0, 5-1 (and two off-board)
                offsets = [
                    [1, 0],  // down-left (off-board)
                    [1, 1],  // down-right (off-board)
                    [-1, 1], // up-right
                    [-1, 0]  // up-left
                ];
            }

            // Get the piece type that's showing movement pattern
            const centerHex = document.getElementById(`hex-${centerRow}-${centerCol}`);
            const centerPiece = centerHex.querySelector('.square-piece, .triangle-piece');
            let friendlyPieceTypes = [];
            
            if (centerPiece) {
                if (centerPiece.classList.contains('square-piece')) {
                    if (centerPiece.classList.contains('white-piece')) {
                            // White square - friendly with other white pieces (squares, triangles, rhombuses, circles, hexgons)
                            friendlyPieceTypes = ['.square-piece.white-piece', '.triangle-piece.white-triangle', '.rhombus-piece.white-rhombus', '.circle-piece.white-circle', '.hexgon-piece.white-hexgon'];
                    } else {
                        // Black square - friendly with other black pieces and triangles
                            friendlyPieceTypes = ['.square-piece:not(.white-piece)', '.triangle-piece:not(.white-triangle)', '.rhombus-piece:not(.white-rhombus)', '.circle-piece:not(.white-circle)', '.hexgon-piece:not(.white-hexgon)'];
                    }
                } else if (centerPiece.classList.contains('triangle-piece')) {
                    if (centerPiece.classList.contains('white-triangle')) {
                        // White triangle - friendly with white squares and other white triangles
                            friendlyPieceTypes = ['.square-piece.white-piece', '.triangle-piece.white-triangle', '.rhombus-piece.white-rhombus', '.circle-piece.white-circle', '.hexgon-piece.white-hexgon'];
                    } else {
                        // Black triangle - friendly with black squares and other black triangles
                            friendlyPieceTypes = ['.square-piece:not(.white-piece)', '.triangle-piece:not(.white-triangle)', '.rhombus-piece:not(.white-rhombus)', '.circle-piece:not(.white-circle)', '.hexgon-piece:not(.white-hexgon)'];
                    }
                }
            }

            // Highlight the hexes in the cross pattern
            offsets.forEach(([rowOffset, colOffset]) => {
                const targetRow = centerRow + rowOffset;
                const targetCol = centerCol + colOffset;
                const targetHex = document.getElementById(`hex-${targetRow}-${targetCol}`);
                
                if (targetHex) {
                    // Check if target hex has a friendly piece
                    let hasFriendlyPiece = false;
                    friendlyPieceTypes.forEach(selector => {
                        if (targetHex.querySelector(selector)) {
                            hasFriendlyPiece = true;
                        }
                    });
                    
                    // Check if target hex has an opponent piece
                    const isWhite = centerPiece && (centerPiece.classList.contains('white-piece') || centerPiece.classList.contains('white-triangle'));
                    const opponentPieceTypes = isWhite ? 
                        ['.square-piece:not(.white-piece)', '.triangle-piece:not(.white-triangle)', '.rhombus-piece:not(.white-rhombus)', '.circle-piece:not(.white-circle)', '.hexgon-piece:not(.white-hexgon)'] :
                        ['.square-piece.white-piece', '.triangle-piece.white-triangle', '.rhombus-piece.white-rhombus', '.circle-piece.white-circle', '.hexgon-piece.white-hexgon'];
                    let hasOpponentPiece = false;
                    opponentPieceTypes.forEach(selector => {
                        if (targetHex.querySelector(selector)) {
                            hasOpponentPiece = true;
                        }
                    });
                    
                    // Highlight in red if opponent piece, green if empty (skip friendly pieces)
                    if (hasOpponentPiece) {
                        console.log(`üî¥ SQUARE: Adding red highlight to ${targetRow}-${targetCol} for opponent piece`);
                        targetHex.classList.add('highlight-red');
                    } else if (!hasFriendlyPiece) {
                        // Check if this position would be vulnerable to attack
                        if (isPositionVulnerable(targetRow, targetCol, isWhite)) {
                            targetHex.classList.add('highlight-danger');
                        } else {
                            targetHex.classList.add('highlight-green');
                        }
                    }
                }
            });
        }

        // Function to show movement pattern for rhombus pieces
        function showRhombusMovementPattern(centerRow, centerCol) {
            console.log(`üéØ showRhombusMovementPattern called for ${centerRow}-${centerCol}`);
            // Clear any existing highlights (but keep threat highlights)
            document.querySelectorAll('.hexagon').forEach(hex => {
                hex.classList.remove('highlight-green', 'highlight-red', 'highlight-danger', 'highlight-diagonal', 'highlight-gray');
            });

            // Get friendly piece types based on rhombus color
            let friendlyPieceTypes;
            const centerHex = document.getElementById(`hex-${centerRow}-${centerCol}`);
            const centerPiece = centerHex.querySelector('.rhombus-piece');
            
            if (centerPiece && centerPiece.classList.contains('white-rhombus')) {
                // White rhombus - friendly with white pieces (squares, triangles, rhombuses, circles, hexgons)
                friendlyPieceTypes = ['.square-piece.white-piece', '.triangle-piece.white-triangle', '.rhombus-piece.white-rhombus', '.circle-piece.white-circle', '.hexgon-piece.white-hexgon'];
            } else {
                // Black rhombus - friendly with black pieces
                friendlyPieceTypes = ['.square-piece:not(.white-piece)', '.triangle-piece:not(.white-triangle)', '.rhombus-piece:not(.white-rhombus)', '.circle-piece:not(.white-circle)', '.hexgon-piece:not(.white-hexgon)'];
            }

            // Define zones for diagonal ability detection
            const deadZone = new Set(["3-3", "3-4", "3-5"]);
            const innerPerimeter = new Set(["4-2", "4-3", "4-4", "4-5", "2-2", "2-3", "2-4", "2-5"]);
            const currentPos = `${centerRow}-${centerCol}`;

            // Use getRhombusMoves to get all possible moves (including diagonal abilities)
            const targets = getRhombusMoves(centerRow, centerCol);

            // Highlight the hexes in the rhombus pattern
            targets.forEach(([targetRow, targetCol]) => {
                const targetHex = document.getElementById(`hex-${targetRow}-${targetCol}`);
                const targetPos = `${targetRow}-${targetCol}`;
                
                if (targetHex) {
                    // Check if target hex has a friendly piece
                    let hasFriendlyPiece = false;
                    friendlyPieceTypes.forEach(selector => {
                        if (targetHex.querySelector(selector)) {
                            hasFriendlyPiece = true;
                        }
                    });
                    
                    // Check if target hex has an opponent piece
                    // NOTE: Rhombuses CANNOT attack other rhombuses, so exclude them from opponent list
                    const isWhite = centerPiece && centerPiece.classList.contains('white-rhombus');
                    const opponentPieceTypes = isWhite ? 
                        ['.square-piece:not(.white-piece)', '.triangle-piece:not(.white-triangle)', '.circle-piece:not(.white-circle)', '.hexgon-piece:not(.white-hexgon)'] :
                        ['.square-piece.white-piece', '.triangle-piece.white-triangle', '.circle-piece.white-circle', '.hexgon-piece.white-hexgon'];
                    let hasOpponentPiece = false;
                    opponentPieceTypes.forEach(selector => {
                        if (targetHex.querySelector(selector)) {
                            hasOpponentPiece = true;
                        }
                    });
                    
                    // Check if this is a diagonal move (from dead zone to inner perimeter or vice versa)
                    const isDiagonalMove = (deadZone.has(currentPos) && innerPerimeter.has(targetPos)) || 
                                          (innerPerimeter.has(currentPos) && deadZone.has(targetPos));
                    
                    // Highlight in red if opponent piece (but NOT for diagonal moves - diagonal is movement only)
                    if (hasOpponentPiece && !isDiagonalMove) {
                        targetHex.classList.add('highlight-red');
                    } else if (!hasFriendlyPiece) {
                        // Check if this position would be vulnerable to attack
                        // Pass 'rhombus' as the moving piece type so we exclude rhombus-on-rhombus threats
                        if (isPositionVulnerable(targetRow, targetCol, isWhite, 'rhombus')) {
                            targetHex.classList.add('highlight-danger');
                        } else {
                            // Use purple highlight for ALL diagonal moves (both directions)
                            if (isDiagonalMove) {
                                targetHex.classList.add('highlight-diagonal');
                            } else {
                                targetHex.classList.add('highlight-green');
                            }
                        }
                    }
                }
            });
        }

        // Function to show movement for circle pieces by zone
        function showCircleMovementPattern(centerRow, centerCol) {
            console.log(`üéØ showCircleMovementPattern called for ${centerRow}-${centerCol}`);
            const centerHex = document.getElementById(`hex-${centerRow}-${centerCol}`);
            if (!centerHex) {
                console.log(`‚ùå centerHex not found!`);
                return;
            }
            const piece = centerHex.querySelector('.circle-piece');
            if (!piece) {
                console.log(`‚ùå circle piece not found!`);
                return;
            }
            
            console.log(`‚úÖ Circle piece found, proceeding...`);

            // Clear previous highlights but keep threat
            document.querySelectorAll('.hexagon').forEach(hex => {
                hex.classList.remove('highlight-green', 'highlight-red', 'highlight-danger', 'highlight-diagonal', 'highlight-gray');
            });

            const coord = `${centerRow}-${centerCol}`;
            console.log(`üìç Current position: ${coord}`);
            
            let zoneSet = null;
            let zoneOrder = null;
            let currentZone = null;
            
            if (circleDeadZone.has(coord)) {
                currentZone = 'dead';
                console.log(`‚ùå Circle is in DEAD ZONE - cannot move`);
                return; // cannot move in dead zone
            } else if (circleInnerZone.has(coord)) {
                zoneSet = circleInnerZone;
                zoneOrder = circleInnerOrder;
                currentZone = 'inner';
                console.log(`‚úÖ Circle is in INNER zone`);
            } else if (circleMiddleZone.has(coord)) {
                zoneSet = circleMiddleZone;
                zoneOrder = circleMiddleOrder;
                currentZone = 'middle';
                console.log(`‚úÖ Circle is in MIDDLE zone`);
            } else if (circleOuterZone.has(coord)) {
                zoneSet = circleOuterZone;
                zoneOrder = circleOuterOrder;
                currentZone = 'outer';
                console.log(`‚úÖ Circle is in OUTER zone`);
            } else {
                console.log(`‚ùå Circle is NOT in any zone!`);
                return;
            }

            const isWhite = piece.classList.contains('white-circle');
            const friendlySelectors = isWhite 
                ? ['.square-piece.white-piece', '.triangle-piece.white-triangle', '.rhombus-piece.white-rhombus', '.circle-piece.white-circle', '.hexgon-piece.white-hexgon']
                : ['.square-piece:not(.white-piece)', '.triangle-piece:not(.white-triangle)', '.rhombus-piece:not(.white-rhombus)', '.circle-piece:not(.white-circle)', '.hexgon-piece:not(.white-hexgon)'];

            const opponentSelectors = isWhite 
                ? ['.square-piece:not(.white-piece)', '.triangle-piece:not(.white-triangle)', '.rhombus-piece:not(.white-rhombus)', '.circle-piece:not(.white-circle)', '.hexgon-piece:not(.white-hexgon)']
                : ['.square-piece.white-piece', '.triangle-piece.white-triangle', '.rhombus-piece.white-rhombus', '.circle-piece.white-circle', '.hexgon-piece.white-hexgon'];

            // ===== PART 1: FULL ZONE PERIMETRIC MOVEMENT (original system) =====
            // Helper function to check if a position is adjacent to the center
            function isAdjacent(targetRow, targetCol) {
                let offsets;
                if (centerRow % 2 === 0) {
                    offsets = [[1, 0], [1, 1], [0, 1], [-1, 0], [-1, 1], [0, -1]];
                } else {
                    offsets = [[1, -1], [1, 0], [0, 1], [-1, -1], [-1, 0], [0, -1]];
                }
                for (const [rowOff, colOff] of offsets) {
                    if (centerRow + rowOff === targetRow && centerCol + colOff === targetCol) {
                        return true;
                    }
                }
                return false;
            }
            
            // Perimetric sweep clockwise until first friendly/opponent
            const startIdx = zoneOrder.indexOf(coord);
            const len = zoneOrder.length;
            console.log(`üîÑ Starting clockwise perimetric sweep. startIdx: ${startIdx}, len: ${len}`);
            
            let clockwiseCount = 0;
            for (let step = 1; step < len; step++) {
                const idx = (startIdx + step) % len;
                const [r,c] = zoneOrder[idx].split('-');
                const hex = document.getElementById(`hex-${r}-${c}`);
                if (!hex) continue;
                
                clockwiseCount++;
                const targetRow = parseInt(r);
                const targetCol = parseInt(c);
                
                // Friendly: stop without highlighting
                let hasFriendly = false;
                for (const sel of friendlySelectors) { if (hex.querySelector(sel)) { hasFriendly = true; break; } }
                if (hasFriendly) {
                    console.log(`  üîÑ CW Step ${step}: ${r}-${c} has friendly piece, stopping`);
                    break;
                }
                // Opponent: ALWAYS highlight red (can attack any opponent on perimeter), then stop
                let hasOpponent = false;
                for (const sel of opponentSelectors) { if (hex.querySelector(sel)) { hasOpponent = true; break; } }
                if (hasOpponent) {
                    console.log(`  üîÑ CW Step ${step}: ${r}-${c} has opponent, adding red and stopping`);
                    hex.classList.add('highlight-red');
                    break;
                }
                // Empty: highlight green and continue
                if (hex !== centerHex) {
                    hex.classList.add('highlight-green');
                    console.log(`  üîÑ CW Step ${step}: ${r}-${c} is empty, added green`);
                }
            }
            console.log(`‚úÖ Clockwise sweep complete. Processed ${clockwiseCount} hexes`);

            // Perimetric sweep counter-clockwise until first friendly/opponent
            console.log(`üîÑ Starting counter-clockwise perimetric sweep`);
            let counterClockwiseCount = 0;
            for (let step = 1; step < len; step++) {
                const idx = (startIdx - step + len) % len;
                const [r,c] = zoneOrder[idx].split('-');
                const hex = document.getElementById(`hex-${r}-${c}`);
                if (!hex) continue;
                
                counterClockwiseCount++;
                const targetRow = parseInt(r);
                const targetCol = parseInt(c);
                
                // Friendly: stop without highlighting
                let hasFriendly = false;
                for (const sel of friendlySelectors) { if (hex.querySelector(sel)) { hasFriendly = true; break; } }
                if (hasFriendly) {
                    console.log(`  üîÑ CCW Step ${step}: ${r}-${c} has friendly piece, stopping`);
                    break;
                }
                // Opponent: ALWAYS highlight red (can attack any opponent on perimeter), then stop
                let hasOpponent = false;
                for (const sel of opponentSelectors) { if (hex.querySelector(sel)) { hasOpponent = true; break; } }
                if (hasOpponent) {
                    console.log(`  üîÑ CCW Step ${step}: ${r}-${c} has opponent, adding red and stopping`);
                    hex.classList.add('highlight-red');
                    break;
                }
                if (hex !== centerHex) {
                    hex.classList.add('highlight-green');
                    console.log(`  üîÑ CCW Step ${step}: ${r}-${c} is empty, added green`);
                }
            }
            console.log(`‚úÖ Counter-clockwise sweep complete. Processed ${counterClockwiseCount} hexes`);

            // ===== PART 2: ADJACENT HEX ZONE TRANSITIONS (hardcoded valid transitions) =====
            console.log(`üî∑ Starting zone transition checks (Part 2)`);
            
            const currentPos = `${centerRow}-${centerCol}`;
            const validTransitions = circleZoneTransitions.get(currentPos);
            
            if (!validTransitions || validTransitions.length === 0) {
                console.log(`üî∑ No valid zone transitions from ${currentPos}`);
            } else {
                console.log(`üî∑ Valid transitions from ${currentPos}:`, validTransitions);
                
                // Check each valid transition target
                validTransitions.forEach(targetPos => {
                    const [targetRow, targetCol] = targetPos.split('-').map(Number);
                    const targetHex = document.getElementById(`hex-${targetRow}-${targetCol}`);
                    
                    console.log(`  üî∑ Checking transition target ${targetPos}`);
                    
                    if (!targetHex) {
                        console.log(`    ‚ö†Ô∏è Hex not found`);
                        return;
                    }
                    
                    // Check if already highlighted from perimetric sweep
                    const alreadyHighlighted = targetHex.classList.contains('highlight-green') || 
                                              targetHex.classList.contains('highlight-red') || 
                                              targetHex.classList.contains('highlight-gray');
                    
                    if (alreadyHighlighted) {
                        console.log(`    ‚è≠Ô∏è Already highlighted, skipping`);
                        return;
                    }
                    
                    // Check if target hex has any piece
                    let hasFriendly = false;
                    for (const sel of friendlySelectors) {
                        if (targetHex.querySelector(sel)) {
                            hasFriendly = true;
                            break;
                        }
                    }
                    
                    let hasOpponent = false;
                    for (const sel of opponentSelectors) {
                        if (targetHex.querySelector(sel)) {
                            hasOpponent = true;
                            break;
                        }
                    }
                    
                    // If has any piece, skip (not attackable via transition)
                    if (hasOpponent || hasFriendly) {
                        console.log(`    ‚¨ú Has piece, not attackable via zone transition`);
                        return;
                    }
                    
                    // Empty hex - valid zone transition move (purple highlight)
                    console.log(`    üíú Adding purple highlight for valid zone transition`);
                    targetHex.classList.add('highlight-diagonal');
                });
            }
        }

        // Show persistent attack highlights for all circles on the board
        function showCircleAttackHighlights() {
            // Get all circle pieces on the board
            const allCircles = document.querySelectorAll('.circle-piece');
            
            allCircles.forEach(circle => {
                const circleHex = circle.closest('.hexagon');
                if (!circleHex) return;
                
                const [, row, col] = circleHex.id.match(/hex-(\d+)-(\d+)/);
                const centerRow = parseInt(row);
                const centerCol = parseInt(col);
                const coord = `${centerRow}-${centerCol}`;
                
                // Skip if in dead zone
                if (circleDeadZone.has(coord)) return;
                
                // Determine zone
                let zoneOrder = null;
                if (circleInnerZone.has(coord)) {
                    zoneOrder = circleInnerOrder;
                } else if (circleMiddleZone.has(coord)) {
                    zoneOrder = circleMiddleOrder;
                } else if (circleOuterZone.has(coord)) {
                    zoneOrder = circleOuterOrder;
                } else {
                    return; // Not in valid zone
                }
                
                const isWhite = circle.classList.contains('white-circle');
                const opponentSelectors = isWhite 
                    ? ['.square-piece:not(.white-piece)', '.triangle-piece:not(.white-triangle)', '.rhombus-piece:not(.white-rhombus)', '.circle-piece:not(.white-circle)', '.hexgon-piece:not(.white-hexgon)']
                    : ['.square-piece.white-piece', '.triangle-piece.white-triangle', '.rhombus-piece.white-rhombus', '.circle-piece.white-circle', '.hexgon-piece.white-hexgon'];
                
                const startIdx = zoneOrder.indexOf(coord);
                const len = zoneOrder.length;
                
                // Check clockwise for first opponent
                for (let step = 1; step < len; step++) {
                    const idx = (startIdx + step) % len;
                    const [r, c] = zoneOrder[idx].split('-');
                    const hex = document.getElementById(`hex-${r}-${c}`);
                    if (!hex) continue;
                    
                    let hasOpponent = false;
                    for (const sel of opponentSelectors) {
                        if (hex.querySelector(sel)) {
                            hasOpponent = true;
                            break;
                        }
                    }
                    
                    if (hasOpponent) {
                        // Add red highlight for attackable opponent
                        hex.classList.add('highlight-red');
                        break; // Stop at first piece
                    } else if (hex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece')) {
                        break; // Stop at friendly piece
                    }
                }
                
                // Check counter-clockwise for first opponent
                for (let step = 1; step < len; step++) {
                    const idx = (startIdx - step + len) % len;
                    const [r, c] = zoneOrder[idx].split('-');
                    const hex = document.getElementById(`hex-${r}-${c}`);
                    if (!hex) continue;
                    
                    let hasOpponent = false;
                    for (const sel of opponentSelectors) {
                        if (hex.querySelector(sel)) {
                            hasOpponent = true;
                            break;
                        }
                    }
                    
                    if (hasOpponent) {
                        // Add red highlight for attackable opponent
                        hex.classList.add('highlight-red');
                        break; // Stop at first piece
                    } else if (hex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece')) {
                        break; // Stop at friendly piece
                    }
                }
            });
        }

        // ===== FOG OF WAR SYSTEM =====
        
        // Calculate distance between two hexagon positions
        function getHexDistance(hex1Id, hex2Id) {
            const [, row1, col1] = hex1Id.match(/hex-(\d+)-(\d+)/).map(Number);
            const [, row2, col2] = hex2Id.match(/hex-(\d+)-(\d+)/).map(Number);
            
            // Convert offset coordinates to cube coordinates for hex distance
            const x1 = col1 - Math.floor(row1 / 2);
            const z1 = row1;
            const y1 = -x1 - z1;
            
            const x2 = col2 - Math.floor(row2 / 2);
            const z2 = row2;
            const y2 = -x2 - z2;
            
            // Manhattan distance in cube coordinates
            return (Math.abs(x1 - x2) + Math.abs(y1 - y2) + Math.abs(z1 - z2)) / 2;
        }
        
        // Get all visible hexes for the current player under Fog of War
        function getVisibleHexes(forPlayer) {
            if (!fogOfWarEnabled) {
                // Return all hexes if fog is disabled
                return Array.from(document.querySelectorAll('.hexagon')).map(h => h.id);
            }
            
            const visibleHexIds = new Set();
            
            // Get all pieces belonging to the player
            const playerPieceSelector = forPlayer === 'white' 
                ? '.white-piece, .white-triangle, .white-rhombus, .white-circle, .white-hexgon'
                : '.square-piece:not(.white-piece), .triangle-piece:not(.white-triangle), .rhombus-piece:not(.white-rhombus), .circle-piece:not(.white-circle), .hexgon-piece:not(.white-hexgon)';
            
            const playerPieces = document.querySelectorAll(playerPieceSelector);
            
            // For each player piece, reveal hexes within radius
            playerPieces.forEach(piece => {
                const pieceHex = piece.closest('.hexagon');
                if (!pieceHex) return;
                
                const pieceHexId = pieceHex.id;
                visibleHexIds.add(pieceHexId); // Always see your own piece
                
                // Check all hexes on board
                document.querySelectorAll('.hexagon').forEach(hex => {
                    const distance = getHexDistance(pieceHexId, hex.id);
                    if (distance <= fogOfWarRadius) {
                        visibleHexIds.add(hex.id);
                    }
                });
            });
            
            return Array.from(visibleHexIds);
        }
        
        // Apply fog of war visual effects to the board
        function updateFogOfWar() {
            if (!fogOfWarEnabled) {
                // Remove all fog effects
                document.querySelectorAll('.hexagon').forEach(hex => {
                    hex.classList.remove('fog-hidden', 'fog-dimmed');
                    const pieces = hex.querySelectorAll('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                    pieces.forEach(p => p.style.visibility = 'visible');
                });
                return;
            }
            
            const visibleHexIds = getVisibleHexes(currentPlayer);
            const visibleSet = new Set(visibleHexIds);
            
            // Apply fog to all hexes
            document.querySelectorAll('.hexagon').forEach(hex => {
                if (visibleSet.has(hex.id)) {
                    // Visible hex - remove fog
                    hex.classList.remove('fog-hidden', 'fog-dimmed');
                    const pieces = hex.querySelectorAll('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                    pieces.forEach(p => p.style.visibility = 'visible');
                } else {
                    // Hidden hex - apply fog
                    hex.classList.add('fog-hidden');
                    // Hide opponent pieces in fog
                    const opponentPieceSelector = currentPlayer === 'white'
                        ? '.square-piece:not(.white-piece), .triangle-piece:not(.white-triangle), .rhombus-piece:not(.white-rhombus), .circle-piece:not(.white-circle), .hexgon-piece:not(.white-hexgon)'
                        : '.white-piece, .white-triangle, .white-rhombus, .white-circle, .white-hexgon';
                    
                    const opponentPieces = hex.querySelectorAll(opponentPieceSelector);
                    opponentPieces.forEach(p => p.style.visibility = 'hidden');
                }
            });
        }
        
        // Reveal hexes briefly when a piece attacks (if enabled)
        function revealAttackArea(attackerHexId, targetHexId) {
            if (!fogOfWarEnabled || !fogOfWarRevealOnAttack) return;
            
            // Temporarily reveal the attack path
            const revealedHexes = [attackerHexId, targetHexId];
            
            revealedHexes.forEach(hexId => {
                const hex = document.getElementById(hexId);
                if (hex) {
                    hex.classList.remove('fog-hidden');
                    hex.classList.add('fog-revealed-temp');
                    const pieces = hex.querySelectorAll('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                    pieces.forEach(p => {
                        p.style.visibility = 'visible';
                        p.style.animation = 'fogRevealPulse 0.5s ease-out';
                    });
                }
            });
            
            // Reapply fog after 2 seconds
            setTimeout(() => {
                revealedHexes.forEach(hexId => {
                    const hex = document.getElementById(hexId);
                    if (hex) {
                        hex.classList.remove('fog-revealed-temp');
                    }
                });
                updateFogOfWar();
            }, 2000);
        }

        // Show the movement pattern for the square at position 3-4
        // showSquareMovementPattern(3, 4); // Removed auto-highlight on load

        // Track which piece is currently selected
        let _selectedPiece = null;
        Object.defineProperty(window, 'selectedPiece', {
            get: function() {
                return _selectedPiece;
            },
            set: function(value) {
                console.log('selectedPiece changed from', _selectedPiece, 'to', value);
                _selectedPiece = value;
            }
        });

        // Turn-based logic
        let currentPlayer = 'black'; // Black starts first
        let gameOver = false;
        let gameInProgress = false; // Track if we're currently in an active game
        let gameMode = 'full'; // 'full', 'square-attack', or 'ai'
        let aiEnabled = false; // AI opponent enabled
        let boardFlipped = false; // Track if board is flipped for white player perspective
        let aiDifficulty = 'medium'; // 'easy', 'medium', or 'hard'
        let aiThinking = false; // Lock player input while AI is thinking
        let llmMode = false; // LLM AI mode (mockup)
        let currentAIModel = 'claude-sonnet'; // 'claude-sonnet', 'gpt4', 'grok', 'gemini'
        let showAllMoves = false; // Track if "show all moves" mode is active
        
        // Fog of War variant settings
        let fogOfWarEnabled = false; // Enable/disable Fog of War mode
        let fogOfWarRadius = 2; // Visibility radius (number of hexes)
        let fogOfWarRevealOnAttack = true; // Reveal pieces when they attack
        
        // Last move tracking for highlighting
        let lastMoveFrom = null; // Hex ID of last move source
        let lastMoveTo = null; // Hex ID of last move destination
        
        // Triangle orientation tracking (0-5 for 6 orientations, 60¬∞ each)
        let triangleOrientations = new Map(); // hexId -> orientation (0-5)
        
        // Hexgon orientation tracking (0-5 for 6 orientations, 60¬∞ each)
        let hexgonOrientations = new Map(); // hexId -> orientation (0-5)
        
        // Track piece actions for move+rotate vs attack rules
        let pieceActions = new Map(); // hexId -> {moved: boolean, attacked: boolean, rotated: boolean}
        let currentTurnPiece = null; // Track which piece is active this turn

        // Circle zones (by board coordinates as strings "r-c")
        const circleDeadZone = new Set(["3-3","3-4","3-5"]);
        // Zone membership (Set) and ordered rings (Array) for perimetric sweep
        const circleInnerOrder = ["3-2","4-2","4-3","4-4","4-5","3-6","2-5","2-4","2-3","2-2"]; // clockwise ring
        const circleMiddleOrder = ["2-1","1-1","1-2","1-3","1-4","1-5","2-6","3-7","4-6","5-5","5-4","5-3","5-2","5-1","4-1","3-1"]; // clockwise ring
        const circleOuterOrder = ["3-0","2-0","1-0","0-0","0-1","0-2","0-3","0-4","0-5","1-6","2-7","3-8","4-7","5-6","6-5","6-4","6-3","6-2","6-1","6-0","5-0","4-0"]; // clockwise ring
        const circleInnerZone = new Set(circleInnerOrder);
        const circleMiddleZone = new Set(circleMiddleOrder);
        const circleOuterZone = new Set(circleOuterOrder);
        
        // Circle zone-change gateways (entry/exit hexes)
        // Radials: [0-5 ‚áÑ 1-5 ‚áÑ 2-5], [6-5 ‚áÑ 5-5 ‚áÑ 4-5], [6-0 ‚áÑ 5-1 ‚áÑ 4-2], [0-0 ‚áÑ 1-1 ‚áÑ 2-3]
        const circleGateways = new Map([
            ["0-5", ["1-5"]],
            ["1-5", ["0-5", "2-5"]],
            ["2-5", ["1-5"]],
            ["6-5", ["5-5"]],
            ["5-5", ["6-5", "4-5"]],
            ["4-5", ["5-5"]],
            ["6-0", ["5-1"]],
            ["5-1", ["6-0", "4-2"]],
            ["4-2", ["5-1"]],
            ["0-0", ["1-1"]],
            ["1-1", ["0-0", "2-2"]],
            ["2-2", ["1-1"]]
        ]);

        // Circle zone transition map - defines which adjacent hexes allow zone transitions for each position
        // Format: "position" -> [list of valid zone-transition target positions]
        const circleZoneTransitions = new Map([
            // OUTER ZONE to MIDDLE ZONE transitions (hardcoded by user)
            ["3-8", ["3-7"]], // outer to middle
            ["4-7", ["4-6", "3-7"]], // outer to middle
            ["5-6", ["5-5", "4-6"]], // outer to middle
            ["6-5", ["5-5"]], // outer to middle
            ["6-4", ["5-4", "5-5"]], // outer to middle
            ["6-3", ["5-3", "5-4"]], // outer to middle
            ["6-2", ["5-2", "5-3"]], // outer to middle
            ["6-1", ["5-1", "5-2"]], // outer to middle
            ["6-0", ["5-1"]], // outer to middle
            ["5-0", ["5-1", "4-1"]], // outer to middle
            ["4-0", ["4-1", "3-1"]], // outer to middle
            ["3-0", ["3-1"]], // outer to middle
            ["2-0", ["3-1", "2-1"]], // outer to middle
            ["1-0", ["2-1", "1-1"]], // outer to middle
            ["0-0", ["1-1"]], // outer to middle
            ["0-1", ["1-1", "1-2"]], // outer to middle
            ["0-2", ["1-2", "1-3"]], // outer to middle
            ["0-3", ["1-3", "1-4"]], // outer to middle
            ["0-4", ["1-4", "1-5"]], // outer to middle
            ["0-5", ["1-5"]], // outer to middle
            ["1-6", ["1-5", "2-6"]], // outer to middle
            ["2-7", ["2-6", "3-7"]], // outer to middle
            
            // MIDDLE ZONE to OUTER ZONE and INNER ZONE transitions (hardcoded by user)
            ["3-1", ["4-0", "3-0", "2-0", "3-2"]], // middle to outer + inner
            ["2-1", ["2-0", "1-0", "3-2", "2-2"]], // middle to outer + inner
            ["1-1", ["1-0", "0-0", "0-1", "2-2"]], // middle to outer + inner
            ["1-2", ["0-1", "0-2", "2-2", "2-3"]], // middle to outer + inner
            ["1-3", ["0-2", "0-3", "2-3", "2-4"]], // middle to outer + inner
            ["1-4", ["0-3", "0-4", "2-4", "2-5"]], // middle to outer + inner
            ["1-5", ["0-4", "0-5", "1-6", "2-5"]], // middle to outer + inner
            ["2-6", ["3-6", "2-5", "1-6", "2-7"]], // middle to outer + inner
            ["3-7", ["4-7", "3-8", "2-7", "3-6"]], // middle to outer + inner
            ["4-6", ["4-5", "3-6", "5-6", "4-7"]], // middle to outer + inner
            ["5-5", ["6-4", "6-5", "5-6", "4-5"]], // middle to outer + inner
            ["5-4", ["6-4", "6-3", "4-5", "4-4"]], // middle to outer + inner
            ["5-3", ["6-3", "6-2", "4-4", "4-3"]], // middle to outer + inner
            ["5-2", ["6-2", "6-1", "4-3", "4-2"]], // middle to outer + inner
            ["5-1", ["6-1", "6-0", "5-0", "4-2"]], // middle to outer + inner
            ["4-1", ["5-0", "4-0", "4-2", "3-2"]], // middle to outer + inner
            
            // INNER ZONE to MIDDLE ZONE transitions (hardcoded by user)
            ["3-6", ["2-6", "3-7", "4-6"]], // inner to middle
            ["4-5", ["4-6", "5-5", "5-4"]], // inner to middle
            ["4-4", ["5-4", "5-3"]], // inner to middle
            ["4-3", ["5-3", "5-2"]], // inner to middle
            ["4-2", ["5-2", "5-1", "4-1"]], // inner to middle
            ["3-2", ["4-1", "3-1", "2-1"]], // inner to middle
            ["2-2", ["1-2", "1-1", "2-1"]], // inner to middle
            ["2-3", ["1-2", "1-3"]], // inner to middle
            ["2-4", ["1-3", "1-4"]], // inner to middle
            ["2-5", ["1-4", "1-5", "2-6"]], // inner to middle
            
            // NO DEAD ZONE transitions - circles cannot move or attack in dead zone
            // NO INNER to DEAD transitions - circles cannot enter dead zone
        ]);

        // Settings state - must be defined before updateTurnDisplay() is called
        window.gameSettings = {
            soundEffects: true,
            music: false,
            coordinates: false,
            highlightMoves: true,
            animationSpeed: 2,
            confirmMoves: false,
            showThreats: true,
            showLastMove: false,
            fogOfWar: false,
            fogRadius: 2,
            currentMusicTrack: 0
        };
        // Ensure base defense variant is tracked in settings
        if (typeof window.gameSettings.baseDefenseVariant === 'undefined') {
            window.gameSettings.baseDefenseVariant = window.baseDefenseVariant || 'original';
        }

        // Simple move history for undo (stack of last actions)
        const moveHistory = []; // entries: {fromId,toId,pieceClass,capturedHTML,endedTurn,isTriangle}
        
        // Captured pieces tracking
        const capturedWhitePieces = []; // Array of piece characters: 'S', 'T', 'R', 'C', 'H'
        const capturedBlackPieces = []; // Array of piece characters: 's', 't', 'r', 'c', 'h'
        
        // Initialize turn display
        updateTurnDisplay();
        
        // Initialize base defence display
        updateBaseDefenceDisplay();

        // ===== BASE DEFENSE VARIANT LOGIC =====
    // Variant: 'original' (only rhombus can defend base), 'shape-defense' (shapes defend base)
    window.baseDefenseVariant = 'original'; // Default, will be set by UI

        // Helper: Check if a piece is defending the base
        function isDefendingBase(pieceType, isWhite) {
            // 'original' : only rhombus defends the base
            // 'shape-defense' : any attacking shape can defend the base
            if (window.baseDefenseVariant === 'original') {
                return pieceType === 'rhombus';
            } else if (window.baseDefenseVariant === 'shape-defense') {
                return true;
            }
            return false;
        }

        // Helper: Get base hex for each player
        function getBaseHex(isWhite) {
            // Standard base hexes (updated to match win conditions)
            return isWhite ? '3-0' : '3-8';
        }

        // Helper: Is a piece currently defending its base?
        function isBaseDefended(isWhite) {
            const baseHex = getBaseHex(isWhite);
            const piece = document.querySelector(`.hexagon[data-coords='${baseHex}'] .piece`);
            if (!piece) return false;
            const pieceType = getPieceTypeFromClass(piece.className);
            return isDefendingBase(pieceType, isWhite);
        }

        // Helper: Get piece type from className
        function getPieceTypeFromClass(className) {
            if (className.includes('rhombus')) return 'rhombus';
            if (className.includes('square')) return 'square';
            if (className.includes('triangle')) return 'triangle';
            if (className.includes('circle')) return 'circle';
            if (className.includes('hexgon')) return 'hexgon';
            return null;
        }

        // Enforce base defense rule on move
        function enforceBaseDefenseRule(fromHexId, toHexId, piece, isWhite) {
            // If moving from base hex, check if move is legal under current variant
            const baseHexCoords = getBaseHex(isWhite); // e.g., '3-1'
            const baseHex = 'hex-' + baseHexCoords; // canonical 'hex-3-1'
            const oppBaseHex = 'hex-' + getBaseHex(!isWhite); // Opponent's base hex (for win)
            const pieceType = getPieceTypeFromClass(piece.className);

            // Normalize fromHexId in case callers pass '3-1' vs 'hex-3-1'
            const normalize = id => (id && id.startsWith('hex-')) ? id : ('hex-' + id);
            const fromIdCanonical = normalize(fromHexId);

            if (fromIdCanonical === baseHex) {
                    if (window.baseDefenseVariant === 'original') {
                    // Only rhombus can leave the base
                    if (pieceType !== 'rhombus') {
                        showBaseDefenseWarning();
                        return false;
                    }
                    // If rhombus, allow move to any hex (including opponent's base)
                } else if (window.baseDefenseVariant === 'shape-defense') {
                    // Shape defense: rhombus cannot move to opponent's base if that destination base is under attack
                    if (pieceType === 'rhombus' && toHexId === oppBaseHex) {
                        // Check if the opponent's base hex (the destination) is under threat by the opponent
                        const [, destRow, destCol] = oppBaseHex.match(/hex-(\d+)-(\d+)/);
                        // Simulate placing the rhombus at the destination and check if the opponent
                        // would be able to attack that square (captures the rhombus). This avoids
                        // false negatives caused by path blockers that would be removed/changed
                        // in the post-move position.
                        try {
                            const destHexEl = document.getElementById('hex-' + destRow + '-' + destCol);
                            let temp = null;
                            if (destHexEl) {
                                temp = document.createElement('div');
                                // Use appropriate color for the simulated rhombus so piece checkers behave
                                temp.className = isWhite ? 'rhombus-piece white-rhombus' : 'rhombus-piece';
                                temp.setAttribute('data-temp-simulation', 'true');
                                destHexEl.appendChild(temp);
                            }
                            const attackable = isPieceUnderThreat(parseInt(destRow), parseInt(destCol), !isWhite);
                            // enforcement simulation log removed
                            if (temp) temp.remove();
                            if (attackable) {
                                showShapeDefenseWarning(pieceType);
                                return false;
                            }
                        } catch (e) {
                            // simulation error logging removed
                        }
                    }
                }
            }
            return true;
        }

        // Show popup/warning for illegal base defense move
        function showBaseDefenseWarning() {
            alert('‚ùå Illegal move: Only the allowed piece(s) can leave the base in this variant!');
        }

        // Check if a piece can leave base under shape defense rules
        function canLeaveBaseUnderShapeDefense(pieceType, isWhite) {
            // Shape defense only applies to rhombus - other pieces can always leave
            if (pieceType !== 'rhombus') return true;

            // This function is no longer used for rhombus - rhombus movement to opponent's base
            // is now checked separately in enforceBaseDefenseRule
            return true;
        }

    // Debug tracing removed

        // Helper: check if a square (row,col) is attackable by pieces of a given color
        function isSquareAttackableByColor(row, col, attackerIsWhite) {
            // isSquareAttackableByColor tracing removed
            const attackerSelectors = attackerIsWhite ?
                ['.square-piece.white-piece', '.triangle-piece.white-triangle', '.rhombus-piece.white-rhombus', '.circle-piece.white-circle', '.hexgon-piece.white-hexgon'] :
                ['.square-piece:not(.white-piece)', '.triangle-piece:not(.white-triangle)', '.rhombus-piece:not(.white-rhombus)', '.circle-piece:not(.white-circle)', '.hexgon-piece:not(.white-hexgon)'];

            for (let sel of attackerSelectors) {
                const attackers = document.querySelectorAll(sel);
                for (let attacker of attackers) {
                    try {
                        if (attacker.style.display === 'none' || attacker.hasAttribute('data-temp-simulation')) continue;
                        const attackerHex = attacker.closest('.hexagon');
                        if (!attackerHex) continue;
                        const [, aRow, aCol] = attackerHex.id.match(/hex-(\d+)-(\d+)/);
                        const canAttack = canPieceActuallyAttack(parseInt(aRow), parseInt(aCol), row, col, attacker);
                        // per-attacker tracing removed
                        if (canAttack) {
                            // per-attacker positive trace removed
                            return true;
                        }
                    } catch (e) {
                        // per-attacker error logging removed
                        continue;
                    }
                }
            }
            // Fallback: use existing isPieceUnderThreat helper which enumerates opponent pieces
            // and may catch cases missed by the selector-based scan (especially complex circle
            // perimeter checks). Note: isPieceUnderThreat expects the 'isWhite' parameter
            // indicating the color of the piece being checked; here we invert attackerIsWhite
            // to pass the correct side.
            try {
                const fallback = isPieceUnderThreat(row, col, !attackerIsWhite);
                // fallback tracing removed
                if (fallback) {
                    // fallback positive trace removed
                    return true;
                }
            } catch (e) {
                // fallback error logging removed
            }
            return false;
        }

        // Show popup/warning for shape defense violation
        function showShapeDefenseWarning(pieceType) {
            if (pieceType === 'rhombus') {
                alert('Shape Defense: Cannot escape - your base is not under threat. Position your shapes to defend the base first.');
            } else {
                alert(`‚ùå Illegal move: ${pieceType} cannot leave base under shape defense rules!`);
            }
        }

        // Patch into move logic: before allowing a move from base, enforce rule
        // Find the main move handler (drag/drop or click move)
        // Example: in handlePieceMove or similar, add:
        // if (!enforceBaseDefenseRule(fromHexId, toHexId, piece, isWhite)) return;

        // --- PATCH DRAG/DROP LOGIC ---
        // Find setupDragAndDrop and patch drop handler:
        // (This is a comment for the next patch step)
        
        // Initialize threat highlighting
        highlightThreatenedPieces();

        function setGatewayHighlight(active) {
            const hexes = document.querySelectorAll('.gateway-highlight');
            hexes.forEach(hex => hex.classList.remove('gateway-highlight'));
            if (!active) return;
            try {
                const all = new Set([].concat(
                    ...Array.from(circleGateways.entries()).map(([k, v]) => [k, ...v])
                ));
                all.forEach(id => {
                    const [r,c] = id.split('-');
                    const hex = document.getElementById(`hex-${r}-${c}`);
                    if (hex) hex.classList.add('gateway-highlight');
                });
            } catch (e) { /* ignore */ }
        }
        
        // Test function - add to window for debugging
        window.testThreats = function() {
            console.log('Testing threat detection...');
            highlightThreatenedPieces();
        };
        
        // Test function to manually apply threat highlighting
        window.testThreatHighlight = function() {
            console.log('Testing threat highlight CSS...');
            const hex = document.getElementById('hex-5-4');
            if (hex) {
                hex.classList.add('highlight-threat');
                console.log('Applied highlight-threat to hex-5-4');
                console.log('Element classes:', hex.className);
            } else {
                console.log('hex-5-4 not found');
            }
        };
        
        // Undo last move
        function undoLastMove() {
            setGatewayHighlight(false);
            if (moveHistory.length === 0) return;
            const last = moveHistory.pop();
            const toHex = document.getElementById(last.toId);
            const fromHex = document.getElementById(last.fromId);
            if (!toHex || !fromHex) return;

            // Remove piece from destination (including hexgon-piece!)
            const movedPiece = toHex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
            if (movedPiece) movedPiece.remove();

            // Restore piece back to origin
            const piece = document.createElement('div');
            piece.className = last.pieceClass;
            piece.draggable = true;
            fromHex.appendChild(piece);

            // Restore captured piece if any and remove one eliminated-panel entry
            if (last.capturedHTML) {
                try {
                    const payload = JSON.parse(last.capturedHTML);
                    toHex.insertAdjacentHTML('beforeend', payload.html);
                    const elimId = payload.elimId;
                    if (elimId) {
                        const elimEntry = document.querySelector(`.eliminated-piece[data-eliminated-id="${elimId}"]`);
                        if (elimEntry) elimEntry.remove();
                    }
                } catch(e) {
                    // Fallback to old format if any
                    toHex.insertAdjacentHTML('beforeend', last.capturedHTML);
                }
            }

            // Rebind drag for restored piece (same logic as for new pieces)
            piece.addEventListener('dragstart', function(e) {
                console.log('üé¨ DRAGSTART event triggered for piece at:', this.parentElement.id);
                console.log('  Piece classes:', this.className);
                
                if (gameOver || !isCurrentPlayerPiece(this)) {
                    console.log('‚ùå DRAGSTART blocked: gameOver or not current player piece');
                    e.preventDefault();
                    return;
                }
                if (currentTurnPiece && currentTurnPiece !== this.parentElement) {
                    console.log('‚ùå DRAGSTART blocked: already moved a piece this turn');
                    e.preventDefault();
                    alert('You can only move or rotate one piece per turn!');
                    return;
                }
                console.log('‚úÖ DRAGSTART proceeding...');
                
                draggedPiece = this;
                draggedFromHex = this.parentElement;
                selectedPiece = this.parentElement;
                currentTurnPiece = this.parentElement;
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/html', this.outerHTML);

                const hexId = this.parentElement.id;
                const [, row, col] = hexId.match(/hex-(\d+)-(\d+)/);
                console.log('üìç Piece position:', row, col);
                
                if (this.classList.contains('circle-piece')) {
                    console.log('üîµ Calling showCircleMovementPattern');
                    showCircleMovementPattern(parseInt(row), parseInt(col));
                }
                const rotationControls = document.getElementById('rotation-controls');
                if (rotationControls) {
                    if (this.classList.contains('triangle-piece') || this.classList.contains('hexgon-piece')) {
                        rotationControls.style.display = 'block';
                    } else {
                        rotationControls.style.display = 'none';
                    }
                }
                if (this.classList.contains('circle-piece')) {
                    showCircleMovementPattern(parseInt(row), parseInt(col));
                } else if (this.classList.contains('triangle-piece')) {
                    // Both white and black triangles use the same rotation-aware movement system
                    showTriangleMovementPattern(parseInt(row), parseInt(col));
                } else if (this.classList.contains('hexgon-piece')) {
                    showHexgonMovementPattern(parseInt(row), parseInt(col));
                } else if (this.classList.contains('rhombus-piece')) {
                    showRhombusMovementPattern(parseInt(row), parseInt(col));
                } else {
                    showSquareMovementPattern(parseInt(row), parseInt(col));
                }
            });
            piece.addEventListener('dragend', function(e) {
        document.querySelectorAll('.hexagon').forEach(hex => {
                    hex.classList.remove('highlight-green', 'highlight-red', 'highlight-danger', 'highlight-diagonal', 'highlight-gray');
                });
                draggedPiece = null;
                draggedFromHex = null;
                // Keep selection for triangles and hexagons so rotation buttons remain available
                if (!this.classList.contains('triangle-piece') && !this.classList.contains('hexgon-piece')) {
                    selectedPiece = null;
                    currentTurnPiece = null;
                    const rotationControls = document.getElementById('rotation-controls');
                    if (rotationControls) rotationControls.style.display = 'none';
                }
                if (!this.classList.contains('circle-piece')) {
                    setGatewayHighlight(false);
                }
            });

            // If the move ended the turn, revert the turn
            if (last.endedTurn && !gameOver) {
                switchTurn();
            }

            // Reset selection/controls to avoid blocking
            selectedPiece = null;
            currentTurnPiece = null;
            const rotationControls = document.getElementById('rotation-controls');
            if (rotationControls) rotationControls.style.display = 'none';

            // Update all pieces under attack after undo
            highlightAllPiecesUnderAttack();
        }
        
        // Test function to check movement patterns
        window.testMovement = function(row, col) {
            console.log(`Testing movement pattern for ${row}-${col}`);
            const hex = document.getElementById(`hex-${row}-${col}`);
            if (hex) {
                const piece = hex.querySelector('.square-piece, .triangle-piece, .rhombus-piece');
                if (piece) {
                    if (piece.classList.contains('square-piece')) {
                        showSquareMovementPattern(row, col);
                    } else if (piece.classList.contains('triangle-piece')) {
                        // Both white and black triangles use the same rotation-aware movement system
                        showTriangleMovementPattern(row, col);
                    } else if (piece.classList.contains('rhombus-piece')) {
                        showRhombusMovementPattern(row, col);
                    }
                } else {
                    console.log('No piece found at this position');
                }
            } else {
                console.log('Hex not found');
            }
        };
        
        // Test function to check if a specific position is highlighted
        window.checkHighlight = function(row, col) {
            const hex = document.getElementById(`hex-${row}-${col}`);
            if (hex) {
                console.log(`Hex ${row}-${col} classes:`, hex.className);
                console.log(`Has highlight-green:`, hex.classList.contains('highlight-green'));
                console.log(`Has highlight-red:`, hex.classList.contains('highlight-red'));
                console.log(`Has highlight-danger:`, hex.classList.contains('highlight-danger'));
                console.log(`Has highlight-threat:`, hex.classList.contains('highlight-threat'));
            } else {
                console.log('Hex not found');
            }
        };
        

        // Start menu functionality
        // Function to initialize board for game mode
        function initializeBoard(mode) {
            gameMode = mode;
            
            // If Square Attack mode, replace triangles, circles, and hexgons with squares
            if (mode === 'square-attack') {
                // Replace white triangle at 1-0 with square
                const hex10 = document.getElementById('hex-1-0');
                const triangle10 = hex10.querySelector('.triangle-piece');
                if (triangle10) {
                    triangle10.remove();
                    const square = document.createElement('div');
                    square.className = 'square-piece white-piece';
                    square.draggable = true;
                    hex10.appendChild(square);
                }
                
                // Replace black triangle at 1-6 with square
                const hex16 = document.getElementById('hex-1-6');
                const triangle16 = hex16.querySelector('.triangle-piece');
                if (triangle16) {
                    triangle16.remove();
                    const square = document.createElement('div');
                    square.className = 'square-piece';
                    square.draggable = true;
                    hex16.appendChild(square);
                }
                
                // Replace white circle at 2-0 with square
                const hex20 = document.getElementById('hex-2-0');
                const circle20 = hex20.querySelector('.circle-piece');
                if (circle20) {
                    circle20.remove();
                    const square = document.createElement('div');
                    square.className = 'square-piece white-piece';
                    square.draggable = true;
                    hex20.appendChild(square);
                }
                
                // Replace black hexgon at 2-7 with square
                const hex27 = document.getElementById('hex-2-7');
                const hexgon27 = hex27.querySelector('.hexgon-piece');
                if (hexgon27) {
                    hexgon27.remove();
                    const square = document.createElement('div');
                    square.className = 'square-piece';
                    square.draggable = true;
                    hex27.appendChild(square);
                }
                
                // Replace white hexgon at 4-0 with square
                const hex40 = document.getElementById('hex-4-0');
                const hexgon40 = hex40.querySelector('.hexgon-piece');
                if (hexgon40) {
                    hexgon40.remove();
                    const square = document.createElement('div');
                    square.className = 'square-piece white-piece';
                    square.draggable = true;
                    hex40.appendChild(square);
                }
                
                // Replace black circle at 4-7 with square
                const hex47 = document.getElementById('hex-4-7');
                const circle47 = hex47.querySelector('.circle-piece');
                if (circle47) {
                    circle47.remove();
                    const square = document.createElement('div');
                    square.className = 'square-piece';
                    square.draggable = true;
                    hex47.appendChild(square);
                }
                
                // Replace white triangle at 5-0 with square
                const hex50 = document.getElementById('hex-5-0');
                const triangle50 = hex50.querySelector('.triangle-piece');
                if (triangle50) {
                    triangle50.remove();
                    const square = document.createElement('div');
                    square.className = 'square-piece white-piece';
                    square.draggable = true;
                    hex50.appendChild(square);
                }
                
                // Replace black triangle at 5-6 with square
                const hex56 = document.getElementById('hex-5-6');
                const triangle56 = hex56.querySelector('.triangle-piece');
                if (triangle56) {
                    triangle56.remove();
                    const square = document.createElement('div');
                    square.className = 'square-piece';
                    square.draggable = true;
                    hex56.appendChild(square);
                }
            }
            
            // If Hexagon Siege mode, replace triangles, circles, and squares with hexagons
            if (mode === 'hexagon-siege') {
                // Replace white triangle at 1-0 with hexagon
                const hex10 = document.getElementById('hex-1-0');
                const triangle10 = hex10.querySelector('.triangle-piece');
                if (triangle10) {
                    triangle10.remove();
                    const hexagon = document.createElement('div');
                    hexagon.className = 'hexgon-piece white-hexgon';
                    hexagon.draggable = true;
                    hex10.appendChild(hexagon);
                }
                
                // Replace black triangle at 1-6 with hexagon
                const hex16 = document.getElementById('hex-1-6');
                const triangle16 = hex16.querySelector('.triangle-piece');
                if (triangle16) {
                    triangle16.remove();
                    const hexagon = document.createElement('div');
                    hexagon.className = 'hexgon-piece';
                    hexagon.draggable = true;
                    hex16.appendChild(hexagon);
                }
                
                // Replace white circle at 2-0 with hexagon
                const hex20 = document.getElementById('hex-2-0');
                const circle20 = hex20.querySelector('.circle-piece');
                if (circle20) {
                    circle20.remove();
                    const hexagon = document.createElement('div');
                    hexagon.className = 'hexgon-piece white-hexgon';
                    hexagon.draggable = true;
                    hex20.appendChild(hexagon);
                }
                
                // Replace white square at 3-0 with hexagon
                const hex30 = document.getElementById('hex-3-0');
                const square30 = hex30.querySelector('.square-piece');
                if (square30) {
                    square30.remove();
                    const hexagon = document.createElement('div');
                    hexagon.className = 'hexgon-piece white-hexgon';
                    hexagon.draggable = true;
                    hex30.appendChild(hexagon);
                }
                
                // Replace black square at 3-7 with hexagon
                const hex37 = document.getElementById('hex-3-7');
                const square37 = hex37.querySelector('.square-piece');
                if (square37) {
                    square37.remove();
                    const hexagon = document.createElement('div');
                    hexagon.className = 'hexgon-piece';
                    hexagon.draggable = true;
                    hex37.appendChild(hexagon);
                }
                
                // Replace black circle at 4-7 with hexagon
                const hex47 = document.getElementById('hex-4-7');
                const circle47 = hex47.querySelector('.circle-piece');
                if (circle47) {
                    circle47.remove();
                    const hexagon = document.createElement('div');
                    hexagon.className = 'hexgon-piece';
                    hexagon.draggable = true;
                    hex47.appendChild(hexagon);
                }
                
                // Replace white triangle at 5-0 with hexagon
                const hex50 = document.getElementById('hex-5-0');
                const triangle50 = hex50.querySelector('.triangle-piece');
                if (triangle50) {
                    triangle50.remove();
                    const hexagon = document.createElement('div');
                    hexagon.className = 'hexgon-piece white-hexgon';
                    hexagon.draggable = true;
                    hex50.appendChild(hexagon);
                }
                
                // Replace black triangle at 5-6 with hexagon
                const hex56 = document.getElementById('hex-5-6');
                const triangle56 = hex56.querySelector('.triangle-piece');
                if (triangle56) {
                    triangle56.remove();
                    const hexagon = document.createElement('div');
                    hexagon.className = 'hexgon-piece';
                    hexagon.draggable = true;
                    hex56.appendChild(hexagon);
                }
            }
            
            // Re-setup drag and drop for all pieces
            setupDragAndDrop();
        }

        // Setup menu event listeners with null checks
        const gameBtn = document.getElementById('start-game-btn');
        if (gameBtn) {
            gameBtn.addEventListener('click', function() {
                // Show game variants modal for PVP mode
                openGameVariantsModal('pvp');
            });
        }
        
        const aiModeBtn = document.getElementById('start-ai-mode-btn');
        if (aiModeBtn) {
            aiModeBtn.addEventListener('click', function() {
                // Show game variants modal for AI mode
                openGameVariantsModal('ai');
            });
        }
        
        const llmModeBtn = document.getElementById('start-llm-mode-btn');
        if (llmModeBtn) {
            llmModeBtn.addEventListener('click', function() {
                // Show game variants modal for LLM mode
                openGameVariantsModal('llm');
            });
        }
        
        const gameModesBtn = document.getElementById('start-game-modes-btn');
        if (gameModesBtn) {
            gameModesBtn.addEventListener('click', function() {
                // Show game modes modal
                openGameModesModal();
            });
        }
        
        const multiplayerBtn = document.getElementById('start-multiplayer-btn');
        if (multiplayerBtn) {
            multiplayerBtn.addEventListener('click', function() {
                // Show multiplayer modal
                openMultiplayerModal();
            });
        }

        const puzzlesBtn = document.getElementById('start-puzzles-btn');
        if (puzzlesBtn) {
            puzzlesBtn.addEventListener('click', function() {
                // Show puzzles modal
                openPuzzlesModal();
            });
        }

        // ========== PUZZLE FUNCTIONALITY ==========
        
        let puzzleMode = false;
        let currentPuzzle = null;
        let puzzleMoves = 0;
        let puzzleMaxMoves = 0;
        
        // Puzzle definitions
        const puzzles = {
            'escape-easy-1': {
                name: 'Escape Easy #1',
                type: 'escape',
                maxMoves: 2,
                startPlayer: 'white',
                description: 'Move the white rhombus to position 3-8 in 2 moves',
                goalPosition: '3-8',
                goalPiece: 'white-rhombus',
                initialBoard: {
                    '3-6': { piece: 'rhombus-piece white-rhombus', draggable: true }
                }
            },
            'checkmate-1': {
                name: 'Tactical Checkmate #1',
                type: 'checkmate',
                maxMoves: 3,
                startPlayer: 'white',
                description: 'White to move and win. Can you find the winning sequence?',
                goalPiece: 'capture-black-rhombus',
                initialBoard: {
                    '4-6': { piece: 'triangle-piece', draggable: true },
                    '2-6': { piece: 'triangle-piece', draggable: true },
                    '3-5': { piece: 'rhombus-piece white-rhombus', draggable: true },
                    '3-3': { piece: 'rhombus-piece', draggable: true },
                    '4-0': { piece: 'triangle-piece white-triangle', draggable: true }
                }
            }
        };
        
        function openPuzzlesModal() {
            document.getElementById('puzzles-modal').style.display = 'flex';
        }
        
        function closePuzzlesModal() {
            document.getElementById('puzzles-modal').style.display = 'none';
        }
        
        function startPuzzle(puzzleId) {
            const puzzle = puzzles[puzzleId];
            if (!puzzle) {
                alert('Puzzle not found!');
                return;
            }
            
            currentPuzzle = puzzle;
            puzzleMode = true;
            puzzleMoves = 0;
            puzzleMaxMoves = puzzle.maxMoves;
            
            // Close modals
            closePuzzlesModal();
            document.getElementById('start-menu').style.display = 'none';
            
            // Show game board
            document.getElementById('board-display-container').style.display = 'block';
            
            // Clear the board
            clearBoard();
            
            // Set up puzzle board
            setupPuzzleBoard(puzzle);
            
            // Set current player
            currentPlayer = puzzle.startPlayer;
            gameOver = false;
            aiEnabled = false;
            
            // Update UI
            updateTurnDisplay();
            highlightThreatenedPieces();
            
            // Show puzzle info
            showPuzzleInfo();
        }
        
        function clearBoard() {
            // Remove all pieces from board
            document.querySelectorAll('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece').forEach(piece => {
                piece.remove();
            });
        }
        
        function setupPuzzleBoard(puzzle) {
            // Place pieces according to puzzle configuration
            for (const [hexId, config] of Object.entries(puzzle.initialBoard)) {
                const hex = document.getElementById(`hex-${hexId}`);
                if (hex) {
                    const piece = document.createElement('div');
                    piece.className = config.piece;
                    piece.draggable = config.draggable;
                    hex.appendChild(piece);
                }
            }
            
            // Re-setup drag and drop
            setupDragAndDrop();
        }
        
        function showPuzzleInfo() {
            // Create puzzle info panel
            let infoPanel = document.getElementById('puzzle-info-panel');
            if (!infoPanel) {
                infoPanel = document.createElement('div');
                infoPanel.id = 'puzzle-info-panel';
                infoPanel.style.cssText = `
                    position: fixed;
                    top: 100px;
                    left: 20px;
                    background: #262421;
                    border: 1px solid #ffd700;
                    border-radius: 8px;
                    padding: 15px;
                    color: white;
                    z-index: 9999;
                    text-align: center;
                    width: 200px;
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
                `;
                document.body.appendChild(infoPanel);
            }
            
            infoPanel.innerHTML = `
                <h3 style="color: #ffd700; margin: 0 0 8px 0; font-size: 1.1em;">üß© ${currentPuzzle.name}</h3>
                <p style="margin: 0 0 10px 0; color: #ccc; font-size: 0.85em; line-height: 1.3;">${currentPuzzle.description}</p>
                <div style="font-size: 1.1em; color: #4ecdc4; margin-bottom: 10px;">
                    <strong>Moves:</strong><br/>
                    <span id="puzzle-move-counter" style="font-size: 1.3em;">${puzzleMoves}</span> / ${puzzleMaxMoves}
                </div>
                <button onclick="resetPuzzle()" style="
                    background: #ff6b6b;
                    color: white;
                    border: none;
                    padding: 6px 12px;
                    border-radius: 5px;
                    cursor: pointer;
                    margin: 3px;
                    font-size: 0.9em;
                    width: calc(50% - 6px);
                ">üîÑ Reset</button>
                <button onclick="exitPuzzle()" style="
                    background: #555;
                    color: white;
                    border: none;
                    padding: 6px 12px;
                    border-radius: 5px;
                    cursor: pointer;
                    margin: 3px;
                    font-size: 0.9em;
                    width: calc(50% - 6px);
                ">‚Üê Exit</button>
            `;
        }
        
        function updatePuzzleMoves() {
            puzzleMoves++;
            const counter = document.getElementById('puzzle-move-counter');
            if (counter) {
                counter.textContent = puzzleMoves;
            }
            
            // Check if puzzle is solved
            checkPuzzleSolution();
            
            // Check if out of moves
            if (puzzleMoves >= puzzleMaxMoves && !gameOver) {
                setTimeout(() => {
                    if (!checkPuzzleSolution()) {
                        alert('‚ùå Out of moves! Try again.');
                        resetPuzzle();
                    }
                }, 500);
            }
        }
        
        function checkPuzzleSolution() {
            if (!currentPuzzle) return false;
            
            if (currentPuzzle.type === 'escape') {
                // Check if the goal piece is at the goal position
                const goalHex = document.getElementById(`hex-${currentPuzzle.goalPosition}`);
                if (goalHex) {
                    const piece = goalHex.querySelector(`.${currentPuzzle.goalPiece.replace(' ', '.')}`);
                    if (piece) {
                        // Puzzle solved!
                        setTimeout(() => {
                            playWinSound();
                            alert(`üéâ Puzzle Solved! You completed it in ${puzzleMoves} moves!`);
                            exitPuzzle();
                        }, 500);
                        return true;
                    }
                }
            }
            return false;
        }
        
        function resetPuzzle() {
            if (currentPuzzle) {
                puzzleMoves = 0;
                clearBoard();
                setupPuzzleBoard(currentPuzzle);
                currentPlayer = currentPuzzle.startPlayer;
                updateTurnDisplay();
                showPuzzleInfo();
            }
        }
        
        function exitPuzzle() {
            puzzleMode = false;
            currentPuzzle = null;
            puzzleMoves = 0;
            
            // Remove puzzle info panel
            const infoPanel = document.getElementById('puzzle-info-panel');
            if (infoPanel) {
                infoPanel.remove();
            }
            
            // Show start menu
            showStartMenu();
        }

        // ========== TIMER FUNCTIONALITY ==========
        
        let timerEnabled = false;
        let whiteTimeLeft = 600; // seconds (10 minutes)
        let blackTimeLeft = 600;
        let timerInterval = null;
        let selectedGameMode = null; // To store which game mode was selected
        // Renamed for Game Variants Modal
        window.openGameVariantsModal = function(gameMode) {
            selectedGameMode = gameMode;
            document.getElementById('game-variants-modal').style.display = 'flex';
        }

        function closeGameVariantsModal() {
            document.getElementById('game-variants-modal').style.display = 'none';
            // Don't reset selectedGameMode here - it's needed for startGameWithTime()
        }
        
        function startGameWithTime(minutes) {
            closeGameVariantsModal();
            
            // Hide splash page and start menu
            const splashPage = document.getElementById('splash-page');
            if (splashPage) splashPage.style.display = 'none';
            
            // Set timer
            if (minutes > 0) {
                timerEnabled = true;
                whiteTimeLeft = minutes * 60;
                blackTimeLeft = minutes * 60;
                updateTimerDisplay();
                document.getElementById('player-timers').style.display = 'flex';
            } else {
                timerEnabled = false;
                document.getElementById('player-timers').style.display = 'none';
            }
            
            // Hide start menu
            document.getElementById('start-menu').style.display = 'none';
            // Show game board
            document.getElementById('board-display-container').style.display = 'block';
            
            // Mark that we're now in an active game
            gameInProgress = true;
            
            // Initialize game based on selected mode
            if (selectedGameMode === 'pvp') {
            initializeBoard('full');
                aiEnabled = false;
            } else if (selectedGameMode === 'ai') {
                initializeBoard('full');
                aiEnabled = true;
                llmMode = false;
            } else if (selectedGameMode === 'llm') {
                document.getElementById('ai-reasoning-panel').style.display = 'block';
                initializeBoard('full');
                aiEnabled = true;
                llmMode = true;
                currentAIModel = 'claude-sonnet';
            }
            
            // Reset game state
            currentTurnPiece = null;
            escapeRaceNotificationShown = false;
            clearMovementHistory();
            clearMoveRepetitions();
            clearCoordinateLabels();
            highlightThreatenedPieces();
            updateAIModelDisplay();
            
            // Update turn display
            updateTurnDisplay();
            
            // Start timer if enabled
            if (timerEnabled) {
                startTimer();
            }
            
            // Debug: Log AI state after initialization
            console.log('üéÆ Game initialized:', {
                mode: selectedGameMode,
                aiEnabled,
                currentPlayer,
                gameOver
            });
            
            // Reset selectedGameMode after game starts
            selectedGameMode = null;
            
            // Note: AI will trigger automatically when it becomes White's turn
        }
        
        function startTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
            }
            
            timerInterval = setInterval(() => {
                if (gameOver || puzzleMode) {
                    stopTimer();
                    return;
                }
                
                // Decrease time for current player
                if (currentPlayer === 'white') {
                    whiteTimeLeft--;
                    if (whiteTimeLeft <= 0) {
                        whiteTimeLeft = 0;
                        stopTimer();
                        showGameOver('Black wins on time!');
                    }
                } else {
                    blackTimeLeft--;
                    if (blackTimeLeft <= 0) {
                        blackTimeLeft = 0;
                        stopTimer();
                        showGameOver('White wins on time!');
                    }
                }
                
                updateTimerDisplay();
            }, 1000);
        }
        
        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }
        
        function updateTimerDisplay() {
            const whiteTimer = document.getElementById('white-timer');
            const blackTimer = document.getElementById('black-timer');
            
            // Format time as MM:SS
            const whiteMinutes = Math.floor(whiteTimeLeft / 60);
            const whiteSeconds = whiteTimeLeft % 60;
            const blackMinutes = Math.floor(blackTimeLeft / 60);
            const blackSeconds = blackTimeLeft % 60;
            
            whiteTimer.querySelector('.timer-time').textContent = 
                `${whiteMinutes}:${whiteSeconds.toString().padStart(2, '0')}`;
            blackTimer.querySelector('.timer-time').textContent = 
                `${blackMinutes}:${blackSeconds.toString().padStart(2, '0')}`;
            
            // Update active state
            whiteTimer.classList.toggle('active', currentPlayer === 'white');
            blackTimer.classList.toggle('active', currentPlayer === 'black');
            
            // Add low time warning (under 1 minute)
            whiteTimer.classList.toggle('low-time', whiteTimeLeft < 60);
            blackTimer.classList.toggle('low-time', blackTimeLeft < 60);
        }
        
        // ========== LEARNING MODAL ==========
        
        function openLearningModal() {
            document.getElementById('learning-modal').style.display = 'flex';
        }
        
        function closeLearningModal() {
            document.getElementById('learning-modal').style.display = 'none';
        }
        
        // Add event listener for Learn button
        // Fix: Only add event listener if element exists
        var learnBtn = document.getElementById('start-learn-btn');
        if (learnBtn) {
            learnBtn.addEventListener('click', openLearningModal);
        }

        // ========== GAME ANALYSIS MODAL ==========
        
        let analysisData = null;
        let currentMoveIndex = 0;
        let autoPlayInterval = null;
        let moveAnnotations = new Map(); // moveIndex -> {symbol: '!', comment: 'Good move', evaluation: +0.5}
        let positionEvaluations = new Map(); // position RPN -> evaluation score
        
        function openAnalysisModal() {
            document.getElementById('analysis-modal').style.display = 'block';
        }
        
        function closeAnalysisModal() {
            document.getElementById('analysis-modal').style.display = 'none';
            stopAutoPlay();
            
            // If there's an active game, restore it
            // (Hide start menu and show board if we have moves or are in a game)
            if (moveCount > 0 || window.rpnMoveHistory.length > 0 || !gameOver) {
                const startMenu = document.getElementById('start-menu');
                if (startMenu) {
                    startMenu.style.display = 'none';
                }
                
                // Show the game board and side panels
                const boardContainer = document.getElementById('board-display-container');
                if (boardContainer) {
                    boardContainer.style.display = 'block';
                }
            }
        }
        
        // Load RMN file
        function loadRMNFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const content = e.target.result;
                parseRMNContent(content);
            };
            reader.readAsText(file);
        }
        
        // Load current game
        function loadCurrentGame() {
            console.log('üìä Loading current game for analysis...');
            console.log(`   rpnMoveHistory.length: ${window.rpnMoveHistory.length}`);
            
            if (window.rpnMoveHistory.length === 0) {
                // Allow analyzing starting position even with no moves
                const confirm = window.confirm('No moves have been made yet. Analyze starting position?');
                if (!confirm) return;
            }
            
            // Get current board position (full RPN string)
            const fullRPN = exportPositionRPN();
            console.log('üìä Full RPN:', fullRPN);
            
            // Extract just the board part (before the first space)
            const currentPosition = fullRPN.split(' ')[0];
            console.log('üìä Current board position RPN (extracted):', currentPosition);
            
            // Create RMN content from current game
            const rmnContent = exportGameRMN();
            console.log('üìÑ Generated RMN content:', rmnContent);
            
            // Parse the RMN and add current position
            parseRMNContent(rmnContent, currentPosition);
        }
        
        // Debug function to show current position
        function debugCurrentPosition() {
            console.log('üîç === DEBUG CURRENT POSITION ===');
            
            // Check specific problematic hexes
            const testHexes = ['hex-0-0', 'hex-0-5', 'hex-6-0', 'hex-6-5'];
            testHexes.forEach(hexId => {
                const hex = document.getElementById(hexId);
                if (hex) {
                    console.log(`üîç Checking ${hexId}:`);
                    console.log('   - innerHTML:', hex.innerHTML.substring(0, 200));
                    console.log('   - children count:', hex.children.length);
                    console.log('   - querySelector for piece:', hex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece'));
                    
                    // Check all children
                    for (let i = 0; i < hex.children.length; i++) {
                        const child = hex.children[i];
                        console.log(`   - Child ${i}:`, child.className, child.tagName);
                    }
                } else {
                    console.log(`üîç ${hexId} NOT FOUND`);
                }
            });
            
            const fullRPN = exportPositionRPN();
            console.log('üîç Full RPN:', fullRPN);
            const boardOnly = fullRPN.split(' ')[0];
            console.log('üîç Board only:', boardOnly);
            alert('Current board RPN (check console for details):\n\n' + boardOnly);
        }
        
        // Parse RMN content
        function parseRMNContent(content, currentPosition = null) {
            try {
                const lines = content.split('\n').filter(line => line.trim());
                
                // Parse metadata
                const metadata = {};
                const moves = [];
                
                for (const line of lines) {
                    if (line.startsWith('[')) {
                        // Metadata line: [Key "Value"]
                        const match = line.match(/\[(\w+) "(.+)"\]/);
                        if (match) {
                            metadata[match[1].toLowerCase()] = match[2];
                        }
                    } else if (line.match(/^\d+\./)) {
                        // Move line: 1. C2-0>3-1 r3-8>3-6
                        const moveMatch = line.match(/^\d+\.\s+(\S+)(?:\s+(\S+))?/);
                        if (moveMatch) {
                            moves.push({
                                number: moves.length + 1,
                                white: moveMatch[1] || '',
                                black: moveMatch[2] || '',
                                combined: moveMatch[1] + (moveMatch[2] ? ' ' + moveMatch[2] : '')
                            });
                        }
                    }
                }
                
                const startPos = metadata.startposition || 'S4s/T05t0/C6h0/R7r/H06c/t05T0/s4S';
                
                console.log('üìä parseRMNContent - startPos:', startPos);
                console.log('üìä parseRMNContent - currentPosition parameter:', currentPosition);
                
                analysisData = {
                    metadata,
                    moves,
                    totalMoves: moves.reduce((sum, m) => sum + (m.white ? 1 : 0) + (m.black ? 1 : 0), 0),
                    startPosition: startPos,
                    // Store current position if provided (for analyzing current game)
                    currentBoardPosition: currentPosition || startPos
                };
                
                console.log('üìä analysisData.currentBoardPosition:', analysisData.currentBoardPosition);
                console.log('üìä analysisData.totalMoves:', analysisData.totalMoves);
                
                displayAnalysis();
                
            } catch (error) {
                console.error('Error parsing RMN:', error);
                alert('Error loading RMN file: ' + error.message);
            }
        }
        
        // Display analysis
        function displayAnalysis() {
            if (!analysisData) return;
            
            // Show all sections
            document.getElementById('analysis-info').style.display = 'block';
            document.getElementById('analysis-navigator').style.display = 'block';
            document.getElementById('analysis-board-container').style.display = 'block';
            document.getElementById('analysis-moves').style.display = 'block';
            document.getElementById('analysis-stats').style.display = 'block';
            
            // Display metadata
            const metadataDiv = document.getElementById('analysis-metadata');
                        metadataDiv.innerHTML = `
                                <p><strong>White:</strong> ${analysisData.metadata.white || 'Unknown'}</p>
                                <p><strong>Black:</strong> ${analysisData.metadata.black || 'Unknown'}</p>
                                <p><strong>Date:</strong> ${analysisData.metadata.date || 'Unknown'}</p>
                                <p><strong>Result:</strong> ${analysisData.metadata.result || 'Unknown'}</p>
                                <p><strong>Starting Position:</strong> ${analysisData.startPosition === 'S4s/T05t0/C6h0/R7r/H06c/t05T0/s4S' ? 'Standard PvP' : 'Custom'}</p>
                                <hr style='border:0; border-top:1px solid #444; margin:10px 0;'>
                                <div style='margin-top:10px;'>
                                    <span style='color:#ffd700; font-weight:bold; font-size:1.08em;'>‚ö° Advanced Features</span>
                                    <ul style='color:#ccc; margin:8px 0 0 18px; font-size:0.98em; line-height:1.7;'>
                                        <li><b>Repetition Detection</b>: Three-fold repetition rule, draw offers, and visual warnings.</li>
                                        <li><b>Base Defense System</b>: Prevents early base captures, toggleable in settings.</li>
                                        <li><b>Threat Analysis</b>: Real-time threat and checkmate detection, highlights threatened pieces.</li>
                                        <li><b>Show All Moves</b>: Toggle to display all legal moves and rotations for current player.</li>
                                        <li><b>Defense Highlights</b>: Highlights pieces defended by others, optional toggle.</li>
                                        <li><b>Dark Mode</b>: Switch between light/dark themes, remembers your preference.</li>
                                        <li><b>Game Variants</b>: Blitz, Fog of War, King of the Hill (see Quick Reference for more).</li>
                                    </ul>
                                </div>
                        `;
            

            // Recognize opening by RPN (first position)
            let openingNameHtml = '';
            if (analysisData && analysisData.startPosition) {
                const found = OPENING_BOOK.find(o => o.rpn === analysisData.startPosition);
                if (found) {
                    openingNameHtml = `<div style='background:#23272e; color:#4ecdc4; padding:10px 16px; border-radius:8px; margin-bottom:10px; font-size:1.1em; font-weight:600;'>
                        üìñ Opening: <span style='color:#fff;'>${found.name}</span>
                        <span style='font-size:0.9em; color:#aaa; font-weight:400; margin-left:10px;'>(${found.moves.join(', ')})</span>
                    </div>`;
                }
            }

            // Display move list with annotations, with opening name above
            const moveListDiv = document.getElementById('analysis-move-list');
            moveListDiv.innerHTML = openingNameHtml;
            displayMoveListWithAnnotations();
            
            // Display statistics
            const statsDiv = document.getElementById('analysis-statistics');
            const captures = analysisData.moves.filter(m => 
                (m.white && m.white.includes('x')) || (m.black && m.black.includes('x'))
            ).length;
            const rotations = analysisData.moves.filter(m =>
                (m.white && m.white.includes('@')) || (m.black && m.black.includes('@'))
            ).length;
            
            if (analysisData.totalMoves === 0) {
                statsDiv.innerHTML = `
                    <p><strong>Total Moves:</strong> 0</p>
                    <p style="color: #888; font-style: italic;">Play some moves to see game statistics!</p>
                `;
            } else {
                statsDiv.innerHTML = `
                    <p><strong>Total Moves:</strong> ${analysisData.totalMoves}</p>
                    <p><strong>Captures:</strong> ${captures}</p>
                    <p><strong>Rotations:</strong> ${rotations}</p>
                    <p><strong>Average Move Length:</strong> ${(analysisData.totalMoves / analysisData.moves.length).toFixed(1)} per turn</p>
                `;
            }
            
            // Update navigator
            document.getElementById('total-moves').textContent = analysisData.totalMoves;
            document.getElementById('move-slider').max = analysisData.totalMoves;
            currentMoveIndex = 0;
            updateNavigator();
        }
        
        // Navigator functions
        function goToStart() {
            currentMoveIndex = 0;
            updateNavigator();
        }
        
        function previousMove() {
            if (currentMoveIndex > 0) {
                currentMoveIndex--;
                updateNavigator();
            }
        }
        
        function nextMove() {
            if (currentMoveIndex < analysisData.totalMoves) {
                currentMoveIndex++;
                updateNavigator();
            }
        }
        
        function goToEnd() {
            currentMoveIndex = analysisData.totalMoves;
            updateNavigator();
        }
        
        function jumpToMove(index) {
            currentMoveIndex = index;
            updateNavigator();
        }
        
        function updateNavigator() {
            document.getElementById('current-move-number').textContent = currentMoveIndex;
            document.getElementById('move-slider').value = currentMoveIndex;
            
            // Display current move info
            const moveInfoDiv = document.getElementById('current-move-info');
            if (currentMoveIndex === 0) {
                moveInfoDiv.textContent = 'Starting position';
            } else if (currentMoveIndex === analysisData.totalMoves) {
                moveInfoDiv.textContent = `Current position (after ${analysisData.totalMoves} moves)`;
            } else {
                const moveNumber = Math.ceil(currentMoveIndex / 2);
                const isWhite = currentMoveIndex % 2 === 1;
                const move = analysisData.moves[moveNumber - 1];
                const notation = isWhite ? move.white : move.black;
                
                // Note: For current game analysis, intermediate positions not available
                const positionNote = analysisData.currentBoardPosition && !analysisData.positions ? 
                    ' (showing start position - intermediate positions not stored)' : '';
                moveInfoDiv.textContent = `Move ${currentMoveIndex}: ${isWhite ? 'White' : 'Black'} - ${notation}${positionNote}`;
            }
            
            // Update move list highlighting only
            updateMoveListHighlight();
            
            // Update mini board display
            updateAnalysisMiniBoard();
            
            // Update position evaluation
            displayEvaluation();
        }
        
        // Update move list highlighting without re-rendering everything
        function updateMoveListHighlight() {
            if (!analysisData) return;
            
            // Use the annotation display system
            displayMoveListWithAnnotations();
        }
        
        function toggleAutoPlay() {
            if (autoPlayInterval) {
                stopAutoPlay();
            } else {
                startAutoPlay();
            }
        }
        
        function startAutoPlay() {
            const btn = document.getElementById('autoplay-btn');
            btn.textContent = '‚è∏Ô∏è Pause';
            btn.style.backgroundColor = '#ff6b6b';
            
            autoPlayInterval = setInterval(() => {
                if (currentMoveIndex < analysisData.totalMoves) {
                    nextMove();
                } else {
                    stopAutoPlay();
                }
            }, 1500); // 1.5 seconds per move
        }
        
        function stopAutoPlay() {
            if (autoPlayInterval) {
                clearInterval(autoPlayInterval);
                autoPlayInterval = null;
                const btn = document.getElementById('autoplay-btn');
                btn.textContent = '‚ñ∂Ô∏è Auto Play';
                btn.style.backgroundColor = '#4ecdc4';
            }
        }

        // ========== MOVE ANNOTATION SYSTEM ==========
        
        // Annotation symbols and their meanings
        const ANNOTATIONS = {
            '!': { name: 'Good move', color: '#4ecdc4', description: 'Strong, effective move' },
            '!!': { name: 'Brilliant move', color: '#00ff00', description: 'Exceptional, game-changing move' },
            '?': { name: 'Mistake', color: '#ffa500', description: 'Questionable move, likely not best' },
            '??': { name: 'Blunder', color: '#ff0000', description: 'Serious error, significant disadvantage' },
            '!?': { name: 'Interesting move', color: '#9b59b6', description: 'Unclear but interesting' },
            '?!': { name: 'Dubious move', color: '#e67e22', description: 'Likely inferior but worth considering' }
        };
        
        // Add or update annotation for a move
        function annotateMo(moveIndex, symbol, comment = '') {
            if (!analysisData) return;
            
            const annotation = {
                symbol: symbol,
                comment: comment,
                timestamp: new Date().toISOString()
            };
            
            moveAnnotations.set(moveIndex, annotation);
            console.log(`üìù Annotated move ${moveIndex} with ${symbol}:`, comment);
            
            // Refresh the move list display
            displayMoveListWithAnnotations();
        }
        
        // Remove annotation from a move
        function removeAnnotation(moveIndex) {
            moveAnnotations.delete(moveIndex);
            displayMoveListWithAnnotations();
        }
        
        // Display move list with annotations
        function displayMoveListWithAnnotations() {
            if (!analysisData) return;
            
            const moveListDiv = document.getElementById('analysis-move-list');
            let moveHtml = '';
            
            if (analysisData.moves.length === 0) {
                moveHtml = '<p style="color: #888; font-style: italic;">No moves played yet.</p>';
            } else {
                analysisData.moves.forEach((move, index) => {
                    const isHighlighted = index === Math.floor(currentMoveIndex / 2);
                    
                    // Check for annotations on white and black moves
                    const whiteMoveIndex = index * 2;
                    const blackMoveIndex = index * 2 + 1;
                    const whiteAnnotation = moveAnnotations.get(whiteMoveIndex);
                    const blackAnnotation = moveAnnotations.get(blackMoveIndex);
                    
                    moveHtml += `<div style="padding: 8px; background: ${isHighlighted ? 'rgba(78, 205, 196, 0.2)' : 'transparent'}; border-radius: 4px; margin-bottom: 4px; border-left: 3px solid ${isHighlighted ? '#4ecdc4' : 'transparent'};">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span>
                                ${move.number}. 
                                ${move.white}
                                ${whiteAnnotation ? `<span style="color: ${ANNOTATIONS[whiteAnnotation.symbol].color}; font-weight: bold; margin-left: 4px;" title="${whiteAnnotation.comment || ANNOTATIONS[whiteAnnotation.symbol].description}">${whiteAnnotation.symbol}</span>` : ''}
                                ${move.black ? (' ' + move.black) : ''}
                                ${blackAnnotation ? `<span style="color: ${ANNOTATIONS[blackAnnotation.symbol].color}; font-weight: bold; margin-left: 4px;" title="${blackAnnotation.comment || ANNOTATIONS[blackAnnotation.symbol].description}">${blackAnnotation.symbol}</span>` : ''}
                            </span>
                            <button onclick="showAnnotationMenu(${whiteMoveIndex})" style="background: #555; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 11px;">‚úèÔ∏è</button>
                        </div>
                        ${whiteAnnotation && whiteAnnotation.comment ? `<div style="font-size: 12px; color: #ccc; margin-top: 4px; font-style: italic;">${whiteAnnotation.comment}</div>` : ''}
                        ${blackAnnotation && blackAnnotation.comment ? `<div style="font-size: 12px; color: #ccc; margin-top: 4px; font-style: italic;">${blackAnnotation.comment}</div>` : ''}
                    </div>`;
                });
            }
            
            moveListDiv.innerHTML = moveHtml;
        }
        
        // Show annotation menu popup
        function showAnnotationMenu(moveIndex) {
            const existing = moveAnnotations.get(moveIndex);
            
            const menu = document.createElement('div');
            menu.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: #262421;
                border: 2px solid #4ecdc4;
                border-radius: 12px;
                padding: 20px;
                z-index: 10001;
                min-width: 350px;
                box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            `;
            
            menu.innerHTML = `
                <h3 style="color: #4ecdc4; margin: 0 0 15px 0;">üìù Annotate Move ${Math.floor(moveIndex/2) + 1}${moveIndex % 2 === 0 ? ' (White)' : ' (Black)'}</h3>
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 15px;">
                    ${Object.entries(ANNOTATIONS).map(([symbol, data]) => `
                        <button onclick="selectAnnotation('${symbol}', ${moveIndex})" style="
                            background: ${data.color};
                            color: ${symbol === '!!' ? '#000' : '#fff'};
                            border: none;
                            padding: 10px;
                            border-radius: 6px;
                            cursor: pointer;
                            font-weight: bold;
                            font-size: 18px;
                        " title="${data.description}">${symbol}</button>
                    `).join('')}
                </div>
                <textarea id="annotation-comment" placeholder="Add a comment (optional)..." style="
                    width: 100%;
                    height: 80px;
                    background: #1a1a1a;
                    color: white;
                    border: 1px solid #555;
                    border-radius: 6px;
                    padding: 10px;
                    font-family: inherit;
                    resize: vertical;
                    margin-bottom: 15px;
                ">${existing && existing.comment ? existing.comment : ''}</textarea>
                <div style="display: flex; gap: 10px;">
                    <button onclick="saveAnnotation(${moveIndex})" style="
                        background: #4ecdc4;
                        color: #262421;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 6px;
                        cursor: pointer;
                        font-weight: bold;
                        flex: 1;
                    ">üíæ Save</button>
                    ${existing ? `<button onclick="removeAnnotation(${moveIndex}); closeAnnotationMenu()" style="
                        background: #ff6b6b;
                        color: white;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 6px;
                        cursor: pointer;
                        font-weight: bold;
                    ">üóëÔ∏è Remove</button>` : ''}
                    <button onclick="closeAnnotationMenu()" style="
                        background: #555;
                        color: white;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 6px;
                        cursor: pointer;
                        font-weight: bold;
                    ">‚úñÔ∏è Cancel</button>
                </div>
            `;
            
            menu.id = 'annotation-menu';
            document.body.appendChild(menu);
            
            // Store current move index for symbol selection
            window.currentAnnotationMoveIndex = moveIndex;
        }
        
        // Select annotation symbol
        function selectAnnotation(symbol, moveIndex) {
            window.currentAnnotationSymbol = symbol;
            // Highlight selected button
            document.querySelectorAll('#annotation-menu button').forEach(btn => {
                if (btn.textContent.trim() === symbol) {
                    btn.style.outline = '3px solid white';
                } else if (Object.keys(ANNOTATIONS).includes(btn.textContent.trim())) {
                    btn.style.outline = 'none';
                }
            });
        }
        
        // Save annotation
        function saveAnnotation(moveIndex) {
            const symbol = window.currentAnnotationSymbol || '!';
            const comment = document.getElementById('annotation-comment').value;
            annotateMo(moveIndex, symbol, comment);
            closeAnnotationMenu();
        }
        
        // Close annotation menu
        function closeAnnotationMenu() {
            const menu = document.getElementById('annotation-menu');
            if (menu) menu.remove();
            window.currentAnnotationSymbol = null;
            window.currentAnnotationMoveIndex = null;
        }
        
        // Annotate the current move being viewed in navigator
        function annotateCurrentMove() {
            if (!analysisData || currentMoveIndex === 0) {
                alert('‚ö†Ô∏è Please navigate to a move first. Cannot annotate the starting position.');
                return;
            }
            
            // Open annotation menu for current move
            showAnnotationMenu(currentMoveIndex);
        }

        // ========== POSITION EVALUATION SYSTEM ==========
        
        // Piece values for material evaluation
        const PIECE_VALUES = {
            'S': 5,  // Square - most powerful
            'T': 4,  // Triangle
            'C': 3,  // Circle
            'R': 3,  // Rhombus
            'H': 4,  // Hexagon
        };
        
        // Position bonuses (center control, advancement)
        function evaluatePosition(rpnPosition) {
            if (positionEvaluations.has(rpnPosition)) {
                return positionEvaluations.get(rpnPosition);
            }
            
            let whiteScore = 0;
            let blackScore = 0;
            
            // Parse RPN and evaluate pieces
            const pieces = rpnPosition.split('/');
            
            pieces.forEach(piece => {
                if (!piece) return;
                
                // Extract piece type and position
                const isWhite = piece[0] === piece[0].toUpperCase();
                const pieceType = piece[0].toUpperCase();
                const position = piece.slice(1);
                
                // Material value
                const materialValue = PIECE_VALUES[pieceType] || 3;
                
                // Position bonus (pieces closer to enemy base are more valuable)
                let positionBonus = 0;
                if (position.length >= 2) {
                    const col = parseInt(position[0]);
                    const row = parseInt(position[1]);
                    
                    if (!isNaN(col) && !isNaN(row)) {
                        // White pieces get bonus for advancing (higher row numbers)
                        // Black pieces get bonus for advancing (lower row numbers)
                        if (isWhite) {
                            positionBonus = row * 0.5; // Bonus for advancing towards black base
                        } else {
                            positionBonus = (6 - row) * 0.5; // Bonus for advancing towards white base
                        }
                        
                        // Center control bonus (columns 2-4 are center)
                        if (col >= 2 && col <= 4) {
                            positionBonus += 0.5;
                        }
                    }
                }
                
                const totalValue = materialValue + positionBonus;
                
                if (isWhite) {
                    whiteScore += totalValue;
                } else {
                    blackScore += totalValue;
                }
            });
            
            // Calculate advantage (positive = white advantage, negative = black advantage)
            const evaluation = whiteScore - blackScore;
            
            // Store in cache
            positionEvaluations.set(rpnPosition, evaluation);
            
            return evaluation;
        }
        
        // Get evaluation description
        function getEvaluationDescription(score) {
            if (score > 10) return { text: 'White is winning', color: '#00ff00', icon: '++' };
            if (score > 5) return { text: 'White is better', color: '#90ee90', icon: '+' };
            if (score > 2) return { text: 'White has slight advantage', color: '#b0e0b0', icon: '+/=' };
            if (score > -2) return { text: 'Equal position', color: '#ffff99', icon: '=' };
            if (score > -5) return { text: 'Black has slight advantage', color: '#ffb0b0', icon: '=/+' };
            if (score > -10) return { text: 'Black is better', color: '#ff9999', icon: '+' };
            return { text: 'Black is winning', color: '#ff0000', icon: '++' };
        }
        
        // Display evaluation for current position
        function displayEvaluation() {
            const currentRPN = getCurrentPositionRPN();
            if (!currentRPN) return;
            
            const evaluation = evaluatePosition(currentRPN);
            const evalDesc = getEvaluationDescription(evaluation);
            
            // Find or create evaluation display
            let evalDiv = document.getElementById('evaluation-display');
            if (!evalDiv) {
                evalDiv = document.createElement('div');
                evalDiv.id = 'evaluation-display';
                const boardContainer = document.getElementById('analysis-board-container');
                if (boardContainer) {
                    boardContainer.appendChild(evalDiv);
                }
            }
            
            evalDiv.innerHTML = `
                <div style="
                    margin-top: 20px;
                    padding: 15px;
                    background: rgba(0,0,0,0.3);
                    border-radius: 8px;
                    text-align: center;
                ">
                    <div style="
                        font-size: 24px;
                        font-weight: bold;
                        color: ${evalDesc.color};
                        margin-bottom: 10px;
                    ">${evalDesc.icon} ${evaluation > 0 ? '+' : ''}${evaluation.toFixed(1)}</div>
                    <div style="
                        font-size: 14px;
                        color: #ccc;
                    ">${evalDesc.text}</div>
                    <div style="
                        margin-top: 10px;
                        height: 20px;
                        background: linear-gradient(to right, #ff0000, #ffff00, #00ff00);
                        border-radius: 10px;
                        position: relative;
                        overflow: hidden;
                    ">
                        <div style="
                            position: absolute;
                            top: 0;
                            left: 50%;
                            width: 3px;
                            height: 100%;
                            background: #fff;
                            box-shadow: 0 0 10px rgba(255,255,255,0.5);
                            transform: translateX(${(evaluation / 20) * 50}%);
                        "></div>
                    </div>
                </div>
            `;
        }
        
        // Get current position RPN from mini board or analysis data
        function getCurrentPositionRPN() {
            // For now, return the starting position or current board position
            if (analysisData && analysisData.currentBoardPosition) {
                return analysisData.currentBoardPosition;
            }
            return analysisData?.startPosition || null;
        }

        // ========== MINI BOARD FOR ANALYSIS ==========
        
        // Create mini board HTML structure
        function createMiniBoard() {
            const container = document.getElementById('analysis-mini-board');
            container.innerHTML = ''; // Clear existing
            
            // Create 7 rows with appropriate hex counts (correct sizes for the actual board)
            const rowSizes = [6, 7, 8, 9, 8, 7, 6];
            
            for (let r = 0; r < 7; r++) {
                const row = document.createElement('div');
                row.className = 'row';
                
                for (let i = 0; i < rowSizes[r]; i++) {
                    const hex = document.createElement('div');
                    hex.className = 'hexagon';
                    hex.id = `mini-hex-${r}-${i}`;
                    
                    // Add color classes based on position
                    if (r === 0 || r === 6) hex.classList.add('color-dark-brown');
                    else if (r === 1 || r === 5) hex.classList.add('color-orange-med');
                    else hex.classList.add('color-orange-light');
                    
                    row.appendChild(hex);
                }
                
                container.appendChild(row);
            }
        }
        
        // Update mini board with current position
        function updateAnalysisMiniBoard() {
            if (!analysisData) return;
            
            // Create board if it doesn't exist
            if (!document.getElementById('analysis-mini-board').hasChildNodes()) {
                createMiniBoard();
            }
            
            console.log('üé® === UPDATE MINI BOARD START ===');
            console.log('üé® Current move index:', currentMoveIndex);
            console.log('üé® Total moves:', analysisData.totalMoves);
            console.log('üé® Has currentBoardPosition?', !!analysisData.currentBoardPosition);
            console.log('üé® Has positions array?', !!analysisData.positions);
            
            // Get the RPN for current move
            let rpn = analysisData.startPosition;
            let source = 'starting position (default)';
            
            // If we're at the end (latest move), show the current board position
            if (currentMoveIndex === analysisData.totalMoves && analysisData.currentBoardPosition) {
                rpn = analysisData.currentBoardPosition;
                source = 'current board position (end of game)';
                console.log('üé® Using current board position (end of game)');
            }
            // If positions array exists (from a loaded RMN with position data), use it
            else if (analysisData.positions && analysisData.positions[currentMoveIndex]) {
                rpn = analysisData.positions[currentMoveIndex];
                source = `stored position for move ${currentMoveIndex}`;
                console.log('üé® Using stored position for move', currentMoveIndex);
            }
            // Otherwise show starting position
            else if (currentMoveIndex === 0) {
                source = 'starting position (move 0)';
                console.log('üé® Showing starting position');
            }
            
            console.log('üé® RPN Source:', source);
            console.log('üé® Mini board updating with RPN:', rpn);
            console.log('üé® Current move index:', currentMoveIndex, '/ Total moves:', analysisData.totalMoves);
            
            // Clear all pieces first
            const allHexes = document.querySelectorAll('#analysis-mini-board .hexagon');
            allHexes.forEach(hex => {
                hex.innerHTML = '';
            });
            
            // Parse RPN and place pieces
            if (rpn) {
                const rows = rpn.split('/');
                console.log('üé® RPN rows:', rows);
                
                for (let r = 0; r < rows.length && r < 7; r++) {
                    const rowData = rows[r];
                    let colIndex = 0;
                    console.log(`üé® Processing row ${r}: "${rowData}"`);
                    
                    for (let i = 0; i < rowData.length; i++) {
                        const char = rowData[i];
                        
                        if (char >= '0' && char <= '9') {
                            // Check if this is a rotation number (follows T, t, H, or h)
                            const prevChar = i > 0 ? rowData[i - 1] : '';
                            const isRotation = (prevChar === 'T' || prevChar === 't' || 
                                              prevChar === 'H' || prevChar === 'h');
                            
                            if (isRotation) {
                                // This is a rotation number, skip it (already handled when placing the piece)
                                continue;
                            } else {
                                // Number means empty hexes
                                colIndex += parseInt(char);
                            }
                        } else {
                            // Letter means piece
                            const hex = document.getElementById(`mini-hex-${r}-${colIndex}`);
                            if (hex) {
                                const piece = document.createElement('img');
                                piece.className = 'piece';
                                
                                const isWhite = char === char.toUpperCase();
                                const color = isWhite ? 'white' : 'black';
                                
                                // Check if next character is a rotation number
                                let rotation = 0;
                                if (i + 1 < rowData.length && rowData[i + 1] >= '0' && rowData[i + 1] <= '5') {
                                    const charLower = char.toLowerCase();
                                    if (charLower === 't' || charLower === 'h') {
                                        rotation = parseInt(rowData[i + 1]);
                                    }
                                }
                                
                                // Map piece letters to shapes (matching actual filenames)
                                const shapeMap = {
                                    's': 'square', 
                                    't': 'Triangle', 
                                    'r': 'Rhombus', 
                                    'c': 'circle', 
                                    'h': 'hexagon'
                                };
                                const shape = shapeMap[char.toLowerCase()];
                                
                                if (shape) {
                                    // Handle inconsistent capitalization in filenames
                                    // white square uses "Front" (capital F), others use "front"
                                    const frontWord = (shape === 'square' && isWhite) ? 'Front' : 'front';
                                    piece.src = `ASSETS/${shape} ${color} ${frontWord}.png`;
                                    piece.alt = `${color} ${shape}`;
                                    
                                    // Apply rotation if this is a triangle or hexagon
                                    if (rotation > 0) {
                                        const rotationDegrees = rotation * 60;
                                        piece.style.transform = `rotate(-90deg) rotate(${rotationDegrees}deg)`;
                                        console.log(`üé® Placing ${color} ${shape} at row ${r}, col ${colIndex} with rotation ${rotation} (${rotationDegrees}¬∞)`);
                                    } else {
                                        console.log(`üé® Placing ${color} ${shape} at row ${r}, col ${colIndex} (hex mini-hex-${r}-${colIndex})`);
                                    }
                                    
                                    hex.appendChild(piece);
                                } else {
                                    console.warn(`üé® Unknown piece type: ${char}`);
                                }
                            } else {
                                console.warn(`üé® Hex not found: mini-hex-${r}-${colIndex}`);
                            }
                            colIndex++;
                        }
                    }
                }
            }
        }

        // ========== LEADERBOARD FUNCTIONALITY ==========
        
        let currentLeaderboardTab = 'daily';
        
        function openLeaderboardModal() {
            document.getElementById('leaderboard-modal').style.display = 'flex';
        }
        
        function closeLeaderboardModal() {
            document.getElementById('leaderboard-modal').style.display = 'none';
        }
        
        function switchLeaderboardTab(tab) {
            currentLeaderboardTab = tab;
            
            // Update tab button styles
            const tabs = ['daily', 'weekly', 'alltime'];
            tabs.forEach(t => {
                const btn = document.getElementById(`lb-tab-${t}`);
                if (btn) {
                    if (t === tab) {
                        btn.style.background = '#f1c40f';
                        btn.style.color = '#262421';
                    } else {
                        btn.style.background = '#444';
                        btn.style.color = '#ccc';
                    }
                }
            });
            
            // Note: In a real implementation, you would fetch different data here
            // For now, we're just showing the same static data
            console.log('Switched to', tab, 'leaderboard');
        }
        
        // Add event listener for Leaderboard button
        const leaderboardBtn = document.getElementById('start-leaderboard-btn');
        if (leaderboardBtn) {
            leaderboardBtn.addEventListener('click', openLeaderboardModal);
        }

        // ========== SETTINGS FUNCTIONALITY ==========
        
        // Settings state - now defined earlier in the file before updateTurnDisplay()
        
        function openSettingsModal() {
            document.getElementById('settings-modal').style.display = 'flex';
            loadSettings();
        }
        
        function closeSettingsModal() {
            document.getElementById('settings-modal').style.display = 'none';
            saveSettings();
            applySettings(); // Apply the settings after closing
        }
        
        function toggleSetting(settingName) {
            const checkbox = document.getElementById(`setting-${settingName}`);
            const isChecked = checkbox.checked;
            
            // Update the visual toggle
            const toggleContainer = checkbox.nextElementSibling;
            const toggleButton = toggleContainer.nextElementSibling;
            
            if (isChecked) {
                // Turn off
                checkbox.checked = false;
                toggleContainer.style.backgroundColor = '#555';
                toggleButton.style.left = '4px';
                
                // Map setting names to gameSettings keys
                const settingMap = {
                    'sound-effects': 'soundEffects',
                    'music': 'music',
                    'coordinates': 'coordinates',
                    'highlight-moves': 'highlightMoves',
                    'confirm-moves': 'confirmMoves',
                    'show-threats': 'showThreats',
                    'show-last-move': 'showLastMove'
                };
                
                if (settingMap[settingName]) {
                    gameSettings[settingMap[settingName]] = false;
                }
            } else {
                // Turn on
                checkbox.checked = true;
                const colors = {
                    'sound-effects': '#4ecdc4',
                    'music': '#4ecdc4',
                    'coordinates': '#ffd700',
                    'highlight-moves': '#ffd700',
                    'confirm-moves': '#a55eea',
                    'show-threats': '#a55eea',
                    'show-last-move': '#a55eea'
                };
                toggleContainer.style.backgroundColor = colors[settingName] || '#4ecdc4';
                toggleButton.style.left = '34px';
                
                // Map setting names to gameSettings keys
                const settingMap = {
                    'sound-effects': 'soundEffects',
                    'music': 'music',
                    'coordinates': 'coordinates',
                    'highlight-moves': 'highlightMoves',
                    'confirm-moves': 'confirmMoves',
                    'show-threats': 'showThreats',
                    'show-last-move': 'showLastMove'
                };
                
                if (settingMap[settingName]) {
                    gameSettings[settingMap[settingName]] = true;
                }
            }
            
            applySettings();
        }
        
        function loadSettings() {
            // Load from localStorage if available
            const saved = localStorage.getItem('romgonSettings');
            if (saved) {
                Object.assign(gameSettings, JSON.parse(saved));
            }
            
            // Update UI to match settings
            updateSettingsUI();
        }
        
        function saveSettings() {
            // Save to localStorage
            localStorage.setItem('romgonSettings', JSON.stringify(gameSettings));
            applySettings();
        }
        
        function updateSettingsUI() {
            // Update all toggle switches to match current settings
            const settingElements = {
                'sound-effects': window.gameSettings.soundEffects,
                'music': window.gameSettings.music,
                'coordinates': window.gameSettings.coordinates,
                'highlight-moves': window.gameSettings.highlightMoves,
                'confirm-moves': window.gameSettings.confirmMoves,
                'show-threats': window.gameSettings.showThreats,
                'show-last-move': window.gameSettings.showLastMove
            };
            
            for (const [key, value] of Object.entries(settingElements)) {
                const checkbox = document.getElementById(`setting-${key}`);
                const toggleContainer = checkbox.nextElementSibling;
                const toggleButton = toggleContainer.nextElementSibling;
                
                checkbox.checked = value;
                if (value) {
                    const colors = {
                        'sound-effects': '#4ecdc4',
                        'music': '#4ecdc4',
                        'coordinates': '#ffd700',
                        'highlight-moves': '#ffd700',
                        'confirm-moves': '#a55eea',
                        'show-threats': '#a55eea',
                        'show-last-move': '#a55eea'
                    };
                    toggleContainer.style.backgroundColor = colors[key];
                    toggleButton.style.left = '34px';
                } else {
                    toggleContainer.style.backgroundColor = '#555';
                    toggleButton.style.left = '4px';
                }
            }
            
            // Update animation speed slider
            document.getElementById('setting-animation-speed').value = window.gameSettings.animationSpeed;
        }
        
        function applySettings() {
            // Apply settings to the game
            console.log('Settings applied:', window.gameSettings);

            // Ensure base defense runtime variant matches saved settings
            if (typeof window.gameSettings.baseDefenseVariant !== 'undefined') {
                window.baseDefenseVariant = window.gameSettings.baseDefenseVariant;
                // applySettings runtime sync log removed
            }
            // No floating badge: side-panel indicators are the single source of truth
            // Update side-panel indicators if present
            try {
                updateVariantIndicators();
            } catch (e) {
                // ignore if not yet defined or DOM not ready
            }
            
            // Apply music setting
            if (window.gameSettings.music) {
                if (currentMusicTrack === 0 && window.gameSettings.currentMusicTrack > 0) {
                    playBackgroundMusic(window.gameSettings.currentMusicTrack); // Resume last track
                } else if (currentMusicTrack === 0) {
                    playBackgroundMusic(1); // Start with track 1 if music is enabled
                }
            } else {
                stopBackgroundMusic();
            }
            
            // Update music button display
            updateMusicButtonDisplay();
            
            // Example: Apply coordinate display setting
            if (window.gameSettings.coordinates) {
                // Show coordinates (you can integrate with existing coordinate toggle)
                console.log('Coordinates enabled');
            }
        }
        
        function resetSettings() {
            // Reset to defaults
            window.gameSettings.soundEffects = true;
            window.gameSettings.music = false;
            window.gameSettings.coordinates = false;
            window.gameSettings.highlightMoves = true;
            window.gameSettings.animationSpeed = 2;
            window.gameSettings.confirmMoves = false;
            window.gameSettings.showThreats = true;
            window.gameSettings.showLastMove = true;
            window.gameSettings.currentMusicTrack = 0;
            
            // Stop any playing music
            stopBackgroundMusic();
            
            updateSettingsUI();
            saveSettings();
            
            showNotification('‚öôÔ∏è Settings reset to defaults', 'info');
        }
        
        // Add event listener for Settings button
        const settingsBtn = document.getElementById('start-settings-btn');
        if (settingsBtn) {
            settingsBtn.addEventListener('click', openSettingsModal);
        }

        // ========== GAME MODES FUNCTIONALITY ==========
        
        function openGameModesModal() {
            document.getElementById('game-modes-modal').style.display = 'flex';
        }
        
        function closeGameModesModal() {
            document.getElementById('game-modes-modal').style.display = 'none';
        }
        
        function startGameMode(mode) {
            // Close game modes modal
            closeGameModesModal();
            
            // Hide start menu
            document.getElementById('start-menu').style.display = 'none';
            
            // Show game board
            document.getElementById('board-display-container').style.display = 'block';
            
            // Mark that we're now in an active game
            gameInProgress = true;
            
            // Initialize board with the selected mode
            initializeBoard(mode);
            
            // Reset game state for new game
            currentTurnPiece = null;
            escapeRaceNotificationShown = false;
            clearMovementHistory();
            clearMoveRepetitions();
            clearCoordinateLabels();
            highlightThreatenedPieces();
            
            console.log(`Started game mode: ${mode}`);
        }
        
        function testAI() {
            console.log('üß™ Testing AI...');
            console.log('Current state:', {
                aiEnabled,
                currentPlayer,
                gameOver,
                aiThinking
            });
            
            if (aiEnabled && currentPlayer === 'white' && !gameOver && !aiThinking) {
                makeAIMove();
            } else {
                console.log('‚ùå AI test failed - conditions not met');
                if (!aiEnabled) console.log('‚ùå AI not enabled');
                if (currentPlayer !== 'white') console.log('‚ùå Not white turn, current:', currentPlayer);
                if (gameOver) console.log('‚ùå Game is over');
                if (aiThinking) console.log('‚ùå AI is already thinking');
            }
        }
        
        function testTriangleRotation() {
            console.log('üî∫ Testing Triangle Rotation...');
            
            // Test all orientations
            for (let i = 0; i < 6; i++) {
                console.log(`\nüî∫ Testing orientation ${i}:`);
                const angleMap = [270, 330, 30, 90, 150, 210];
                const rotation = angleMap[i];
                console.log(`  Should point to: ${rotation}¬∞ (position ${i} on hex)`);
            }
            
            // Test a specific triangle
            const testHex = document.getElementById('hex-5-6');
            if (testHex) {
                const triangle = testHex.querySelector('.triangle-piece');
                if (triangle) {
                    console.log('\nüî∫ Testing triangle at 5-6:');
                    const currentOrientation = getTriangleOrientation('hex-5-6');
                    console.log('Current orientation:', currentOrientation);
                    
                    // Test right rotation
                    console.log('Testing right rotation...');
                    rotateTriangleRight('hex-5-6');
                    
                    // Test left rotation
                    console.log('Testing left rotation...');
                    rotateTriangleLeft('hex-5-6');
                } else {
                    console.log('‚ùå No triangle found at 5-6');
                }
            } else {
                console.log('‚ùå Hex 5-6 not found');
            }
        }

        // ========== MULTIPLAYER FUNCTIONALITY ==========
        
        let socket = null;
        let multiplayerMode = false;
        let myPlayerColor = null;
        let currentRoomCode = null;
        let opponentConnected = false;

        // Initialize Socket.IO connection
        function initializeMultiplayerConnection() {
            // Connect to server (change this to your server URL in production)
            // Check if we're on file:// protocol or localhost
            let serverURL;
            if (window.location.protocol === 'file:' || 
                window.location.hostname === '' || 
                window.location.hostname === 'localhost' || 
                window.location.hostname === '127.0.0.1') {
                serverURL = 'http://localhost:3000';
            } else {
                serverURL = window.location.origin;
            }
            
            console.log('üîå Connecting to multiplayer server:', serverURL);
            socket = io(serverURL);
            
            // Connection events
            socket.on('connect', () => {
                console.log('‚úÖ Connected to multiplayer server');
                updateConnectionStatus('connected', 'Connected');
            });
            
            socket.on('disconnect', () => {
                console.log('‚ùå Disconnected from server');
                updateConnectionStatus('disconnected', 'Disconnected');
                if (multiplayerMode && opponentConnected) {
                    showNotification('‚ö†Ô∏è Connection lost to server', 'warning');
                }
            });
            
            socket.on('connect_error', (error) => {
                console.error('‚ùå Connection error:', error);
                updateConnectionStatus('disconnected', 'Server not found');
                document.getElementById('mp-error-message').textContent = 
                    '‚ö†Ô∏è Cannot connect to server. Make sure the server is running (npm start)';
            });
            
            // Room created
            socket.on('room-created', (data) => {
                console.log('üéÆ Room created:', data);
                currentRoomCode = data.roomCode;
                myPlayerColor = data.playerColor;
                multiplayerMode = true;
                
                // Update UI
                document.getElementById('room-code-display').textContent = data.roomCode;
                showView('mp-create-room');
                updateConnectionStatus('waiting', 'Waiting for opponent...');
                document.getElementById('player-color-display').textContent = myPlayerColor.toUpperCase();
                document.getElementById('current-room-code').textContent = data.roomCode;
                document.getElementById('room-info').style.display = 'block';
                document.getElementById('multiplayer-status').style.display = 'block';
            });
            
            // Opponent joined
            socket.on('opponent-joined', (data) => {
                console.log('üë§ Opponent joined:', data);
                opponentConnected = true;
                showNotification(`‚úÖ Opponent joined! You are ${myPlayerColor.toUpperCase()}`, 'success');
            });
            
            // Room joined
            socket.on('room-joined', (data) => {
                console.log('‚úÖ Joined room:', data);
                currentRoomCode = data.roomCode;
                myPlayerColor = data.playerColor;
                multiplayerMode = true;
                opponentConnected = true;
                
                // Update UI
                updateConnectionStatus('connected', 'Connected to game');
                document.getElementById('player-color-display').textContent = myPlayerColor.toUpperCase();
                document.getElementById('current-room-code').textContent = data.roomCode;
                document.getElementById('room-info').style.display = 'block';
                document.getElementById('multiplayer-status').style.display = 'block';
                
                showNotification(`‚úÖ Joined as ${myPlayerColor.toUpperCase()}!`, 'success');
            });
            
            // Game start
            socket.on('game-start', (data) => {
                console.log('üéÆ Game starting:', data);
                closeMultiplayerModal();
                
            // Hide start menu
            document.getElementById('start-menu').style.display = 'none';
            // Show game board
            document.getElementById('board-display-container').style.display = 'block';
            
            // Mark that we're now in an active game
            gameInProgress = true;
            
                // Initialize board
            initializeBoard('full');
                aiEnabled = false;
            currentTurnPiece = null;
            escapeRaceNotificationShown = false;
            clearMovementHistory();
            clearMoveRepetitions();
            clearCoordinateLabels();
            highlightThreatenedPieces();
                
                showNotification(`üéÆ Game started! ${data.currentPlayer.toUpperCase()} goes first`, 'info');
            });
            
            // Move made by opponent
            socket.on('move-made', (data) => {
                if (data.playerColor === myPlayerColor) return; // Ignore our own moves
                
                console.log('üì• Opponent move:', data);
                
                // Apply the move
                applyOpponentMove(data.move, data.gameState);
            });
            
            // Turn ended
            socket.on('turn-ended', (data) => {
                console.log('üîÑ Turn ended:', data);
                currentPlayer = data.currentPlayer;
                updateTurnDisplay();
                highlightThreatenedPieces();
                
                if (currentPlayer === myPlayerColor) {
                    showNotification('‚ú® Your turn!', 'info');
                }
            });
            
            // Game ended
            socket.on('game-ended', (data) => {
                console.log('üèÜ Game ended:', data);
                showGameOver(data.winner, data.reason);
            });
            
            // Room errors
            socket.on('room-error', (data) => {
                console.error('‚ùå Room error:', data.message);
                document.getElementById('mp-error-message').textContent = data.message;
            });
            
            // Opponent disconnected
            socket.on('opponent-disconnected', (data) => {
                console.log('‚ö†Ô∏è Opponent disconnected:', data);
                opponentConnected = false;
                showNotification(`‚ö†Ô∏è ${data.message}`, 'warning');
            });
            
            // Room closed
            socket.on('room-closed', (data) => {
                console.log('üóëÔ∏è Room closed:', data.reason);
                showNotification(`Room closed: ${data.reason}`, 'warning');
                resetMultiplayerState();
            });
        }
        
        // Multiplayer UI Functions
        function openMultiplayerModal() {
            if (!socket) {
                initializeMultiplayerConnection();
            }
            document.getElementById('multiplayer-modal').classList.add('active');
            showView('mp-main-menu');
        }
        
        function closeMultiplayerModal() {
            document.getElementById('multiplayer-modal').classList.remove('active');
        }
        
        function showView(viewId) {
            // Hide all views
            document.getElementById('mp-main-menu').style.display = 'none';
            document.getElementById('mp-create-room').style.display = 'none';
            document.getElementById('mp-join-room').style.display = 'none';
            
            // Show requested view
            document.getElementById(viewId).style.display = 'block';
        }
        
        function createMultiplayerRoom() {
            if (!socket || !socket.connected) {
                document.getElementById('mp-error-message').textContent = 'Connecting to server...';
                setTimeout(() => {
                    if (socket && socket.connected) {
                        createMultiplayerRoom();
                    } else {
                        document.getElementById('mp-error-message').textContent = 'Failed to connect to server';
                    }
                }, 2000);
                return;
            }
            
            // Request room creation
            socket.emit('create-room', {
                gameMode: 'full',
                initialPieces: getPiecePositions()
            });
        }
        
        function showJoinRoom() {
            showView('mp-join-room');
            document.getElementById('mp-error-message').textContent = '';
            document.getElementById('room-code-input').value = '';
        }
        
        function joinMultiplayerRoom() {
            const roomCode = document.getElementById('room-code-input').value.trim().toUpperCase();
            
            if (roomCode.length !== 6) {
                document.getElementById('mp-error-message').textContent = 'Room code must be 6 characters';
                return;
            }
            
            if (!socket || !socket.connected) {
                document.getElementById('mp-error-message').textContent = 'Not connected to server';
                return;
            }
            
            document.getElementById('mp-error-message').textContent = '';
            socket.emit('join-room', { roomCode: roomCode });
        }
        
        function cancelCreateRoom() {
            if (socket && currentRoomCode) {
                socket.disconnect();
                socket = null;
            }
            resetMultiplayerState();
            showView('mp-main-menu');
        }
        
        function backToMultiplayerMenu() {
            showView('mp-main-menu');
            document.getElementById('mp-error-message').textContent = '';
        }
        
        function updateConnectionStatus(status, text) {
            const indicator = document.getElementById('connection-indicator');
            const textElement = document.getElementById('connection-text');
            
            indicator.className = 'status-indicator ' + status;
            textElement.textContent = text;
        }
        
        function resetMultiplayerState() {
            multiplayerMode = false;
            myPlayerColor = null;
            currentRoomCode = null;
            opponentConnected = false;
            document.getElementById('multiplayer-status').style.display = 'none';
            document.getElementById('room-info').style.display = 'none';
        }
        
        // Game state synchronization functions
        function getPiecePositions() {
            const pieces = [];
            document.querySelectorAll('.hexagon').forEach(hex => {
                const piece = hex.querySelector('[class*="-piece"]');
                if (piece) {
                    pieces.push({
                        hexId: hex.id,
                        classes: piece.className
                    });
                }
            });
            return pieces;
        }
        
        function broadcastMove(fromId, toId, pieceClasses, captured) {
            // Don't broadcast in dev mode or if no socket
            if (!multiplayerMode || !socket || myPlayerColor === 'both') return;
            
            socket.emit('make-move', {
                move: {
                    from: fromId,
                    to: toId,
                    piece: pieceClasses,
                    captured: captured
                },
                gameState: {
                    currentPlayer: currentPlayer,
                    pieces: getPiecePositions(),
                    triangleOrientations: Object.fromEntries(triangleOrientations)
                }
            });
        }
        
        function broadcastTurnEnd() {
            if (!multiplayerMode || !socket) return;
            
            socket.emit('end-turn', {
                gameState: {
                    currentPlayer: currentPlayer,
                    pieces: getPiecePositions(),
                    triangleOrientations: Object.fromEntries(triangleOrientations),
                    moveHistory: moveHistory
                }
            });
        }
        
        function broadcastGameOver(winner, reason) {
            // Don't broadcast in dev mode
            if (!multiplayerMode || !socket || myPlayerColor === 'both') return;
            
            socket.emit('game-over', {
                winner: winner,
                reason: reason
            });
        }
        
        function applyOpponentMove(move, gameState) {
            // Find and move the piece
            const fromHex = document.getElementById(move.from);
            const toHex = document.getElementById(move.to);
            
            if (!fromHex || !toHex) return;
            
            const piece = fromHex.querySelector('[class*="-piece"]');
            if (!piece) return;
            
            // Handle capture
            const existingPiece = toHex.querySelector('[class*="-piece"]');
            if (existingPiece) {
                addToEliminatedPieces(existingPiece);
                existingPiece.remove();
                playSound('capture');
            } else {
                playSound('click');
            }
            
            // Move piece
            toHex.appendChild(piece);
            
            // Highlight the opponent's last move
            highlightLastMove(move.from, move.to);
            
            // Update game state
            if (gameState.triangleOrientations) {
                triangleOrientations = new Map(Object.entries(gameState.triangleOrientations));
            }
            
            // Update turn display
            updateTurnDisplay();
            highlightThreatenedPieces();
        }
        
        function showNotification(message, type = 'info') {
            // Create notification element
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 140px;
                right: 20px;
                background: ${type === 'success' ? '#26de81' : type === 'warning' ? '#ffa502' : '#4ecdc4'};
                color: white;
                padding: 15px 20px;
                border-radius: 10px;
                box-shadow: 0 4px 15px rgba(0,0,0,0.3);
                z-index: 10000;
                font-weight: bold;
                animation: slideIn 0.3s ease;
            `;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            // Remove after 3 seconds
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }
        
        // Override switchTurn to broadcast in multiplayer
        const originalSwitchTurn = window.switchTurn;
        window.switchTurn = function() {
            if (multiplayerMode && myPlayerColor !== 'both') {
                // Only allow turn switch if it's our turn (except in dev mode)
                if (currentPlayer !== myPlayerColor) {
                    console.log('Not your turn!');
                    return;
                }
            }
            
            // Call original function
            if (originalSwitchTurn) {
                originalSwitchTurn();
            }
            
            // Broadcast turn end in multiplayer (but not in dev mode)
            if (multiplayerMode && myPlayerColor !== 'both') {
                broadcastTurnEnd();
            }
        };
        
        // Override showGameOver to broadcast in multiplayer
        const originalShowGameOver = window.showGameOver;
        window.showGameOver = function(winner, reason) {
            // Call original function
            if (originalShowGameOver) {
                originalShowGameOver(winner, reason);
            }
            
            // Broadcast game over in multiplayer
            if (multiplayerMode) {
                broadcastGameOver(winner, reason);
            }
        };
        
        // ========== DEV MODE (Local Testing) ==========
        
        function startDevMode() {
            console.log('üîß Starting Dev Mode - Local Multiplayer Test');
            
            // Simulate multiplayer mode without server
            multiplayerMode = true;
            myPlayerColor = 'both'; // Special mode - control both players
            currentRoomCode = 'DEV-MODE';
            opponentConnected = true;
            
            // Update UI
            updateConnectionStatus('connected', 'Dev Mode Active');
            document.getElementById('player-color-display').textContent = 'BOTH (DEV)';
            document.getElementById('current-room-code').textContent = 'DEV-MODE';
            document.getElementById('room-info').style.display = 'block';
            document.getElementById('multiplayer-status').style.display = 'block';
            
            // Close modal and start game
            closeMultiplayerModal();
            
            // Hide start menu
            document.getElementById('start-menu').style.display = 'none';
            // Show game board
            document.getElementById('board-display-container').style.display = 'block';
            // Initialize board
            initializeBoard('full');
            aiEnabled = false;
            currentTurnPiece = null;
            escapeRaceNotificationShown = false;
            clearMovementHistory();
            clearMoveRepetitions();
            clearCoordinateLabels();
            highlightThreatenedPieces();
            
            showNotification('üîß Dev Mode: You can move both Black and White pieces!', 'info');
            
            console.log('‚úÖ Dev Mode active - you can control both players locally');
        }

        // Function to show start menu
        function showStartMenu() {
            // Hide game over overlay if it exists
            const gameOverOverlay = document.querySelector('[style*="position: fixed"][style*="z-index: 1000"]');
            if (gameOverOverlay) {
                gameOverOverlay.remove();
            }
            
            // If we're in an active game, don't reset the game state
            if (!gameInProgress) {
                // Stop and reset timers
                stopTimer();
                timerEnabled = false;
                const playerTimersEl = document.getElementById('player-timers');
                if (playerTimersEl) playerTimersEl.style.display = 'none';
                
                // Reset game state
                gameOver = false;
                currentPlayer = 'black';
                currentTurnPiece = null;
                gameMode = 'full';
                
                // Reset board to original configuration
                resetBoardToOriginal();
                
                // Reset turn display
                updateTurnDisplay();
            }
            
            // Show/hide return to game button based on game state
            const returnToGameContainer = document.getElementById('return-to-game-container');
            if (returnToGameContainer) {
                returnToGameContainer.style.display = gameInProgress ? 'block' : 'none';
            }
            
            // Hide splash page
            const splashPage = document.getElementById('splash-page');
            if (splashPage) splashPage.style.display = 'none';
            
            // Show start menu
            const startMenuEl = document.getElementById('start-menu');
            if (startMenuEl) startMenuEl.style.display = 'flex';
            // Hide game board
            const boardDisplayEl = document.getElementById('board-display-container');
            if (boardDisplayEl) boardDisplayEl.style.display = 'none';
            // Hide AI reasoning panel
            const aiPanelEl = document.getElementById('ai-reasoning-panel');
            if (aiPanelEl) aiPanelEl.style.display = 'none';
        }
        
        // Function to return to active game
        function returnToGame() {
            // Hide start menu
            const startMenuEl = document.getElementById('start-menu');
            if (startMenuEl) startMenuEl.style.display = 'none';
            
            // Show game board
            const boardDisplayEl = document.getElementById('board-display-container');
            if (boardDisplayEl) boardDisplayEl.style.display = 'block';
            
            // Show AI reasoning panel if AI is enabled
            const aiPanelEl = document.getElementById('ai-reasoning-panel');
            if (aiPanelEl && aiEnabled) aiPanelEl.style.display = 'block';
            
            // Reset gameInProgress flag
            gameInProgress = false;
        }
        
        function showAIModelSelector() {
            // Create model selector overlay
            const overlay = document.createElement('div');
            overlay.id = 'ai-model-overlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 2000;
            `;
            
            const selector = document.createElement('div');
            selector.style.cssText = `
                background: linear-gradient(135deg, #1e3c72, #2a5298);
                border: 2px solid #00d2ff;
                border-radius: 20px;
                padding: 30px;
                max-width: 500px;
                width: 90%;
                color: white;
                box-shadow: 0 10px 50px rgba(0, 210, 255, 0.5);
            `;
            
            selector.innerHTML = `
                <h2 style="text-align: center; color: #00d2ff; margin-bottom: 20px;">üß† Select AI Model</h2>
                <p style="text-align: center; font-size: 0.9em; color: #aaa; margin-bottom: 30px;">
                    Choose which AI model to play against (Mockup - uses same algorithm with different personalities)
                </p>
                
                <div style="display: flex; flex-direction: column; gap: 15px;">
                    <button class="ai-model-option" data-model="claude-sonnet" style="
                        background: linear-gradient(45deg, #8b5cf6, #7c3aed);
                        border: 2px solid ${currentAIModel === 'claude-sonnet' ? '#00d2ff' : 'transparent'};
                        color: white;
                        padding: 15px;
                        border-radius: 12px;
                        cursor: pointer;
                        font-size: 1.1em;
                        font-weight: bold;
                        transition: all 0.3s ease;
                    ">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span style="font-size: 1.5em;">üß†</span>
                            <div style="text-align: left;">
                                <div>Claude Sonnet 3.5</div>
                                <div style="font-size: 0.7em; font-weight: normal; opacity: 0.8;">Analytical, methodical thinking</div>
                            </div>
                        </div>
                    </button>
                    
                    <button class="ai-model-option" data-model="gpt4" style="
                        background: linear-gradient(45deg, #10b981, #059669);
                        border: 2px solid ${currentAIModel === 'gpt4' ? '#00d2ff' : 'transparent'};
                        color: white;
                        padding: 15px;
                        border-radius: 12px;
                        cursor: pointer;
                        font-size: 1.1em;
                        font-weight: bold;
                        transition: all 0.3s ease;
                    ">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span style="font-size: 1.5em;">ü§ñ</span>
                            <div style="text-align: left;">
                                <div>GPT-4 Turbo</div>
                                <div style="font-size: 0.7em; font-weight: normal; opacity: 0.8;">Strategic, calculated moves</div>
                            </div>
                        </div>
                    </button>
                    
                    <button class="ai-model-option" data-model="grok" style="
                        background: linear-gradient(45deg, #f59e0b, #d97706);
                        border: 2px solid ${currentAIModel === 'grok' ? '#00d2ff' : 'transparent'};
                        color: white;
                        padding: 15px;
                        border-radius: 12px;
                        cursor: pointer;
                        font-size: 1.1em;
                        font-weight: bold;
                        transition: all 0.3s ease;
                    ">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span style="font-size: 1.5em;">üöÄ</span>
                            <div style="text-align: left;">
                                <div>Grok 2</div>
                                <div style="font-size: 0.7em; font-weight: normal; opacity: 0.8;">Aggressive, bold playstyle</div>
                            </div>
                        </div>
                    </button>
                    
                    <button class="ai-model-option" data-model="gemini" style="
                        background: linear-gradient(45deg, #3b82f6, #2563eb);
                        border: 2px solid ${currentAIModel === 'gemini' ? '#00d2ff' : 'transparent'};
                        color: white;
                        padding: 15px;
                        border-radius: 12px;
                        cursor: pointer;
                        font-size: 1.1em;
                        font-weight: bold;
                        transition: all 0.3s ease;
                    ">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span style="font-size: 1.5em;">‚ú®</span>
                            <div style="text-align: left;">
                                <div>Gemini Pro</div>
                                <div style="font-size: 0.7em; font-weight: normal; opacity: 0.8;">Pattern-focused, precise</div>
                            </div>
                        </div>
                    </button>
                </div>
                
                <button id="close-model-selector" style="
                    width: 100%;
                    background-color: #ef4444;
                    color: white;
                    border: none;
                    padding: 12px;
                    border-radius: 12px;
                    cursor: pointer;
                    font-weight: bold;
                    margin-top: 20px;
                    font-size: 1em;
                ">
                    CANCEL
                </button>
            `;
            
            overlay.appendChild(selector);
            document.body.appendChild(overlay);
            
            // Add event listeners
            document.querySelectorAll('.ai-model-option').forEach(btn => {
                btn.onmouseover = function() { this.style.transform = 'scale(1.02)'; };
                btn.onmouseout = function() { this.style.transform = 'scale(1)'; };
                btn.onclick = function() {
                    const model = this.dataset.model;
                    currentAIModel = model;
                    updateAIModelDisplay();
                    overlay.remove();
                };
            });
            
            document.getElementById('close-model-selector').onclick = () => overlay.remove();
            overlay.onclick = (e) => {
                if (e.target === overlay) overlay.remove();
            };
        }
        
        // Function to reset board to original full game configuration
        function resetBoardToOriginal() {
            // Remove all pieces from all hexes first
            const allHexes = document.querySelectorAll('.hexagon');
            allHexes.forEach(hex => {
                const pieces = hex.querySelectorAll('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                pieces.forEach(piece => piece.remove());
            });
            
            // Restore original pieces
            // White triangle at 1-0
            const hex10 = document.getElementById('hex-1-0');
            const triangle10 = document.createElement('div');
            triangle10.className = 'triangle-piece white-triangle';
            triangle10.draggable = true;
            hex10.appendChild(triangle10);
            
            // Black triangle at 1-6
            const hex16 = document.getElementById('hex-1-6');
            const triangle16 = document.createElement('div');
            triangle16.className = 'triangle-piece';
            triangle16.draggable = true;
            hex16.appendChild(triangle16);
            
            // White circle at 2-0
            const hex20 = document.getElementById('hex-2-0');
            const circle20 = document.createElement('div');
            circle20.className = 'circle-piece white-circle';
            circle20.draggable = true;
            hex20.appendChild(circle20);
            
            // Black hexgon at 2-7
            const hex27 = document.getElementById('hex-2-7');
            const hexgon27 = document.createElement('div');
            hexgon27.className = 'hexgon-piece';
            hexgon27.draggable = true;
            hex27.appendChild(hexgon27);
            
            // White rhombus at 3-0
            const hex30 = document.getElementById('hex-3-0');
            const rhombus30 = document.createElement('div');
            rhombus30.className = 'rhombus-piece white-rhombus';
            rhombus30.draggable = true;
            hex30.appendChild(rhombus30);
            
            // Black rhombus at 3-8
            const hex38 = document.getElementById('hex-3-8');
            const rhombus38 = document.createElement('div');
            rhombus38.className = 'rhombus-piece';
            rhombus38.draggable = true;
            hex38.appendChild(rhombus38);
            
            // White hexgon at 4-0
            const hex40 = document.getElementById('hex-4-0');
            const hexgon40 = document.createElement('div');
            hexgon40.className = 'hexgon-piece white-hexgon';
            hexgon40.draggable = true;
            hex40.appendChild(hexgon40);
            
            // Black circle at 4-7
            const hex47 = document.getElementById('hex-4-7');
            const circle47 = document.createElement('div');
            circle47.className = 'circle-piece';
            circle47.draggable = true;
            hex47.appendChild(circle47);
            
            // White triangle at 5-0
            const hex50 = document.getElementById('hex-5-0');
            const triangle50 = document.createElement('div');
            triangle50.className = 'triangle-piece white-triangle';
            triangle50.draggable = true;
            hex50.appendChild(triangle50);
            
            // Black triangle at 5-6
            const hex56 = document.getElementById('hex-5-6');
            const triangle56 = document.createElement('div');
            triangle56.className = 'triangle-piece';
            triangle56.draggable = true;
            hex56.appendChild(triangle56);
            
            // White square at 0-0
            const hex00 = document.getElementById('hex-0-0');
            const square00 = document.createElement('div');
            square00.className = 'square-piece white-piece';
            square00.draggable = true;
            hex00.appendChild(square00);
            
            // Black square at 6-0
            const hex60 = document.getElementById('hex-6-0');
            const square60 = document.createElement('div');
            square60.className = 'square-piece';
            square60.draggable = true;
            hex60.appendChild(square60);
            
            // Re-setup drag and drop
            setupDragAndDrop();
        }

        // Function to show help
        function showHelp() {
            const helpOverlay = document.createElement('div');
            helpOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 1500;
                color: white;
                font-family: 'Arial', sans-serif;
            `;
            
            const helpContent = document.createElement('div');
            helpContent.style.cssText = `
                background: rgba(0, 0, 0, 0.9);
                padding: 30px;
                border-radius: 15px;
                border: 2px solid #4ecdc4;
                max-width: 600px;
                text-align: left;
                max-height: 80vh;
                overflow-y: auto;
            `;
            
            helpContent.innerHTML = `
                <h2 style="color: #4ecdc4; text-align: center; margin-bottom: 20px;">üéÆ ROMGON - COMPLETE GUIDE</h2>
                
                <h3 style="color: #ff6b6b;">üéØ Victory Conditions</h3>
                <p><strong>Black:</strong> Move rhombus to 3-0 | <strong>White:</strong> Move rhombus to 3-8</p>
                <p><strong>Base Defence:</strong> Cannot win if opponent's rhombus is at their base!</p>
                <p><strong>Deadlock (Checkmate):</strong> Win if opponent's rhombus is under attack with no legal moves!</p>
                <p><strong>Escape Race:</strong> When only rhombuses remain, first to goal wins (Base Defence disabled)!</p>
                <p><strong>Three-Fold Repetition:</strong> Opponent loses if they repeat the same move 3 times!</p>
                
                <h3 style="color: #4ecdc4;">üéÆ Controls</h3>
                <ul>
                    <li><strong>Drag & Drop:</strong> Click and drag pieces to move</li>
                    <li><strong>Valid Moves:</strong> Shown in GREEN when dragging</li>
                    <li><strong>Attack Moves:</strong> Shown in RED when dragging</li>
                    <li><strong>Threat Warning:</strong> RED circle on pieces under attack</li>
                </ul>
                
                <h3 style="color: #ffd93d;">üî∑ Piece Types & Movement</h3>
                <ul>
                    <li><strong>Squares:</strong> Move in straight lines (4 adjacent directions)</li>
                    <li><strong>Triangles:</strong> Move in triangular patterns (3 directions) + ROTATION!</li>
                    <li><strong>Rhombuses:</strong> Complex diagonal movement, key to winning! (Black at 3-8, White at 3-0)</li>
                    <li><strong>Circles:</strong> Zone-based movement - move/attack within perimeter rings (Black at 4-7, White at 2-0)</li>
                    <li><strong>Hexgons:</strong> Move to all 6 adjacent neighboring hexes (Black at 2-7, White at 4-0)</li>
                </ul>
                
                <h3 style="color: #00d2ff;">‚≠ï Circle Movement System</h3>
                <ul>
                    <li><strong>Zone Movement:</strong> Circles move within their current perimeter zone</li>
                    <li><strong>4 Zones:</strong> Dead (center - blocked), Inner, Middle, Outer</li>
                    <li><strong>Zone Change:</strong> Use gateway hexes to move between zones (ends turn)</li>
                    <li><strong>Friendly Blocking:</strong> Cannot jump friendly pieces - stops at first piece in path</li>
                    <li><strong>Golden Gateway Markers:</strong> Visible when dragging circles</li>
                </ul>
                
                <h3 style="color: #ff9f43;">üîÑ Triangle Rotation System</h3>
                <ul>
                    <li><strong>Move + Rotate:</strong> Triangles can move AND rotate in same turn</li>
                    <li><strong>Rotation Buttons:</strong> LEFT/RIGHT buttons appear after moving</li>
                    <li><strong>Free Rotation:</strong> Rotate as many times as needed</li>
                    <li><strong>KEEP Button:</strong> End turn without rotating</li>
                    <li><strong>No Attack + Rotate:</strong> Cannot rotate after attacking</li>
                </ul>
                
                <h3 style="color: #ff6b6b;">‚ö†Ô∏è Game Rules</h3>
                <ul>
                    <li><strong>Turn-based:</strong> Black starts first</li>
                    <li><strong>One Piece Per Turn:</strong> Can only move/rotate ONE piece per turn</li>
                    <li><strong>Rhombus Protection:</strong> Rhombuses cannot attack other rhombuses</li>
                    <li><strong>Game Over:</strong> If any rhombus is eliminated</li>
                    <li><strong>Base Defence:</strong> Active when rhombus is at starting position (3-0 for white, 3-8 for black)</li>
                    <li><strong>Friendly Blocking:</strong> Cannot move to hexes occupied by friendly pieces</li>
                    <li><strong>Attack to Capture:</strong> Move to opponent's hex to eliminate their piece</li>
                </ul>
                
                <h3 style="color: #e74c3c;">‚ôüÔ∏è Deadlock (Checkmate & Stalemate) System</h3>
                <ul>
                    <li><strong>Checkmate:</strong> Opponent's rhombus is UNDER ATTACK and has NO legal moves ‚Üí You Win!</li>
                    <li><strong>Stalemate:</strong> If you have NO legal moves ‚Üí You Lose! (Must resign manually)</li>
                    <li><strong>Check Protection:</strong> You CANNOT move if it puts your rhombus under attack...</li>
                    <li><strong>Exception:</strong> ...UNLESS you capture the attacking piece in the same move!</li>
                    <li><strong>Legal Moves:</strong> Rhombus can move to empty hex OR capture a non-rhombus piece</li>
                    <li><strong>Automatic Detection:</strong> Game checks for checkmate after each turn ends</li>
                    <li><strong>Strategy:</strong> Trap opponent's rhombus with attack, or trap all their pieces!</li>
                </ul>
                
                <h3 style="color: #ff6b6b;">‚öîÔ∏è Escape Race Mode</h3>
                <ul>
                    <li><strong>Activation:</strong> When ALL other pieces are eliminated (only rhombuses remain)</li>
                    <li><strong>Base Defence DISABLED:</strong> Rhombus at base can no longer block opponent's win</li>
                    <li><strong>First to Goal Wins:</strong> Race to reach your goal position (3-0 for Black, 3-8 for White)</li>
                    <li><strong>No Draws:</strong> One player MUST reach their goal before the other</li>
                    <li><strong>Visual Alert:</strong> Game displays "ESCAPE RACE!" notification when mode activates</li>
                    <li><strong>Forced Movement:</strong> If you have ONLY your rhombus left, Base Defence no longer works - must move!</li>
                </ul>
                
                <h3 style="color: #c0392b;">üîÑ Five-Fold Shuttle Repetition Loss</h3>
                <ul>
                    <li><strong>Anti-Stalling Rule:</strong> Prevents infinite shuttling between positions</li>
                    <li><strong>Shuttle Pattern:</strong> Moving between same 2 positions (A‚ÜíB and B‚ÜíA count as SAME shuttle!)</li>
                    <li><strong>Five Shuttles Maximum:</strong> Each shuttle pattern can only be used 5 times TOTAL - then you LOSE!</li>
                    <li><strong>NEVER Resets:</strong> Shuttle counters are permanent across the entire game - cannot be reset!</li>
                    <li><strong>Captures Don't Count:</strong> Making a capture doesn't count toward shuttle limit</li>
                    <li><strong>Tactical Repositioning:</strong> You CAN retreat/advance 2-3 times, but must eventually commit to new positions!</li>
                    <li><strong>‚ö†Ô∏è Visual Warnings:</strong> Moves are color-coded in tracking panel:
                        <ul style="margin-top: 5px;">
                            <li>üü° <strong>Orange (3/5):</strong> Third shuttle - WARNING!</li>
                            <li>üü† <strong>Dark Orange (4/5):</strong> Fourth shuttle - DANGER!</li>
                            <li>üî¥ <strong>Red (5/5):</strong> Fifth shuttle - LOSS!</li>
                        </ul>
                    </li>
                    <li><strong>Example:</strong> Square 1-2‚Üí1-3 (1‚úÖ), 1-3‚Üí1-2 (2‚úÖ), 1-2‚Üí1-3 (3‚ö†Ô∏è), 1-3‚Üí1-2 (4üî•), 1-2‚Üí1-3 (5üíÄ LOSS!)</li>
                    <li><strong>Strategy:</strong> Manage your shuttle budget wisely - each pair of positions has only 5 uses!</li>
                </ul>
                
                <h3 style="color: #a55eea;">üéµ Audio Features</h3>

                <h3 style="color: #ffd700;">‚ö° Advanced Features</h3>
                <ul>
                    <li><strong>Repetition Detection:</strong> Three-fold repetition rule, draw offers, and visual warnings.</li>
                    <li><strong>Base Defense System:</strong> Prevents early base captures, toggleable in settings.</li>
                    <li><strong>Threat Analysis:</strong> Real-time threat and checkmate detection, highlights threatened pieces.</li>
                    <li><strong>Show All Moves:</strong> Toggle to display all legal moves and rotations for current player.</li>
                    <li><strong>Defense Highlights:</strong> Highlights pieces defended by others, optional toggle.</li>
                    <li><strong>Dark Mode:</strong> Switch between light/dark themes, remembers your preference.</li>
                    <li><strong>Game Variants:</strong> Blitz, Fog of War, King of the Hill (see Quick Reference for more).</li>
                    <li><strong>Statistics Dashboard:</strong> Win/loss tracking, piece performance, progress charts, personal records (planned).</li>
                </ul>

                <h3 style="color: #a55eea;">üéµ Audio Features</h3>
                <ul>
                    <li><strong>Move Sound:</strong> Click sound when moving pieces</li>
                    <li><strong>Capture Sound:</strong> Special sound when capturing</li>
                    <li><strong>Win Sound:</strong> Victory sound when winning</li>
                </ul>
                
                <h3 style="color: #26de81;">üìä Game Features</h3>
                <ul>
                    <li><strong>Movement Tracking:</strong> See all moves in side panels (separated by player)</li>
                    <li><strong>Eliminated Pieces:</strong> View captured pieces on sides</li>
                    <li><strong>Coordinate Toggle:</strong> Show/hide hex coordinates (button next to menu)</li>
                    <li><strong>Threat Detection:</strong> Visual warnings for vulnerable pieces</li>
                    <li><strong>Undo Button:</strong> Revert last move (pieces, captures, turn state)</li>
                    <li><strong>Base Defence Indicators:</strong> Shows when rhombus is defending base</li>
                </ul>
                
                <h3 style="color: #ffa502;">üé≤ Game Modes</h3>
                <ul>
                    <li><strong>Full Game:</strong> All 5 piece types (Squares, Triangles, Rhombuses, Circles, Hexgons)</li>
                    <li><strong>Square Attack Mode:</strong> Simplified variant with only Squares and Rhombuses - perfect for learning!</li>
                </ul>
                
                <div style="text-align: center; margin-top: 20px;">
                    <button onclick="this.parentElement.parentElement.parentElement.remove()" style="
                        background-color: #4ecdc4;
                        color: white;
                        border: none;
                        padding: 10px 25px;
                        border-radius: 20px;
                        cursor: pointer;
                        font-weight: bold;
                    ">Close Help</button>
                </div>
            `;
            
            helpOverlay.appendChild(helpContent);
            document.body.appendChild(helpOverlay);
        }


        // Function to check if piece belongs to current player
        function isCurrentPlayerPiece(piece) {
            // Block ALL moves if AI is thinking
            if (aiThinking) return false;
            
            const isWhite = piece.classList.contains('white-piece') || 
                           piece.classList.contains('white-triangle') || 
                           piece.classList.contains('white-rhombus') ||
                           piece.classList.contains('white-circle') ||
                           piece.classList.contains('white-hexgon');
            
            // In AI mode, player can ONLY play Black pieces
            if (aiEnabled && isWhite) return false;
            
            // Return true if it's the current player's piece
            // Note: Board flip doesn't change piece ownership, only visual perspective
            return (currentPlayer === 'white' && isWhite) || (currentPlayer === 'black' && !isWhite);
        }

        // ========== LLM AI MOCKUP ==========
        
        function updateAIModelDisplay() {
            const modelData = {
                'claude-sonnet': { name: 'Claude', icon: 'üß†' },
                'gpt4': { name: 'GPT-4', icon: 'ü§ñ' },
                'grok': { name: 'Grok', icon: 'üöÄ' },
                'gemini': { name: 'Gemini', icon: '‚ú®' }
            };
            const model = modelData[currentAIModel] || { name: 'AI', icon: 'üß†' };
            document.getElementById('ai-model-name').textContent = model.name;
            document.getElementById('ai-model-icon').textContent = model.icon;
        }
        
        function makeLLMAIMove() {
            console.log('üß† LLM AI thinking...');
            
            // Show thinking status
            document.getElementById('ai-thinking-status').textContent = '‚è≥';
            document.getElementById('ai-reasoning-text').textContent = 'Analyzing...';
            document.getElementById('ai-move-text').textContent = '‚ö° Calculating...';
            
            // Quick delay for visual feedback (500ms)
            const thinkingDelay = 500;
            
            setTimeout(() => {
                // Get all valid moves (same as regular AI)
                const whitePieces = document.querySelectorAll('.white-piece, .white-triangle, .white-rhombus, .white-circle, .white-hexgon');
                const validMoves = [];
                
                whitePieces.forEach(piece => {
                    const pieceHex = piece.closest('.hexagon');
                    if (!pieceHex) return;
                    
                    const pieceId = pieceHex.id;
                    const [, fromRow, fromCol] = pieceId.match(/hex-(\d+)-(\d+)/);
                    
                    let pieceType = 'square';
                    if (piece.classList.contains('triangle-piece')) pieceType = 'triangle';
                    else if (piece.classList.contains('rhombus-piece')) pieceType = 'rhombus';
                    else if (piece.classList.contains('circle-piece')) pieceType = 'circle';
                    else if (piece.classList.contains('hexgon-piece')) pieceType = 'hexgon';
                    
                    const moves = getPossibleMoves(parseInt(fromRow), parseInt(fromCol), pieceType, true);
                    moves.forEach(move => {
                        validMoves.push({
                            piece: piece,
                            fromRow: parseInt(fromRow),
                            fromCol: parseInt(fromCol),
                            toRow: move.row,
                            toCol: move.col,
                            isCapture: move.isCapture,
                            type: pieceType,
                            score: evaluateMove(parseInt(fromRow), parseInt(fromCol), move.row, move.col, pieceType, move.isCapture)
                        });
                    });
                });
                
                if (validMoves.length === 0) {
                    console.log('üß† LLM AI has no valid moves!');
                    aiThinking = false;
                    switchTurn();
                    return;
                }
                
                // Sort by score
                validMoves.sort((a, b) => b.score - a.score);
                
                // Pick best move (with slight randomness for variety)
                const topMoves = validMoves.slice(0, Math.min(3, validMoves.length));
                const selectedMove = topMoves[Math.floor(Math.random() * topMoves.length)];
                
                // Generate reasoning based on move
                const reasoning = generateAIReasoning(selectedMove, validMoves);
                
                // Update display with reasoning
                document.getElementById('ai-thinking-status').textContent = '‚úÖ';
                document.getElementById('ai-reasoning-text').innerHTML = reasoning;
                
                const pieceEmoji = {
                    'square': '‚¨õ',
                    'triangle': '‚ñ≤',
                    'rhombus': '‚ô¶Ô∏è',
                    'circle': '‚ö´',
                    'hexgon': '‚¨°'
                }[selectedMove.type] || '?';
                
                document.getElementById('ai-move-text').textContent = 
                    `${pieceEmoji} ${selectedMove.fromRow}-${selectedMove.fromCol} ‚Üí ${selectedMove.toRow}-${selectedMove.toCol}`;
                
                // Execute move immediately (reasoning stays visible)
                executeAIMove(selectedMove);
                
            }, thinkingDelay);
        }
        
        function generateAIReasoning(selectedMove, allMoves) {
            const templates = getReasoningTemplates(currentAIModel);
            const template = templates[Math.floor(Math.random() * templates.length)];
            
            // Analyze board state
            const blackRhombus = document.querySelector('.rhombus-piece:not(.white-rhombus)');
            const whiteRhombus = document.querySelector('.rhombus-piece.white-rhombus');
            
            let blackRhombusPos = null;
            let whiteRhombusPos = null;
            
            if (blackRhombus) {
                const hex = blackRhombus.closest('.hexagon');
                if (hex) {
                    const [, r, c] = hex.id.match(/hex-(\d+)-(\d+)/);
                    blackRhombusPos = `${r}-${c}`;
                }
            }
            
            if (whiteRhombus) {
                const hex = whiteRhombus.closest('.hexagon');
                if (hex) {
                    const [, r, c] = hex.id.match(/hex-(\d+)-(\d+)/);
                    whiteRhombusPos = `${r}-${c}`;
                }
            }
            
            // Build compact reasoning
            let reasoning = '';
            
            // Strategic analysis (concise)
            if (selectedMove.type === 'rhombus') {
                const distanceToGoal = Math.abs(selectedMove.toRow - 3) + Math.abs(selectedMove.toCol - 8);
                reasoning += `üìç <strong>Goal distance: ${distanceToGoal}</strong><br>`;
                if (blackRhombusPos && blackRhombusPos === '3-0') {
                    reasoning += 'Black base defended - careful advance<br>';
                } else {
                    reasoning += 'Advancing toward 3-8 victory<br>';
                }
            } else if (selectedMove.isCapture) {
                reasoning += `‚öîÔ∏è <strong>Capturing ${selectedMove.type}</strong><br>`;
                reasoning += 'Weakens opponent defense<br>';
            } else {
                const positionValue = evaluatePositionStrength(selectedMove.toRow, selectedMove.toCol);
                reasoning += positionValue > 50 ? 'üéØ <strong>Strong position</strong><br>' : 'üìà <strong>Improving position</strong><br>';
            }
            
            // Threat analysis (compact)
            const threatenedCount = countThreatenedOpponentPieces(selectedMove.toRow, selectedMove.toCol, selectedMove.type);
            if (threatenedCount > 0) {
                reasoning += `üî• Threatens ${threatenedCount} piece${threatenedCount > 1 ? 's' : ''}`;
            }
            
            return reasoning;
        }
        
        function evaluatePositionStrength(row, col) {
            let strength = 0;
            // Central positions are stronger
            const centerDistance = Math.abs(row - 3) + Math.abs(col - 4);
            strength += (10 - centerDistance) * 10;
            // Row 3 is critical
            if (row === 3) strength += 30;
            return strength;
        }
        
        function getReasoningTemplates(model) {
            // Compact templates for small panel
            const templates = {
                'claude-sonnet': [
                    { intro: "Analyzing holistically...", conclusion: "" },
                    { intro: "Systematic evaluation:", conclusion: "" },
                    { intro: "Multi-factor analysis:", conclusion: "" }
                ],
                'gpt4': [
                    { intro: "Position evaluated:", conclusion: "" },
                    { intro: "Optimal path identified:", conclusion: "" }
                ],
                'grok': [
                    { intro: "Let's get tactical!", conclusion: "" },
                    { intro: "Spicy play incoming:", conclusion: "" }
                ],
                'gemini': [
                    { intro: "Pattern recognized:", conclusion: "" },
                    { intro: "Strategic path detected:", conclusion: "" }
                ]
            };
            
            return templates[model] || templates['claude-sonnet'];
        }
        
        // ========== AI LOGIC ==========
        
        function makeAIMove() {
            console.log('ü§ñ AI thinking...');
            console.log('ü§ñ AI enabled:', aiEnabled);
            console.log('ü§ñ Current player:', currentPlayer);
            console.log('ü§ñ Game over:', gameOver);
            aiThinking = true; // Lock player input
            
            // If LLM mode, use simulated AI model
            if (llmMode) {
                makeLLMAIMove();
                return;
            }
            
            // Get all White pieces
            const whitePieces = document.querySelectorAll('.white-piece, .white-triangle, .white-rhombus, .white-circle, .white-hexgon');
            console.log('ü§ñ Found white pieces:', whitePieces.length);
            
            // Check if white rhombus is trapped
            const whiteRhombus = document.querySelector('.rhombus-piece.white-rhombus');
            if (whiteRhombus) {
                const rhombusHex = whiteRhombus.closest('.hexagon');
                if (rhombusHex) {
                    const [, rRow, rCol] = rhombusHex.id.match(/hex-(\d+)-(\d+)/);
                    const rhombusMoves = getPossibleMoves(parseInt(rRow), parseInt(rCol), 'rhombus', true);
                    if (rhombusMoves.length === 0) {
                        console.log('‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è CRITICAL ALERT: White rhombus is TRAPPED at', rRow, '-', rCol, '!');
                        console.log('‚ö†Ô∏è Rhombus has ZERO legal moves! AI must free it or move it if possible!');
                    } else {
                        console.log('‚úÖ White rhombus at', rRow, '-', rCol, 'has', rhombusMoves.length, 'legal moves');
                    }
                }
            }
            
            const validMoves = [];
            const validRotations = [];
            
            // Find all valid moves for all white pieces
            whitePieces.forEach(piece => {
                const pieceHex = piece.closest('.hexagon');
                if (!pieceHex) return;
                
                const pieceId = pieceHex.id;
                const [, fromRow, fromCol] = pieceId.match(/hex-(\d+)-(\d+)/);
                
                // Get piece type
                let pieceType = 'square';
                if (piece.classList.contains('triangle-piece')) pieceType = 'triangle';
                else if (piece.classList.contains('rhombus-piece')) pieceType = 'rhombus';
                else if (piece.classList.contains('circle-piece')) pieceType = 'circle';
                else if (piece.classList.contains('hexgon-piece')) pieceType = 'hexgon';
                
                // Get possible moves for this piece
                const moves = getPossibleMoves(parseInt(fromRow), parseInt(fromCol), pieceType, true);
                moves.forEach(move => {
                    // Basic evaluation for single move
                    const singleScore = evaluateMove(parseInt(fromRow), parseInt(fromCol), move.row, move.col, pieceType, move.isCapture);
                    
                    // Multi-move lookahead evaluation (only for hard difficulty)
                    let lookaheadScore = 0;
                    if (aiDifficulty === 'hard') {
                        lookaheadScore = evaluateMultiMoveLookahead(
                            parseInt(fromRow), parseInt(fromCol),
                            move.row, move.col,
                            pieceType, move.isCapture
                        );
                    }
                    
                    validMoves.push({
                        piece: piece,
                        fromRow: parseInt(fromRow),
                        fromCol: parseInt(fromCol),
                        toRow: move.row,
                        toCol: move.col,
                        isCapture: move.isCapture,
                        type: pieceType,
                        isRotation: false,
                        score: singleScore,
                        lookaheadScore: lookaheadScore,
                        totalScore: singleScore + (lookaheadScore * 0.3) // Weight lookahead at 30%
                    });
                });
                
                // For Triangle and Hexagon pieces, also consider rotation actions
                // But only if the piece hasn't already acted this turn
                if (pieceType === 'triangle' || pieceType === 'hexgon') {
                    const actions = pieceActions.get(pieceId) || {moved: false, attacked: false, rotated: false};
                    
                    // Only allow rotation if piece hasn't moved, attacked, or rotated yet
                    if (!actions.moved && !actions.attacked && !actions.rotated) {
                        const rotationEvals = evaluateRotationOptions(parseInt(fromRow), parseInt(fromCol), pieceType, pieceId);
                        rotationEvals.forEach(rotEval => {
                            // Only add rotation if it actually improves the position (score > 0)
                            if (rotEval.score > 0) {
                                validRotations.push({
                                    piece: piece,
                                    pieceId: pieceId,
                                    fromRow: parseInt(fromRow),
                                    fromCol: parseInt(fromCol),
                                    type: pieceType,
                                    isRotation: true,
                                    rotationDirection: rotEval.direction,
                                    newOrientation: rotEval.newOrientation,
                                    score: rotEval.score,
                                    lookaheadScore: 0,
                                    totalScore: rotEval.score
                                });
                            }
                        });
                    }
                }
            });
            
            // Combine moves and rotations
            const allActions = [...validMoves, ...validRotations];
            
            if (allActions.length === 0) {
                console.log('ü§ñ AI has no valid actions!');
                console.log('ü§ñ White pieces found:', whitePieces.length);
                console.log('ü§ñ Valid moves found:', validMoves.length);
                console.log('ü§ñ Valid rotations found (before filtering):', validRotations.length);
                console.log('‚ö†Ô∏è AI is stuck! Possible stalemate situation.');
                aiThinking = false;
                
                // Check if this is a stalemate
                if (whitePieces.length > 0) {
                    alert('‚ö†Ô∏è AI has no valid moves! Possible stalemate - the game may be drawn.');
                }
                return;
            }
            
            console.log('ü§ñ AI found', validMoves.length, 'moves and', validRotations.length, 'rotation options');
            
            // Log action breakdown
            if (allActions.length > 0) {
                const moveActions = allActions.filter(a => !a.isRotation);
                const rotateActions = allActions.filter(a => a.isRotation);
                console.log(`ü§ñ Action breakdown: ${moveActions.length} moves, ${rotateActions.length} rotations (total: ${allActions.length})`);
                
                // If only rotations available and they're all negative, something is wrong
                if (moveActions.length === 0 && rotateActions.length > 0) {
                    console.log('‚ö†Ô∏è WARNING: AI only has rotation options, no movement options!');
                    const bestRotationScore = Math.max(...rotateActions.map(r => r.totalScore));
                    console.log(`‚ö†Ô∏è Best rotation score: ${bestRotationScore.toFixed(1)}`);
                    
                    // If even rotations don't help, we might be stuck
                    if (bestRotationScore < -40) {
                        console.log('‚ö†Ô∏è All rotations are poor choices. AI may be in trouble.');
                    }
                }
            }
            
            // Sort all actions by total score (includes lookahead for hard mode)
            allActions.sort((a, b) => b.totalScore - a.totalScore);
            
            // Log top 3 moves for debugging
            if (aiDifficulty === 'hard') {
                console.log('ü§ñ Top 3 moves with lookahead:');
                allActions.slice(0, 3).forEach((action, i) => {
                    if (action.isRotation) {
                        console.log(`  ${i+1}. Rotate ${action.type} at ${action.fromRow}-${action.fromCol} ${action.rotationDirection} | Total: ${action.totalScore.toFixed(1)}`);
                    } else {
                        console.log(`  ${i+1}. ${action.type} ${action.fromRow}-${action.fromCol} ‚Üí ${action.toRow}-${action.toCol} | Single: ${action.score.toFixed(1)}, Lookahead: ${action.lookaheadScore.toFixed(1)}, Total: ${action.totalScore.toFixed(1)}`);
                    }
                });
            }
            
            // Select action based on difficulty
            let selectedAction;
            if (aiDifficulty === 'easy') {
                // Easy: Random action from bottom 50%
                const bottomHalf = allActions.slice(Math.floor(allActions.length / 2));
                selectedAction = bottomHalf[Math.floor(Math.random() * bottomHalf.length)];
            } else if (aiDifficulty === 'medium') {
                // Medium: Random action from top 50%
                const topHalf = allActions.slice(0, Math.ceil(allActions.length / 2));
                selectedAction = topHalf[Math.floor(Math.random() * topHalf.length)];
            } else {
                // Hard: Always best action (with lookahead)
                selectedAction = allActions[0];
            }
            
            if (selectedAction.isRotation) {
                console.log(`ü§ñ AI chose: Rotate ${selectedAction.type} at ${selectedAction.fromRow}-${selectedAction.fromCol} ${selectedAction.rotationDirection} (score: ${selectedAction.totalScore.toFixed(1)})`);
                executeAIRotation(selectedAction);
            } else {
                console.log(`ü§ñ AI chose: ${selectedAction.type} ${selectedAction.fromRow}-${selectedAction.fromCol} ‚Üí ${selectedAction.toRow}-${selectedAction.toCol} (total: ${selectedAction.totalScore.toFixed(1)})`);
                executeAIMove(selectedAction);
            }
        }
        
        // Evaluate multi-move lookahead: What happens after this move?
        function evaluateMultiMoveLookahead(fromRow, fromCol, toRow, toCol, pieceType, isCapture) {
            let lookaheadScore = 0;
            
            // Simulate the move temporarily
            const simulatedState = simulateMove(fromRow, fromCol, toRow, toCol, pieceType, isCapture);
            if (!simulatedState) return 0; // Invalid simulation
            
            // Evaluate follow-up opportunities from the new position
            const followUpMoves = getFollowUpMoves(toRow, toCol, pieceType, simulatedState);
            
            // Score based on follow-up opportunities
            followUpMoves.forEach(followUp => {
                // Can we capture something valuable next turn?
                if (followUp.isCapture) {
                    lookaheadScore += 50;
                    
                    // Extra bonus for capturing high-value pieces
                    if (followUp.capturedType === 'rhombus') lookaheadScore += 200;
                    else if (followUp.capturedType === 'triangle') lookaheadScore += 40;
                    else if (followUp.capturedType === 'hexgon') lookaheadScore += 35;
                    else if (followUp.capturedType === 'circle') lookaheadScore += 30;
                    else if (followUp.capturedType === 'square') lookaheadScore += 25;
                }
                
                // Can we threaten opponent's rhombus?
                if (followUp.threatenRhombus) {
                    lookaheadScore += 150;
                }
                
                // Can we advance our rhombus toward goal?
                if (pieceType === 'rhombus' && followUp.advanceToGoal) {
                    const distanceToGoal = Math.abs(followUp.toRow - 3) + Math.abs(followUp.toCol - 8);
                    lookaheadScore += (20 - distanceToGoal) * 10;
                }
                
                // Can we create multiple threats (fork)?
                if (followUp.createsFork) {
                    lookaheadScore += 80;
                }
            });
            
            // Check opponent's best response
            const opponentBestResponse = evaluateOpponentResponse(toRow, toCol, pieceType, simulatedState);
            
            // Penalty if opponent can counter-attack effectively
            if (opponentBestResponse.canCapture) {
                lookaheadScore -= 60;
                if (pieceType === 'rhombus') lookaheadScore -= 200; // CRITICAL: Don't lose rhombus!
            }
            
            // Penalty if opponent can threaten our rhombus
            if (opponentBestResponse.threatensOurRhombus) {
                lookaheadScore -= 120;
            }
            
            // Bonus if this move sets up a winning sequence
            if (opponentBestResponse.cannotPreventWin) {
                lookaheadScore += 500; // Forced win in 2 moves!
            }
            
            // Mobility evaluation: Do we have good options from new position?
            const mobilityAfterMove = followUpMoves.length;
            lookaheadScore += mobilityAfterMove * 5;
            
            // Clean up simulation
            cleanupSimulation(simulatedState);
            
            return lookaheadScore;
        }
        
        // Simulate a move and return the game state (temporary DOM manipulation)
        function simulateMove(fromRow, fromCol, toRow, toCol, pieceType, isCapture) {
            const fromHex = document.getElementById(`hex-${fromRow}-${fromCol}`);
            const toHex = document.getElementById(`hex-${toRow}-${toCol}`);
            
            if (!fromHex || !toHex) return null;
            
            const piece = fromHex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
            if (!piece) return null;
            
            // Store original state
            const originalState = {
                fromHex: fromHex,
                toHex: toHex,
                piece: piece.cloneNode(true),
                capturedPiece: null
            };
            
            // If capture, store the captured piece
            if (isCapture) {
                const captured = toHex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                if (captured) {
                    originalState.capturedPiece = captured.cloneNode(true);
                    captured.remove();
                }
            }
            
            // Move the piece (temporarily)
            toHex.appendChild(piece);
            
            return originalState;
        }
        
        // Get follow-up moves from a position
        function getFollowUpMoves(row, col, pieceType, simulatedState) {
            const followUps = [];
            
            // Get possible moves from this position
            const moves = getPossibleMoves(row, col, pieceType, true);
            
            moves.forEach(move => {
                const targetHex = document.getElementById(`hex-${move.row}-${move.col}`);
                if (!targetHex) return;
                
                const followUp = {
                    toRow: move.row,
                    toCol: move.col,
                    isCapture: move.isCapture,
                    capturedType: null,
                    threatenRhombus: false,
                    advanceToGoal: false,
                    createsFork: false
                };
                
                // Check what we'd capture
                if (move.isCapture) {
                    const targetPiece = targetHex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                    if (targetPiece) {
                        if (targetPiece.classList.contains('triangle-piece')) followUp.capturedType = 'triangle';
                        else if (targetPiece.classList.contains('rhombus-piece')) followUp.capturedType = 'rhombus';
                        else if (targetPiece.classList.contains('hexgon-piece')) followUp.capturedType = 'hexgon';
                        else if (targetPiece.classList.contains('circle-piece')) followUp.capturedType = 'circle';
                        else if (targetPiece.classList.contains('square-piece')) followUp.capturedType = 'square';
                    }
                }
                
                // Check if threatening opponent's rhombus
                const blackRhombus = document.querySelector('.rhombus-piece:not(.white-rhombus)');
                if (blackRhombus) {
                    const rhombusHex = blackRhombus.closest('.hexagon');
                    if (rhombusHex) {
                        const [, rRow, rCol] = rhombusHex.id.match(/hex-(\d+)-(\d+)/);
                        if (move.row == rRow && move.col == rCol) {
                            followUp.threatenRhombus = true;
                        }
                    }
                }
                
                // Check if advancing rhombus toward goal
                if (pieceType === 'rhombus') {
                    const distanceToGoal = Math.abs(move.row - 3) + Math.abs(move.col - 8);
                    const currentDistance = Math.abs(row - 3) + Math.abs(col - 8);
                    if (distanceToGoal < currentDistance) {
                        followUp.advanceToGoal = true;
                    }
                }
                
                // Check if creating a fork (multiple threats)
                const threatsFromNewPos = countThreatsFromPosition(move.row, move.col, pieceType);
                if (threatsFromNewPos >= 2) {
                    followUp.createsFork = true;
                }
                
                followUps.push(followUp);
            });
            
            return followUps;
        }
        
        // Count how many opponent pieces we threaten from a position
        function countThreatsFromPosition(row, col, pieceType) {
            let threats = 0;
            const moves = getPossibleMoves(row, col, pieceType, true);
            
            moves.forEach(move => {
                const targetHex = document.getElementById(`hex-${move.row}-${move.col}`);
                if (targetHex && move.isCapture) {
                    const targetPiece = targetHex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                    if (targetPiece) {
                        const isBlack = !targetPiece.classList.contains('white-piece') && 
                                       !targetPiece.classList.contains('white-triangle') && 
                                       !targetPiece.classList.contains('white-rhombus') &&
                                       !targetPiece.classList.contains('white-circle') &&
                                       !targetPiece.classList.contains('white-hexgon');
                        if (isBlack) threats++;
                    }
                }
            });
            
            return threats;
        }
        
        // Evaluate opponent's best response to our move
        function evaluateOpponentResponse(ourRow, ourCol, ourPieceType, simulatedState) {
            const response = {
                canCapture: false,
                threatensOurRhombus: false,
                cannotPreventWin: false
            };
            
            // Check if opponent can capture our piece at new position
            const blackPieces = document.querySelectorAll('.square-piece:not(.white-piece), .triangle-piece:not(.white-triangle), .rhombus-piece:not(.white-rhombus), .circle-piece:not(.white-circle), .hexgon-piece:not(.white-hexgon)');
            
            blackPieces.forEach(blackPiece => {
                const blackHex = blackPiece.closest('.hexagon');
                if (!blackHex) return;
                
                const [, bRow, bCol] = blackHex.id.match(/hex-(\d+)-(\d+)/);
                
                // Get piece type
                let blackType = 'square';
                if (blackPiece.classList.contains('triangle-piece')) blackType = 'triangle';
                else if (blackPiece.classList.contains('rhombus-piece')) blackType = 'rhombus';
                else if (blackPiece.classList.contains('circle-piece')) blackType = 'circle';
                else if (blackPiece.classList.contains('hexgon-piece')) blackType = 'hexgon';
                
                // Check if this black piece can attack our new position
                const blackMoves = getPossibleMoves(parseInt(bRow), parseInt(bCol), blackType, false);
                blackMoves.forEach(move => {
                    if (move.row == ourRow && move.col == ourCol) {
                        response.canCapture = true;
                    }
                });
            });
            
            // Check if opponent can threaten our rhombus
            const whiteRhombus = document.querySelector('.rhombus-piece.white-rhombus');
            if (whiteRhombus) {
                const rhombusHex = whiteRhombus.closest('.hexagon');
                if (rhombusHex) {
                    const [, rRow, rCol] = rhombusHex.id.match(/hex-(\d+)-(\d+)/);
                    
                    blackPieces.forEach(blackPiece => {
                        const blackHex = blackPiece.closest('.hexagon');
                        if (!blackHex) return;
                        
                        const [, bRow, bCol] = blackHex.id.match(/hex-(\d+)-(\d+)/);
                        let blackType = 'square';
                        if (blackPiece.classList.contains('triangle-piece')) blackType = 'triangle';
                        else if (blackPiece.classList.contains('rhombus-piece')) blackType = 'rhombus';
                        else if (blackPiece.classList.contains('circle-piece')) blackType = 'circle';
                        else if (blackPiece.classList.contains('hexgon-piece')) blackType = 'hexgon';
                        
                        const blackMoves = getPossibleMoves(parseInt(bRow), parseInt(bCol), blackType, false);
                        blackMoves.forEach(move => {
                            if (move.row == rRow && move.col == rCol) {
                                response.threatensOurRhombus = true;
                            }
                        });
                    });
                }
            }
            
            // Check if we're setting up a forced win (simplified check)
            if (ourPieceType === 'rhombus') {
                const distanceToGoal = Math.abs(ourRow - 3) + Math.abs(ourCol - 8);
                if (distanceToGoal <= 2 && !response.canCapture) {
                    response.cannotPreventWin = true;
                }
            }
            
            return response;
        }
        
        // Clean up simulated move
        function cleanupSimulation(simulatedState) {
            if (!simulatedState) return;
            
            // Move piece back to original position
            const currentHex = simulatedState.piece.closest('.hexagon');
            if (currentHex) {
                simulatedState.piece.remove();
            }
            simulatedState.fromHex.appendChild(simulatedState.piece);
            
            // Restore captured piece if any
            if (simulatedState.capturedPiece) {
                simulatedState.toHex.appendChild(simulatedState.capturedPiece);
            }
        }
        
        // Evaluate rotation options for Triangle or Hexagon pieces
        function evaluateRotationOptions(row, col, pieceType, pieceId) {
            const rotations = [];
            
            // Get current orientation
            let currentOrientation;
            if (pieceType === 'triangle') {
                currentOrientation = getTriangleOrientation(pieceId);
            } else if (pieceType === 'hexgon') {
                currentOrientation = getHexgonOrientation(pieceId);
            }
            
            // Evaluate rotating left and right
            ['left', 'right'].forEach(direction => {
                let newOrientation = currentOrientation;
                if (direction === 'left') {
                    newOrientation = (currentOrientation - 1 + 6) % 6;
                } else {
                    newOrientation = (currentOrientation + 1) % 6;
                }
                
                // Calculate score for this rotation
                const score = evaluateRotation(row, col, pieceType, currentOrientation, newOrientation);
                
                rotations.push({
                    direction: direction,
                    newOrientation: newOrientation,
                    score: score
                });
            });
            
            return rotations;
        }
        
        // Evaluate the value of rotating a piece
        function evaluateRotation(row, col, pieceType, currentOrientation, newOrientation) {
            let score = 0;
            
            // Get moves with current orientation
            let currentMoves = [];
            if (pieceType === 'triangle') {
                currentMoves = getRotatedTriangleTargets(row, col, currentOrientation, true);
            } else if (pieceType === 'hexgon') {
                currentMoves = getRotatedHexgonTargets(row, col, currentOrientation, true);
            }
            
            // Get moves with new orientation
            let newMoves = [];
            if (pieceType === 'triangle') {
                newMoves = getRotatedTriangleTargets(row, col, newOrientation, true);
            } else if (pieceType === 'hexgon') {
                newMoves = getRotatedHexgonTargets(row, col, newOrientation, true);
            }
            
            // If orientations have the same effective pattern (0==3, 1==4, 2==5), heavily penalize
            const effectiveCurrent = currentOrientation % 3;
            const effectiveNew = newOrientation % 3;
            if (effectiveCurrent === effectiveNew) {
                score -= 1000; // Don't rotate to same effective position!
                return score;
            }
            
            // Mobility bonus: More moves = better
            const mobilityDiff = newMoves.length - currentMoves.length;
            score += mobilityDiff * 15;
            
            // Check if new orientation creates attack opportunities
            let currentAttacks = 0;
            let newAttacks = 0;
            
            // Count attacks on opponent pieces with current orientation
            currentMoves.forEach(([targetRow, targetCol]) => {
                const targetHex = document.getElementById(`hex-${targetRow}-${targetCol}`);
                if (targetHex) {
                    const piece = targetHex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                    if (piece) {
                        const isWhite = piece.classList.contains('white-piece') || 
                                       piece.classList.contains('white-triangle') || 
                                       piece.classList.contains('white-rhombus') ||
                                       piece.classList.contains('white-circle') ||
                                       piece.classList.contains('white-hexgon');
                        if (!isWhite) currentAttacks++;
                    }
                }
            });
            
            // Count attacks on opponent pieces with new orientation
            newMoves.forEach(([targetRow, targetCol]) => {
                const targetHex = document.getElementById(`hex-${targetRow}-${targetCol}`);
                if (targetHex) {
                    const piece = targetHex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                    if (piece) {
                        const isWhite = piece.classList.contains('white-piece') || 
                                       piece.classList.contains('white-triangle') || 
                                       piece.classList.contains('white-rhombus') ||
                                       piece.classList.contains('white-circle') ||
                                       piece.classList.contains('white-hexgon');
                        if (!isWhite) {
                            newAttacks++;
                            // Extra bonus for threatening rhombus
                            if (piece.classList.contains('rhombus-piece')) {
                                score += 400;
                            }
                        }
                    }
                }
            });
            
            // Attack opportunity difference
            const attackDiff = newAttacks - currentAttacks;
            score += attackDiff * 80;
            
            // If we lose attack opportunities, heavily penalize
            if (attackDiff < 0) {
                score -= 100; // Don't rotate away from attacks!
            }
            
            // Check if new orientation threatens more important pieces
            newMoves.forEach(([targetRow, targetCol]) => {
                const targetHex = document.getElementById(`hex-${targetRow}-${targetCol}`);
                if (targetHex) {
                    const piece = targetHex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                    if (piece) {
                        const isWhite = piece.classList.contains('white-piece') || 
                                       piece.classList.contains('white-triangle') || 
                                       piece.classList.contains('white-rhombus') ||
                                       piece.classList.contains('white-circle') ||
                                       piece.classList.contains('white-hexgon');
                        if (!isWhite) {
                            // Bonus based on piece value
                            if (piece.classList.contains('triangle-piece')) score += 30;
                            else if (piece.classList.contains('hexgon-piece')) score += 25;
                            else if (piece.classList.contains('circle-piece')) score += 20;
                            else if (piece.classList.contains('square-piece')) score += 15;
                        }
                    }
                }
            });
            
            // Check if new orientation opens up path to key positions
            // Bonus for attacking toward opponent's base (column 0)
            newMoves.forEach(([targetRow, targetCol]) => {
                if (targetCol < col) { // Moving toward opponent side
                    score += 10;
                }
                if (targetRow === 3) { // Center row
                    score += 8;
                }
            });
            
            // Strong penalty to prefer moving over rotating (unless rotation is clearly better)
            score -= 50;
            
            return score;
        }
        
        // Execute AI rotation action
        function executeAIRotation(action) {
            setTimeout(() => {
                const { pieceId, rotationDirection, newOrientation, type } = action;
                
                if (type === 'triangle') {
                    setTriangleOrientation(pieceId, newOrientation);
                    updateTriangleVisual(pieceId);
                    console.log(`ü§ñ AI rotated triangle at ${pieceId} ${rotationDirection} to orientation ${newOrientation}`);
                } else if (type === 'hexgon') {
                    setHexgonOrientation(pieceId, newOrientation);
                    updateHexgonVisual(pieceId);
                    console.log(`ü§ñ AI rotated hexagon at ${pieceId} ${rotationDirection} to orientation ${newOrientation}`);
                }
                
                // Mark piece as having taken action this turn
                const actions = pieceActions.get(pieceId) || {moved: false, attacked: false, rotated: false};
                actions.rotated = true;
                pieceActions.set(pieceId, actions);
                
                // End turn
                aiThinking = false;
                switchPlayer();
                
                // Play click sound
                playClickSound();
            }, 500); // Small delay for realism
        }

        function getPossibleMoves(fromRow, fromCol, pieceType, isWhite) {
            const moves = [];
            let targets = [];
            
            // Get movement pattern based on piece type
            if (pieceType === 'square') {
                targets = getSquareTargets(fromRow, fromCol);
            } else if (pieceType === 'triangle') {
                // Use rotation-aware movement for triangles
                const hexId = `hex-${fromRow}-${fromCol}`;
                const orientation = getTriangleOrientation(hexId);
                targets = getRotatedTriangleTargets(fromRow, fromCol, orientation, isWhite);
            } else if (pieceType === 'rhombus') {
                targets = getRhombusTargets(fromRow, fromCol);
            } else if (pieceType === 'circle') {
                targets = getCircleTargets(fromRow, fromCol);
            } else if (pieceType === 'hexgon') {
                targets = getHexgonTargets(fromRow, fromCol);
            }
            
            // Check each target
            targets.forEach(([targetRow, targetCol]) => {
                const targetHex = document.getElementById(`hex-${targetRow}-${targetCol}`);
                if (!targetHex) return;
                
                const existingPiece = targetHex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                
                if (!existingPiece) {
                    // Empty hex - valid move
                    moves.push({ row: targetRow, col: targetCol, isCapture: false });
                } else {
                    // Check if it's an opponent piece
                    const isExistingWhite = existingPiece.classList.contains('white-piece') || 
                                           existingPiece.classList.contains('white-triangle') || 
                                           existingPiece.classList.contains('white-rhombus') ||
                                           existingPiece.classList.contains('white-circle') ||
                                           existingPiece.classList.contains('white-hexgon');
                    
                    if (isWhite !== isExistingWhite) {
                        // Opponent piece - check if can attack
                        if (pieceType !== 'rhombus' || !existingPiece.classList.contains('rhombus-piece')) {
                            moves.push({ row: targetRow, col: targetCol, isCapture: true });
                        }
                    }
                }
            });
            
            return moves;
        }
        
        function getSquareTargets(row, col) {
            const targets = [];
            let offsets = [];
            
            if (row === 0) offsets = [[1, 0], [1, 1], [-1, 1], [-1, 0]];
            else if (row === 1) offsets = [[1, 0], [1, 1], [-1, -1], [-1, 0]];
            else if (row === 2) offsets = [[1, 0], [1, 1], [-1, -1], [-1, 0]];
            else if (row === 3) offsets = [[1, -1], [1, 0], [-1, 0], [-1, -1]];
            else if (row === 4) offsets = [[-1, 0], [-1, 1], [1, -1], [1, 0]];
            else if (row === 5) offsets = [[1, 0], [1, 1], [-1, -1], [-1, 0]];
            else if (row === 6) offsets = [[1, 0], [1, 1], [-1, 1], [-1, 0]];
            
            offsets.forEach(([dr, dc]) => {
                const newRow = row + dr;
                const newCol = col + dc;
                if (newRow >= 0 && newRow <= 6 && newCol >= 0) targets.push([newRow, newCol]);
            });
            
            return targets;
        }
        
        function getWhiteTriangleTargets(row, col) {
            const targets = [];
            let offsets = [];
            
            if (row === 0) offsets = [[1, 1], [-1, 1], [0, 1]];
            else if (row === 1) offsets = [[1, 1], [-1, 0], [0, 1]];
            else if (row === 2) offsets = [[1, 1], [-1, 0], [0, 1]];
            else if (row === 3) offsets = [[1, 0], [0, 1], [-1, 0]];
            else if (row === 4) offsets = [[1, 0], [0, 1], [-1, 1]];
            else if (row === 5) offsets = [[1, 0], [0, 1], [-1, 1]];
            else if (row === 6) offsets = [[1, 1], [-1, 1], [0, 1]];
            
            offsets.forEach(([dr, dc]) => {
                const newRow = row + dr;
                const newCol = col + dc;
                if (newRow >= 0 && newRow <= 6 && newCol >= 0) targets.push([newRow, newCol]);
            });
            
            return targets;
        }
        
        function getBlackTriangleTargets(row, col) {
            // Black triangle movement pattern - opposite direction from white triangles
            // Return OFFSETS, not absolute coordinates
            if (row === 0) return [[1, 0], [-1, 0], [0, -1]];
            else if (row === 1) return [[1, 0], [-1, -1], [0, -1]];
            else if (row === 2) return [[1, 0], [-1, -1], [0, -1]];
            else if (row === 3) return [[1, -1], [0, -1], [-1, -1]];
            else if (row === 4) return [[1, -1], [0, -1], [-1, 0]];
            else if (row === 5) return [[1, -1], [0, -1], [-1, 0]];
            else if (row === 6) return [[1, 0], [-1, 0], [0, -1]];
            else return [];
        }
        
        function getRhombusTargets(row, col) {
            return getRhombusMoves(row, col);
        }
        
        function getCircleTargets(row, col) {
            // Circle logic with proper blocking for AI
            const coord = `${row}-${col}`;
            let zoneOrder = null;
            
            // Determine which zone and get the ORDER array (not the Set!)
            if (circleInnerZone.has(coord)) {
                zoneOrder = circleInnerOrder;
            } else if (circleMiddleZone.has(coord)) {
                zoneOrder = circleMiddleOrder;
            } else if (circleOuterZone.has(coord)) {
                zoneOrder = circleOuterOrder;
            }
            
            // If not in any zone (dead zone), return empty
            if (!zoneOrder || !Array.isArray(zoneOrder)) {
                console.log(`Circle at ${coord} not in any valid zone!`);
                return [];
            }
            
            const targets = [];
            const startIdx = zoneOrder.indexOf(coord);
            
            if (startIdx === -1) {
                console.log(`Coord ${coord} not found in zone order!`);
                return [];
            }
            
            // Check clockwise direction for reachable hexes
            for (let i = (startIdx + 1) % zoneOrder.length; i !== startIdx; i = (i + 1) % zoneOrder.length) {
                const targetCoord = zoneOrder[i];
                const [r, c] = targetCoord.split('-').map(Number);
                const targetHex = document.getElementById(`hex-${r}-${c}`);
                
                if (targetHex) {
                    const piece = targetHex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                    if (piece) {
                        // Found a piece - can potentially attack it, but can't go further clockwise
                        targets.push([r, c]);
                        break;
                    } else {
                        // Empty hex - can move here
                        targets.push([r, c]);
                    }
                }
            }
            
            // Check counter-clockwise direction for reachable hexes
            for (let i = (startIdx - 1 + zoneOrder.length) % zoneOrder.length; i !== startIdx; i = (i - 1 + zoneOrder.length) % zoneOrder.length) {
                const targetCoord = zoneOrder[i];
                const [r, c] = targetCoord.split('-').map(Number);
                const targetHex = document.getElementById(`hex-${r}-${c}`);
                
                if (targetHex) {
                    const piece = targetHex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                    if (piece) {
                        // Found a piece - can potentially attack it, but can't go further counter-clockwise
                        targets.push([r, c]);
                        break;
                    } else {
                        // Empty hex - can move here
                        targets.push([r, c]);
                    }
                }
            }
            
            return targets;
        }
        
        function getHexgonTargets(row, col) {
            return getHexgonMoves(row, col);
        }
        
        function getRotatedHexgonTargets(row, col, orientation, isWhite) {
            console.log(`üîç getRotatedHexgonTargets called: row=${row}, col=${col}, orientation=${orientation}, isWhite=${isWhite}`);
            
            // Hexagons have 6 visual orientations (0-5) but only 3 unique movement patterns
            // Orientations 3, 4, 5 repeat the patterns of 0, 1, 2
            let offsets = [];
            
            if (row === 0) {
                if (col === 0) { // Position 00
                    // Orientation 0 & 3: 12-01
                    if (orientation === 0 || orientation === 3) offsets = [[1, 2], [0, 1]];
                    // Orientation 1 & 4: 21-11-12
                    else if (orientation === 1 || orientation === 4) offsets = [[2, 1], [1, 1], [1, 2]];
                    // Orientation 2 & 5: 21-10
                    else if (orientation === 2 || orientation === 5) offsets = [[2, 1], [1, 0]];
                }
                else if (col === 1) { // Position 01
                    // Orientation 0 & 3: 10-00-13-02
                    if (orientation === 0 || orientation === 3) offsets = [[1, -1], [0, -1], [1, 2], [0, 1]];
                    // Orientation 1 & 4: 22-12-13
                    else if (orientation === 1 || orientation === 4) offsets = [[2, 1], [1, 1], [1, 2]];
                    // Orientation 2 & 5: 22-11-10
                    else if (orientation === 2 || orientation === 5) offsets = [[2, 1], [1, 0], [1, -1]];
                }
                else if (col === 2) { // Position 02
                    // Orientation 0 & 3: 11-01-14-03
                    if (orientation === 0 || orientation === 3) offsets = [[1, -1], [0, -1], [1, 2], [0, 1]];
                    // Orientation 1 & 4: 23-13-14
                    else if (orientation === 1 || orientation === 4) offsets = [[2, 1], [1, 1], [1, 2]];
                    // Orientation 2 & 5: 23-12-11
                    else if (orientation === 2 || orientation === 5) offsets = [[2, 1], [1, 0], [1, -1]];
                }
                else if (col === 3) { // Position 03
                    // Orientation 0 & 3: 12-02-15-04
                    if (orientation === 0 || orientation === 3) offsets = [[1, -1], [0, -1], [1, 2], [0, 1]];
                    // Orientation 1 & 4: 24-14-15
                    else if (orientation === 1 || orientation === 4) offsets = [[2, 1], [1, 1], [1, 2]];
                    // Orientation 2 & 5: 24-13-12
                    else if (orientation === 2 || orientation === 5) offsets = [[2, 1], [1, 0], [1, -1]];
                }
                else if (col === 4) { // Position 04
                    // Orientation 0 & 3: 13-03-16-05
                    if (orientation === 0 || orientation === 3) offsets = [[1, -1], [0, -1], [1, 2], [0, 1]];
                    // Orientation 1 & 4: 25-15-16
                    else if (orientation === 1 || orientation === 4) offsets = [[2, 1], [1, 1], [1, 2]];
                    // Orientation 2 & 5: 25-14-13
                    else if (orientation === 2 || orientation === 5) offsets = [[2, 1], [1, 0], [1, -1]];
                }
                else if (col === 5) { // Position 05
                    // Orientation 0 & 3: 14-04
                    if (orientation === 0 || orientation === 3) offsets = [[1, -1], [0, -1]];
                    // Orientation 1 & 4: 26-16
                    else if (orientation === 1 || orientation === 4) offsets = [[2, 1], [1, 1]];
                    // Orientation 2 & 5: 26-15-14
                    else if (orientation === 2 || orientation === 5) offsets = [[2, 1], [1, 0], [1, -1]];
                }
            }
            else if (row === 1) {
                if (col === 0) { // Position 10
                    // Orientation 0 & 3: 22-11-01
                    if (orientation === 0 || orientation === 3) offsets = [[1, 2], [0, 1], [-1, 1]];
                    // Orientation 1 & 4: 31-21-22
                    else if (orientation === 1 || orientation === 4) offsets = [[2, 1], [1, 1], [1, 2]];
                    // Orientation 2 & 5: 00-01-20-31
                    else if (orientation === 2 || orientation === 5) offsets = [[-1, 0], [-1, 1], [1, 0], [2, 1]];
                }
                else if (col === 1) { // Position 11
                    // Orientation 0 & 3: 23-12-02-10-20
                    if (orientation === 0 || orientation === 3) offsets = [[1, 2], [0, 1], [-1, 1], [0, -1], [1, -1]];
                    // Orientation 1 & 4: 00-32-22-23
                    else if (orientation === 1 || orientation === 4) offsets = [[-1, -1], [2, 1], [1, 1], [1, 2]];
                    // Orientation 2 & 5: 01-02-20-21-32
                    else if (orientation === 2 || orientation === 5) offsets = [[-1, 0], [-1, 1], [1, -1], [1, 0], [2, 1]];
                }
                else if (col === 2) { // Position 12
                    // Orientation 0 & 3: 24-13-03-21-11-00
                    if (orientation === 0 || orientation === 3) offsets = [[1, 2], [0, 1], [-1, 1], [1, -1], [0, -1], [-1, -2]];
                    // Orientation 1 & 4: 00-01-33-23-24
                    else if (orientation === 1 || orientation === 4) offsets = [[-1, -2], [-1, -1], [2, 1], [1, 1], [1, 2]];
                    // Orientation 2 & 5: 02-03-21-22-33
                    else if (orientation === 2 || orientation === 5) offsets = [[-1, 0], [-1, 1], [1, -1], [1, 0], [2, 1]];
                }
                else if (col === 3) { // Position 13
                    // Orientation 0 & 3: 25-14-04-22-12-01
                    if (orientation === 0 || orientation === 3) offsets = [[1, 2], [0, 1], [-1, 1], [1, -1], [0, -1], [-1, -2]];
                    // Orientation 1 & 4: 01-02-34-24-25
                    else if (orientation === 1 || orientation === 4) offsets = [[-1, -2], [-1, -1], [2, 1], [1, 1], [1, 2]];
                    // Orientation 2 & 5: 03-04-21-22-23-34
                    else if (orientation === 2 || orientation === 5) offsets = [[-1, 0], [-1, 1], [1, -2], [1, -1], [1, 0], [2, 1]];
                }
                else if (col === 4) { // Position 14
                    // Orientation 0 & 3: 26-15-05-23-13-02
                    if (orientation === 0 || orientation === 3) offsets = [[1, 2], [0, 1], [-1, 1], [1, -1], [0, -1], [-1, -2]];
                    // Orientation 1 & 4: 02-03-35-25-26
                    else if (orientation === 1 || orientation === 4) offsets = [[-1, -2], [-1, -1], [2, 1], [1, 1], [1, 2]];
                    // Orientation 2 & 5: 05-04-23-24-35
                    else if (orientation === 2 || orientation === 5) offsets = [[-1, 1], [-1, 0], [1, -1], [1, 0], [2, 1]];
                }
                else if (col === 5) { // Position 15
                    // Orientation 0 & 3: 27-16-24-14-03
                    if (orientation === 0 || orientation === 3) offsets = [[1, 2], [0, 1], [1, -1], [0, -1], [-1, -2]];
                    // Orientation 1 & 4: 03-04-36-26-27
                    else if (orientation === 1 || orientation === 4) offsets = [[-1, -2], [-1, -1], [2, 1], [1, 1], [1, 2]];
                    // Orientation 2 & 5: 05-24-25-36
                    else if (orientation === 2 || orientation === 5) offsets = [[-1, 0], [1, -1], [1, 0], [2, 1]];
                }
                else if (col === 6) { // Position 16
                    // Orientation 0 & 3: 25-15-04
                    if (orientation === 0 || orientation === 3) offsets = [[1, -1], [0, -1], [-1, -2]];
                    // Orientation 1 & 4: 04-05-37-27
                    else if (orientation === 1 || orientation === 4) offsets = [[-1, -2], [-1, -1], [2, 1], [1, 1]];
                    // Orientation 2 & 5: 37-26-25
                    else if (orientation === 2 || orientation === 5) offsets = [[2, 1], [1, 0], [1, -1]];
                }
            }
            else if (row === 2) {
                if (col === 0) { // Position 20
                    // Orientation 0 & 3: 32-21-11 = [3,2],[2,1],[1,1]
                    if (orientation === 0 || orientation === 3) offsets = [[1, 2], [0, 1], [-1, 1]];
                    // Orientation 1 & 4: 40-31-32 = [4,0],[3,1],[3,2]
                    else if (orientation === 1 || orientation === 4) offsets = [[2, 0], [1, 1], [1, 2]];
                    // Orientation 2 & 5: 10-11-30-40 = [1,0],[1,1],[3,0],[4,0]
                    else if (orientation === 2 || orientation === 5) offsets = [[-1, 0], [-1, 1], [1, 0], [2, 0]];
                }
                else if (col === 1) { // Position 21
                    // Orientation 0 & 3: 20-30-33-22-12 = [2,0],[3,0],[3,3],[2,2],[1,2]
                    if (orientation === 0 || orientation === 3) offsets = [[0, -1], [1, -1], [1, 2], [0, 1], [-1, 1]];
                    // Orientation 1 & 4: 10-00-41-32-33 = [1,0],[0,0],[4,1],[3,2],[3,3]
                    else if (orientation === 1 || orientation === 4) offsets = [[-1, -1], [-2, -1], [2, 0], [1, 1], [1, 2]];
                    // Orientation 2 & 5: 30-31-41-00-12-11 = [3,0],[3,1],[4,1],[0,0],[1,2],[1,1]
                    else if (orientation === 2 || orientation === 5) offsets = [[1, -1], [1, 0], [2, 0], [-2, -1], [-1, 1], [-1, 0]];
                }
                else if (col === 2) { // Position 22
                    // Orientation 0 & 3: 21-31-10-34-23-13 = [2,1],[3,1],[1,0],[3,4],[2,3],[1,3]
                    if (orientation === 0 || orientation === 3) offsets = [[0, -1], [1, -1], [-1, -2], [1, 2], [0, 1], [-1, 1]];
                    // Orientation 1 & 4: 11-10-01-42-33-34 = [1,1],[1,0],[0,1],[4,2],[3,3],[3,4]
                    else if (orientation === 1 || orientation === 4) offsets = [[-1, -1], [-1, -2], [-2, -1], [2, 0], [1, 1], [1, 2]];
                    // Orientation 2 & 5: 31-32-42-01-12-13 = [3,1],[3,2],[4,2],[0,1],[1,2],[1,3]
                    else if (orientation === 2 || orientation === 5) offsets = [[1, -1], [1, 0], [2, 0], [-2, -1], [-1, 0], [-1, 1]];
                }
                else if (col === 3) { // Position 23
                    // Orientation 0 & 3: 22-32-11-35-24-14 = [2,2],[3,2],[1,1],[3,5],[2,4],[1,4]
                    if (orientation === 0 || orientation === 3) offsets = [[0, -1], [1, -1], [-1, -2], [1, 2], [0, 1], [-1, 1]];
                    // Orientation 1 & 4: 11-12-02-43-34-35 = [1,1],[1,2],[0,2],[4,3],[3,4],[3,5]
                    else if (orientation === 1 || orientation === 4) offsets = [[-1, -2], [-1, -1], [-2, -1], [2, 0], [1, 1], [1, 2]];
                    // Orientation 2 & 5: 33-32-43-14-13-02 = [3,3],[3,2],[4,3],[1,4],[1,3],[0,2]
                    else if (orientation === 2 || orientation === 5) offsets = [[1, 0], [1, -1], [2, 0], [-1, 1], [-1, 0], [-2, -1]];
                }
                else if (col === 4) { // Position 24
                    // Orientation 0 & 3: 23-33-12-36-25-15 = [2,3],[3,3],[1,2],[3,6],[2,5],[1,5]
                    if (orientation === 0 || orientation === 3) offsets = [[0, -1], [1, -1], [-1, -2], [1, 2], [0, 1], [-1, 1]];
                    // Orientation 1 & 4: 12-13-03-44-35-36 = [1,2],[1,3],[0,3],[4,4],[3,5],[3,6]
                    else if (orientation === 1 || orientation === 4) offsets = [[-1, -2], [-1, -1], [-2, -1], [2, 0], [1, 1], [1, 2]];
                    // Orientation 2 & 5: 33-34-44-14-03-15 = [3,3],[3,4],[4,4],[1,4],[0,3],[1,5]
                    else if (orientation === 2 || orientation === 5) offsets = [[1, -1], [1, 0], [2, 0], [-1, 0], [-2, -1], [-1, 1]];
                }
                else if (col === 5) { // Position 25
                    // Orientation 0 & 3: 24-34-13-37-26-16 = [2,4],[3,4],[1,3],[3,7],[2,6],[1,6]
                    if (orientation === 0 || orientation === 3) offsets = [[0, -1], [1, -1], [-1, -2], [1, 2], [0, 1], [-1, 1]];
                    // Orientation 1 & 4: 13-14-04-45-36-37 = [1,3],[1,4],[0,4],[4,5],[3,6],[3,7]
                    else if (orientation === 1 || orientation === 4) offsets = [[-1, -2], [-1, -1], [-2, -1], [2, 0], [1, 1], [1, 2]];
                    // Orientation 2 & 5: 04-15-16-34-35-45 = [0,4],[1,5],[1,6],[3,4],[3,5],[4,5]
                    else if (orientation === 2 || orientation === 5) offsets = [[-2, -1], [-1, 0], [-1, 1], [1, -1], [1, 0], [2, 0]];
                }
                else if (col === 6) { // Position 26
                    // Orientation 0 & 3: 25-35-14-27-38 = [2,5],[3,5],[1,4],[2,7],[3,8]
                    if (orientation === 0 || orientation === 3) offsets = [[0, -1], [1, -1], [-1, -2], [0, 1], [1, 2]];
                    // Orientation 1 & 4: 14-15-05-46-38-37 = [1,4],[1,5],[0,5],[4,6],[3,8],[3,7]
                    else if (orientation === 1 || orientation === 4) offsets = [[-1, -2], [-1, -1], [-2, -1], [2, 0], [1, 2], [1, 1]];
                    // Orientation 2 & 5: 16-05-35-36-46 = [1,6],[0,5],[3,5],[3,6],[4,6]
                    else if (orientation === 2 || orientation === 5) offsets = [[-1, 0], [-2, -1], [1, -1], [1, 0], [2, 0]];
                }
                else if (col === 7) { // Position 27
                    // Orientation 0 & 3: 36-26-15 = [3,6],[2,6],[1,5]
                    if (orientation === 0 || orientation === 3) offsets = [[1, -1], [0, -1], [-1, -2]];
                    // Orientation 1 & 4: 15-16-38-47 = [1,5],[1,6],[3,8],[4,7]
                    else if (orientation === 1 || orientation === 4) offsets = [[-1, -2], [-1, -1], [1, 1], [2, 0]];
                    // Orientation 2 & 5: 36-37-47 = [3,6],[3,7],[4,7]
                    else if (orientation === 2 || orientation === 5) offsets = [[1, -1], [1, 0], [2, 0]];
                }
            }
            else if (row === 3) {
                if (col === 0) { // Position 30
                    // Orientation 0 & 3: 41-31-21
                    if (orientation === 0 || orientation === 3) offsets = [[1, 1], [0, 1], [-1, 1]];
                    // Orientation 1 & 4: 41-40
                    else if (orientation === 1 || orientation === 4) offsets = [[1, 1], [1, 0]];
                    // Orientation 2 & 5: 21-20
                    else if (orientation === 2 || orientation === 5) offsets = [[-1, 1], [-1, 0]];
                }
                else if (col === 1) { // Position 31
                    // Orientation 0 & 3: 42-32-22-30
                    if (orientation === 0 || orientation === 3) offsets = [[1, 1], [0, 1], [-1, 1], [0, -1]];
                    // Orientation 1 & 4: 50-41-40-20-10
                    else if (orientation === 1 || orientation === 4) offsets = [[2, -1], [1, 0], [1, -1], [-1, -1], [-2, -1]];
                    // Orientation 2 & 5: 10-21-22-40-50
                    else if (orientation === 2 || orientation === 5) offsets = [[-2, -1], [-1, 0], [-1, 1], [1, -1], [2, -1]];
                }
                else if (col === 2) { // Position 32
                    // Orientation 0 & 3: 40-31-20-43-33-23
                    if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -2], [1, 1], [0, 1], [-1, 1]];
                    // Orientation 1 & 4: 51-42-43-20-21-11
                    else if (orientation === 1 || orientation === 4) offsets = [[2, -1], [1, 0], [1, 1], [-1, -2], [-1, -1], [-2, -1]];
                    // Orientation 2 & 5: 40-41-51-23-22-11
                    else if (orientation === 2 || orientation === 5) offsets = [[1, -2], [1, -1], [2, -1], [-1, 1], [-1, 0], [-2, -1]];
                }
                else if (col === 3) { // Position 33
                    // Orientation 0 & 3: 41-32-21-44-34-24
                    if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -2], [1, 1], [0, 1], [-1, 1]];
                    // Orientation 1 & 4: 52-43-44-21-22-12
                    else if (orientation === 1 || orientation === 4) offsets = [[2, -1], [1, 0], [1, 1], [-1, -2], [-1, -1], [-2, -1]];
                    // Orientation 2 & 5: 52-42-41-12-23-24
                    else if (orientation === 2 || orientation === 5) offsets = [[2, -1], [1, -1], [1, -2], [-2, -1], [-1, 0], [-1, 1]];
                }
                else if (col === 4) { // Position 34
                    // Orientation 0 & 3: 42-33-22-45-35-25
                    if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -2], [1, 1], [0, 1], [-1, 1]];
                    // Orientation 1 & 4: 53-44-45-22-23-13
                    else if (orientation === 1 || orientation === 4) offsets = [[2, -1], [1, 0], [1, 1], [-1, -2], [-1, -1], [-2, -1]];
                    // Orientation 2 & 5: 53-43-42-13-24-25
                    else if (orientation === 2 || orientation === 5) offsets = [[2, -1], [1, -1], [1, -2], [-2, -1], [-1, 0], [-1, 1]];
                }
                else if (col === 5) { // Position 35
                    // Orientation 0 & 3: 43-34-23-46-36-26
                    if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -2], [1, 1], [0, 1], [-1, 1]];
                    // Orientation 1 & 4: 54-45-46-23-24-14
                    else if (orientation === 1 || orientation === 4) offsets = [[2, -1], [1, 0], [1, 1], [-1, -2], [-1, -1], [-2, -1]];
                    // Orientation 2 & 5: 54-44-43-14-25-26
                    else if (orientation === 2 || orientation === 5) offsets = [[2, -1], [1, -1], [1, -2], [-2, -1], [-1, 0], [-1, 1]];
                }
                else if (col === 6) { // Position 36
                    // Orientation 0 & 3: 44-35-24-47-37-27
                    if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -2], [1, 1], [0, 1], [-1, 1]];
                    // Orientation 1 & 4: 55-46-47-24-25-15
                    else if (orientation === 1 || orientation === 4) offsets = [[2, -1], [1, 0], [1, 1], [-1, -2], [-1, -1], [-2, -1]];
                    // Orientation 2 & 5: 55-45-44-15-26-27
                    else if (orientation === 2 || orientation === 5) offsets = [[2, -1], [1, -1], [1, -2], [-2, -1], [-1, 0], [-1, 1]];
                }
                else if (col === 7) { // Position 37
                    // Orientation 0 & 3: 45-36-25-38
                    if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -2], [0, 1]];
                    // Orientation 1 & 4: 56-47-25-26-16
                    else if (orientation === 1 || orientation === 4) offsets = [[2, -1], [1, 0], [-1, -2], [-1, -1], [-2, -1]];
                    // Orientation 2 & 5: 27-16-58-46-45
                    else if (orientation === 2 || orientation === 5) offsets = [[-1, 0], [-2, -1], [2, 1], [1, -1], [1, -2]];
                }
                else if (col === 8) { // Position 38
                    // Orientation 0 & 3: 46-37-26
                    if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -2]];
                    // Orientation 1 & 4: 56-47-25-26-16
                    else if (orientation === 1 || orientation === 4) offsets = [[2, -2], [1, -1], [-1, -3], [-1, -2], [-2, -2]];
                    // Orientation 2 & 5: 27-16-58-46-45
                    else if (orientation === 2 || orientation === 5) offsets = [[-1, -1], [-2, -2], [2, 0], [1, -2], [1, -3]];
                }
            }
            else if (row === 4) {
                if (col === 0) { // Position 40
                    // Orientation 0 & 3: 51-41-32
                    if (orientation === 0 || orientation === 3) offsets = [[1, 1], [0, 1], [-1, 2]];
                    // Orientation 1 & 4: 51-50-30-20
                    else if (orientation === 1 || orientation === 4) offsets = [[1, 1], [1, 0], [-1, 0], [-2, 0]];
                    // Orientation 2 & 5: 31-20-32
                    else if (orientation === 2 || orientation === 5) offsets = [[-1, 1], [-2, 0], [-1, 2]];
                }
                else if (col === 1) { // Position 41
                    // Orientation 0 & 3: 40-52-42-33
                    if (orientation === 0 || orientation === 3) offsets = [[0, -1], [1, 1], [0, 1], [-1, 2]];
                    // Orientation 1 & 4: 52-51-60-30-31-21
                    else if (orientation === 1 || orientation === 4) offsets = [[1, 1], [1, 0], [2, -1], [-1, -1], [-1, 0], [-2, 0]];
                    // Orientation 2 & 5: 60-50-33-32-21
                    else if (orientation === 2 || orientation === 5) offsets = [[2, -1], [1, -1], [-1, 2], [-1, 1], [-2, 0]];
                }
                else if (col === 2) { // Position 42
                    // Orientation 0 & 3: 50-41-31-53-43-34
                    if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -1], [1, 1], [0, 1], [-1, 2]];
                    // Orientation 1 & 4: 61-52-53-31-32-22
                    else if (orientation === 1 || orientation === 4) offsets = [[2, -1], [1, 0], [1, 1], [-1, -1], [-1, 0], [-2, 0]];
                    // Orientation 2 & 5: 61-51-50-34-33-22
                    else if (orientation === 2 || orientation === 5) offsets = [[2, -1], [1, -1], [1, -2], [-1, 2], [-1, 1], [-2, 0]];
                }
                else if (col === 3) { // Position 43
                    // Orientation 0 & 3: 51-42-32-54-44-35
                    if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -1], [1, 1], [0, 1], [-1, 2]];
                    // Orientation 1 & 4: 62-53-54-32-33-23
                    else if (orientation === 1 || orientation === 4) offsets = [[2, -1], [1, 0], [1, 1], [-1, -1], [-1, 0], [-2, 0]];
                    // Orientation 2 & 5: 62-52-51-35-34-23
                    else if (orientation === 2 || orientation === 5) offsets = [[2, -1], [1, -1], [1, -2], [-1, 2], [-1, 1], [-2, 0]];
                }
                else if (col === 4) { // Position 44
                    // Orientation 0 & 3: 52-43-33-55-45-36
                    if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -1], [1, 1], [0, 1], [-1, 2]];
                    // Orientation 1 & 4: 63-54-55-33-34-24
                    else if (orientation === 1 || orientation === 4) offsets = [[2, -1], [1, 0], [1, 1], [-1, -1], [-1, 0], [-2, 0]];
                    // Orientation 2 & 5: 63-53-52-36-35-24
                    else if (orientation === 2 || orientation === 5) offsets = [[2, -1], [1, -1], [1, -2], [-1, 2], [-1, 1], [-2, 0]];
                }
                else if (col === 5) { // Position 45
                    // Orientation 0 & 3: 53-44-34-56-46-37
                    if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -1], [1, 1], [0, 1], [-1, 2]];
                    // Orientation 1 & 4: 62-55-56-34-35-25
                    else if (orientation === 1 || orientation === 4) offsets = [[2, -3], [1, 0], [1, 1], [-1, -1], [-1, 0], [-2, 0]];
                    // Orientation 2 & 5: 64-54-53-37-36-25
                    else if (orientation === 2 || orientation === 5) offsets = [[2, -1], [1, -1], [1, -2], [-1, 2], [-1, 1], [-2, 0]];
                }
                else if (col === 6) { // Position 46
                    // Orientation 0 & 3: 54-45-35-47-38
                    if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -1], [0, 1], [-1, 2]];
                    // Orientation 1 & 4: 65-56-35-36-26
                    else if (orientation === 1 || orientation === 4) offsets = [[2, -1], [1, 0], [-1, -1], [-1, 0], [-2, 0]];
                    // Orientation 2 & 5: 65-55-54-38-37-26
                    else if (orientation === 2 || orientation === 5) offsets = [[2, -1], [1, -1], [1, -2], [-1, 2], [-1, 1], [-2, 0]];
                }
                else if (col === 7) { // Position 47
                    // Orientation 0 & 3: 55-46-36
                    if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -1]];
                    // Orientation 1 & 4: 56-55-38-27
                    else if (orientation === 1 || orientation === 4) offsets = [[1, -1], [1, -2], [-1, 1], [-2, 0]];
                    // Orientation 2 & 5: 56-55-38-27
                    else if (orientation === 2 || orientation === 5) offsets = [[1, -1], [1, -2], [-1, 1], [-2, 0]];
                }
            }
            else if (row === 5) {
                if (col === 0) { // Position 50
                    // Orientation 0 & 3: 61-51-42
                    if (orientation === 0 || orientation === 3) offsets = [[1, 1], [0, 1], [-1, 2]];
                    // Orientation 1 & 4: 40-31-60-61
                    else if (orientation === 1 || orientation === 4) offsets = [[-1, 0], [-2, 1], [1, 0], [1, 1]];
                    // Orientation 2 & 5: 42-41-31
                    else if (orientation === 2 || orientation === 5) offsets = [[-1, 2], [-1, 1], [-2, 1]];
                }
                else if (col === 1) { // Position 51
                    // Orientation 0 & 3: 62-52-43-50-40
                    if (orientation === 0 || orientation === 3) offsets = [[1, 1], [0, 1], [-1, 2], [0, -1], [-1, -1]];
                    // Orientation 1 & 4: 40-41-32-61-62
                    else if (orientation === 1 || orientation === 4) offsets = [[-1, -1], [-1, 0], [-2, 1], [1, 0], [1, 1]];
                    // Orientation 2 & 5: 60-43-42-32
                    else if (orientation === 2 || orientation === 5) offsets = [[1, -1], [-1, 2], [-1, 1], [-2, 1]];
                }
                else if (col === 2) { // Position 52
                    // Orientation 0 & 3: 60-51-41-63-53-44
                    if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -1], [1, 1], [0, 1], [-1, 2]];
                    // Orientation 1 & 4: 41-42-33-62-63
                    else if (orientation === 1 || orientation === 4) offsets = [[-1, -1], [-1, 0], [-2, 1], [1, 0], [1, 1]];
                    // Orientation 2 & 5: 60-61-44-43-33
                    else if (orientation === 2 || orientation === 5) offsets = [[1, -2], [1, -1], [-1, 2], [-1, 1], [-2, 1]];
                }
                else if (col === 3) { // Position 53
                    // Orientation 0 & 3: 61-52-42-64-54-45
                    if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -1], [1, 1], [0, 1], [-1, 2]];
                    // Orientation 1 & 4: 42-43-34-63-64
                    else if (orientation === 1 || orientation === 4) offsets = [[-1, -1], [-1, 0], [-2, 1], [1, 0], [1, 1]];
                    // Orientation 2 & 5: 61-62-45-44-34
                    else if (orientation === 2 || orientation === 5) offsets = [[1, -2], [1, -1], [-1, 2], [-1, 1], [-2, 1]];
                }
                else if (col === 4) { // Position 54
                    // Orientation 0 & 3: 62-53-43-65-55-46
                    if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -1], [1, 1], [0, 1], [-1, 2]];
                    // Orientation 1 & 4: 64-65-43-44-35
                    else if (orientation === 1 || orientation === 4) offsets = [[1, 0], [1, 1], [-1, -1], [-1, 0], [-2, 1]];
                    // Orientation 2 & 5: 62-63-46-45-35
                    else if (orientation === 2 || orientation === 5) offsets = [[1, -2], [1, -1], [-1, 2], [-1, 1], [-2, 1]];
                }
                else if (col === 5) { // Position 55
                    // Orientation 0 & 3: 63-54-44-56-47
                    if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -1], [0, 1], [-1, 2]];
                    // Orientation 1 & 4: 45-44-36-65
                    else if (orientation === 1 || orientation === 4) offsets = [[-1, 0], [-1, -1], [-2, 1], [1, 0]];
                    // Orientation 2 & 5: 64-63-47-46-36
                    else if (orientation === 2 || orientation === 5) offsets = [[1, -1], [1, -2], [-1, 2], [-1, 1], [-2, 1]];
                }
                else if (col === 6) { // Position 56
                    // Orientation 0 & 3: 64-55-45
                    if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -1]];
                    // Orientation 1 & 4: 45-46-37
                    else if (orientation === 1 || orientation === 4) offsets = [[-1, -1], [-1, 0], [-2, 1]];
                    // Orientation 2 & 5: 64-65-47-37
                    else if (orientation === 2 || orientation === 5) offsets = [[1, -2], [1, -1], [-1, 1], [-2, 1]];
                }
            }
            
            // If no pattern found or offsets empty, use base movement (orientation 0)
            if (offsets.length === 0) {
                console.log(`‚ö†Ô∏è No rotation pattern found for row=${row}, col=${col}, orientation=${orientation}. Using base pattern.`);
                const baseTargets = getHexgonMoves(row, col);
                console.log('üìç Base hexagon targets:', baseTargets);
                return baseTargets;
            }
            
            console.log(`üîç Hexagon pattern for ${row}-${col} orientation ${orientation}:`, offsets);
            
            // Convert offsets to absolute coordinates
            const targets = offsets.map(([dr, dc]) => [row + dr, col + dc]);
            console.log(`üéØ Hexagon target coordinates:`, targets);
            
            return targets;
        }
        
        function getRotatedTriangleTargets(row, col, orientation, isWhite) {
            console.log(`üîç getRotatedTriangleTargets called: row=${row}, col=${col}, orientation=${orientation}, isWhite=${isWhite}`);
            
            // Get the specific movement pattern for this position and orientation
            let offsets = [];
            
            if (isWhite) {
                // White triangle patterns - rotation-aware patterns (opposite to black triangles)
                // White triangles face towards black pieces, so their patterns are opposite
                if (row === 0) {
                    // Row 0 patterns - corrected based on position 0-1 observations
                    if (orientation === 0) offsets = [[0, 1], [1, 1]]; // 02-12 pattern
                    else if (orientation === 1) offsets = [[1, 0], [1, 1], [0, 1]]; // 11-12-02 pattern
                    else if (orientation === 2) offsets = [[1, 1], [1, 0], [0, -1]]; // 12-11-00 pattern
                    else if (orientation === 3) offsets = [[1, 0], [0, -1]]; // 11-00 pattern
                    else if (orientation === 4) offsets = [[0, -1]]; // 00 pattern (correct)
                    else if (orientation === 5) offsets = [[0, 1]]; // 02 pattern (correct)
                } else if (row === 1) {
                    // Row 1 patterns - corrected based on position 1-2 observations
                    if (orientation === 0) offsets = [[1, 1], [0, 1], [-1, 0]]; // 23-13-02 pattern
                    else if (orientation === 1) offsets = [[1, 0], [1, 1], [0, 1]]; // 22-23-13 pattern
                    else if (orientation === 2) offsets = [[1, 1], [1, 0], [0, -1]]; // 23-22-11 pattern
                    else if (orientation === 3) offsets = [[1, 0], [0, -1], [-1, -1]]; // 22-11-01 pattern
                    else if (orientation === 4) offsets = [[0, -1], [-1, -1], [-1, 0]]; // 11-01-02 pattern
                    else if (orientation === 5) offsets = [[-1, -1], [-1, 0], [0, 1]]; // 01-02-13 pattern
                } else if (row === 2) {
                    // Row 2 patterns - corrected based on position 2-2 observations
                    if (orientation === 0) offsets = [[1, 1], [0, 1], [-1, 0]]; // 33-23-12 pattern
                    else if (orientation === 1) offsets = [[1, 0], [1, 1], [0, 1]]; // 32-33-23 pattern
                    else if (orientation === 2) offsets = [[1, 1], [1, 0], [0, -1]]; // 33-32-21 pattern
                    else if (orientation === 3) offsets = [[1, 0], [0, -1], [-1, -1]]; // 32-21-11 pattern
                    else if (orientation === 4) offsets = [[0, -1], [-1, -1], [-1, 0]]; // 21-11-12 pattern
                    else if (orientation === 5) offsets = [[-1, -1], [-1, 0], [0, 1]]; // 11-12-23 pattern
                } else if (row === 3) {
                    // Row 3 patterns - position-specific with rotation
                    if (col === 0) {
                        if (orientation === 0 || orientation === 3) offsets = [[1, 1], [0, 1], [-1, 1]]; // 41-31-21
                        else if (orientation === 1 || orientation === 4) offsets = [[1, 1], [1, 0]]; // 41-40
                        else if (orientation === 2 || orientation === 5) offsets = [[-1, 1], [-1, 0]]; // 21-20
                    } else if (col === 1) {
                        if (orientation === 0 || orientation === 3) offsets = [[1, 1], [0, 1], [-1, 1], [0, -1]]; // 42-32-22-30
                        else if (orientation === 1 || orientation === 4) offsets = [[2, -1], [1, 0], [1, -1], [-1, -1], [-2, -1]]; // 50-41-40-20-10
                        else if (orientation === 2 || orientation === 5) offsets = [[-2, -1], [-1, 0], [-1, 1], [1, -1], [2, -1]]; // 10-21-22-40-50
                    } else if (col === 2) {
                        if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -2], [1, 1], [0, 1], [-1, 1]]; // 40-31-20-43-33-23
                        else if (orientation === 1 || orientation === 4) offsets = [[2, -1], [1, 0], [1, 1], [-1, -2], [-1, -1], [-2, -1]]; // 51-42-43-20-21-11
                        else if (orientation === 2 || orientation === 5) offsets = [[1, -2], [1, -1], [2, -1], [-1, 1], [-1, 0], [-2, -1]]; // 40-41-51-23-22-11
                    } else if (col === 3) {
                        if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -2], [1, 1], [0, 1], [-1, 1]]; // 41-32-21-44-34-24
                        else if (orientation === 1 || orientation === 4) offsets = [[2, -1], [1, 0], [1, 1], [-1, -2], [-1, -1], [-2, -1]]; // 52-43-44-21-22-12
                        else if (orientation === 2 || orientation === 5) offsets = [[2, -1], [1, -1], [1, -2], [-2, -1], [-1, 0], [-1, 1]]; // 52-42-41-12-23-24
                    } else if (col === 4) {
                        if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -2], [1, 1], [0, 1], [-1, 1]]; // 42-33-22-45-35-25
                        else if (orientation === 1 || orientation === 4) offsets = [[2, -1], [1, 0], [1, 1], [-1, -2], [-1, -1], [-2, -1]]; // 53-44-45-22-23-13
                        else if (orientation === 2 || orientation === 5) offsets = [[2, -1], [1, -1], [1, -2], [-2, -1], [-1, 0], [-1, 1]]; // 53-43-42-13-24-25
                    } else if (col === 5) {
                        if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -2], [1, 1], [0, 1], [-1, 1]]; // 43-34-23-46-36-26
                        else if (orientation === 1 || orientation === 4) offsets = [[2, -1], [1, 0], [1, 1], [-1, -2], [-1, -1], [-2, -1]]; // 54-45-46-23-24-14
                        else if (orientation === 2 || orientation === 5) offsets = [[2, -1], [1, -1], [1, -2], [-2, -1], [-1, 0], [-1, 1]]; // 54-44-43-14-25-26
                    } else if (col === 6) {
                        if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -2], [1, 1], [0, 1], [-1, 1]]; // 44-35-24-47-37-27
                        else if (orientation === 1 || orientation === 4) offsets = [[2, -1], [1, 0], [1, 1], [-1, -2], [-1, -1], [-2, -1]]; // 55-46-47-24-25-15
                        else if (orientation === 2 || orientation === 5) offsets = [[2, -1], [1, -1], [1, -2], [-2, -1], [-1, 0], [-1, 1]]; // 55-45-44-15-26-27
                    } else if (col === 7) {
                        if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -2], [0, 1]]; // 45-36-25-38
                        else if (orientation === 1 || orientation === 4) offsets = [[2, -1], [1, 0], [-1, -2], [-1, -1], [-2, -1]]; // 56-47-25-26-16
                        else if (orientation === 2 || orientation === 5) offsets = [[-1, 0], [-2, -1], [2, 1], [1, -1], [1, -2]]; // 27-16-58-46-45
                    } else if (col === 8) {
                        if (orientation === 0 || orientation === 3) offsets = [[1, -2], [0, -1], [-1, -2]]; // 46-37-26
                        else if (orientation === 1 || orientation === 4) offsets = [[2, -2], [1, -1], [-1, -3], [-1, -2], [-2, -2]]; // 56-47-25-26-16
                        else if (orientation === 2 || orientation === 5) offsets = [[-1, -1], [-2, -2], [2, 0], [1, -2], [1, -3]]; // 27-16-58-46-45
                    } else {
                        // Default fallback for any other column
                        if (orientation === 0 || orientation === 3) offsets = [[1, 0], [0, 1], [-1, 0]]; // 43-34-23 pattern
                        else if (orientation === 1 || orientation === 4) offsets = [[0, 1], [1, 0], [1, -1]]; // 34-43-42 pattern
                        else if (orientation === 2 || orientation === 5) offsets = [[1, 0], [1, -1], [0, -1]]; // 43-42-32 pattern
                    }
                } else if (row === 4) {
                    // Row 4 patterns - position-specific with rotation (mirror structure of row 2)
                    if (col === 0) {
                        if (orientation === 0 || orientation === 3) offsets = [[1, 0], [0, 1], [-1, 1]]; // 50-41-31
                        else if (orientation === 1 || orientation === 4) offsets = [[2, 0], [1, 1], [1, 0]]; // 60-51-50
                        else if (orientation === 2 || orientation === 5) offsets = [[-1, 0], [-1, 1], [1, 0], [2, 0]]; // 30-31-50-60
                    } else if (col === 1) {
                        if (orientation === 0 || orientation === 3) offsets = [[0, -1], [1, -1], [1, 2], [0, 1], [-1, 1]]; // 40-50-53-42-32
                        else if (orientation === 1 || orientation === 4) offsets = [[-1, -1], [-2, -1], [2, 0], [1, 1], [1, 2]]; // 30-20-61-52-53
                        else if (orientation === 2 || orientation === 5) offsets = [[1, -1], [1, 0], [2, 0], [-2, -1], [-1, 1], [-1, 0]]; // 50-51-61-20-32-31
                    } else if (col === 2) {
                        if (orientation === 0 || orientation === 3) offsets = [[0, -1], [1, -1], [-1, -2], [1, 2], [0, 1], [-1, 1]]; // 41-51-30-54-43-33
                        else if (orientation === 1 || orientation === 4) offsets = [[-1, -1], [-1, -2], [-2, -1], [2, 0], [1, 1], [1, 2]]; // 31-30-21-62-53-54
                        else if (orientation === 2 || orientation === 5) offsets = [[1, -1], [1, 0], [2, 0], [-2, -1], [-1, 0], [-1, 1]]; // 51-52-62-21-32-33
                    } else if (col === 3) {
                        if (orientation === 0 || orientation === 3) offsets = [[0, -1], [1, -1], [-1, -2], [1, 2], [0, 1], [-1, 1]]; // 42-52-31-55-44-34
                        else if (orientation === 1 || orientation === 4) offsets = [[-1, -2], [-1, -1], [-2, -1], [2, 0], [1, 1], [1, 2]]; // 31-32-22-63-54-55
                        else if (orientation === 2 || orientation === 5) offsets = [[1, 0], [1, -1], [2, 0], [-1, 1], [-1, 0], [-2, -1]]; // 53-52-63-34-33-22
                    } else if (col === 4) {
                        if (orientation === 0 || orientation === 3) offsets = [[0, -1], [1, -1], [-1, -2], [1, 2], [0, 1], [-1, 1]]; // 43-53-32-56-45-35
                        else if (orientation === 1 || orientation === 4) offsets = [[-1, -2], [-1, -1], [-2, -1], [2, 0], [1, 1], [1, 2]]; // 32-33-23-64-55-56
                        else if (orientation === 2 || orientation === 5) offsets = [[1, -1], [1, 0], [2, 0], [-1, 0], [-2, -1], [-1, 1]]; // 53-54-64-34-23-35
                    } else if (col === 5) {
                        if (orientation === 0 || orientation === 3) offsets = [[0, -1], [1, -1], [-1, -2], [1, 2], [0, 1], [-1, 1]]; // 44-54-33-57-46-36
                        else if (orientation === 1 || orientation === 4) offsets = [[-1, -2], [-1, -1], [-2, -1], [2, 0], [1, 1], [1, 2]]; // 33-34-24-65-56-57
                        else if (orientation === 2 || orientation === 5) offsets = [[-2, -1], [-1, 0], [-1, 1], [1, -1], [1, 0], [2, 0]]; // 24-35-36-54-55-65
                    } else if (col === 6) {
                        if (orientation === 0 || orientation === 3) offsets = [[0, -1], [1, -1], [-1, -2], [0, 1], [1, 2]]; // 45-55-34-47-58
                        else if (orientation === 1 || orientation === 4) offsets = [[-1, -2], [-1, -1], [-2, -1], [2, 0], [1, 2], [1, 1]]; // 34-35-25-66-58-57
                        else if (orientation === 2 || orientation === 5) offsets = [[-1, 0], [-2, -1], [1, -1], [1, 0], [2, 0]]; // 36-25-55-56-66
                    } else if (col === 7) {
                        if (orientation === 0 || orientation === 3) offsets = [[1, -1], [0, -1], [-1, -2]]; // 56-46-35
                        else if (orientation === 1 || orientation === 4) offsets = [[-1, -2], [-1, -1], [1, 1], [2, 0]]; // 35-36-58-67
                        else if (orientation === 2 || orientation === 5) offsets = [[1, -1], [1, 0], [2, 0]]; // 56-57-67
                    } else {
                        // Default fallback
                        if (orientation === 0 || orientation === 3) offsets = [[1, 0], [0, 1], [-1, 1]]; 
                        else if (orientation === 1 || orientation === 4) offsets = [[1, 0], [1, -1], [0, 1]]; 
                        else if (orientation === 2 || orientation === 5) offsets = [[1, 0], [1, -1], [0, -1]]; 
                    }
                } else if (row === 5) {
                    // Row 5 patterns - corrected based on position 5-1 observations
                    if (orientation === 0) offsets = [[1, 0], [0, 1], [-1, 1]]; // 61-52-42 pattern
                    else if (orientation === 1) offsets = [[1, 0], [1, -1], [0, 1]]; // 61-60-52 pattern
                    else if (orientation === 2) offsets = [[1, 0], [1, -1], [0, -1]]; // 61-60-50 pattern
                    else if (orientation === 3) offsets = [[-1, 0], [0, -1], [1, -1]]; // 41-50-60 pattern
                    else if (orientation === 4) offsets = [[-1, 0], [-1, 1], [0, -1]]; // 41-42-50 pattern
                    else if (orientation === 5) offsets = [[-1, 0], [-1, 1], [0, 1]]; // 41-42-52 pattern (correct)
                } else if (row === 6) {
                    // Row 6 patterns - using same patterns as row 5
                    if (orientation === 0) offsets = [[1, 0], [0, 1], [-1, 1]]; // 61-52-42 pattern
                    else if (orientation === 1) offsets = [[1, 0], [1, -1], [0, 1]]; // 61-60-52 pattern
                    else if (orientation === 2) offsets = [[1, 0], [1, -1], [0, -1]]; // 61-60-50 pattern
                    else if (orientation === 3) offsets = [[-1, 0], [0, -1], [1, -1]]; // 41-50-60 pattern
                    else if (orientation === 4) offsets = [[-1, 0], [-1, 1], [0, -1]]; // 41-42-50 pattern
                    else if (orientation === 5) offsets = [[-1, 0], [-1, 1], [0, 1]]; // 41-42-52 pattern
                }
            } else {
                // Black triangle patterns - specific patterns for each orientation
                // Most rows use the same rotation patterns, but some rows have special cases
                if (row === 3) {
                    // Row 3 patterns - corrected based on position 3-4 observations
                    if (orientation === 0) offsets = [[1, -1], [0, -1], [-1, -1]]; // 43-33-23 pattern
                    else if (orientation === 1) offsets = [[0, -1], [-1, -1], [-1, 0]]; // 33-23-24 pattern
                    else if (orientation === 2) offsets = [[-1, -1], [-1, 0], [0, 1]]; // 23-24-35 pattern
                    else if (orientation === 3) offsets = [[1, 0], [0, 1], [-1, 0]]; // 44-35-24 pattern
                    else if (orientation === 4) offsets = [[0, 1], [1, 0], [1, -1]]; // 56-65-64 pattern (correct)
                    else if (orientation === 5) offsets = [[1, 0], [1, -1], [0, -1]]; // 65-64-54 pattern (correct)
                } else if (row === 4) {
                    // Row 4 patterns - using same patterns as rows 5 & 6
                    if (orientation === 0) offsets = [[1, -1], [0, -1], [-1, 0]]; // 64-54-45 pattern
                    else if (orientation === 1) offsets = [[0, -1], [-1, 0], [-1, 1]]; // 54-45-46 pattern
                    else if (orientation === 2) offsets = [[-1, 0], [-1, 1], [0, 1]]; // 45-46-56 pattern
                    else if (orientation === 3) offsets = [[1, 0], [0, 1], [-1, 1]]; // 65-56-46 pattern
                    else if (orientation === 4) offsets = [[0, 1], [1, 0], [1, -1]]; // 56-65-64 pattern
                    else if (orientation === 5) offsets = [[1, 0], [1, -1], [0, -1]]; // 65-64-54 pattern
                } else if (row === 5 || row === 6) {
                    // Rows 5 & 6 patterns - these were working correctly before
                    if (orientation === 0) offsets = [[1, -1], [0, -1], [-1, 0]]; // 64-54-45 pattern
                    else if (orientation === 1) offsets = [[0, -1], [-1, 0], [-1, 1]]; // 54-45-46 pattern
                    else if (orientation === 2) offsets = [[-1, 0], [-1, 1], [0, 1]]; // 45-46-56 pattern
                    else if (orientation === 3) offsets = [[1, 0], [0, 1], [-1, 1]]; // 65-56-46 pattern
                    else if (orientation === 4) offsets = [[0, 1], [1, 0], [1, -1]]; // 56-65-64 pattern
                    else if (orientation === 5) offsets = [[1, 0], [1, -1], [0, -1]]; // 65-64-54 pattern
                } else if (row === 2) {
                    // Row 2 patterns - corrected based on position 2-3 observations
                    if (orientation === 0) offsets = [[0, -1], [1, 0], [-1, -1]]; // 22-33-12 pattern
                    else if (orientation === 1) offsets = [[-1, -1], [0, -1], [-1, 0]]; // 12-22-13 pattern
                    else if (orientation === 2) offsets = [[-1, 0], [-1, -1], [0, 1]]; // 13-12-24 pattern
                    else if (orientation === 3) offsets = [[1, 1], [0, 1], [-1, 0]]; // 34-24-13 pattern
                    else if (orientation === 4) offsets = [[1, 1], [1, 0], [0, 1]]; // 34-33-24 pattern
                    else if (orientation === 5) offsets = [[1, 1], [0, -1], [1, 0]]; // 34-22-33 pattern
                } else if (row === 1) {
                    // Row 1 patterns - corrected based on position 1-3 observations
                    if (orientation === 0) offsets = [[1, 0], [-1, -1], [0, -1]]; // 23-02-12 pattern
                    else if (orientation === 1) offsets = [[0, -1], [-1, -1], [-1, 0]]; // 12-02-03 pattern
                    else if (orientation === 2) offsets = [[-1, -1], [-1, 0], [0, 1]]; // 02-03-14 pattern
                    else if (orientation === 3) offsets = [[1, 1], [0, 1], [-1, 0]]; // 24-14-03 pattern
                    else if (orientation === 4) offsets = [[0, 1], [1, 0], [1, 1]]; // 14-23-24 pattern
                    else if (orientation === 5) offsets = [[1, 1], [1, 0], [0, -1]]; // 24-23-12 pattern
                } else if (row === 0) {
                    // Row 0 patterns - corrected based on position 0-3 observations
                    if (orientation === 0) offsets = [[1, 0], [0, -1]]; // 13-02 pattern
                    else if (orientation === 1) offsets = [[0, -1]]; // 02 pattern (correct)
                    else if (orientation === 2) offsets = [[0, 1]]; // 04 pattern (correct)
                    else if (orientation === 3) offsets = [[0, 1], [1, 1]]; // 04-14 pattern
                    else if (orientation === 4) offsets = [[0, 1], [1, 1], [1, 0]]; // 04-14-13 pattern
                    else if (orientation === 5) offsets = [[1, 0], [1, 1], [0, -1]]; // 13-14-02 pattern
                } else {
                    // Standard rotation patterns for any other cases
                    if (orientation === 0) offsets = [[1, -1], [0, -1], [-1, 0]]; // 64-54-45 pattern
                    else if (orientation === 1) offsets = [[0, -1], [-1, 0], [-1, 1]]; // 54-45-46 pattern
                    else if (orientation === 2) offsets = [[-1, 0], [-1, 1], [0, 1]]; // 45-46-56 pattern
                    else if (orientation === 3) offsets = [[1, 0], [0, 1], [-1, 0]]; // 65-56-46 pattern
                    else if (orientation === 4) offsets = [[0, 1], [1, 0], [1, -1]]; // 56-65-64 pattern
                    else if (orientation === 5) offsets = [[1, 0], [1, -1], [0, -1]]; // 65-64-54 pattern
                }
            }
            
            console.log(`üîç Pattern for ${row}-${col} orientation ${orientation}:`, offsets);
            console.log(`üîç Pattern details:`, offsets.map(([dr, dc]) => `[${dr}, ${dc}]`));
            
            // Show expected target coordinates
            const expectedTargets = offsets.map(([dr, dc]) => `hex-${row + dr}-${col + dc}`);
            console.log(`üéØ Expected target coordinates:`, expectedTargets);
            
            return offsets;
        }
        
        function evaluateMove(fromRow, fromCol, toRow, toCol, pieceType, isCapture) {
            let score = 0;
            
            // === CRITICAL: AVOID MOVING INTO THREATS ===
            
            // NEVER move into a position where we'll be captured!
            if (isPieceUnderThreat(toRow, toCol, true)) {
                // Only acceptable if we're capturing something MORE valuable
                if (!isCapture) {
                    score -= 2000; // Huge penalty for walking into danger
                } else {
                    // Capturing while threatened - only worth it for high-value pieces
                    const targetHex = document.getElementById(`hex-${toRow}-${toCol}`);
                    if (targetHex) {
                        const targetPiece = targetHex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                        if (!targetPiece || !targetPiece.classList.contains('rhombus-piece')) {
                            score -= 1000; // Don't trade pieces when we're threatened
                        }
                    }
                }
            }
            
            // === HIGH PRIORITY: WINNING & SURVIVAL ===
            
            // Get rhombus positions for strategic evaluation
            let blackRhombus = document.querySelector('.rhombus-piece:not(.white-rhombus)');
            const whiteRhombus = document.querySelector('.rhombus-piece.white-rhombus');
            
            // Check if this is a winning move
            if (pieceType === 'rhombus' && toRow === 3 && toCol === 8) {
                // Check if black rhombus is blocking our base
                if (blackRhombus) {
                    const blackHex = blackRhombus.closest('.hexagon');
                    if (blackHex) {
                        const [, bRow, bCol] = blackHex.id.match(/hex-(\d+)-(\d+)/);
                        if (bRow == 3 && bCol == 8) {
                            // Black is blocking our goal - can't win yet
                            score += 500; // Still good position
                        } else {
                            score += 100000; // INSTANT WIN!
                        }
                    }
                }
            }
            
            // Protect our rhombus from being checkmated/stalemated
            if (whiteRhombus) {
                const rhombusHex = whiteRhombus.closest('.hexagon');
                if (rhombusHex) {
                    const [, rRow, rCol] = rhombusHex.id.match(/hex-(\d+)-(\d+)/);
                    
                    // CRITICAL: Check if rhombus is trapped/locked (no legal moves)
                    const rhombusMoves = getPossibleMoves(parseInt(rRow), parseInt(rCol), 'rhombus', true);
                    const rhombusIsTrapped = rhombusMoves.length === 0;
                    
                    if (rhombusIsTrapped) {
                        console.log('‚ö†Ô∏è CRITICAL: White rhombus is TRAPPED at', rRow, '-', rCol, '!');
                        
                        // If THIS IS the rhombus and it has ANY legal move, take it!
                        if (pieceType === 'rhombus' && fromRow == rRow && fromCol == rCol) {
                            score += 5000; // MAXIMUM PRIORITY: Escape the trap!
                            console.log('‚úÖ Rhombus escape move:', fromRow, '-', fromCol, '‚Üí', toRow, '-', toCol);
                        }
                        
                        // If another piece can capture a piece blocking the rhombus
                        if (isCapture && pieceType !== 'rhombus') {
                            // Check if the captured piece was blocking rhombus escape routes
                            const distanceToRhombus = Math.abs(toRow - rRow) + Math.abs(toCol - rCol);
                            if (distanceToRhombus <= 2) {
                                score += 2000; // Very high priority: Free the rhombus!
                                console.log('‚úÖ Capturing blocker near trapped rhombus');
                            }
                        }
                    } else if (isPieceUnderThreat(parseInt(rRow), parseInt(rCol), true)) {
                        // Rhombus is threatened but not trapped
                        // Moving rhombus away from danger
                        if (pieceType === 'rhombus') {
                            score += 1500; // CRITICAL: Escape danger!
                        }
                        // Or blocking/capturing the threat
                        if (isCapture) score += 800;
                        
                        // Check if THIS move blocks the threat to our rhombus
                        if (wouldBlockThreat(fromRow, fromCol, toRow, toCol, rRow, rCol)) {
                            score += 1000; // Blocking threat to rhombus!
                        }
                    }
                }
            }
            
            // === CAPTURES ===
            if (isCapture) {
                // Prioritize capturing valuable pieces
                const targetHex = document.getElementById(`hex-${toRow}-${toCol}`);
                if (targetHex) {
                    const targetPiece = targetHex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                    if (targetPiece) {
                        if (targetPiece.classList.contains('triangle-piece')) score += 150;
                        else if (targetPiece.classList.contains('hexgon-piece')) score += 140;
                        else if (targetPiece.classList.contains('circle-piece')) score += 130;
                        else if (targetPiece.classList.contains('square-piece')) score += 120;
                    }
                }
            }
            
            // === RHOMBUS STRATEGY ===
            if (pieceType === 'rhombus') {
                // Progressive advancement toward 3-8
                const distanceToGoal = Math.abs(toRow - 3) + Math.abs(toCol - 8);
                score += (20 - distanceToGoal) * 15;
                
                // Prefer row 3 (direct path to goal)
                if (toRow === 3) score += 50;
                
                // Don't leave base until we have support
                if (fromRow === 3 && fromCol === 0) {
                    const whiteSquares = document.querySelectorAll('.square-piece.white-piece');
                    const whiteTriangles = document.querySelectorAll('.triangle-piece.white-triangle');
                    if (whiteSquares.length + whiteTriangles.length < 3) {
                        score -= 200; // Stay at base if we're weak
                    }
                }
                
                // Avoid getting trapped
                const rhombusMoves = getRhombusMoves(toRow, toCol);
                score += rhombusMoves.length * 20; // More escape options = better
            }
            
            // === DEFENSIVE PLAY ===
            
            // Block opponent's rhombus path
            if (blackRhombus) {
                const blackHex = blackRhombus.closest('.hexagon');
                if (blackHex) {
                    const [, bRow, bCol] = blackHex.id.match(/hex-(\d+)-(\d+)/);
                    const blackDistanceToGoal = Math.abs(bRow - 3) + Math.abs(bCol - 0);
                    
                    // If black is close to winning, block them!
                    if (blackDistanceToGoal <= 3) {
                        const distanceToBlackRhombus = Math.abs(toRow - bRow) + Math.abs(toCol - bCol);
                        score += (10 - distanceToBlackRhombus) * 30; // Get close to block
                    }
                }
            }
            
            // Defend our base (3-8) if rhombus has left
            if (whiteRhombus) {
                const rhombusHex = whiteRhombus.closest('.hexagon');
                if (rhombusHex) {
                    const [, rRow, rCol] = rhombusHex.id.match(/hex-(\d+)-(\d+)/);
                    if (!(rRow == 3 && rCol == 8)) {
                        // Rhombus not at base - defend it
                        if (toRow === 3 && toCol === 8) score += 100;
                    }
                }
            }
            
            // === POSITIONAL PLAY ===
            
            // Control center (row 3, middle columns)
            if (toRow === 3) score += 30;
            const centerDistance = Math.abs(toRow - 3) + Math.abs(toCol - 4);
            score += (10 - centerDistance) * 5;
            
            // Forward progress (move toward opponent)
            if (toCol < fromCol) score += 15; // White wants to go left toward black's side
            
            // Piece mobility - prefer moves that give more options
            let mobilityBonus = 0;
            if (pieceType === 'square') {
                const futureMoves = getSquareTargets(toRow, toCol);
                mobilityBonus = futureMoves.length * 3;
            } else if (pieceType === 'triangle') {
                const futureMoves = getWhiteTriangleTargets(toRow, toCol);
                mobilityBonus = futureMoves.length * 3;
            } else if (pieceType === 'hexgon') {
                const futureMoves = getHexgonTargets(toRow, toCol);
                mobilityBonus = futureMoves.length * 3;
            }
            score += mobilityBonus;
            
            // === TACTICAL THREATS ===
            
            // Check if this move threatens opponent's pieces
            const threatenedPieces = countThreatenedOpponentPieces(toRow, toCol, pieceType);
            score += threatenedPieces * 40; // Increased from 25
            
            // MAJOR BONUS: Threaten opponent's rhombus!
            if (blackRhombus) {
                const blackHex = blackRhombus.closest('.hexagon');
                if (blackHex) {
                    const [, bRow, bCol] = blackHex.id.match(/hex-(\d+)-(\d+)/);
                    if (wouldThreatenPosition(toRow, toCol, pieceType, parseInt(bRow), parseInt(bCol))) {
                        score += 600; // HUGE bonus for threatening opponent's rhombus!
                    }
                }
            }
            
            // BONUS: Move our pieces to safety if they're currently threatened
            if (isPieceUnderThreat(fromRow, fromCol, true) && !isPieceUnderThreat(toRow, toCol, true)) {
                score += 300; // Escaping from danger!
            }
            
            // Small random factor for variety
            score += Math.random() * 3;
            
            return score;
        }
        
        // Check if a piece at toRow,toCol would threaten targetRow,targetCol
        function wouldThreatenPosition(pieceRow, pieceCol, pieceType, targetRow, targetCol) {
            if (pieceType === 'square') {
                return canSquareAttack(pieceRow, pieceCol, targetRow, targetCol);
            } else if (pieceType === 'triangle') {
                // AI plays white triangles
                return canWhiteTriangleAttack(pieceRow, pieceCol, targetRow, targetCol, null);
            } else if (pieceType === 'rhombus') {
                return canRhombusAttack(pieceRow, pieceCol, targetRow, targetCol);
            } else if (pieceType === 'circle') {
                // Need to simulate circle attack - simplified check
                const targets = getCircleTargets(pieceRow, pieceCol);
                return targets.some(([r, c]) => r === targetRow && c === targetCol);
            } else if (pieceType === 'hexgon') {
                const moves = getHexgonMoves(pieceRow, pieceCol);
                return moves.includes(`${targetRow}-${targetCol}`);
            }
            return false;
        }
        
        // Check if moving a piece to toRow,toCol would block threats to our rhombus at rhombusRow,rhombusCol
        function wouldBlockThreat(fromRow, fromCol, toRow, toCol, rhombusRow, rhombusCol) {
            // Find all black pieces that threaten our rhombus
            const blackPieces = document.querySelectorAll('.square-piece:not(.white-piece), .triangle-piece:not(.white-triangle), .circle-piece:not(.white-circle), .hexgon-piece:not(.white-hexgon)');
            
            let blocksAnyThreat = false;
            
            blackPieces.forEach(piece => {
                const pieceHex = piece.closest('.hexagon');
                if (!pieceHex) return;
                
                const [, pRow, pCol] = pieceHex.id.match(/hex-(\d+)-(\d+)/);
                const pr = parseInt(pRow);
                const pc = parseInt(pCol);
                
                // Check if this black piece threatens our rhombus
                let threatens = false;
                if (piece.classList.contains('square-piece')) {
                    threatens = canSquareAttack(pr, pc, rhombusRow, rhombusCol);
                } else if (piece.classList.contains('triangle-piece')) {
                    threatens = canBlackTriangleAttack(pr, pc, rhombusRow, rhombusCol, piece);
                } else if (piece.classList.contains('circle-piece')) {
                    threatens = canCircleAttack(pr, pc, rhombusRow, rhombusCol, piece);
                } else if (piece.classList.contains('hexgon-piece')) {
                    const moves = getHexgonMoves(pr, pc);
                    threatens = moves.includes(`${rhombusRow}-${rhombusCol}`);
                }
                
                if (threatens) {
                    // Check if our new position blocks this threat
                    // Simple check: are we moving between the attacker and our rhombus?
                    if (isPositionBetween(toRow, toCol, pr, pc, rhombusRow, rhombusCol)) {
                        blocksAnyThreat = true;
                    }
                }
            });
            
            return blocksAnyThreat;
        }
        
        // Simple check if position is "between" two other positions (same row or adjacent)
        function isPositionBetween(row, col, attackerRow, attackerCol, targetRow, targetCol) {
            // Check if on same row and between
            if (row === attackerRow && row === targetRow) {
                const minCol = Math.min(attackerCol, targetCol);
                const maxCol = Math.max(attackerCol, targetCol);
                return col > minCol && col < maxCol;
            }
            // Check if on same column-ish path (simplified)
            if (col === attackerCol && col === targetCol) {
                const minRow = Math.min(attackerRow, targetRow);
                const maxRow = Math.max(attackerRow, targetRow);
                return row > minRow && row < maxRow;
            }
            return false;
        }
        
        // Helper: Count how many opponent pieces this move threatens
        function countThreatenedOpponentPieces(row, col, pieceType) {
            let count = 0;
            let targets = [];
            
            if (pieceType === 'square') targets = getSquareTargets(row, col);
            else if (pieceType === 'triangle') targets = getWhiteTriangleTargets(row, col);
            else if (pieceType === 'rhombus') targets = getRhombusTargets(row, col);
            else if (pieceType === 'circle') targets = getCircleTargets(row, col);
            else if (pieceType === 'hexgon') targets = getHexgonTargets(row, col);
            
            targets.forEach(([r, c]) => {
                const hex = document.getElementById(`hex-${r}-${c}`);
                if (hex) {
                    const piece = hex.querySelector('.square-piece, .triangle-piece, .circle-piece, .hexgon-piece');
                    if (piece && !piece.classList.contains('white-piece') && 
                        !piece.classList.contains('white-triangle') && 
                        !piece.classList.contains('white-circle') && 
                        !piece.classList.contains('white-hexgon')) {
                        count++;
                    }
                }
            });
            
            return count;
        }
        
        function executeAIMove(move) {
            const fromHex = document.getElementById(`hex-${move.fromRow}-${move.fromCol}`);
            const toHex = document.getElementById(`hex-${move.toRow}-${move.toCol}`);
            
            if (!fromHex || !toHex) return;
            
            const piece = move.piece;
            const existingPiece = toHex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
            
            // Handle capture
            if (existingPiece) {
                addToEliminatedPieces(existingPiece);
                existingPiece.remove();
                new Audio('ASSETS/captured.mp3').play().catch(e => console.log('Audio play failed:', e));
            } else {
                new Audio('ASSETS/click.mp3').play().catch(e => console.log('Audio play failed:', e));
            }
            
            // Move piece
            piece.remove();
            const newPiece = piece.cloneNode(true);
            toHex.appendChild(newPiece);
            
            // Re-setup drag and drop
            setupDragAndDrop();
            
            // Record move
            const repetitionCount = checkRepetition(move.fromRow, move.fromCol, move.toRow, move.toCol, move.type, true, move.isCapture);
            recordMove(move.fromRow, move.fromCol, move.toRow, move.toCol, move.type, true, move.isCapture, repetitionCount);
            
            // Check win conditions (pass the target position and new piece)
            checkWinConditions(move.toRow, move.toCol, newPiece);
            
            // Switch turn back to player
            aiThinking = false; // Unlock player input
            if (!gameOver) {
                switchTurn();
            }
        }
        
        // Function to switch turns
        function switchTurn() {
            currentPlayer = currentPlayer === 'black' ? 'white' : 'black';
            updateTurnDisplay();
            
            // Auto-flip board based on current player
            autoBoardFlip();
            
            // Refresh "show all moves" if it's enabled
            if (showAllMoves) {
                displayAllPossibleMoves();
            }
            
            // Update timers if enabled
            if (timerEnabled) {
                updateTimerDisplay();
            }
            
            // Update puzzle move counter if in puzzle mode
            if (puzzleMode) {
                updatePuzzleMoves();
            }
            
            // Clear all piece actions for the new turn
            pieceActions.clear();
            // Reset the active piece for the new turn
            currentTurnPiece = null;
            console.log('Cleared currentTurnPiece in switchTurn');
            // Hide rotation controls and clear selection when turn ends
            const rotationControlsEl = document.getElementById('rotation-controls');
            if (rotationControlsEl) {
                rotationControlsEl.style.display = 'none';
            }
            selectedPiece = null;
            console.log('Turn switched, cleared selectedPiece');
            
            // AI Move: If AI is enabled and it's White's turn
            console.log('üîÑ Turn switch - AI enabled:', aiEnabled, 'Current player:', currentPlayer, 'Game over:', gameOver);
            if (aiEnabled && currentPlayer === 'white' && !gameOver) {
                console.log('ü§ñ Triggering AI move in 800ms...');
                // Small delay for better UX (let player see board state)
                setTimeout(() => {
                    makeAIMove();
                }, 800);
            }
            // Highlight threatened pieces after each turn
            highlightAllPiecesUnderAttack();
            
            // Show persistent circle attack highlights
            showCircleAttackHighlights();
            
            // Update Fog of War visibility for new player
            updateFogOfWar();
            
            // Check for rhombus deadlock (checkmate) after turn switch
            const isCheckmate = checkRhombusDeadlock();
            
            // TODO: Stalemate checking is disabled for now due to performance and complexity
            // It's an extremely rare scenario in Romgon
            // If no checkmate, check for stalemate (no legal moves but rhombus not under attack)
            // if (!isCheckmate && !gameOver) {
            //     const currentPlayerIsWhite = currentPlayer === 'white';
            //     const hasLegalMoves = doesPlayerHaveAnyLegalMoves(currentPlayerIsWhite);
            //     
            //     if (!hasLegalMoves) {
            //         console.log(`üîí STALEMATE! ${currentPlayer.toUpperCase()} has no legal moves!`);
            //         // In Romgon, if you have no legal moves, your OPPONENT WINS
            //         const winner = currentPlayer === 'white' ? 'Black' : 'White';
            //         showGameOver(winner, `üèÜ ${winner} Wins by Stalemate! ${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)} has no legal moves!`);
            //     }
            // }
            // Check if Escape Race mode just activated and show notification
            checkAndNotifyEscapeRace();
        }

        // Function to toggle board flip for white player perspective
        function toggleBoardFlip() {
            boardFlipped = !boardFlipped;
            const board = document.querySelector('.board');
            if (boardFlipped) {
                board.classList.add('flipped');
            } else {
                board.classList.remove('flipped');
            }
            
            // Play flip sound
            playFlipboardSound();
            
            // Update flip button text
            const flipButton = document.getElementById('flip-button');
            if (flipButton) {
                flipButton.innerHTML = boardFlipped ? 'üîÑ NORMAL' : 'üîÑ FLIP';
            }
            
            console.log('Board flip manually toggled:', boardFlipped);
        }
        
        // Function to auto-flip board based on current player
        function autoBoardFlip() {
            const board = document.querySelector('.board');
            
            // White's turn: Flip board so white is at bottom
            // Black's turn: Normal view so black is at bottom
            if (currentPlayer === 'white') {
                board.classList.add('flipped');
                boardFlipped = true;
                playFlipboardSound(); // Play flip sound
                console.log('üîÑ Auto-flipped board for White player');
            } else {
                board.classList.remove('flipped');
                boardFlipped = false;
                playFlipboardSound(); // Play flip sound
                console.log('üîÑ Board normal view for Black player');
            }
            
            // Update flip button text if it exists
            const flipButton = document.getElementById('flip-button');
            if (flipButton) {
                flipButton.innerHTML = boardFlipped ? 'üîÑ NORMAL' : 'üîÑ FLIP';
            }
        }
        
        // Function to toggle "show all moves" mode
        function toggleShowAllMoves() {
            showAllMoves = !showAllMoves;
            
            if (showAllMoves) {
                displayAllPossibleMoves();
                console.log('üëÅÔ∏è Show all moves: ENABLED');
            } else {
                clearAllMoveHighlights();
                console.log('üëÅÔ∏è Show all moves: DISABLED');
            }
            
            // Update button appearance
            const showAllButton = document.getElementById('show-all-moves-button');
            if (showAllButton) {
                showAllButton.innerHTML = showAllMoves ? 'üëÅÔ∏è HIDE ALL' : 'üëÅÔ∏è SHOW ALL';
                showAllButton.style.backgroundColor = showAllMoves ? '#00ff00' : '#666';
            }
        }
        
        // Function to display all possible moves for all pieces
        function displayAllPossibleMoves() {
            // Clear any existing highlights first
            clearAllMoveHighlights();
            
            // Get all pieces for current player
            const pieces = currentPlayer === 'black' 
                ? document.querySelectorAll('.square-piece:not(.white-piece), .triangle-piece:not(.white-triangle), .rhombus-piece:not(.white-rhombus), .circle-piece:not(.white-circle), .hexgon-piece:not(.white-hexgon)')
                : document.querySelectorAll('.white-piece, .white-triangle, .white-rhombus, .white-circle, .white-hexgon');
            
            console.log(`üëÅÔ∏è Displaying all moves for ${pieces.length} ${currentPlayer} pieces`);
            
            pieces.forEach(piece => {
                const pieceHex = piece.closest('.hexagon');
                if (!pieceHex) return;
                
                const [, row, col] = pieceHex.id.match(/hex-(\d+)-(\d+)/);
                
                // Get piece type
                let pieceType = 'square';
                if (piece.classList.contains('triangle-piece')) pieceType = 'triangle';
                else if (piece.classList.contains('rhombus-piece')) pieceType = 'rhombus';
                else if (piece.classList.contains('circle-piece')) pieceType = 'circle';
                else if (piece.classList.contains('hexgon-piece')) pieceType = 'hexgon';
                
                // Highlight all possible moves for this piece
                highlightPieceMoves(parseInt(row), parseInt(col), pieceType, pieceHex.id);
                
                // Add rotation indicator for rotatable pieces
                if (pieceType === 'triangle' || pieceType === 'hexgon') {
                    addRotationIndicator(pieceHex, pieceType);
                }
            });
            
            console.log(`üìç Displayed all moves for ${currentPlayer} pieces`);
        }
        
        // Function to highlight moves for a specific piece (without clearing existing highlights)
        function highlightPieceMoves(row, col, pieceType, hexId) {
            let targets = [];
            
            // Get movement pattern based on piece type
            if (pieceType === 'square') {
                targets = getSquareTargets(row, col);
            } else if (pieceType === 'triangle') {
                const orientation = getTriangleOrientation(hexId);
                const hex = document.getElementById(hexId);
                const piece = hex.querySelector('.triangle-piece');
                const isWhite = piece && (piece.classList.contains('white-triangle') || piece.classList.contains('white-piece'));
                // getRotatedTriangleTargets returns offsets, need to convert to absolute coords
                const offsets = getRotatedTriangleTargets(row, col, orientation, isWhite);
                targets = offsets.map(([dr, dc]) => [row + dr, col + dc]);
            } else if (pieceType === 'rhombus') {
                targets = getRhombusTargets(row, col);
            } else if (pieceType === 'circle') {
                targets = getCircleTargets(row, col);
            } else if (pieceType === 'hexgon') {
                const orientation = getHexgonOrientation(hexId);
                const hex = document.getElementById(hexId);
                const piece = hex.querySelector('.hexgon-piece');
                const isWhite = piece && (piece.classList.contains('white-hexgon') || piece.classList.contains('white-piece'));
                targets = getRotatedHexgonTargets(row, col, orientation, isWhite);
            }
            
            // Determine if piece is white or black
            const hex = document.getElementById(hexId);
            const piece = hex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
            const isWhite = piece && (
                piece.classList.contains('white-piece') ||
                piece.classList.contains('white-triangle') ||
                piece.classList.contains('white-rhombus') ||
                piece.classList.contains('white-circle') ||
                piece.classList.contains('white-hexgon')
            );
            
            // Highlight each target
            targets.forEach(([targetRow, targetCol]) => {
                const targetHex = document.getElementById(`hex-${targetRow}-${targetCol}`);
                if (!targetHex) return;
                
                // Check if target has a piece
                const targetPiece = targetHex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                
                if (!targetPiece) {
                    // Empty hex - valid move (green)
                    targetHex.classList.add('highlight-green');
                } else {
                    // Has a piece - check if it's opponent or friendly
                    const targetIsWhite = targetPiece.classList.contains('white-piece') ||
                                        targetPiece.classList.contains('white-triangle') ||
                                        targetPiece.classList.contains('white-rhombus') ||
                                        targetPiece.classList.contains('white-circle') ||
                                        targetPiece.classList.contains('white-hexgon');
                    
                    if (targetIsWhite !== isWhite) {
                        // Opponent piece - valid attack (red)
                        targetHex.classList.add('highlight-red');
                    }
                    // Skip friendly pieces (no gray highlight)
                }
            });
        }
        
        // Function to add rotation indicator on a piece
        function addRotationIndicator(hexElement, pieceType) {
            // Check if piece has already acted this turn
            const actions = pieceActions.get(hexElement.id) || {moved: false, attacked: false, rotated: false};
            if (actions.moved || actions.attacked || actions.rotated) {
                return; // Don't show rotation for pieces that already acted
            }
            
            // Create rotation indicator overlay
            const rotationOverlay = document.createElement('div');
            rotationOverlay.className = 'rotation-overlay';
            rotationOverlay.innerHTML = '‚ü≤'; // Rotation symbol
            rotationOverlay.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 18px;
                height: 18px;
                background: rgba(155, 89, 182, 0.85);
                color: white;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 12px;
                font-weight: bold;
                pointer-events: none;
                z-index: 10;
                box-shadow: 0 0 5px rgba(155, 89, 182, 1);
                border: 1.5px solid rgba(255, 255, 255, 0.9);
            `;
            
            hexElement.appendChild(rotationOverlay);
        }
        
        // Function to clear all move highlights
        function clearAllMoveHighlights() {
            // Remove all highlight classes
            document.querySelectorAll('.hexagon').forEach(hex => {
                hex.classList.remove('highlight-green', 'highlight-red', 'highlight-danger', 'highlight-diagonal', 'highlight-gray');
            });
            
            // Remove rotation indicators
            document.querySelectorAll('.rotation-overlay').forEach(overlay => {
                overlay.remove();
            });
        }


        // Function to update turn display
        function updateTurnDisplay() {
            // Don't show turn indicator on splash page
            const splashPage = document.getElementById('splash-page');
            const boardContainer = document.getElementById('board-display-container');
            
            // Only show turn indicator if we're on the game board
            if (!boardContainer || boardContainer.style.display === 'none') {
                // Remove existing turn indicator if board is not visible
                const existingIndicator = document.getElementById('turn-indicator');
                if (existingIndicator) {
                    existingIndicator.remove();
                }
                return;
            }
            
            // Remove existing turn indicator
            const existingIndicator = document.getElementById('turn-indicator');
            if (existingIndicator) {
                existingIndicator.remove();
            }

            // Create new turn indicator container
            const turnIndicator = document.createElement('div');
            turnIndicator.id = 'turn-indicator';
            turnIndicator.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                display: flex;
                align-items: center;
                gap: 15px;
                z-index: 3001;
            `;

            // Create left button (Main Menu)
            const menuButton = document.createElement('button');
            menuButton.innerHTML = 'üè† MENU';
            menuButton.style.cssText = `
                background-color: #ff6b6b;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 20px;
                cursor: pointer;
                font-weight: bold;
                font-size: 12px;
                box-shadow: 0 2px 8px rgba(255, 107, 107, 0.3);
                transition: all 0.3s ease;
            `;
            menuButton.onclick = function() {
                gameInProgress = true;
                showStartMenu();
            };
            menuButton.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            menuButton.onmouseout = function() { this.style.transform = 'scale(1)'; };

            // Create AI model selector button (only for LLM mode)
            let aiModelButton = null;
            if (llmMode) {
                aiModelButton = document.createElement('button');
                aiModelButton.id = 'ai-model-selector-btn';
                aiModelButton.innerHTML = 'üß† AI';
                aiModelButton.style.cssText = `
                    background-color: #00d2ff;
                    color: white;
                    border: none;
                    padding: 8px 16px;
                    border-radius: 20px;
                    cursor: pointer;
                    font-weight: bold;
                    font-size: 12px;
                    box-shadow: 0 2px 8px rgba(0, 210, 255, 0.3);
                    transition: all 0.3s ease;
                `;
                aiModelButton.onclick = showAIModelSelector;
                aiModelButton.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
                aiModelButton.onmouseout = function() { this.style.transform = 'scale(1)'; };
            }

            // Create coordinate toggle button
            const coordButton = document.createElement('button');
            coordButton.innerHTML = 'üìç COORDS';
            coordButton.style.cssText = `
                background-color: #ffa500;
                color: white;
                border: none;
                padding: 4px 10px;
                border-radius: 15px;
                cursor: pointer;
                font-weight: bold;
                font-size: 10px;
                box-shadow: 0 2px 8px rgba(255, 165, 0, 0.3);
                transition: all 0.3s ease;
            `;
            coordButton.onclick = toggleCoordinates;
            coordButton.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            coordButton.onmouseout = function() { this.style.transform = 'scale(1)'; };

            // Create defense toggle button
            const defenseButton = document.createElement('button');
            defenseButton.innerHTML = 'üõ°Ô∏è DEFENSE';
            defenseButton.style.cssText = `
                background-color: #27ae60;
                color: white;
                border: none;
                padding: 4px 10px;
                border-radius: 15px;
                cursor: pointer;
                font-weight: bold;
                font-size: 10px;
                box-shadow: 0 2px 8px rgba(39, 174, 96, 0.3);
                transition: all 0.3s ease;
                margin-left: 5px;
            `;
            let defenseHighlightEnabled = false;
            defenseButton.onclick = function() {
                defenseHighlightEnabled = !defenseHighlightEnabled;
                this.style.backgroundColor = defenseHighlightEnabled ? '#16a085' : '#27ae60';
                
                if (defenseHighlightEnabled) {
                    showDefenseHighlights();
                } else {
                    clearDefenseHighlights();
                }
            };
            defenseButton.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            defenseButton.onmouseout = function() { this.style.transform = 'scale(1)'; };

            // Create Fog of War toggle button
            const fogButton = document.createElement('button');
            fogButton.innerHTML = fogOfWarEnabled ? 'üëÅÔ∏è FOG ON' : 'üëÅÔ∏è FOG OFF';
            fogButton.style.cssText = `
                background-color: ${fogOfWarEnabled ? '#8e44ad' : '#95a5a6'};
                color: white;
                border: none;
                padding: 4px 10px;
                border-radius: 15px;
                cursor: pointer;
                font-weight: bold;
                font-size: 10px;
                box-shadow: 0 2px 8px rgba(142, 68, 173, 0.3);
                transition: all 0.3s ease;
                margin-left: 5px;
            `;
            fogButton.onclick = function() {
                fogOfWarEnabled = !fogOfWarEnabled;
                this.innerHTML = fogOfWarEnabled ? 'üëÅÔ∏è FOG ON' : 'üëÅÔ∏è FOG OFF';
                this.style.backgroundColor = fogOfWarEnabled ? '#8e44ad' : '#95a5a6';
                updateFogOfWar();
                console.log('üå´Ô∏è Fog of War:', fogOfWarEnabled ? 'ENABLED' : 'DISABLED');
            };
            fogButton.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            fogButton.onmouseout = function() { this.style.transform = 'scale(1)'; };

            function showDefenseHighlights() {
                // Get all pieces on the board
                const allPieces = document.querySelectorAll('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                
                allPieces.forEach(piece => {
                    const pieceHex = piece.closest('.hexagon');
                    if (!pieceHex) return;
                    
                    const pieceId = pieceHex.id;
                    const [, row, col] = pieceId.match(/hex-(\d+)-(\d+)/);
                    const isWhite = piece.classList.contains('white-piece') || 
                                   piece.classList.contains('white-triangle') || 
                                   piece.classList.contains('white-rhombus') ||
                                   piece.classList.contains('white-circle') ||
                                   piece.classList.contains('white-hexgon');
                    
                    // Check if this piece is defended by a friendly piece
                    if (isPieceDefendedByFriendly(parseInt(row), parseInt(col), isWhite)) {
                        pieceHex.classList.add('highlight-defended');
                    }
                });
            }
            
            function clearDefenseHighlights() {
                document.querySelectorAll('.hexagon').forEach(hex => {
                    hex.classList.remove('highlight-defended');
                });
            }
            
            function isPieceDefendedByFriendly(pieceRow, pieceCol, isWhite) {
                // Get all friendly pieces
                const friendlyPieceTypes = isWhite ? 
                    ['.square-piece.white-piece', '.triangle-piece.white-triangle', '.rhombus-piece.white-rhombus', '.circle-piece.white-circle', '.hexgon-piece.white-hexgon'] :
                    ['.square-piece:not(.white-piece)', '.triangle-piece:not(.white-triangle)', '.rhombus-piece:not(.white-rhombus)', '.circle-piece:not(.white-circle)', '.hexgon-piece:not(.white-hexgon)'];
                
                // Check each friendly piece to see if it can reach this position
                for (let pieceType of friendlyPieceTypes) {
                    const friendlyPieces = document.querySelectorAll(pieceType);
                    for (let piece of friendlyPieces) {
                        const pieceHex = piece.closest('.hexagon');
                        if (!pieceHex) continue;
                        
                        const pieceId = pieceHex.id;
                        const [, friendlyRow, friendlyCol] = pieceId.match(/hex-(\d+)-(\d+)/);
                        
                        // Skip if checking the same piece
                        if (parseInt(friendlyRow) === pieceRow && parseInt(friendlyCol) === pieceCol) {
                            continue;
                        }
                        
                        // Check if this friendly piece can attack/reach the target position
                        if (canPieceActuallyAttack(parseInt(friendlyRow), parseInt(friendlyCol), pieceRow, pieceCol, piece)) {
                            return true;
                        }
                    }
                }
                return false;
            }

            // Create rotation controls container
            const rotationControls = document.createElement('div');
            rotationControls.id = 'rotation-controls';
            rotationControls.style.cssText = `
                display: none;
                position: fixed;
                bottom: 15px;
                left: 50%;
                transform: translateX(-50%);
                z-index: 3002;
                background: rgba(0, 0, 0, 0.8);
                padding: 6px 10px;
                border-radius: 8px;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
            `;

            // Create rotate left button
            const rotateLeftButton = document.createElement('button');
            rotateLeftButton.innerHTML = '‚Üª RIGHT';
            rotateLeftButton.style.cssText = `
                background-color: #9b59b6;
                color: white;
                border: none;
                padding: 4px 8px;
                margin: 0 3px;
                border-radius: 4px;
                cursor: pointer;
                font-weight: bold;
                font-size: 10px;
                transition: all 0.2s ease;
                box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            `;
            rotateLeftButton.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            rotateLeftButton.onmouseout = function() { this.style.transform = 'scale(1)'; };
            rotateLeftButton.onclick = function() {
                console.log('Left rotation button clicked!');
                console.log('Selected piece:', selectedPiece);
                if (selectedPiece) {
                    const [, row, col] = selectedPiece.id.match(/hex-(\d+)-(\d+)/);
                    console.log('Rotating piece at:', row, col);
                    const piece = selectedPiece.querySelector('.triangle-piece, .hexgon-piece');
                    if (piece && piece.classList.contains('triangle-piece')) {
                        rotateTriangleLeft(`hex-${row}-${col}`);
                    } else if (piece && piece.classList.contains('hexgon-piece')) {
                        rotateHexgonLeft(`hex-${row}-${col}`);
                    }
                    // Just rotate visually, don't update movement pattern
                } else {
                    console.log('No selected piece!');
                }
            };

            // Create rotate right button
            const rotateRightButton = document.createElement('button');
            rotateRightButton.innerHTML = '‚Ü∫ LEFT';
            rotateRightButton.style.cssText = `
                background-color: #9b59b6;
                color: white;
                border: none;
                padding: 4px 8px;
                margin: 0 3px;
                border-radius: 4px;
                cursor: pointer;
                font-weight: bold;
                font-size: 10px;
                transition: all 0.2s ease;
                box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            `;
            rotateRightButton.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            rotateRightButton.onmouseout = function() { this.style.transform = 'scale(1)'; };
            rotateRightButton.onclick = function() {
                console.log('Right rotation button clicked!');
                console.log('Selected piece:', selectedPiece);
                if (selectedPiece) {
                    const [, row, col] = selectedPiece.id.match(/hex-(\d+)-(\d+)/);
                    console.log('Rotating piece at:', row, col);
                    const piece = selectedPiece.querySelector('.triangle-piece, .hexgon-piece');
                    if (piece && piece.classList.contains('triangle-piece')) {
                        rotateTriangleRight(`hex-${row}-${col}`);
                    } else if (piece && piece.classList.contains('hexgon-piece')) {
                        rotateHexgonRight(`hex-${row}-${col}`);
                    }
                    // Just rotate visually, don't update movement pattern
                } else {
                    console.log('No selected piece!');
                }
            };

            // Create keep button
            const keepButton = document.createElement('button');
            keepButton.innerHTML = 'KEEP';
            keepButton.style.cssText = `
                background-color: #27ae60;
                color: white;
                border: none;
                padding: 4px 8px;
                margin: 0 3px;
                border-radius: 4px;
                cursor: pointer;
                font-weight: bold;
                font-size: 10px;
                transition: all 0.2s ease;
                box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            `;
            keepButton.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            keepButton.onmouseout = function() { this.style.transform = 'scale(1)'; };
            keepButton.onclick = function() {
                console.log('Keep button clicked!');
                console.log('Selected piece:', selectedPiece);
                if (selectedPiece) {
                    const hexId = selectedPiece.id;
                    const [, row, col] = hexId.match(/hex-(\d+)-(\d+)/);
                    const piece = selectedPiece.querySelector('.triangle-piece, .hexgon-piece');
                    const pieceType = piece && piece.classList.contains('triangle-piece') ? 'triangle' : 'hexgon';
                    console.log(`Keeping ${pieceType} at:`, row, col, 'with current orientation');
                    
                    // Check if any action was performed this turn
                    const actions = pieceActions.get(hexId) || {moved: false, attacked: false, rotated: false};
                    const hasPerformedAction = actions.moved || actions.attacked || actions.rotated;
                    
                    // If no action was performed, confirm with user
                    if (!hasPerformedAction) {
                        const confirmed = confirm('‚ö†Ô∏è WARNING: You haven\'t made any move, rotation, or attack!\n\nAre you sure you want to end your turn without doing anything?');
                        if (!confirmed) {
                            console.log('Keep action cancelled by user');
                            return; // Don't end turn
                        }
                    }
                    
                    // Mark as rotated (even though no rotation happened) to end turn
                    actions.rotated = true;
                    pieceActions.set(hexId, actions);
                    
                    // End turn
                    if (!gameOver) {
                        console.log('Ending turn after keep');
                        switchTurn();
                        // Update base defence display
                        updateBaseDefenceDisplay();
                        // Update attack highlights for all pieces
                        highlightAllPiecesUnderAttack();
                    }
                } else {
                    console.log('No selected piece!');
                }
            };

            // Create release button
            const releaseButton = document.createElement('button');
            releaseButton.innerHTML = 'RELEASE';
            releaseButton.style.cssText = `
                background-color: #e74c3c;
                color: white;
                border: none;
                padding: 4px 8px;
                margin: 0 3px;
                border-radius: 4px;
                cursor: pointer;
                font-weight: bold;
                font-size: 10px;
                transition: all 0.2s ease;
                box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            `;
            releaseButton.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            releaseButton.onmouseout = function() { this.style.transform = 'scale(1)'; };
            releaseButton.onclick = function() {
                console.log('Release button clicked!');
                console.log('Before release - currentTurnPiece:', currentTurnPiece ? currentTurnPiece.id : 'null');
                console.log('Before release - selectedPiece:', selectedPiece ? selectedPiece.id : 'null');
                if (selectedPiece) {
                    // Clear highlights
                    document.querySelectorAll('.hexagon').forEach(hex => {
                        hex.classList.remove('highlight-green', 'highlight-red', 'highlight-danger', 'highlight-diagonal', 'highlight-gray', 'highlight-selected', 'highlight-under-attack', 'highlight-rhombus-check');
                    });
                    
                    // Clear selection
                    selectedPiece = null;
                    
                    // Clear current turn piece restriction
                    currentTurnPiece = null;
                    
                    // Clear dragged pieces
                    draggedPiece = null;
                    draggedFromHex = null;
                    
                    // Hide rotation controls
                    rotationControls.style.display = 'none';
                    
                    console.log('After release - currentTurnPiece:', currentTurnPiece);
                    console.log('After release - selectedPiece:', selectedPiece);
                    console.log('Piece released - you can now select another piece');
                } else {
                    console.log('No selected piece to release!');
                }
            };

            rotationControls.appendChild(rotateLeftButton);
            rotationControls.appendChild(keepButton);
            rotationControls.appendChild(rotateRightButton);
            rotationControls.appendChild(releaseButton);

            // Create center turn display
            const turnDisplay = document.createElement('div');
            turnDisplay.style.cssText = `
                background-color: ${currentPlayer === 'black' ? '#333' : '#fff'};
                color: ${currentPlayer === 'black' ? '#fff' : '#333'};
                padding: 10px 20px;
                border-radius: 20px;
                font-weight: bold;
                font-size: 16px;
                border: 2px solid ${currentPlayer === 'black' ? '#fff' : '#333'};
                box-shadow: 0 2px 10px rgba(0,0,0,0.5);
            `;
            turnDisplay.textContent = `${currentPlayer.toUpperCase()} TURN`;

            // Add guest indicator if user is logged in as guest
            if (isGuestUser()) {
                const guestIndicator = document.createElement('div');
                guestIndicator.style.cssText = `
                    display: inline-block;
                    background-color: #4ecdc4;
                    color: #262421;
                    padding: 2px 8px;
                    border-radius: 10px;
                    font-size: 10px;
                    font-weight: bold;
                    margin-left: 10px;
                    border: 1px solid #fff;
                    text-transform: uppercase;
                `;
                guestIndicator.textContent = 'GUEST';
                turnDisplay.appendChild(guestIndicator);
            }

            // Create right button (Help)
            const helpButton = document.createElement('button');
            helpButton.innerHTML = '‚ùì HELP';
            helpButton.style.cssText = `
                background-color: #4ecdc4;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 20px;
                cursor: pointer;
                font-weight: bold;
                font-size: 12px;
                box-shadow: 0 2px 8px rgba(78, 205, 196, 0.3);
                transition: all 0.3s ease;
            `;
            helpButton.onclick = showHelp;
            helpButton.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            helpButton.onmouseout = function() { this.style.transform = 'scale(1)'; };

            // Append all elements
            turnIndicator.appendChild(menuButton);
            if (aiModelButton) {
                turnIndicator.appendChild(aiModelButton);
            }
            turnIndicator.appendChild(coordButton);
            turnIndicator.appendChild(defenseButton);
            turnIndicator.appendChild(fogButton);
            
            // Create music toggle button (wooden board style)
            const musicButton = document.createElement('button');
            const updateMusicButtonDisplayLocal = () => {
                const isMusicOn = gameSettings.music && currentMusicTrack > 0;
                musicButton.innerHTML = isMusicOn ? 'üîä MUSIC' : 'üîá MUSIC';
                musicButton.style.backgroundColor = isMusicOn ? '#8B4513' : '#654321'; // Wooden brown colors
                musicButton.style.border = '2px solid #D2691E'; // Saddle brown border for wooden look
                musicButton.style.boxShadow = isMusicOn ? '0 2px 8px rgba(139, 69, 19, 0.4)' : '0 2px 8px rgba(101, 67, 33, 0.3)';
            };
            updateMusicButtonDisplayLocal(); // Initial display
            musicButton.style.cssText = `
                color: white;
                border: 2px solid #D2691E;
                padding: 4px 10px;
                border-radius: 15px;
                cursor: pointer;
                font-weight: bold;
                font-size: 10px;
                transition: all 0.3s ease;
                margin-left: 5px;
                background: linear-gradient(135deg, #8B4513, #654321); /* Wooden gradient */
            `;
            musicButton.onclick = function() {
                if (gameSettings.music && currentMusicTrack > 0) {
                    // Music is on, turn it off
                    stopBackgroundMusic();
                    gameSettings.music = false;
                } else {
                    // Music is off, turn it on
                    gameSettings.music = true;
                    if (gameSettings.currentMusicTrack > 0) {
                        playBackgroundMusic(gameSettings.currentMusicTrack);
                    } else {
                        playBackgroundMusic(1); // Start with track 1
                    }
                }
                updateMusicButtonDisplayLocal();
                saveSettings();
            };
            musicButton.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            musicButton.onmouseout = function() { this.style.transform = 'scale(1)'; };
            
            turnIndicator.appendChild(musicButton);
            
            turnIndicator.appendChild(turnDisplay);
            // Create undo button
            const undoButton = document.createElement('button');
            undoButton.innerHTML = '‚Ü©Ô∏è UNDO';
            undoButton.style.cssText = `
                background-color: #8884ff;
                color: white;
                border: none;
                padding: 4px 10px;
                border-radius: 15px;
                cursor: pointer;
                font-weight: bold;
                font-size: 10px;
                box-shadow: 0 2px 8px rgba(136, 132, 255, 0.3);
                transition: all 0.3s ease;
                margin-left: 6px;
            `;
            undoButton.onclick = undoLastMove;
            undoButton.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            undoButton.onmouseout = function() { this.style.transform = 'scale(1)'; };

            // Create toggle last move highlight button
            const toggleLastMoveButton = document.createElement('button');
            const isLastMoveVisible = typeof gameSettings !== 'undefined' ? gameSettings.showLastMove : true;
            toggleLastMoveButton.innerHTML = isLastMoveVisible ? 'üëÅÔ∏è HIDE' : 'üëÅÔ∏è SHOW';
            toggleLastMoveButton.title = 'Toggle last move highlight';
            toggleLastMoveButton.style.cssText = `
                background-color: ${isLastMoveVisible ? '#ffd700' : '#666'};
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 20px;
                cursor: pointer;
                font-weight: bold;
                font-size: 12px;
                box-shadow: 0 2px 8px rgba(255, 215, 0, 0.3);
                transition: all 0.3s ease;
                margin-left: 6px;
            `;
            toggleLastMoveButton.onclick = function() {
                if (typeof gameSettings !== 'undefined') {
                    gameSettings.showLastMove = !gameSettings.showLastMove;
                    this.innerHTML = gameSettings.showLastMove ? 'üëÅÔ∏è HIDE' : 'üëÅÔ∏è SHOW';
                    this.style.backgroundColor = gameSettings.showLastMove ? '#ffd700' : '#666';
                    
                    // Update the highlight display
                    if (gameSettings.showLastMove) {
                        highlightLastMove(lastMoveFrom, lastMoveTo);
                    } else {
                        clearLastMoveHighlight();
                    }
                }
            };
            toggleLastMoveButton.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            toggleLastMoveButton.onmouseout = function() { this.style.transform = 'scale(1)'; };

            // Create "Show All Moves" button
            const showAllMovesButton = document.createElement('button');
            showAllMovesButton.id = 'show-all-moves-button';
            showAllMovesButton.innerHTML = showAllMoves ? 'üëÅÔ∏è HIDE ALL' : 'üëÅÔ∏è SHOW ALL';
            showAllMovesButton.title = 'Show all possible moves for all pieces (including rotations)';
            showAllMovesButton.style.cssText = `
                background-color: ${showAllMoves ? '#00ff00' : '#666'};
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 20px;
                cursor: pointer;
                font-weight: bold;
                font-size: 12px;
                box-shadow: 0 2px 8px rgba(0, 255, 0, 0.3);
                transition: all 0.3s ease;
                margin-left: 6px;
            `;
            showAllMovesButton.onclick = toggleShowAllMoves;
            showAllMovesButton.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            showAllMovesButton.onmouseout = function() { this.style.transform = 'scale(1)'; };

            // Create board flip button (manual override for auto-flip)
            const flipButton = document.createElement('button');
            flipButton.id = 'flip-button';
            flipButton.innerHTML = boardFlipped ? 'üîÑ NORMAL' : 'üîÑ FLIP';
            flipButton.title = 'Manually flip board orientation (overrides auto-flip)';
            flipButton.style.cssText = `
                background-color: #ffa500;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 20px;
                cursor: pointer;
                font-weight: bold;
                font-size: 12px;
                box-shadow: 0 2px 8px rgba(255, 165, 0, 0.3);
                transition: all 0.3s ease;
                margin-left: 6px;
            `;
            flipButton.onclick = function() {
                toggleBoardFlip();
                this.innerHTML = boardFlipped ? 'üîÑ NORMAL' : 'üîÑ FLIP';
            };
            flipButton.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            flipButton.onmouseout = function() { this.style.transform = 'scale(1)'; };

            turnIndicator.appendChild(flipButton); // Always show flip button (for both players)
            turnIndicator.appendChild(helpButton);
            turnIndicator.appendChild(showAllMovesButton); // Add show all moves button
            turnIndicator.appendChild(toggleLastMoveButton);
            turnIndicator.appendChild(undoButton);
            
            // ============================================
            // RPN SYSTEM BUTTONS
            // ============================================
            
            // Copy Position button
            const copyPositionBtn = document.createElement('button');
            copyPositionBtn.innerHTML = 'üìã';
            copyPositionBtn.title = 'Copy position to clipboard (RPN)';
            copyPositionBtn.style.cssText = `
                background: #4ecdc4;
                color: white;
                border: none;
                padding: 8px 12px;
                border-radius: 6px;
                cursor: pointer;
                font-weight: 600;
                font-size: 1em;
                box-shadow: 0 2px 8px rgba(78, 205, 196, 0.3);
                transition: all 0.3s ease;
                margin-left: 6px;
            `;
            copyPositionBtn.onclick = copyPositionToClipboard;
            copyPositionBtn.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            copyPositionBtn.onmouseout = function() { this.style.transform = 'scale(1)'; };
            
            // Load Position button
            const loadPositionBtn = document.createElement('button');
            loadPositionBtn.innerHTML = 'üì•';
            loadPositionBtn.title = 'Load position from RPN notation';
            loadPositionBtn.style.cssText = `
                background: #a55eea;
                color: white;
                border: none;
                padding: 8px 12px;
                border-radius: 6px;
                cursor: pointer;
                font-weight: 600;
                font-size: 1em;
                box-shadow: 0 2px 8px rgba(165, 94, 234, 0.3);
                transition: all 0.3s ease;
                margin-left: 6px;
            `;
            loadPositionBtn.onclick = openLoadPositionModal;
            loadPositionBtn.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            loadPositionBtn.onmouseout = function() { this.style.transform = 'scale(1)'; };
            
            // Export Game button
            const exportGameBtn = document.createElement('button');
            exportGameBtn.innerHTML = 'üíæ';
            exportGameBtn.title = 'Download game in RMN format';
            exportGameBtn.style.cssText = `
                background: #ffd700;
                color: #262421;
                border: none;
                padding: 8px 12px;
                border-radius: 6px;
                cursor: pointer;
                font-weight: 600;
                font-size: 1em;
                box-shadow: 0 2px 8px rgba(255, 215, 0, 0.3);
                transition: all 0.3s ease;
                margin-left: 6px;
            `;
            exportGameBtn.onclick = downloadGameRMN;
            exportGameBtn.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            exportGameBtn.onmouseout = function() { this.style.transform = 'scale(1)'; };
            
            // Log RPN button (dev tool)
            const logRPNBtn = document.createElement('button');
            logRPNBtn.innerHTML = 'üîç';
            logRPNBtn.title = 'Log current RPN to console';
            logRPNBtn.style.cssText = `
                background: #555;
                color: white;
                border: none;
                padding: 8px 12px;
                border-radius: 6px;
                cursor: pointer;
                font-weight: 600;
                font-size: 1em;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
                transition: all 0.3s ease;
                margin-left: 6px;
            `;
            logRPNBtn.onclick = logPositionRPN;
            logRPNBtn.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            logRPNBtn.onmouseout = function() { this.style.transform = 'scale(1)'; };
            
            // Dark Mode Toggle button
            const darkModeBtn = document.createElement('button');
            darkModeBtn.innerHTML = 'üåô';
            darkModeBtn.title = 'Toggle Dark/Light Mode';
            darkModeBtn.style.cssText = `
                background: #7f8c8d;
                color: white;
                border: none;
                padding: 8px 12px;
                border-radius: 6px;
                cursor: pointer;
                font-weight: 600;
                font-size: 1em;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
                transition: all 0.3s ease;
                margin-left: 6px;
            `;
            darkModeBtn.onclick = toggleDarkMode;
            darkModeBtn.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            darkModeBtn.onmouseout = function() { this.style.transform = 'scale(1)'; };
            
            // Wooden Theme Toggle button
            const woodenThemeBtn = document.createElement('button');
            woodenThemeBtn.innerHTML = 'ü™µ';
            woodenThemeBtn.title = 'Toggle Wooden Board';
            woodenThemeBtn.style.cssText = `
                background: #8B4513;
                color: white;
                border: none;
                padding: 8px 12px;
                border-radius: 6px;
                cursor: pointer;
                font-weight: 600;
                font-size: 1em;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
                transition: all 0.3s ease;
                margin-left: 6px;
            `;
            woodenThemeBtn.onclick = toggleWoodenTheme;
            woodenThemeBtn.onmouseover = function() { this.style.transform = 'scale(1.05)'; };
            woodenThemeBtn.onmouseout = function() { this.style.transform = 'scale(1)'; };
            
            // Append RPN buttons
            turnIndicator.appendChild(copyPositionBtn);
            turnIndicator.appendChild(loadPositionBtn);
            turnIndicator.appendChild(exportGameBtn);
            turnIndicator.appendChild(logRPNBtn);
            turnIndicator.appendChild(darkModeBtn);
            turnIndicator.appendChild(woodenThemeBtn);
            
            // ============================================
            // END RPN BUTTONS
            // ============================================
            
            document.body.appendChild(turnIndicator);
            document.body.appendChild(rotationControls);
        }

        // Function to add eliminated piece to display
        function addToEliminatedPieces(piece) {
            const isWhite = piece.classList.contains('white-piece') || 
                           piece.classList.contains('white-triangle') || 
                           piece.classList.contains('white-rhombus') ||
                           piece.classList.contains('white-circle') ||
                           piece.classList.contains('white-hexgon');
            
            // Track in captured arrays for RPN export
            const pieceChar = pieceToChar(piece);
            if (pieceChar) {
                if (isWhite) {
                    capturedWhitePieces.push(pieceChar);
                    console.log(`üì¶ Captured WHITE piece: ${pieceChar}, total white captured: ${capturedWhitePieces.length}`);
                } else {
                    capturedBlackPieces.push(pieceChar);
                    console.log(`üì¶ Captured BLACK piece: ${pieceChar}, total black captured: ${capturedBlackPieces.length}`);
                }
            }
            
            const eliminatedContainer = isWhite ? 
                document.getElementById('white-eliminated') : 
                document.getElementById('black-eliminated');
            
            // Create a copy of the piece for the eliminated display
            const eliminatedPiece = document.createElement('div');
            eliminatedPiece.className = piece.className + ' eliminated-piece';
            
            // Remove positioning and make it smaller
            eliminatedPiece.style.position = 'static';
            eliminatedPiece.style.transform = 'none';
            eliminatedPiece.style.top = 'auto';
            eliminatedPiece.style.left = 'auto';
            eliminatedPiece.style.margin = '2px';
            
            eliminatedContainer.appendChild(eliminatedPiece);
            // Link eliminated entry to original so undo can remove it
            const elimId = Date.now().toString() + Math.random().toString(36).slice(2);
            piece.setAttribute('data-eliminated-id', elimId);
            eliminatedPiece.setAttribute('data-eliminated-id', elimId);
            
            // Check if a rhombus was eliminated - if so, game over
            if (piece.classList.contains('rhombus-piece')) {
                showGameOver(isWhite ? 'Black' : 'White', 'A rhombus was eliminated!');
            }
        }
        
        // Helper function to add captured piece to display from RPN character
        function addCapturedPieceToDisplay(pieceChar, isWhite) {
            const eliminatedContainer = isWhite ? 
                document.getElementById('white-eliminated') : 
                document.getElementById('black-eliminated');
            
            const pieceData = charToPiece(pieceChar);
            if (!pieceData) return;
            
            const eliminatedPiece = document.createElement('div');
            eliminatedPiece.className = pieceData.baseClass + ' eliminated-piece';
            if (pieceData.specificClass) {
                eliminatedPiece.classList.add(pieceData.specificClass);
            }
            
            // Remove positioning and make it smaller
            eliminatedPiece.style.position = 'static';
            eliminatedPiece.style.transform = 'none';
            eliminatedPiece.style.top = 'auto';
            eliminatedPiece.style.left = 'auto';
            eliminatedPiece.style.margin = '2px';
            
            eliminatedContainer.appendChild(eliminatedPiece);
            console.log(`üì¶ Added ${isWhite ? 'WHITE' : 'BLACK'} ${pieceData.baseClass} to eliminated panel`);
        }

        // Function to check win conditions
        function checkWinConditions(row, col, piece) {
            // Check if it's a rhombus piece
            if (piece.classList.contains('rhombus-piece')) {
                const isWhite = piece.classList.contains('white-rhombus');
                
                // Check if we're in "Escape Race" mode (only rhombuses remain)
                const isEscapeRaceMode = checkEscapeRaceMode();
                
                // Black rhombus reaches 3-0 (row 3, col 0) - Black wins
                if (!isWhite && row == 3 && col == 0) {
                    if (isEscapeRaceMode) {
                        // Escape Race mode - Base Defence disabled, instant win!
                        showGameOver('Black', '‚öîÔ∏è ESCAPE RACE! Black rhombus reached the goal first!');
                        return;
                    }
                    
                    // Normal mode - Check if white base defence is active
                    const activeDefences = isBaseDefenceActive();
                    if (activeDefences.includes('white')) {
                        // White base defence is active, black cannot win
                        return;
                    }
                    showGameOver('Black', 'Black rhombus reached the goal!');
                }
                // White rhombus reaches 3-8 (row 3, col 8) - White wins
                else if (isWhite && row == 3 && col == 8) {
                    if (isEscapeRaceMode) {
                        // Escape Race mode - Base Defence disabled, instant win!
                        showGameOver('White', '‚öîÔ∏è ESCAPE RACE! White rhombus reached the goal first!');
                        return;
                    }
                    
                    // Normal mode - Check if black base defence is active
                    const activeDefences = isBaseDefenceActive();
                    if (activeDefences.includes('black')) {
                        // Black base defence is active, white cannot win
                        return;
                    }
                    showGameOver('White', 'White rhombus reached the goal!');
                }
            }
        }
        
        // Function to check if game is in "Escape Race" mode (only rhombuses remain)
        function checkEscapeRaceMode() {
            const allSquares = document.querySelectorAll('.square-piece');
            const allTriangles = document.querySelectorAll('.triangle-piece');
            const allCircles = document.querySelectorAll('.circle-piece');
            const allHexgons = document.querySelectorAll('.hexgon-piece');
            
            // Check if ONLY rhombuses remain (no other pieces)
            const onlyRhombusesRemain = allSquares.length === 0 && 
                                       allTriangles.length === 0 && 
                                       allCircles.length === 0 && 
                                       allHexgons.length === 0;
            
            return onlyRhombusesRemain;
        }
        
        // Track if we've already shown the Escape Race notification
        let escapeRaceNotificationShown = false;
        
        // Function to check and notify when Escape Race mode activates
        function checkAndNotifyEscapeRace() {
            if (escapeRaceNotificationShown) return; // Already shown
            
            if (checkEscapeRaceMode()) {
                escapeRaceNotificationShown = true;
                
                // Create overlay notification
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: linear-gradient(135deg, #ff6b6b, #ee5a6f);
                    color: white;
                    padding: 30px 50px;
                    border-radius: 20px;
                    border: 3px solid #fff;
                    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
                    z-index: 2000;
                    text-align: center;
                    font-family: Arial, sans-serif;
                    animation: escapeRacePulse 0.5s ease-in-out;
                `;
                
                notification.innerHTML = `
                    <h2 style="margin: 0 0 15px 0; font-size: 2.5em; text-shadow: 2px 2px 4px rgba(0,0,0,0.3);">
                        ‚öîÔ∏è ESCAPE RACE! ‚öîÔ∏è
                    </h2>
                    <p style="margin: 0 0 10px 0; font-size: 1.2em; line-height: 1.5;">
                        All other pieces eliminated!<br>
                        <strong>Base Defence is DISABLED</strong><br>
                        First rhombus to goal wins!
                    </p>
                    <p style="margin: 10px 0 0 0; font-size: 0.9em; opacity: 0.9;">
                        White goal: 3-8 | Black goal: 3-0
                    </p>
                `;
                
                // Add animation CSS
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes escapeRacePulse {
                        0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
                        50% { transform: translate(-50%, -50%) scale(1.1); }
                        100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
                    }
                `;
                document.head.appendChild(style);
                
                document.body.appendChild(notification);
                
                // Auto-remove after 4 seconds
                setTimeout(() => {
                    notification.style.transition = 'opacity 0.5s, transform 0.5s';
                    notification.style.opacity = '0';
                    notification.style.transform = 'translate(-50%, -50%) scale(0.8)';
                    setTimeout(() => notification.remove(), 500);
                }, 4000);
            }
        }

        // Function to check if current player has ANY legal moves (for stalemate detection)
        function doesPlayerHaveAnyLegalMoves(isWhite) {
            console.log(`üîç Checking if ${isWhite ? 'WHITE' : 'BLACK'} has any legal moves...`);
            
            // Get all pieces for this player
            const pieceSelector = isWhite 
                ? '.square-piece.white-piece, .triangle-piece.white-triangle, .rhombus-piece.white-rhombus, .circle-piece.white-circle, .hexgon-piece.white-hexgon'
                : '.square-piece:not(.white-piece), .triangle-piece:not(.white-triangle), .rhombus-piece:not(.white-rhombus), .circle-piece:not(.white-circle), .hexgon-piece:not(.white-hexgon)';
            
            const playerPieces = document.querySelectorAll(pieceSelector);
            console.log(`Found ${playerPieces.length} pieces for ${isWhite ? 'WHITE' : 'BLACK'}`);
            
            // Check each piece to see if it has at least one legal move
            for (const piece of playerPieces) {
                const hex = piece.closest('.hexagon');
                if (!hex) continue;
                
                const [, row, col] = hex.id.match(/hex-(\d+)-(\d+)/);
                const pieceRow = parseInt(row);
                const pieceCol = parseInt(col);
                
                // Get possible moves based on piece type
                let possibleMoves = [];
                if (piece.classList.contains('square-piece')) {
                    possibleMoves = getSquareMoves(pieceRow, pieceCol);
                } else if (piece.classList.contains('triangle-piece')) {
                    possibleMoves = getTriangleMoves(pieceRow, pieceCol, getTriangleOrientation(hex.id) || 0);
                } else if (piece.classList.contains('rhombus-piece')) {
                    possibleMoves = getRhombusMoves(pieceRow, pieceCol);
                } else if (piece.classList.contains('circle-piece')) {
                    possibleMoves = getCircleMoves(pieceRow, pieceCol);
                } else if (piece.classList.contains('hexgon-piece')) {
                    possibleMoves = getHexgonMoves(pieceRow, pieceCol);
                }
                
                // Check if any of these moves are legal (don't put rhombus in check)
                for (const [targetRow, targetCol] of possibleMoves) {
                    const targetHex = document.getElementById(`hex-${targetRow}-${targetCol}`);
                    if (!targetHex) continue;
                    
                    const occupyingPiece = targetHex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                    
                    // Skip if occupied by friendly piece (except rhombus can't capture rhombus)
                    if (occupyingPiece) {
                        const isOccupyingWhite = occupyingPiece.classList.contains('white-piece') || 
                                                occupyingPiece.classList.contains('white-triangle') || 
                                                occupyingPiece.classList.contains('white-rhombus') ||
                                                occupyingPiece.classList.contains('white-circle') ||
                                                occupyingPiece.classList.contains('white-hexgon');
                        
                        if (isOccupyingWhite === isWhite) continue; // Friendly piece
                        if (piece.classList.contains('rhombus-piece') && occupyingPiece.classList.contains('rhombus-piece')) {
                            continue; // Rhombus can't capture rhombus
                        }
                    }
                    
                    // Check if this move would put own rhombus in check
                    const pieceClasses = piece.className;
                    const wouldBeIllegal = wouldMoveResultInOwnCheckmate(hex.id, targetHex.id, pieceClasses, occupyingPiece);
                    
                    if (!wouldBeIllegal) {
                        console.log(`‚úÖ Legal move found: ${hex.id} ‚Üí ${targetHex.id}`);
                        return true; // Found at least one legal move
                    }
                }
            }
            
            console.log(`‚ùå NO LEGAL MOVES for ${isWhite ? 'WHITE' : 'BLACK'}!`);
            return false; // No legal moves found
        }

        // Function to check if a rhombus is in deadlock (checkmate) or stalemate
        function checkRhombusDeadlock() {
            console.log('üîç Checking for rhombus deadlock...');
            
            // Check both rhombuses
            const whiteRhombus = document.querySelector('.rhombus-piece.white-rhombus');
            const blackRhombus = document.querySelector('.rhombus-piece:not(.white-rhombus)');
            
            // Check white rhombus deadlock (ONLY if under attack AND no moves)
            if (whiteRhombus) {
                const deadlockResult = isRhombusInDeadlock(whiteRhombus, true);
                console.log('White rhombus deadlock check:', deadlockResult);
                // CRITICAL: Only trigger game over if rhombus is BOTH under attack AND has no moves
                if (deadlockResult.isDeadlocked && deadlockResult.underAttack) {
                    console.log('‚ö†Ô∏è WHITE RHOMBUS CHECKMATE! Black wins!');
                    showGameOver('Black', '‚ôüÔ∏è Checkmate! White rhombus is under attack with no escape!');
                    return true;
                }
                // If rhombus has no moves but is NOT under attack, game continues (not stalemate)
            }
            
            // Check black rhombus deadlock (ONLY if under attack AND no moves)
            if (blackRhombus) {
                const deadlockResult = isRhombusInDeadlock(blackRhombus, false);
                console.log('Black rhombus deadlock check:', deadlockResult);
                // CRITICAL: Only trigger game over if rhombus is BOTH under attack AND has no moves
                if (deadlockResult.isDeadlocked && deadlockResult.underAttack) {
                    console.log('‚ö†Ô∏è BLACK RHOMBUS CHECKMATE! White wins!');
                    showGameOver('White', '‚ôüÔ∏è Checkmate! Black rhombus is under attack with no escape!');
                    return true;
                }
                // If rhombus has no moves but is NOT under attack, game continues (not stalemate)
            }
            
            console.log('No rhombus deadlock detected');
            return false;
        }

        // Function to check if a specific rhombus is in deadlock (returns object with details)
        function isRhombusInDeadlock(rhombus, isWhite) {
            const rhombusHex = rhombus.parentElement;
            const rhombusId = rhombusHex.id;
            const [, rhombusRow, rhombusCol] = rhombusId.match(/hex-(\d+)-(\d+)/);
            
            console.log(`Checking ${isWhite ? 'WHITE' : 'BLACK'} rhombus at ${rhombusRow}-${rhombusCol}`);
            
            // Check if rhombus is under attack
            const underAttack = isPieceUnderThreat(parseInt(rhombusRow), parseInt(rhombusCol), isWhite);
            console.log(`Rhombus under attack: ${underAttack}`);
            
            // Get all possible moves for this rhombus
            const possibleMoves = getRhombusMoves(parseInt(rhombusRow), parseInt(rhombusCol));
            console.log(`Possible moves for rhombus:`, possibleMoves);
            
            // Check each possible move
            let hasLegalMove = false;
            for (const [targetRow, targetCol] of possibleMoves) {
                const targetHex = document.getElementById(`hex-${targetRow}-${targetCol}`);
                if (!targetHex) continue;
                
                // Check if this hex is occupied
                const occupyingPiece = targetHex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                
                let canMoveHere = false;
                
                if (!occupyingPiece) {
                    // Empty hex - can potentially move here
                    canMoveHere = true;
                } else {
                    // Check if it's an opponent piece (can capture)
                    const isOccupyingWhite = occupyingPiece.classList.contains('white-piece') || 
                                            occupyingPiece.classList.contains('white-triangle') || 
                                            occupyingPiece.classList.contains('white-rhombus') ||
                                            occupyingPiece.classList.contains('white-circle') ||
                                            occupyingPiece.classList.contains('white-hexgon');
                    
                    // If occupying piece is opponent and not a rhombus, can capture
                    if (isOccupyingWhite !== isWhite && !occupyingPiece.classList.contains('rhombus-piece')) {
                        canMoveHere = true;
                    }
                }
                
                // If we can move here, check if rhombus would STILL be under attack after moving
                if (canMoveHere) {
                    console.log(`Simulating move to ${targetRow}-${targetCol}...`);
                    
                    // Simulate the move: hide rhombus at current position, check if it would be threatened at new position
                    rhombus.style.display = 'none';
                    if (occupyingPiece) occupyingPiece.style.display = 'none';
                    
                    // Create temporary rhombus at target position
                    const tempRhombus = document.createElement('div');
                    tempRhombus.className = rhombus.className;
                    tempRhombus.setAttribute('data-temp-simulation', 'true');
                    targetHex.appendChild(tempRhombus);
                    
                    // Check if rhombus would be under attack at new position
                    const wouldBeUnderAttack = isPieceUnderThreat(targetRow, targetCol, isWhite);
                    console.log(`Would be under attack at ${targetRow}-${targetCol}: ${wouldBeUnderAttack}`);
                    
                    // Clean up simulation
                    tempRhombus.remove();
                    rhombus.style.display = '';
                    if (occupyingPiece) occupyingPiece.style.display = '';
                    
                    // If this move would get rhombus out of check, it's a legal move!
                    if (!wouldBeUnderAttack) {
                        console.log(`Found legal move to ${targetRow}-${targetCol}!`);
                        hasLegalMove = true;
                        break;
                    }
                }
            }
            
            // If no legal moves available that get rhombus out of check - deadlock!
            if (!hasLegalMove) {
                console.log('No legal moves found - rhombus is in deadlock!');
                return { isDeadlocked: true, underAttack: underAttack };
            }
            
            console.log('Rhombus has legal moves - NOT in deadlock');
            return { isDeadlocked: false, underAttack: underAttack };
        }
        
        // NEW: Check if a move would result in checkmate for your own rhombus
        function wouldMoveResultInOwnCheckmate(fromHexId, toHexId, movingPieceClasses, capturedPiece) {
            // Check if a move would result in own rhombus being checkmated
            
            // Find the player's rhombus
            const isWhiteMoving = movingPieceClasses.includes('white-piece') || 
                                 movingPieceClasses.includes('white-triangle') || 
                                 movingPieceClasses.includes('white-rhombus') ||
                                 movingPieceClasses.includes('white-circle') ||
                                 movingPieceClasses.includes('white-hexgon');
            
            // determine if white is moving
            
            const rhombusSelector = isWhiteMoving ? '.rhombus-piece.white-rhombus' : '.rhombus-piece:not(.white-rhombus)';
            const playerRhombus = document.querySelector(rhombusSelector);
            
            if (!playerRhombus) {
                console.log('No rhombus found for player');
                return false; // No rhombus to protect
            }
            
            const rhombusHex = playerRhombus.parentElement;
            const rhombusId = rhombusHex.id;
            const [, rhombusRow, rhombusCol] = rhombusId.match(/hex-(\d+)-(\d+)/);
            
            // player rhombus coordinates: rhombusRow,rhombusCol
            
            // Check if the rhombus itself is being moved
            const isMovingRhombus = movingPieceClasses.includes('rhombus-piece');
            // flag: isMovingRhombus
            
            // Get the piece being moved
            const fromHex = document.getElementById(fromHexId);
            const toHex = document.getElementById(toHexId);
            const movingPiece = fromHex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
            
            if (!movingPiece) {
                return false;
            }
            
            // Temporarily hide the moving piece and captured piece for simulation
            movingPiece.style.display = 'none';
            const capturedPieceBackup = capturedPiece ? capturedPiece.style.display : null;
            if (capturedPiece) capturedPiece.style.display = 'none';
            
            // Create temporary piece at destination
            const tempPiece = document.createElement('div');
            tempPiece.className = movingPieceClasses;
            tempPiece.setAttribute('data-temp-simulation', 'true');
            toHex.appendChild(tempPiece);
            
            // temp piece created at destination for simulation
            
            // QUICK WIN CASE: If the move places the player's rhombus onto the opponent's goal hex, it's an immediate win -> NOT illegal
            // Note: Winning goal hexes are fixed: Black goal = hex-3-0, White goal = hex-3-8
            const moverIsWhite = movingPieceClasses.includes('white-rhombus') || movingPieceClasses.includes('white-piece');
            // The goal hex for the mover: White wins by reaching hex-3-8, Black wins by reaching hex-3-0
            const moverGoalHex = moverIsWhite ? 'hex-3-8' : 'hex-3-0';
            // quick-win mover details
            if (isMovingRhombus && toHexId === moverGoalHex) {
                // For shape-defense variant, do not auto-allow a rhombus win if the destination
                // goal hex is attackable by the opponent. In that case, the move should be
                // considered illegal (blocked) unless the attacker is captured.
                try {
                    // Check either the global variable or the settings-backed variant (UI may set gameSettings)
                    const currentBaseDefense = (typeof window.baseDefenseVariant !== 'undefined') ? window.baseDefenseVariant : (window.gameSettings && window.gameSettings.baseDefenseVariant);
                    // current base defense variant checked
                    if (currentBaseDefense === 'shape-defense') {
                        const [, destR, destC] = toHexId.match(/hex-(\d+)-(\d+)/);
                        const destAttackable = isSquareAttackableByColor(parseInt(destR), parseInt(destC), !moverIsWhite);
                        // wouldMoveResultInOwnCheckmate tracing removed
                        if (destAttackable) {
                            // Clean up simulation before returning that move is illegal
                            tempPiece.remove();
                            movingPiece.style.display = '';
                            if (capturedPiece && capturedPieceBackup !== null) {
                                capturedPiece.style.display = capturedPieceBackup;
                            }
                            return true; // mark as illegal
                        }
                    }
                } catch (e) {
                    console.warn('Error evaluating shape-defense on quick win:', e);
                }

                // move places rhombus on mover goal hex - allow as win
                // Clean up the temp simulation before returning
                tempPiece.remove();
                movingPiece.style.display = '';
                if (capturedPiece && capturedPieceBackup !== null) {
                    capturedPiece.style.display = capturedPieceBackup;
                }
                return false;
            }

            // If moving the rhombus itself, check the NEW position; otherwise check the original position
            const [, toRow, toCol] = toHexId.match(/hex-(\d+)-(\d+)/);
            const checkRow = isMovingRhombus ? parseInt(toRow) : parseInt(rhombusRow);
            const checkCol = isMovingRhombus ? parseInt(toCol) : parseInt(rhombusCol);
            
            console.log(`Checking if rhombus would be under attack at: ${checkRow}-${checkCol}`);
            
            // Check if rhombus would be under attack after this move
            const underAttack = isPieceUnderThreat(checkRow, checkCol, isWhiteMoving);
            
            console.log('Rhombus under attack after move:', underAttack);
            
            let wouldBeIllegal = false;
            
            if (underAttack) {
                // If rhombus is moving and capturing the piece that would be attacking it, that's LEGAL!
                if (isMovingRhombus && capturedPiece) {
                    console.log('‚úÖ Rhombus is capturing the attacking piece - move is LEGAL');
                    wouldBeIllegal = false;
                } else {
                    // Rhombus would be under attack after this move - ILLEGAL!
                    // In chess terms: You cannot make a move that leaves your king in check
                    console.log('‚ùå ILLEGAL! This move would leave your rhombus under attack!');
                    wouldBeIllegal = true;
                }
            } else {
                console.log('‚úÖ Rhombus not under attack - move is safe');
            }
            
            // Clean up simulation
            tempPiece.remove();
            movingPiece.style.display = '';
            if (capturedPiece && capturedPieceBackup !== null) {
                capturedPiece.style.display = capturedPieceBackup;
            }
            
            console.log('Final result - would be illegal move:', wouldBeIllegal);
            
            return wouldBeIllegal;
        }

        // Function to get all possible moves for a hexgon at a given position
        function getHexgonMoves(centerRow, centerCol, rotation = 0) {
            let targets = [];
            
            if (centerRow === 0) {
                switch (centerCol) {
                    case 0: targets = [[0,1],[1,2]]; break;
                    case 1: targets = [[0,0],[1,0],[0,2],[1,3]]; break;
                    case 2: targets = [[0,1],[1,1],[0,3],[1,4]]; break;
                    case 3: targets = [[0,2],[1,2],[0,4],[1,5]]; break;
                    case 4: targets = [[0,3],[1,3],[0,5],[1,6]]; break;
                    case 5: targets = [[0,4],[1,4]]; break;
                    default: targets = [];
                }
            } else if (centerRow === 1) {
                switch (centerCol) {
                    case 0: targets = [[1,1],[2,2],[0,1]]; break;
                    case 1: targets = [[0,0],[1,0],[0,2],[1,3]]; break;
                    case 2: targets = [[1,1],[2,1],[0,0],[1,3],[2,4],[0,3]]; break;
                    case 3: targets = [[1,2],[2,2],[0,1],[1,4],[2,5],[0,4]]; break;
                    case 4: targets = [[1,3],[2,3],[0,2],[1,5],[2,6],[0,5]]; break;
                    case 5: targets = [[1,4],[2,4],[0,3],[1,6]]; break;
                    case 6: targets = [[2,6],[3,6],[1,5]]; break;
                    default: targets = [];
                }
            } else if (centerRow === 2) {
                switch (centerCol) {
                    case 0: targets = [[2,1],[3,2],[1,1]]; break;
                    case 1: targets = [[2,2],[3,3],[1,2],[2,0]]; break;
                    case 2: targets = [[2,3],[3,4],[1,3],[2,1],[3,1],[1,0]]; break;
                    case 3: targets = [[2,4],[3,5],[1,4],[2,2],[3,2],[1,1]]; break;
                    case 4: targets = [[2,5],[3,6],[1,5],[2,3],[3,3],[1,2]]; break;
                    case 5: targets = [[2,6],[3,7],[1,6],[2,4],[3,4],[1,3]]; break;
                    case 6: targets = [[2,7],[2,5],[3,5],[1,4]]; break;
                    case 7: targets = [[2,6],[3,6],[1,5]]; break;
                    default: targets = [];
                }
            } else if (centerRow === 3) {
                // Row 3 with rotation-based patterns
                if (centerCol === 0) {
                    if (rotation === 0) targets = [[4,1],[3,1],[2,1]];
                    else if (rotation === 1) targets = [[4,1],[4,0]];
                    else if (rotation === 2) targets = [[2,1],[2,0]];
                } else if (centerCol === 1) {
                    if (rotation === 0) targets = [[4,2],[3,2],[2,2],[3,0]];
                    else if (rotation === 1) targets = [[5,0],[4,1],[4,0],[2,0],[1,0]];
                    else if (rotation === 2) targets = [[1,0],[2,1],[2,2],[4,0],[5,0]];
                } else if (centerCol === 2) {
                    if (rotation === 0) targets = [[4,0],[3,1],[2,0],[4,3],[3,3],[2,3]];
                    else if (rotation === 1) targets = [[5,1],[4,2],[4,3],[2,0],[2,1],[1,1]];
                    else if (rotation === 2) targets = [[4,0],[4,1],[5,1],[2,3],[2,2],[1,1]];
                } else if (centerCol === 3) {
                    if (rotation === 0) targets = [[4,1],[3,2],[2,1],[4,4],[3,4],[2,4]];
                    else if (rotation === 1) targets = [[5,2],[4,3],[4,4],[2,1],[2,2],[1,2]];
                    else if (rotation === 2) targets = [[5,2],[4,2],[4,1],[1,2],[2,3],[2,4]];
                } else if (centerCol === 4) {
                    if (rotation === 0) targets = [[4,2],[3,3],[2,2],[4,5],[3,5],[2,5]];
                    else if (rotation === 1) targets = [[5,3],[4,4],[4,5],[2,2],[2,3],[1,3]];
                    else if (rotation === 2) targets = [[5,3],[4,3],[4,2],[1,3],[2,4],[2,5]];
                } else if (centerCol === 5) {
                    if (rotation === 0) targets = [[4,3],[3,4],[2,3],[4,6],[3,6],[2,6]];
                    else if (rotation === 1) targets = [[5,4],[4,5],[4,6],[2,3],[2,4],[1,4]];
                    else if (rotation === 2) targets = [[5,4],[4,4],[4,3],[1,4],[2,5],[2,6]];
                } else if (centerCol === 6) {
                    if (rotation === 0) targets = [[4,4],[3,5],[2,4],[4,7],[3,7],[2,7]];
                    else if (rotation === 1) targets = [[5,5],[4,6],[4,7],[2,4],[2,5],[1,5]];
                    else if (rotation === 2) targets = [[5,5],[4,5],[4,4],[1,5],[2,6],[2,7]];
                } else if (centerCol === 7) {
                    if (rotation === 0) targets = [[4,5],[3,6],[2,5],[3,8]];
                    else if (rotation === 1) targets = [[5,6],[4,7],[2,5],[2,6],[1,6]];
                    else if (rotation === 2) targets = [[2,7],[1,6],[5,8],[4,6],[4,5]];
                } else if (centerCol === 8) {
                    if (rotation === 0) targets = [[4,6],[3,7],[2,6]];
                    else if (rotation === 1) targets = [[5,6],[4,7],[2,5],[2,6],[1,6]];
                    else if (rotation === 2) targets = [[2,7],[1,6],[5,8],[4,6],[4,5]];
                }
            } else if (centerRow === 4) {
                switch (centerCol) {
                    case 0: targets = [[4,1],[3,2],[5,1]]; break;
                    case 1: targets = [[4,0],[4,2],[5,2],[3,3]]; break;
                    case 2: targets = [[4,1],[5,0],[3,1],[4,3],[5,3],[3,4]]; break;
                    case 3: targets = [[4,2],[5,1],[3,2],[4,4],[5,4],[3,5]]; break;
                    case 4: targets = [[4,3],[5,2],[3,3],[4,5],[5,5],[3,6]]; break;
                    case 5: targets = [[4,4],[5,3],[3,4],[4,6],[5,6],[3,7]]; break;
                    case 6: targets = [[4,5],[5,4],[3,5],[4,7]]; break;
                    case 7: targets = [[4,6],[5,5],[3,6]]; break;
                    default: targets = [];
                }
            } else if (centerRow === 5) {
                switch (centerCol) {
                    case 0: targets = [[5,1],[6,1],[4,2]]; break;
                    case 1: targets = [[5,0],[6,2],[5,2],[4,3]]; break;
                    case 2: targets = [[5,1],[6,0],[4,1],[5,3],[6,3],[4,4]]; break;
                    case 3: targets = [[5,2],[6,1],[4,2],[5,4],[6,4],[4,5]]; break;
                    case 4: targets = [[5,3],[6,2],[4,3],[5,5],[6,5],[4,6]]; break;
                    case 5: targets = [[5,4],[6,3],[4,4],[5,6]]; break;
                    case 6: targets = [[5,5],[6,4],[4,5]]; break;
                    default: targets = [];
                }
            } else if (centerRow === 6) {
                switch (centerCol) {
                    case 0: targets = [[6,1],[5,2]]; break;
                    case 1: targets = [[6,0],[5,0],[6,2],[5,3]]; break;
                    case 2: targets = [[6,1],[5,1],[6,3],[5,4]]; break;
                    case 3: targets = [[6,2],[5,2],[6,4],[5,5]]; break;
                    case 4: targets = [[6,3],[5,3],[6,5],[5,6]]; break;
                    case 5: targets = [[6,4],[5,4]]; break;
                    default: targets = [];
                }
            }
            
            return targets;
        }
        
        // Function to get all possible moves for a rhombus at a given position
        function getRhombusMoves(centerRow, centerCol) {
            let targets = [];
            
            // Dead zone and inner perimeter definitions for special diagonal moves
            const deadZone = new Set(["3-3", "3-4", "3-5"]);
            const innerPerimeter = new Set(["2-2", "2-3", "2-4", "2-5", "3-2", "3-6", "4-2", "4-3", "4-4", "4-5"]);
            const currentPos = `${centerRow}-${centerCol}`;
            
            // Use the same mapping as showRhombusMovementPattern
            if (centerRow === 0) {
                switch (centerCol) {
                    case 0: targets = [[2,1],[0,1],[0,2]]; break;
                    case 1: targets = [[2,2],[0,2],[0,3],[0,0]]; break;
                    case 2: targets = [[2,3],[0,3],[0,4],[0,0],[0,1]]; break;
                    case 3: targets = [[2,4],[0,4],[0,5],[0,1],[0,2]]; break;
                    case 4: targets = [[2,5],[0,5],[0,3],[0,2]]; break;
                    case 5: targets = [[2,6],[0,4],[0,3]]; break;
                }
            } else if (centerRow === 1) {
                switch (centerCol) {
                    case 0: targets = [[3,1],[1,2],[1,1]]; break;
                    case 1: targets = [[3,2],[1,0],[1,2],[1,3]]; break;
                    case 2: targets = [[3,3],[1,3],[1,4],[1,1],[1,0]]; break;
                    case 3: targets = [[3,4],[1,4],[1,5],[1,2],[1,1]]; break;
                    case 4: targets = [[3,5],[1,5],[1,6],[1,3],[1,2]]; break;
                    case 5: targets = [[1,4],[1,3],[3,6]]; break;
                    case 6: targets = [[3,7],[1,5],[1,4]]; break;
                }
            } else if (centerRow === 2) {
                switch (centerCol) {
                    case 0: targets = [[4,0],[2,1],[2,2]]; break;
                    case 1: targets = [[4,1],[2,2],[2,3],[0,0]]; break;
                    case 2: targets = [[2,1],[2,0],[4,2],[2,3],[2,4],[0,1]]; break;
                    case 3: targets = [[2,2],[2,1],[4,3],[2,4],[2,5],[0,2]]; break;
                    case 4: targets = [[2,3],[2,2],[4,4],[2,5],[2,6],[0,3]]; break;
                    case 5: targets = [[2,4],[2,3],[4,5],[2,6],[2,7],[0,4]]; break;
                    case 6: targets = [[2,5],[2,4],[4,6],[2,7],[0,5]]; break;
                    case 7: targets = [[2,6],[2,5],[4,7]]; break;
                }
            } else if (centerRow === 3) {
                switch (centerCol) {
                    case 0: targets = [[3,2],[3,1]]; break;
                    case 1: targets = [[1,0],[5,0],[3,2],[3,3]]; break;
                    case 2: targets = [[1,1],[5,1],[3,1],[3,0],[3,3],[3,4]]; break;
                    case 3: targets = [[1,2],[5,2],[3,2],[3,1],[3,4],[3,5]]; break;
                    case 4: targets = [[1,3],[5,3],[3,3],[3,2],[3,5],[3,6]]; break;
                    case 5: targets = [[1,4],[5,4],[3,4],[3,3],[3,6],[3,7]]; break;
                    case 6: targets = [[1,5],[5,5],[3,5],[3,4],[3,7],[3,8]]; break;
                    case 7: targets = [[1,6],[5,6],[3,6],[3,5],[3,8]]; break;
                    case 8: targets = [[3,7],[3,6]]; break;
                }
            } else if (centerRow === 4) {
                switch (centerCol) {
                    case 0: targets = [[4,1],[4,2],[2,0]]; break;
                    case 1: targets = [[6,0],[2,1],[4,0],[4,2],[4,3]]; break;
                    case 2: targets = [[6,1],[2,2],[4,1],[4,0],[4,3],[4,4]]; break;
                    case 3: targets = [[6,2],[2,3],[4,2],[4,1],[4,4],[4,5]]; break;
                    case 4: targets = [[6,3],[2,4],[4,3],[4,2],[4,5],[4,6]]; break;
                    case 5: targets = [[6,4],[2,5],[4,4],[4,3],[4,6],[4,7]]; break;
                    case 6: targets = [[6,5],[2,6],[4,5],[4,4],[4,7]]; break;
                    case 7: targets = [[4,6],[4,5],[2,7]]; break;
                }
            } else if (centerRow === 5) {
                switch (centerCol) {
                    case 0: targets = [[5,1],[5,2],[3,1]]; break;
                    case 1: targets = [[3,2],[5,0],[5,2],[5,3]]; break;
                    case 2: targets = [[3,3],[5,3],[5,4],[5,1],[5,0]]; break;
                    case 3: targets = [[3,4],[5,4],[5,5],[5,2],[5,1]]; break;
                    case 4: targets = [[3,5],[5,5],[5,6],[5,3],[5,2]]; break;
                    case 5: targets = [[5,4],[5,3],[3,6]]; break;
                    case 6: targets = [[3,7],[5,5],[5,4]]; break;
                }
            } else if (centerRow === 6) {
                switch (centerCol) {
                    case 0: targets = [[6,1],[6,2],[4,1]]; break;
                    case 1: targets = [[6,0],[6,2],[6,3],[4,2]]; break;
                    case 2: targets = [[6,3],[6,4],[6,1],[6,0],[4,3]]; break;
                    case 3: targets = [[6,4],[6,5],[6,2],[6,1],[4,4]]; break;
                    case 4: targets = [[6,5],[6,3],[6,2],[4,5]]; break;
                    case 5: targets = [[6,4],[6,3],[4,6]]; break;
                }
            }
            
            // SPECIAL ABILITY: When rhombus is in dead zone or specific inner perimeter positions,
            // it can move diagonally between these zones (ONLY between dead zone and inner zone)
            if (deadZone.has(currentPos) || innerPerimeter.has(currentPos)) {
                const diagonalMoves = [];
                
                // Define exact diagonal connections between dead zone and inner perimeter
                // These are the ONLY allowed diagonal moves for this special ability
                const diagonalConnections = {
                    // Dead zone positions and their specific diagonal inner perimeter neighbors
                    "3-3": [[4,2], [2,2], [2,3], [4,3]],           // 3-3 can reach 4-2, 2-2, 2-3, 4-3
                    "3-4": [[4,3], [4,4], [2,3], [2,4]],           // 3-4 can reach 4-3, 4-4, 2-3, 2-4
                    "3-5": [[4,4], [4,5], [2,4], [2,5]],           // 3-5 can reach 4-4, 4-5, 2-4, 2-5
                    // Inner perimeter positions that can reach dead zone diagonally
                    "4-2": [[3,3]],                                 // 4-2 can reach 3-3
                    "4-3": [[3,3], [3,4]],                         // 4-3 can reach 3-3, 3-4
                    "4-4": [[3,4], [3,5]],                         // 4-4 can reach 3-4, 3-5
                    "4-5": [[3,5]],                                 // 4-5 can reach 3-5
                    "2-2": [[3,3]],                                 // 2-2 can reach 3-3
                    "2-3": [[3,3], [3,4]],                         // 2-3 can reach 3-3, 3-4
                    "2-4": [[3,4], [3,5]],                         // 2-4 can reach 3-4, 3-5
                    "2-5": [[3,5]]                                  // 2-5 can reach 3-5
                };
                
                // Add diagonal moves if current position has defined connections
                if (diagonalConnections[currentPos]) {
                    for (const [row, col] of diagonalConnections[currentPos]) {
                        // Only add if not already in targets
                        const alreadyExists = targets.some(([r, c]) => r === row && c === col);
                        if (!alreadyExists) {
                            diagonalMoves.push([row, col]);
                        }
                    }
                }
                
                // Add the diagonal moves to the targets
                targets = targets.concat(diagonalMoves);
            }
            
            return targets;
        }

        // Function to check if base defence is active
        function isBaseDefenceActive() {
            const activeDefences = [];
            
            // Check if white rhombus is still at its base (3-0)
            const whiteRhombus = document.querySelector('.rhombus-piece.white-rhombus');
            if (whiteRhombus) {
                const whiteHex = whiteRhombus.parentElement;
                const whiteId = whiteHex.id;
                const [, whiteRow, whiteCol] = whiteId.match(/hex-(\d+)-(\d+)/);
                if (whiteRow == 3 && whiteCol == 0) {
                    // Check if white has other pieces besides rhombus
                    const whiteOtherPieces = document.querySelectorAll(
                        '.square-piece.white-piece, .triangle-piece.white-triangle, .circle-piece.white-circle, .hexgon-piece.white-hexgon'
                    );
                    
                    // Base defence only active if white has OTHER pieces
                    // If only rhombus left, MUST move from base
                    if (whiteOtherPieces.length > 0) {
                        activeDefences.push('white'); // White base defence is active
                    }
                }
            }

            // Check if black rhombus is still at its base (3-8)
            const blackRhombus = document.querySelector('.rhombus-piece:not(.white-rhombus)');
            if (blackRhombus) {
                const blackHex = blackRhombus.parentElement;
                const blackId = blackHex.id;
                const [, blackRow, blackCol] = blackId.match(/hex-(\d+)-(\d+)/);
                if (blackRow == 3 && blackCol == 8) {
                    // Check if black has other pieces besides rhombus
                    const blackOtherPieces = document.querySelectorAll(
                        '.square-piece:not(.white-piece), .triangle-piece:not(.white-triangle), .circle-piece:not(.white-circle), .hexgon-piece:not(.white-hexgon)'
                    );
                    
                    // Base defence only active if black has OTHER pieces
                    // If only rhombus left, MUST move from base
                    if (blackOtherPieces.length > 0) {
                        activeDefences.push('black'); // Black base defence is active
                    }
                }
            }

            return activeDefences; // Return array of active defences
        }

        // Function to update base defence display
        function updateBaseDefenceDisplay() {
            // Remove existing base defence indicators
            const existingWhiteIndicator = document.getElementById('white-base-defence');
            const existingBlackIndicator = document.getElementById('black-base-defence');
            const existingGuestIndicatorBlack = document.getElementById('guest-indicator-black');
            const existingGuestIndicatorWhite = document.getElementById('guest-indicator-white');
            if (existingWhiteIndicator) existingWhiteIndicator.remove();
            if (existingBlackIndicator) existingBlackIndicator.remove();
            if (existingGuestIndicatorBlack) existingGuestIndicatorBlack.remove();
            if (existingGuestIndicatorWhite) existingGuestIndicatorWhite.remove();

            const activeDefences = isBaseDefenceActive();
            
            // Add guest indicator above BOTH eliminated sections if user is guest
            if (isGuestUser()) {
                const blackEliminatedSection = document.querySelector('.eliminated-section:last-child');
                const whiteEliminatedSection = document.querySelector('.eliminated-section:first-child');
                const makeGuestIndicator = (id) => {
                    const el = document.createElement('div');
                    el.id = id;
                    el.className = 'guest-indicator-badge';
                    el.style.cssText = `
                        background-color: #ff6b6b;
                        color: white;
                        padding: 8px 12px;
                        border-radius: 10px;
                        font-weight: bold;
                        font-size: 12px;
                        text-align: center;
                        margin-bottom: 10px;
                        border: 2px solid #fff;
                        box-shadow: 0 2px 6px rgba(0,0,0,0.3);
                        cursor: pointer;
                        position: relative;
                    `;
                    el.textContent = 'üë§ Logged in as Guest';

                    // Tooltip element
                    const tip = document.createElement('div');
                    tip.className = 'guest-tooltip';
                    tip.style.cssText = `
                        position: absolute;
                        top: 110%;
                        left: 50%;
                        transform: translateX(-50%);
                        background: rgba(0,0,0,0.85);
                        color: #fff;
                        padding: 6px 8px;
                        font-size: 11px;
                        border-radius: 6px;
                        white-space: nowrap;
                        display: none;
                        z-index: 100;
                    `;
                    tip.textContent = 'Guest: limited features (no cloud saves, no online ranking)';
                    el.appendChild(tip);

                    // Show tooltip on hover
                    el.addEventListener('mouseenter', () => { tip.style.display = 'block'; });
                    el.addEventListener('mouseleave', () => { tip.style.display = 'none'; });

                    // Click to prompt login
                    el.addEventListener('click', (e) => { e.stopPropagation(); showAccountModal(); });

                    return el;
                };

                if (blackEliminatedSection) {
                    const guestIndicatorBlack = makeGuestIndicator('guest-indicator-black');
                    blackEliminatedSection.insertBefore(guestIndicatorBlack, blackEliminatedSection.firstChild);
                }
                if (whiteEliminatedSection) {
                    const guestIndicatorWhite = makeGuestIndicator('guest-indicator-white');
                    whiteEliminatedSection.insertBefore(guestIndicatorWhite, whiteEliminatedSection.firstChild);
                }
            }
            
            // Insert white base defence indicator into its placeholder so ordering is
            // eliminated -> base-defence -> variant -> openings -> moves
            const whitePlaceholder = document.getElementById('white-base-defence-placeholder');
            if (whitePlaceholder) {
                const whiteIndicator = document.createElement('div');
                whiteIndicator.id = 'white-base-defence';
                const isWhiteDefending = activeDefences.includes('white');
                whiteIndicator.style.cssText = `
                    background-color: ${isWhiteDefending ? '#ff6b6b' : '#333'};
                    color: white;
                    padding: 8px 12px;
                    border-radius: 10px;
                    font-weight: bold;
                    font-size: 12px;
                    text-align: center;
                    margin-top: 10px;
                    border: 2px solid ${isWhiteDefending ? '#fff' : '#666'};
                    box-shadow: 0 2px 6px rgba(0,0,0,0.3);
                `;
                whiteIndicator.textContent = isWhiteDefending ? 'BASE DEFENCE' : 'BASE OPEN';
                whitePlaceholder.innerHTML = ''; // clear existing placeholder
                whitePlaceholder.appendChild(whiteIndicator);
            }

            // Insert black base defence indicator into its placeholder
            const blackPlaceholder = document.getElementById('black-base-defence-placeholder');
            if (blackPlaceholder) {
                const blackIndicator = document.createElement('div');
                blackIndicator.id = 'black-base-defence';
                const isBlackDefending = activeDefences.includes('black');
                blackIndicator.style.cssText = `
                    background-color: ${isBlackDefending ? '#ff6b6b' : '#333'};
                    color: white;
                    padding: 8px 12px;
                    border-radius: 10px;
                    font-weight: bold;
                    font-size: 12px;
                    text-align: center;
                    margin-top: 10px;
                    border: 2px solid ${isBlackDefending ? '#fff' : '#666'};
                    box-shadow: 0 2px 6px rgba(0,0,0,0.3);
                `;
                blackIndicator.textContent = isBlackDefending ? 'BASE DEFENCE' : 'BASE OPEN';
                blackPlaceholder.innerHTML = '';
                blackPlaceholder.appendChild(blackIndicator);
            }
        }

        // Function to show game over screen
        function showGameOver(winner, reason) {
            gameOver = true; // Set game over flag
            gameInProgress = false; // Game is no longer in progress
            
            // Hide rotation controls on game over
            const rotationControls = document.getElementById('rotation-controls');
            if (rotationControls) {
                rotationControls.style.display = 'none';
            }
            
            // Play win sound
            playWinSound();
            
            // Create game over overlay
            const gameOverOverlay = document.createElement('div');
            gameOverOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 1000;
                font-family: sans-serif;
            `;
            
            const gameOverContent = document.createElement('div');
            gameOverContent.style.cssText = `
                background-color: #2a2a2a;
                padding: 40px;
                border-radius: 15px;
                border: 3px solid #444;
                text-align: center;
                color: white;
                max-width: 400px;
            `;
            
            gameOverContent.innerHTML = `
                <h1 style="color: #ff6b6b; margin: 0 0 20px 0; font-size: 2.5em;">GAME OVER</h1>
                <h2 style="color: #4ecdc4; margin: 0 0 20px 0; font-size: 1.8em;">${winner} WINS!</h2>
                <p style="margin: 0 0 30px 0; font-size: 1.2em;">${reason}</p>
                <div style="display: flex; flex-direction: column; gap: 15px; align-items: center;">
                    <div style="display: flex; gap: 15px; justify-content: center;">
                        <button onclick="backToGameFromGameOver()" style="
                            background-color: #3498db;
                            color: white;
                            border: none;
                            padding: 15px 30px;
                            font-size: 1.2em;
                            border-radius: 8px;
                            cursor: pointer;
                            font-weight: bold;
                        ">üéÆ Back to Game</button>
                        <button onclick="analyzeGameFromGameOver()" style="
                            background-color: #9b59b6;
                            color: white;
                            border: none;
                            padding: 15px 30px;
                            font-size: 1.2em;
                            border-radius: 8px;
                            cursor: pointer;
                            font-weight: bold;
                        ">üìä Analyze Game</button>
                    </div>
                    <div style="display: flex; gap: 15px; justify-content: center;">
                        <button onclick="copyRPNFromGameOver()" style="
                            background-color: #16a085;
                            color: white;
                            border: none;
                            padding: 15px 30px;
                            font-size: 1.2em;
                            border-radius: 8px;
                            cursor: pointer;
                            font-weight: bold;
                        ">üìã Copy RPN</button>
                        <button onclick="saveGameFromGameOver()" style="
                            background-color: #f39c12;
                            color: white;
                            border: none;
                            padding: 15px 30px;
                            font-size: 1.2em;
                            border-radius: 8px;
                            cursor: pointer;
                            font-weight: bold;
                        ">üíæ Save Game</button>
                    </div>
                    <div style="display: flex; gap: 15px; justify-content: center;">
                        <button onclick="location.reload()" style="
                            background-color: #4ecdc4;
                            color: white;
                            border: none;
                            padding: 15px 30px;
                            font-size: 1.2em;
                            border-radius: 8px;
                            cursor: pointer;
                            font-weight: bold;
                        ">Play Again</button>
                        <button onclick="showStartMenu()" style="
                            background-color: #ff6b6b;
                            color: white;
                            border: none;
                            padding: 15px 30px;
                            font-size: 1.2em;
                            border-radius: 8px;
                            cursor: pointer;
                            font-weight: bold;
                        ">Main Menu</button>
                    </div>
                </div>
            `;
            
            gameOverOverlay.appendChild(gameOverContent);
            document.body.appendChild(gameOverOverlay);
        }

        // Function to go back to game from game over screen (spectate mode)
        function backToGameFromGameOver() {
            console.log('üéÆ Returning to game board for spectating...');
            // Close the game over overlay
            const gameOverOverlay = document.querySelector('div[style*="position: fixed"]');
            if (gameOverOverlay) {
                gameOverOverlay.remove();
            }
            // The board is already showing the final position
            // User can now view the board, copy RPN, or take screenshots
            console.log('‚úÖ Game board visible. You can now spectate the final position.');
            console.log('üíæ To save RPN, open console and type: exportPositionRPN()');
        }

        // Function to copy RPN notation from game over screen
        function copyRPNFromGameOver() {
            console.log('üìã Copying RPN to clipboard...');
            
            // Export the full RPN string
            const fullRPN = exportPositionRPN();
            
            // Copy to clipboard
            navigator.clipboard.writeText(fullRPN).then(() => {
                alert('‚úÖ Full RPN copied to clipboard!\n\n' + fullRPN);
            }).catch(err => {
                // Fallback if clipboard API fails
                console.error('Failed to copy to clipboard:', err);
                alert('‚ùå Could not copy to clipboard automatically.\n\nRPN:\n' + fullRPN + '\n\n(Please copy manually from console)');
            });
        }

        // Function to analyze game from game over screen
        function analyzeGameFromGameOver() {
            console.log('üìä Opening analysis from game over screen...');
            // Close the game over overlay
            const gameOverOverlay = document.querySelector('div[style*="position: fixed"]');
            if (gameOverOverlay) {
                gameOverOverlay.remove();
            }
            // Call the existing loadCurrentGame function
            loadCurrentGame();
        }

        // Function to save game from game over screen
        function saveGameFromGameOver() {
            console.log('üíæ Saving game from game over screen...');
            
            // Export the current game state as RMN
            const fullRPN = exportPositionRPN();
            const boardPosition = fullRPN.split(' ')[0];
            
            // Generate RMN content
            const today = new Date();
            const dateStr = today.toISOString().split('T')[0];
            
            const rmnContent = `[White "Player 1"]
[Black "Player 2"]
[Date "${dateStr}"]
[Result "*"]
[StartPosition "S4s/T05t0/C6h0/R7r/H06c/t05T0/s4S"]

${moveHistory || '(No moves played yet - starting position)'}

*`;
            
            // Create a blob and download it
            const blob = new Blob([rmnContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `romgon-game-${dateStr}.rmn`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            alert('‚úÖ Game saved successfully!\n\nFile: romgon-game-' + dateStr + '.rmn');
        }

        // Add drag and drop functionality
        let draggedPiece = null;
        let draggedFromHex = null;

        // Make pieces draggable
        function setupDragAndDrop() {
            const pieces = document.querySelectorAll('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
            
            pieces.forEach(piece => {
                piece.draggable = true;
                
                piece.addEventListener('dragstart', function(e) {
                    // Check if it's the current player's turn and piece
                    if (gameOver || !isCurrentPlayerPiece(this)) {
                        e.preventDefault(); // Prevent drag if not current player's turn
                        return;
                    }

                    // Check if another piece is already active this turn
                    if (currentTurnPiece && currentTurnPiece !== this.parentElement) {
                        e.preventDefault(); // Prevent drag if another piece is already active
                        alert('You can only move or rotate one piece per turn!');
                        return;
                    }

                    draggedPiece = this;
                    draggedFromHex = this.parentElement;
                    selectedPiece = this.parentElement; // Set selected piece for rotation controls
                    currentTurnPiece = this.parentElement; // Mark this piece as active for the turn
                    console.log('Set currentTurnPiece to:', currentTurnPiece.id);
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/html', this.outerHTML);
                    
                    // Show movement highlights based on piece type
                    const hexId = this.parentElement.id;
                    const [, row, col] = hexId.match(/hex-(\d+)-(\d+)/);
                    
                    const rotationControls = document.getElementById('rotation-controls');
                    if (rotationControls) {
                        if (this.classList.contains('triangle-piece') || this.classList.contains('hexgon-piece')) {
                            console.log('Showing rotation controls for rotatable piece');
                            rotationControls.style.display = 'block';
                        } else {
                            console.log('Hiding rotation controls for non-rotatable piece');
                            rotationControls.style.display = 'none';
                        }
                    }
                    
                    if (this.classList.contains('circle-piece')) {
                        showCircleMovementPattern(parseInt(row), parseInt(col));
                    } else if (this.classList.contains('hexgon-piece')) {
                        showHexgonMovementPattern(parseInt(row), parseInt(col));
                    } else if (this.classList.contains('triangle-piece')) {
                        // Both white and black triangles use the same rotation-aware movement system
                        showTriangleMovementPattern(parseInt(row), parseInt(col));
                    } else if (this.classList.contains('rhombus-piece')) {
                        showRhombusMovementPattern(parseInt(row), parseInt(col));
                    } else {
                        showSquareMovementPattern(parseInt(row), parseInt(col));
                    }
                });
                
                piece.addEventListener('dragend', function(e) {
                    // Clear highlights when drag ends (but keep threat highlights)
                    document.querySelectorAll('.hexagon').forEach(hex => {
                        hex.classList.remove('highlight-green', 'highlight-red', 'highlight-danger', 'highlight-diagonal', 'highlight-gray');
                    });
                    draggedPiece = null;
                    draggedFromHex = null;
                    
                    // Keep selection and rotation controls for triangles AND hexagons
                    // Only clear for pieces that cannot rotate
                    if (!this.classList.contains('triangle-piece') && !this.classList.contains('hexgon-piece')) {
                        selectedPiece = null;
                        currentTurnPiece = null; // Clear current turn piece for non-rotatables
                        console.log('Cleared currentTurnPiece in dragend');
                        const rotationControls = document.getElementById('rotation-controls');
                        if (rotationControls) {
                            rotationControls.style.display = 'none';
                        }
                    }
                    // For triangles and hexagons, selectedPiece is set in the drop event, not here
                });
            });
        }

        // Setup drag and drop when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                initAudio();
                setupDragAndDrop();
                // Initial check for pieces under attack at game start
                setTimeout(() => highlightAllPiecesUnderAttack(), 100);
            });
        } else {
            initAudio();
            setupDragAndDrop();
            // Initial check for pieces under attack at game start
            setTimeout(() => highlightAllPiecesUnderAttack(), 100);
        }


        // Make hexagons drop targets
                    document.querySelectorAll('.hexagon').forEach(hex => {
            hex.addEventListener('dragover', function(e) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            });
            
                hex.addEventListener('drop', function(e) {
                e.preventDefault();
                
                if (!draggedPiece) return;
                
                const targetHex = this;
                const targetId = targetHex.id;
                const [, targetRow, targetCol] = targetId.match(/hex-(\d+)-(\d+)/);
                
                // Check if this is a valid move (highlighted position)
                // Note: highlight-threat is just a visual warning and doesn't block movement
                
                if (!targetHex.classList.contains('highlight-green') && 
                    !targetHex.classList.contains('highlight-red') && 
                    !targetHex.classList.contains('highlight-danger') && 
                    !targetHex.classList.contains('highlight-diagonal')) {
                    console.log('‚ùå DROP BLOCKED: No valid highlight found');
                    return; // Invalid move
                }
                console.log('‚úÖ DROP: Valid highlight found, proceeding...');
                
                // Check piece colors for capture logic
                const isDraggedWhite = draggedPiece.classList.contains('white-piece') || 
                                    draggedPiece.classList.contains('white-triangle') || 
                                    draggedPiece.classList.contains('white-rhombus') ||
                                    draggedPiece.classList.contains('white-circle') ||
                                    draggedPiece.classList.contains('white-hexgon');


                // ENFORCE BASE DEFENSE RULE (use already declared fromHexId and toHexId below)
                if (!enforceBaseDefenseRule(draggedFromHex.id, targetHex.id, draggedPiece, isDraggedWhite)) return;

                // Additional shape defense check: block rhombus escape if opponent's base (destination) is under attack
                if (window.baseDefenseVariant === 'shape-defense' && 
                    draggedPiece.classList.contains('rhombus-piece') && 
                    targetHex.id === 'hex-' + getBaseHex(!isDraggedWhite)) {
                    // Destination is opponent base - check if opponent can attack that base
                    const [, destRow, destCol] = targetHex.id.match(/hex-(\d+)-(\d+)/);
                    // Simulate the rhombus at the destination and test if opponent could attack it
                    try {
                        const destHexEl = document.getElementById('hex-' + destRow + '-' + destCol);
                        let tempSim = null;
                        if (destHexEl) {
                            tempSim = document.createElement('div');
                            tempSim.className = isDraggedWhite ? 'rhombus-piece white-rhombus' : 'rhombus-piece';
                            tempSim.setAttribute('data-temp-simulation', 'true');
                            destHexEl.appendChild(tempSim);
                        }
                            const attackable = isPieceUnderThreat(parseInt(destRow), parseInt(destCol), !isDraggedWhite);
                            if (tempSim) tempSim.remove();
                        if (attackable) {
                            showShapeDefenseWarning('rhombus');
                            return;
                        }
                    } catch (e) {
                        // drop-handler simulation error suppressed
                    }
                }

                // Check if there's an opponent piece to capture
                const existingPiece = targetHex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');

                // CRITICAL: Check if this move would put own rhombus in checkmate
                const pieceClasses = draggedPiece.className;
                // --- PATCH: Allow rhombus to win by skipping checkmate check when moving from base to opponent's base ---
                const isDraggedRhombus = draggedPiece.classList.contains('rhombus-piece');
                // Patch: Use full hex ID format for base hexes
                const fromBaseHex = 'hex-' + getBaseHex(isDraggedWhite);
                const toOppBaseHex = 'hex-' + getBaseHex(!isDraggedWhite);
                if (isDraggedRhombus && draggedFromHex.id === fromBaseHex && targetId === toOppBaseHex) {
                    // skipping checkmate check for rhombus moving from base to opponent base
                } else {
                    if (wouldMoveResultInOwnCheckmate(draggedFromHex.id, targetId, pieceClasses, existingPiece)) {
                        alert('‚ùå ILLEGAL MOVE! This move puts your rhombus under attack. You can only do this if you capture the attacking piece!');
                        return; // Block the move
                    }
                }
                
                let didCapture = false;
                if (existingPiece) {
                    // Check if both pieces are rhombuses - if so, no attack allowed
                    const isDraggedRhombus = draggedPiece.classList.contains('rhombus-piece');
                    const isExistingRhombus = existingPiece.classList.contains('rhombus-piece');
                    
                    if (isDraggedRhombus && isExistingRhombus) {
                        // Rhombus cannot attack another rhombus - block the move
                        return;
                    }
                    
                    // Check if it's an opponent piece (different color)
                    const isExistingWhite = existingPiece.classList.contains('white-piece') || 
                                        existingPiece.classList.contains('white-triangle') || 
                                        existingPiece.classList.contains('white-rhombus') ||
                                        existingPiece.classList.contains('white-circle') ||
                                        existingPiece.classList.contains('white-hexgon');
                    
                    // If different colors, capture the opponent piece
                    if (isDraggedWhite !== isExistingWhite) {
                        // Add to eliminated pieces display before removing
                        addToEliminatedPieces(existingPiece);
                        existingPiece.remove(); // Capture the opponent piece
                        // Play captured sound for capture
                        playCapturedSound();
                        didCapture = true;
                        
                        // Reveal attack area in Fog of War mode
                        revealAttackArea(draggedFromHex.id, targetHex.id);
                    }
                }
                
                // Move the piece
                const fromHexId = draggedFromHex.id;
                
                // Preserve triangle or hexgon orientation if it's a rotatable piece
                let preservedOrientation = null;
                if (draggedPiece.classList.contains('triangle-piece')) {
                    preservedOrientation = getTriangleOrientation(fromHexId);
                    console.log('Preserving triangle orientation:', preservedOrientation, 'from', fromHexId);
                } else if (draggedPiece.classList.contains('hexgon-piece')) {
                    preservedOrientation = getHexgonOrientation(fromHexId);
                    console.log('Preserving hexgon orientation:', preservedOrientation, 'from', fromHexId);
                }
                
                draggedPiece.remove();
                    
                    const newPiece = document.createElement('div');
                    newPiece.className = pieceClasses;
                newPiece.draggable = true;
                targetHex.appendChild(newPiece);
                
                // Restore triangle or hexgon orientation if it was preserved
                if (preservedOrientation !== null) {
                    const toHexId = targetHex.id;
                    if (draggedPiece.classList.contains('triangle-piece')) {
                        setTriangleOrientation(toHexId, preservedOrientation);
                        updateTriangleVisual(toHexId);
                        console.log('Restored triangle orientation:', preservedOrientation, 'to', toHexId);
                        
                        // Clean up the old orientation from the source hex
                        triangleOrientations.delete(fromHexId);
                        console.log('Cleaned up old triangle orientation from:', fromHexId);
                    } else if (draggedPiece.classList.contains('hexgon-piece')) {
                        setHexgonOrientation(toHexId, preservedOrientation);
                        updateHexgonVisual(toHexId);
                        console.log('Restored hexgon orientation:', preservedOrientation, 'to', toHexId);
                        
                        // Clean up the old orientation from the source hex
                        hexgonOrientations.delete(fromHexId);
                        console.log('Cleaned up old hexgon orientation from:', fromHexId);
                    }
                }
                
                // Broadcast move to multiplayer opponent
                broadcastMove(fromHexId, targetId, pieceClasses, didCapture);
                
                // Update selectedPiece to the new location for triangles and hexagons
                if (newPiece.classList.contains('triangle-piece') || newPiece.classList.contains('hexgon-piece')) {
                    selectedPiece = targetHex;
                    currentTurnPiece = targetHex; // Also update currentTurnPiece for rotatable pieces
                    console.log('Set selectedPiece to targetHex for rotatable piece:', selectedPiece);
                    console.log('Set currentTurnPiece to targetHex for rotatable piece:', currentTurnPiece);
                    // Show rotation controls for rotatable pieces after movement
                    const rotationControls = document.getElementById('rotation-controls');
                    if (rotationControls) {
                        rotationControls.style.display = 'block';
                    }
                }
                
                // Record the move
                const fromHex = draggedFromHex;
                const [, fromRow, fromCol] = fromHex.id.match(/hex-(\d+)-(\d+)/);
                const isWhite = newPiece.classList.contains('white-piece') || 
                               newPiece.classList.contains('white-triangle') || 
                               newPiece.classList.contains('white-rhombus') ||
                               newPiece.classList.contains('white-circle') ||
                               newPiece.classList.contains('white-hexgon');
                const pieceType = newPiece.classList.contains('square-piece') ? 'square' : 
                                 newPiece.classList.contains('triangle-piece') ? 'triangle' : 
                                 newPiece.classList.contains('rhombus-piece') ? 'rhombus' : 
                                 newPiece.classList.contains('circle-piece') ? 'circle' : 'hexgon';
                const isCapture = didCapture;
                
                // Check repetition BEFORE recording move
                const repetitionCount = checkRepetition(parseInt(fromRow), parseInt(fromCol), targetRow, targetCol, pieceType, isWhite, isCapture);
                
                // Record move with repetition count for color-coding
                recordMove(parseInt(fromRow), parseInt(fromCol), targetRow, targetCol, pieceType, isWhite, isCapture, repetitionCount);
                
                // Record move in RPN format for export/import (pass hex IDs, not elements)
                recordMoveRPN(fromHex.id, targetHex.id, newPiece, isCapture, false, '');
                
                // Track piece actions for move+rotate vs attack rules
                const toHexId = targetHex.id;
                const actions = pieceActions.get(fromHexId) || {moved: false, attacked: false, rotated: false};
                
                if (isCapture) {
                    actions.attacked = true;
                } else {
                    actions.moved = true;
                }
                
                // Transfer actions to new hex if piece moved
                if (fromHexId !== toHexId) {
                    pieceActions.set(toHexId, actions);
                    pieceActions.delete(fromHexId);
                } else {
                    pieceActions.set(fromHexId, actions);
                }

                // If a RHOMBUS moved from its base, update base defence display immediately
                try {
                    const movedIsRhombus = newPiece.classList.contains('rhombus-piece');
                    if (movedIsRhombus && fromHexId) {
                        const m = fromHexId.match(/hex-(\d+)-(\d+)/);
                        if (m) {
                            const fromR = parseInt(m[1], 10);
                            const fromC = parseInt(m[2], 10);
                            // white base is 3-0, black base is 3-8
                            if ((fromR === 3 && fromC === 0) || (fromR === 3 && fromC === 8)) {
                                // Rhombus left its base ‚Äî refresh indicators
                                updateBaseDefenceDisplay();
                            }
                        }
                    }
                } catch (e) {
                    // ignore UI update failures
                }
                
                // Play click sound
                playClickSound();
                
                // Highlight the last move
                highlightLastMove(fromHexId, toHexId);
                
                // Check ALL pieces on the board to see if they're under attack
                highlightAllPiecesUnderAttack();
                
                // Check for win conditions based on rhombus position
                checkWinConditions(targetRow, targetCol, newPiece);
                
                // CRITICAL: Check for rhombus deadlock/checkmate immediately after move
                // This catches situations where opponent's rhombus is now in checkmate
                if (!gameOver) {
                    checkRhombusDeadlock();
                }
                
                // End turn rules
                if (!gameOver) {
                    if (isCapture) {
                        switchTurn();
                        updateBaseDefenceDisplay();
                    } else if (!newPiece.classList.contains('triangle-piece') && !newPiece.classList.contains('hexgon-piece')) {
                        // Non-rotatable pieces end the turn automatically
                        switchTurn();
                        updateBaseDefenceDisplay();
                    } // triangles and hexagons end turn via rotation/KEEP flow
                }

                // Push to move history for undo
                // Capture metadata for undo: remove one eliminated entry by id
                let capturedHTML = null;
                if (isCapture && existingPiece) {
                    const elimId = existingPiece.getAttribute('data-eliminated-id');
                    capturedHTML = JSON.stringify({html: existingPiece.outerHTML, elimId});
                }
                moveHistory.push({
                    fromId: fromHex.id,
                    toId: targetHex.id,
                    pieceClass: pieceClasses,
                    capturedHTML: capturedHTML,
                    endedTurn: isCapture || (!newPiece.classList.contains('triangle-piece') && !newPiece.classList.contains('hexgon-piece')),
                    isTriangle: newPiece.classList.contains('triangle-piece'),
                    isHexgon: newPiece.classList.contains('hexgon-piece')
                });

                // Re-add drag event listeners to the new piece
                newPiece.addEventListener('dragstart', function(e) {
                    // Check if it's the current player's turn and piece
                    if (gameOver || !isCurrentPlayerPiece(this)) {
                        e.preventDefault(); // Prevent drag if not current player's turn
                        return;
                    }

                    // Check if another piece is already active this turn
                    if (currentTurnPiece && currentTurnPiece !== this.parentElement) {
                        e.preventDefault(); // Prevent drag if another piece is already active
                        alert('You can only move or rotate one piece per turn!');
                        return;
                    }

                    draggedPiece = this;
                    draggedFromHex = this.parentElement;
                    selectedPiece = this.parentElement; // Set selected piece for rotation controls
                    currentTurnPiece = this.parentElement; // Mark this piece as active for the turn
                    console.log('Set currentTurnPiece to:', currentTurnPiece.id);
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/html', this.outerHTML);
                    
                    // Show rotation controls if this is a triangle or hexagon, hide if not
                    const rotationControls = document.getElementById('rotation-controls');
                    console.log('Rotation controls element:', rotationControls);
                    if (rotationControls) {
                        if (this.classList.contains('triangle-piece') || this.classList.contains('hexgon-piece')) {
                            console.log('Showing rotation controls for rotatable piece');
                            rotationControls.style.display = 'block';
                } else {
                            console.log('Hiding rotation controls for non-rotatable piece');
                            rotationControls.style.display = 'none';
                        }
                    } else {
                        console.log('Rotation controls element not found!');
                    }
                    
                    // Show movement pattern
                    const hexId = this.parentElement.id;
                    const [, row, col] = hexId.match(/hex-(\d+)-(\d+)/);
                    
                    if (this.classList.contains('circle-piece')) {
                        showCircleMovementPattern(parseInt(row), parseInt(col));
                    } else if (this.classList.contains('hexgon-piece')) {
                        showHexgonMovementPattern(parseInt(row), parseInt(col));
                    } else if (this.classList.contains('triangle-piece')) {
                        // Both white and black triangles use the same rotation-aware movement system
                        showTriangleMovementPattern(parseInt(row), parseInt(col));
                    } else if (this.classList.contains('rhombus-piece')) {
                        showRhombusMovementPattern(parseInt(row), parseInt(col));
                    } else {
                        showSquareMovementPattern(parseInt(row), parseInt(col));
                    }
                });
                
                newPiece.addEventListener('dragend', function(e) {
                    // Clear highlights when drag ends (but keep threat highlights)
                    document.querySelectorAll('.hexagon').forEach(hex => {
                        hex.classList.remove('highlight-green', 'highlight-red', 'highlight-danger', 'highlight-diagonal', 'highlight-gray');
                    });
                    draggedPiece = null;
                    draggedFromHex = null;
                    
                    // Clear selectedPiece and rotation controls for non-rotatable pieces
                    if (!this.classList.contains('triangle-piece') && !this.classList.contains('hexgon-piece')) {
                    selectedPiece = null;
                        currentTurnPiece = null; // Clear current turn piece for non-rotatable pieces
                        console.log('Cleared currentTurnPiece in dragend');
                        const rotationControls = document.getElementById('rotation-controls');
                        if (rotationControls) {
                            rotationControls.style.display = 'none';
                        }
                    }
                    // For rotatable pieces (triangles and hexagons), selectedPiece is set in the drop event, not here
                });
                
                // Clear highlights (but keep threat highlights)
                    document.querySelectorAll('.hexagon').forEach(hex => {
                        hex.classList.remove('highlight-green', 'highlight-red', 'highlight-danger', 'highlight-diagonal', 'highlight-gray');
                    });
            });
        });

        // Function to show movement pattern for hexgon pieces (row-specific mapping)
        function showHexgonMovementPattern(centerRow, centerCol) {
            console.log(`üéØ showHexgonMovementPattern called: centerRow=${centerRow}, centerCol=${centerCol}`);
            
            // Clear any existing highlights (but keep threat highlights)
            document.querySelectorAll('.hexagon').forEach(hex => {
                hex.classList.remove('highlight-green', 'highlight-red', 'highlight-danger', 'highlight-diagonal', 'highlight-gray');
            });

            // Get hexgon orientation for rotation-aware movement
            const hexId = `hex-${centerRow}-${centerCol}`;
            const orientation = getHexgonOrientation(hexId);
            console.log(`üéØ Hexgon orientation: ${orientation}`);
            
            // Determine if it's white or black hexgon
            const hexgon = document.querySelector(`#${hexId} .hexgon-piece`);
            const isWhite = hexgon && (hexgon.classList.contains('white-hexgon') || hexgon.classList.contains('white-piece'));
            console.log(`üéØ Hexgon isWhite: ${isWhite}`);
            
            // Get rotation-aware movement pattern
            const targets = getRotatedHexgonTargets(centerRow, centerCol, orientation, isWhite);
            console.log(`üéØ Rotated targets:`, targets);

            // Get friendly and opponent piece types based on hexgon color
            let friendlyPieceTypes, opponentPieceTypes;
            const centerHex = document.getElementById(`hex-${centerRow}-${centerCol}`);
            const centerPiece = centerHex.querySelector('.hexgon-piece');
            
            if (centerPiece && centerPiece.classList.contains('white-hexgon')) {
                // White hexgon - friendly with white pieces, opponent with black pieces
                friendlyPieceTypes = ['.square-piece.white-piece', '.triangle-piece.white-triangle', '.rhombus-piece.white-rhombus', '.circle-piece.white-circle', '.hexgon-piece.white-hexgon'];
                opponentPieceTypes = ['.square-piece:not(.white-piece)', '.triangle-piece:not(.white-triangle)', '.rhombus-piece:not(.white-rhombus)', '.circle-piece:not(.white-circle)', '.hexgon-piece:not(.white-hexgon)'];
            } else {
                // Black hexgon - friendly with black pieces, opponent with white pieces
                friendlyPieceTypes = ['.square-piece:not(.white-piece)', '.triangle-piece:not(.white-triangle)', '.rhombus-piece:not(.white-rhombus)', '.circle-piece:not(.white-circle)', '.hexgon-piece:not(.white-hexgon)'];
                opponentPieceTypes = ['.square-piece.white-piece', '.triangle-piece.white-triangle', '.rhombus-piece.white-rhombus', '.circle-piece.white-circle', '.hexgon-piece.white-hexgon'];
            }

            // Highlight targets using rotation-aware movement pattern
            targets.forEach(([targetRow, targetCol]) => {
                const targetHex = document.getElementById(`hex-${targetRow}-${targetCol}`);
                if (!targetHex) return;
                
                // Check if target hex has a friendly piece
                let hasFriendlyPiece = false;
                friendlyPieceTypes.forEach(selector => {
                    if (targetHex.querySelector(selector)) {
                        hasFriendlyPiece = true;
                    }
                });
                
                // Check if target hex has an opponent piece
                let hasOpponentPiece = false;
                opponentPieceTypes.forEach(selector => {
                    if (targetHex.querySelector(selector)) {
                        hasOpponentPiece = true;
                    }
                });
                
                // Highlight in red if opponent piece, gray if friendly, green if empty, danger if vulnerable
                if (hasOpponentPiece) {
                    targetHex.classList.add('highlight-red');
                } else if (hasFriendlyPiece) {
                    targetHex.classList.add('highlight-gray');
                } else {
                    // Check if this position would be vulnerable to attack
                    if (isPositionVulnerable(targetRow, targetCol, isWhite)) {
                        targetHex.classList.add('highlight-danger');
                    } else {
                        targetHex.classList.add('highlight-green');
                    }
                }
            });
        }

        // ============================================
        // ROMGON POSITION NOTATION (RPN) SYSTEM
        // ============================================
        
        // Track move history for RPN game export (separate from undo moveHistory)
        // let rpnMoveHistory = []; // Moved to global scope above
        
        let gameMetadata = {
            white: 'Player 1',
            black: 'Player 2 (AI)',
            date: new Date().toISOString().split('T')[0],
            result: '*'
        };

        // Helper: Convert piece element to notation character
        function pieceToChar(pieceElement) {
            if (!pieceElement) return null;
            
            const isWhite = pieceElement.classList.contains('white-piece') ||
                          pieceElement.classList.contains('white-triangle') ||
                          pieceElement.classList.contains('white-rhombus') ||
                          pieceElement.classList.contains('white-circle') ||
                          pieceElement.classList.contains('white-hexgon');
            
            let char = '';
            
            if (pieceElement.classList.contains('square-piece')) {
                char = isWhite ? 'S' : 's';
            } else if (pieceElement.classList.contains('triangle-piece')) {
                char = isWhite ? 'T' : 't';
            } else if (pieceElement.classList.contains('rhombus-piece')) {
                char = isWhite ? 'R' : 'r';
            } else if (pieceElement.classList.contains('circle-piece')) {
                char = isWhite ? 'C' : 'c';
            } else if (pieceElement.classList.contains('hexgon-piece')) {
                char = isWhite ? 'H' : 'h';
            }
            
            return char;
        }

        // Helper: Get rotation state for triangle/hexagon
        function getPieceRotation(hexId, pieceType) {
            if (pieceType === 'T' || pieceType === 't') {
                return triangleOrientations.get(hexId) || 0;
            } else if (pieceType === 'H' || pieceType === 'h') {
                return hexgonOrientations.get(hexId) || 0;
            }
            return null;
        }

        // Helper: Convert notation character to piece classes
        function charToPiece(char, rotation = 0) {
            const isUpper = char === char.toUpperCase();
            
            const charUpper = char.toUpperCase();
            let baseClass = '';
            let specificClass = '';
            
            switch(charUpper) {
                case 'S':
                    baseClass = 'square-piece';
                    specificClass = isUpper ? 'white-piece' : '';
                    break;
                case 'T':
                    baseClass = 'triangle-piece';
                    specificClass = isUpper ? 'white-triangle' : '';
                    break;
                case 'R':
                    baseClass = 'rhombus-piece';
                    specificClass = isUpper ? 'white-rhombus' : '';
                    break;
                case 'C':
                    baseClass = 'circle-piece';
                    specificClass = isUpper ? 'white-circle' : '';
                    break;
                case 'H':
                    baseClass = 'hexgon-piece';
                    specificClass = isUpper ? 'white-hexgon' : '';
                    break;
                default:
                    return null;
            }
            
            return {
                baseClass,
                specificClass,
                rotation: rotation
            };
        }

        // Export current board position to RPN format
        function exportPositionRPN() {
            console.log('üîç === STARTING RPN EXPORT ===');
            console.log('üìã Board flipped state:', boardFlipped);
            console.log('üìã Current player:', currentPlayer);
            
            const boardRows = [
                [0, 6],   // Row 0: 0-0 to 0-5 (6 hexes)
                [1, 7],   // Row 1: 1-0 to 1-6 (7 hexes)
                [2, 8],   // Row 2: 2-0 to 2-7 (8 hexes)
                [3, 9],   // Row 3: 3-0 to 3-8 (9 hexes)
                [4, 8],   // Row 4: 4-0 to 4-7 (8 hexes)
                [5, 7],   // Row 5: 5-0 to 5-6 (7 hexes)
                [6, 6]    // Row 6: 6-0 to 6-5 (6 hexes)
            ];
            
            let rpnParts = [];
            let totalPiecesFound = 0;
            
            // Build board notation
            for (const [rowNum, hexCount] of boardRows) {
                let rowNotation = '';
                let emptyCount = 0;
                let piecesInRow = 0;
                
                for (let col = 0; col < hexCount; col++) {
                    const hexId = `hex-${rowNum}-${col}`;
                    const hex = document.getElementById(hexId);
                    
                    if (!hex) {
                        console.warn(`‚ö†Ô∏è Hex not found: ${hexId}`);
                        emptyCount++;
                        continue;
                    }
                    
                    const piece = hex.querySelector('.square-piece, .triangle-piece, .rhombus-piece, .circle-piece, .hexgon-piece');
                    
                    // Check if piece exists and is visible
                    let isValidPiece = false;
                    if (piece) {
                        const isHidden = piece.style.display === 'none' || piece.hasAttribute('data-temp-simulation');
                        const isWhite = piece.classList.contains('white-piece') || 
                                      piece.classList.contains('white-triangle') || 
                                      piece.classList.contains('white-rhombus') || 
                                      piece.classList.contains('white-circle') || 
                                      piece.classList.contains('white-hexgon');
                        const color = isWhite ? 'WHITE' : 'BLACK';
                        console.log(`‚úÖ Found ${color} piece at ${hexId}:`, piece.className, isHidden ? '(HIDDEN - TREATED AS EMPTY)' : '(VISIBLE)');
                        
                        if (!isHidden) {
                            isValidPiece = true;
                            piecesInRow++;
                            totalPiecesFound++;
                        } else {
                            console.warn(`‚ö†Ô∏è Treating hidden piece at ${hexId} as empty space`);
                        }
                    }
                    
                    if (!isValidPiece) {
                        emptyCount++;
                    } else {
                        // Add any accumulated empty spaces
                        if (emptyCount > 0) {
                            rowNotation += emptyCount;
                            emptyCount = 0;
                        }
                        
                        // Add piece notation
                        const char = pieceToChar(piece);
                        console.log(`  ‚Üí pieceToChar returned: "${char}" for ${hexId}`);
                        if (char) {
                            rowNotation += char;
                            
                            // Add rotation for triangles and hexagons (ALWAYS include, even if 0, for unambiguous parsing)
                            if (char === 'T' || char === 't' || char === 'H' || char === 'h') {
                                const rotation = getPieceRotation(hexId, char) || 0;
                                rowNotation += rotation;
                            }
                        } else {
                            console.error(`‚ùå pieceToChar returned null for piece at ${hexId}:`, piece.className);
                        }
                    }
                }
                
                console.log(`üìä Row ${rowNum}: Found ${piecesInRow} pieces, notation: "${rowNotation}"`);
                
                // Add final empty count if row ends with empty spaces
                if (emptyCount > 0) {
                    rowNotation += emptyCount;
                }
                
                // If entire row is empty, use the hex count
                if (rowNotation === '') {
                    rowNotation = hexCount.toString();
                }
                
                rpnParts.push(rowNotation);
            }
            
            console.log(`üìä TOTAL PIECES FOUND: ${totalPiecesFound}`);
            console.log('üìã RPN Parts:', rpnParts);
            
            // Add metadata
            const activePlayer = currentPlayer === 'white' ? 'w' : 'b';
            const moveCount = Math.floor(window.rpnMoveHistory.length / 2);
            
            // Build captured pieces notation
            const capturedWhite = capturedWhitePieces.join('') || '-';
            const capturedBlack = capturedBlackPieces.join('') || '-';
            
            // Build piece action states (format: hexId:actions,hexId:actions,...)
            // actions: m=moved, a=attacked, r=rotated
            let actionStates = [];
            for (const [hexId, actions] of pieceActions.entries()) {
                const actionChars = [];
                if (actions.moved) actionChars.push('m');
                if (actions.attacked) actionChars.push('a');
                if (actions.rotated) actionChars.push('r');
                if (actionChars.length > 0) {
                    actionStates.push(`${hexId}:${actionChars.join('')}`);
                }
            }
            const actionStateStr = actionStates.length > 0 ? actionStates.join(',') : '-';
            
            // Build move history (format: move1;move2;move3...)
            const moveHistoryStr = window.rpnMoveHistory.length > 0 
                ? window.rpnMoveHistory.map(m => m.notation).join(';') 
                : '-';
            
            // Get base defence state (format: w|b|wb|-)
            // w = white defending, b = black defending, wb = both, - = neither
            const activeDefences = isBaseDefenceActive();
            const baseDefenceStr = activeDefences.length > 0 ? activeDefences.join('') : '-';
            
            // Get current turn piece (which piece is mid-turn for multi-actions)
            // Format: hex-3-0 or - if no active piece
            const activePieceStr = currentTurnPiece ? currentTurnPiece : '-';
            
            // Get timer state (format: whiteSeconds:blackSeconds or - if no timer)
            // Example: 595:600 means white has 9:55 left, black has 10:00 left
            const timerStr = timerInterval ? `${whiteTimeLeft}:${blackTimeLeft}` : '-';
            
            // Combine into full RPN with all data
            // Format: board activePlayer moveCount capturedWhite capturedBlack actionStates moveHistory baseDefence activePiece timer
            const rpn = `${rpnParts.join('/')} ${activePlayer} ${moveCount} ${capturedWhite} ${capturedBlack} ${actionStateStr} ${moveHistoryStr} ${baseDefenceStr} ${activePieceStr} ${timerStr}`;
            
            console.log('üéØ FINAL RPN STRING:', rpn);
            console.log(`üì¶ Captured White: ${capturedWhite}, Captured Black: ${capturedBlack}`);
            console.log(`‚ö° Action States: ${actionStateStr}`);
            console.log(`üìú Move History: ${moveHistoryStr.substring(0, 100)}${moveHistoryStr.length > 100 ? '...' : ''}`);
            // Base Defence log removed
            console.log(`üé≤ Active Piece: ${activePieceStr}`);
            console.log(`‚è±Ô∏è Timer State: ${timerStr}`);
            console.log('üîç === RPN EXPORT COMPLETE ===');
            
            return rpn;
        }

        // Rebuild move display panels from rpnMoveHistory
        function rebuildMoveDisplay() {
            console.log('üîÑ Rebuilding move display from history...');
            
            // Clear both move panels
            const whiteMovesList = document.getElementById('white-moves');
            const blackMovesList = document.getElementById('black-moves');
            
            if (whiteMovesList) whiteMovesList.innerHTML = '';
            if (blackMovesList) blackMovesList.innerHTML = '';
            
            // Helper to convert piece char to symbol
            const pieceCharToSymbol = (char) => {
                const upper = char.toUpperCase();
                if (upper === 'S') return '‚ñ†';
                if (upper === 'T') return '‚ñ≤';
                if (upper === 'R') return '‚óÜ';
                if (upper === 'C') return '‚óè';
                if (upper === 'H') return '‚¨°';
                return '?';
            };
            
            // Helper to parse notation like "C2-0>3-1x" or "r3-8>3-6"
            const parseNotation = (notation) => {
                const match = notation.match(/^([STRCHstrch])(\d+-\d+)>(\d+-\d+)(x)?/);
                if (!match) return null;
                
                const [, pieceChar, fromCoord, toCoord, captureFlag] = match;
                const [fromRow, fromCol] = fromCoord.split('-');
                const [toRow, toCol] = toCoord.split('-');
                
                return {
                    pieceChar,
                    fromRow,
                    fromCol,
                    toRow,
                    toCol,
                    isCapture: !!captureFlag
                };
            };
            
            // Rebuild from rpnMoveHistory
            let moveNumber = 1;
            for (let i = 0; i < window.rpnMoveHistory.length; i++) {
                const move = window.rpnMoveHistory[i];
                const isWhiteMove = i % 2 === 1;
                const moveList = isWhiteMove ? whiteMovesList : blackMovesList;

                if (moveList) {
                    const parsed = parseNotation(move.notation);
                    if (parsed) {
                        const li = document.createElement('li');
                        li.className = `movement-item ${isWhiteMove ? 'white-move' : 'black-move'}`;

                        const pieceSymbol = pieceCharToSymbol(parsed.pieceChar);
                        const captureText = parsed.isCapture ? ' (capture)' : '';

                        // Match the format from recordMove(): "1. ‚ñ† 3-8 ‚Üí 3-6 (capture)"
                        li.textContent = `${moveNumber}. ${pieceSymbol} ${parsed.fromRow}-${parsed.fromCol} ‚Üí ${parsed.toRow}-${parsed.toCol}${captureText}`;

                        moveList.appendChild(li);

                        if (isWhiteMove) moveNumber++;
                    }
                }
            }
            
            // Auto-scroll to bottom
            if (whiteMovesList) whiteMovesList.scrollTop = whiteMovesList.scrollHeight;
            if (blackMovesList) blackMovesList.scrollTop = blackMovesList.scrollHeight;
            
            console.log(`   Rebuilt ${rpnMoveHistory.length} moves in display panels`);
        }

        // Import board position from RPN format
        function importPositionRPN(rpnString) {
            try {
                // Parse RPN string
                const parts = rpnString.trim().split(' ');
                if (parts.length < 2) {
                    throw new Error('Invalid RPN format: missing components');
                }
                
                const boardNotation = parts[0];
                const activePlayer = parts[1];
                const capturedWhiteStr = parts.length >= 4 ? parts[3] : '-';
                const capturedBlackStr = parts.length >= 5 ? parts[4] : '-';
                const actionStatesStr = parts.length >= 6 ? parts[5] : '-';
                const moveHistoryStr = parts.length >= 7 ? parts[6] : '-';
                const baseDefenceStr = parts.length >= 8 ? parts[7] : '-';
                const activePieceStr = parts.length >= 9 ? parts[8] : '-';
                const timerStr = parts.length >= 10 ? parts[9] : '-';
                
                console.log('üì• Importing RPN with extended data:');
                console.log(`   Captured White: ${capturedWhiteStr}`);
                console.log(`   Captured Black: ${capturedBlackStr}`);
                console.log(`   Action States: ${actionStatesStr}`);
                console.log(`   Move History: ${moveHistoryStr.substring(0, 100)}${moveHistoryStr.length > 100 ? '...' : ''}`);
                console.log(`   Base Defence: ${baseDefenceStr}`);
                console.log(`   Active Piece: ${activePieceStr}`);
                console.log(`   Timer State: ${timerStr}`);
                
                // Clear current board
                clearBoard();
                
                // Reset orientations
                triangleOrientations.clear();
                hexgonOrientations.clear();
                
                // Clear captured pieces arrays
                capturedWhitePieces.length = 0;
                capturedBlackPieces.length = 0;
                
                // Clear piece actions
                pieceActions.clear();
                
                // Clear move history
                rpnMoveHistory.length = 0;
                
                // Parse rows
                const rows = boardNotation.split('/');
                if (rows.length !== 7) {
                    throw new Error('Invalid RPN format: must have 7 rows');
                }
                
                const boardRows = [
                    [0, 6],   // Row 0: 0-0 to 0-5
                    [1, 7],   // Row 1: 1-0 to 1-6
                    [2, 8],   // Row 2: 2-0 to 2-7
                    [3, 9],   // Row 3: 3-0 to 3-8
                    [4, 8],   // Row 4: 4-0 to 4-7
                    [5, 7],   // Row 5: 5-0 to 5-6
                    [6, 6]    // Row 6: 6-0 to 6-5
                ];
                
                // Process each row
                for (let i = 0; i < rows.length; i++) {
                    const rowNotation = rows[i];
                    const [rowNum, hexCount] = boardRows[i];
                    let col = 0;
                    let j = 0;
                    
                    console.log(`\nüì• Importing Row ${rowNum}: "${rowNotation}" (${hexCount} hexes total)`);
                    
                    while (j < rowNotation.length && col < hexCount) {
                        const char = rowNotation[j];
                        
                        // Check if it's a number (empty spaces)
                        if (!isNaN(char)) {
                            const skipCount = parseInt(char);
                            console.log(`  [j=${j}, col=${col}] Digit '${char}' ‚Üí Skip ${skipCount} spaces, new col=${col + skipCount}`);
                            col += skipCount;
                            j++;
                        } else {
                            // It's a piece
                            const hexId = `hex-${rowNum}-${col}`;
                            const hex = document.getElementById(hexId);
                            
                            console.log(`  [j=${j}, col=${col}] Letter '${char}' ‚Üí Piece at ${hexId}`);
                            
                            if (hex) {
                                // Check for rotation (ALWAYS present for T/t/H/h pieces)
                                let rotation = 0;
                                const isRotatablePiece = (char === 'T' || char === 't' || char === 'H' || char === 'h');
                                
                                if (isRotatablePiece) {
                                    // MUST have a rotation digit next
                                    if (j + 1 < rowNotation.length && !isNaN(rowNotation[j + 1])) {
                                        rotation = parseInt(rowNotation[j + 1]);
                                        console.log(`    ‚Üí Has rotation: ${rotation} (next char: '${rowNotation[j + 1]}')`);
                                        j++; // Skip rotation digit
                                    } else {
                                        console.error(`    ‚ùå ERROR: T/H piece missing rotation digit!`);
                                    }
                                }
                                
                                // Create piece
                                const pieceData = charToPiece(char, rotation);
                                if (pieceData) {
                                    const piece = document.createElement('div');
                                    piece.className = pieceData.baseClass;
                                    if (pieceData.specificClass) {
                                        piece.classList.add(pieceData.specificClass);
                                    }
                                    piece.draggable = true;
                                    
                                    hex.appendChild(piece);
                                    console.log(`    ‚úÖ Created ${pieceData.baseClass} ${pieceData.specificClass || ''}`);
                                    
                                    // Set rotation if applicable
                                    if ((char === 'T' || char === 't' || char === 'H' || char === 'h') && rotation > 0) {
                                        if (char === 'T' || char === 't') {
                                            setTriangleOrientation(hexId, rotation);
                                            // CRITICAL: Always include translate(-50%, -50%) for centering!
                                            const angleMap = [270, 330, 30, 90, 150, 210];
                                            const rotationDeg = angleMap[rotation % 6];
                                            piece.style.transform = `translate(-50%, -50%) rotate(${rotationDeg}deg)`;
                                        } else if (char === 'H' || char === 'h') {
                                            setHexgonOrientation(hexId, rotation);
                                            // CRITICAL: Always include translate(-50%, -50%) for centering!
                                            const angleMap = [0, 60, 120, 180, 240, 300];
                                            const rotationDeg = angleMap[rotation % 6];
                                            piece.style.transform = `translate(-50%, -50%) rotate(90deg) rotate(${rotationDeg}deg)`;
                                        }
                                    }
                                } else {
                                    console.error(`    ‚ùå charToPiece returned null for '${char}'`);
                                }
                            } else {
                                console.error(`    ‚ùå Hex ${hexId} not found in DOM`);
                            }
                            
                            col++;
                            j++;
                        }
                    }
                    console.log(`  ‚úÖ Row ${rowNum} complete: processed ${j} characters, placed pieces up to col ${col - 1}`);
                }
                
                // Set game state
                currentPlayer = activePlayer === 'w' ? 'white' : 'black';
                gameOver = false;
                
                // Restore captured pieces
                console.log(`üì¶ Restoring captured pieces: White="${capturedWhiteStr}", Black="${capturedBlackStr}"`);
                if (capturedWhiteStr && capturedWhiteStr !== '-') {
                    for (const char of capturedWhiteStr) {
                        capturedWhitePieces.push(char);
                        addCapturedPieceToDisplay(char, true);
                    }
                }
                if (capturedBlackStr && capturedBlackStr !== '-') {
                    for (const char of capturedBlackStr) {
                        capturedBlackPieces.push(char);
                        addCapturedPieceToDisplay(char, false);
                    }
                }
                
                // Restore piece action states
                console.log(`‚ö° Restoring action states: ${actionStatesStr}`);
                if (actionStatesStr && actionStatesStr !== '-') {
                    const actionEntries = actionStatesStr.split(',');
                    for (const entry of actionEntries) {
                        const [hexId, actions] = entry.split(':');
                        if (hexId && actions) {
                            pieceActions.set(hexId, {
                                moved: actions.includes('m'),
                                attacked: actions.includes('a'),
                                rotated: actions.includes('r')
                            });
                            console.log(`   ${hexId}: moved=${actions.includes('m')}, attacked=${actions.includes('a')}, rotated=${actions.includes('r')}`);
                        }
                    }
                }
                
                // Restore move history
                console.log(`üìú Restoring move history: ${moveHistoryStr.substring(0, 50)}...`);
                if (moveHistoryStr && moveHistoryStr !== '-') {
                    const moves = moveHistoryStr.split(';');
                    for (let i = 0; i < moves.length; i++) {
                        const moveNotation = moves[i];
                        if (moveNotation) {
                            rpnMoveHistory.push({
                                notation: moveNotation,
                                player: i % 2 === 0 ? 'black' : 'white',
                                timestamp: new Date().toISOString()
                            });
                        }
                    }
                    console.log(`   Restored ${rpnMoveHistory.length} moves`);
                    // Rebuild move display panels
                    rebuildMoveDisplay();
                }
                
                // Restore active piece (for multi-action turns)
                console.log(`üé≤ Restoring active piece: ${activePieceStr}`);
                if (activePieceStr && activePieceStr !== '-') {
                    currentTurnPiece = activePieceStr;
                    console.log(`   Current turn piece set to: ${currentTurnPiece}`);
                } else {
                    currentTurnPiece = null;
                    console.log(`   No active piece this turn`);
                }
                
                // Restore timer state
                console.log(`‚è±Ô∏è Restoring timer state: ${timerStr}`);
                if (timerStr && timerStr !== '-') {
                    const [whiteTime, blackTime] = timerStr.split(':').map(t => parseInt(t));
                    if (!isNaN(whiteTime) && !isNaN(blackTime)) {
                        whiteTimeLeft = whiteTime;
                        blackTimeLeft = blackTime;
                        console.log(`   White time: ${whiteTime}s, Black time: ${blackTime}s`);
                        
                        // Show timer display
                        const timerContainer = document.getElementById('player-timers');
                        if (timerContainer) {
                            timerContainer.style.display = 'flex';
                        }
                        
                        // Start the timer (it will auto-pause if needed)
                        if (!timerInterval) {
                            startTimer();
                        }
                        
                        // Update the display immediately
                        updateTimerDisplay();
                    }
                } else {
                    console.log(`   No timer active`);
                }
                
                // Re-setup drag and drop
                setupDragAndDrop();
                
                // Update display
                updateTurnDisplay();
                highlightThreatenedPieces();
                
                // Update base defence display (will show correct state based on board position)
                updateBaseDefenceDisplay();
                
                console.log('‚úÖ Position imported successfully from RPN');
                return true;
                
            } catch (error) {
                console.error('‚ùå Error importing RPN:', error);
                alert('Error importing position: ' + error.message);
                return false;
            }
        }

        // Validate RPN format
        function validateRPN(rpnString) {
            try {
                const parts = rpnString.trim().split(' ');
                if (parts.length < 2) return false;
                
                const boardNotation = parts[0];
                const rows = boardNotation.split('/');
                
                return rows.length === 7;
            } catch {
                return false;
            }
        }

        // Convert move to RMN (Romgon Move Notation)
        function moveToNotation(fromHex, toHex, piece, captured = false, rotated = false, special = '') {
            const pieceChar = pieceToChar(piece);
            if (!pieceChar) return null;
            
            const fromCoord = fromHex.replace('hex-', '');
            const toCoord = toHex.replace('hex-', '');
            
            let notation = `${pieceChar}${fromCoord}>${toCoord}`;
            
            if (captured) notation += 'x';
            if (rotated) notation += '@';
            if (special === 'diagonal') notation += 'd';
            
            return notation;
        }

        // Record a move in history
        function recordMoveRPN(fromHex, toHex, piece, captured = false, rotated = false, special = '') {
            const notation = moveToNotation(fromHex, toHex, piece, captured, rotated, special);
            console.log(`üìù recordMoveRPN called: ${fromHex} -> ${toHex}, notation: ${notation}`);
            if (notation) {
                rpnMoveHistory.push({
                    notation: notation,
                    player: currentPlayer,
                    timestamp: new Date().toISOString()
                });
                console.log(`   ‚úÖ Move recorded. Total moves: ${rpnMoveHistory.length}`);
                // Update opening display immediately after recording a move
                try { alwaysUpdateOpeningDisplay(); } catch (e) { /* ignore */ }
            } else {
                console.warn('   ‚ö†Ô∏è No notation generated, move not recorded');
            }
        }

        // Export full game in RMN format
        function exportGameRMN() {
            let output = '';
            
            // Add metadata
            output += `[White "${gameMetadata.white}"]\n`;
            output += `[Black "${gameMetadata.black}"]\n`;
            output += `[Date "${gameMetadata.date}"]\n`;
            output += `[Result "${gameMetadata.result}"]\n`;
            
            // Add starting position in RPN format (for game reconstruction)
            // Standard starting position with rotation numbers for triangles and hexagons
            const startingPosition = 'S4s/T05t0/C6h0/R7r/H06c/t05T0/s4S';
            output += `[StartPosition "${startingPosition}"]\n`;
            output += '\n';
            
            // Add moves (or note if no moves)
            if (rpnMoveHistory.length === 0) {
                output += '(No moves played yet - starting position)\n';
            } else {
                let moveNumber = 1;
                for (let i = 0; i < rpnMoveHistory.length; i += 2) {
                    const whiteMove = rpnMoveHistory[i] ? rpnMoveHistory[i].notation : '';
                    const blackMove = rpnMoveHistory[i + 1] ? rpnMoveHistory[i + 1].notation : '';
                    
                    output += `${moveNumber}. ${whiteMove}`;
                    if (blackMove) {
                        output += ` ${blackMove}`;
                    }
                    output += '\n';
                    moveNumber++;
                }
            }
            
            // Add result
            output += '\n' + gameMetadata.result;
            
            return output;
        }

        // Copy position to clipboard
        async function copyPositionToClipboard() {
            try {
                const rpn = exportPositionRPN();
                await navigator.clipboard.writeText(rpn);
                
                // Show feedback
                showNotification('‚úÖ Position copied to clipboard!', 'success');
                console.log('üìã RPN copied:', rpn);
            } catch (error) {
                console.error('‚ùå Error copying to clipboard:', error);
                alert('Error copying position: ' + error.message);
            }
        }

        // Show notification message
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 120px;
                right: 20px;
                background: ${type === 'success' ? '#4ecdc4' : type === 'error' ? '#ff6b6b' : '#555'};
                color: white;
                padding: 15px 25px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 10001;
                font-weight: 600;
                animation: slideIn 0.3s ease;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        // Open load position modal
        function openLoadPositionModal() {
            let modal = document.getElementById('load-position-modal');
            if (!modal) {
                modal = createLoadPositionModal();
            }
            modal.style.display = 'flex';
        }

        // Create load position modal
        function createLoadPositionModal() {
            const modal = document.createElement('div');
            modal.id = 'load-position-modal';
            modal.style.cssText = `
                display: none;
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.9);
                z-index: 10000;
                justify-content: center;
                align-items: center;
            `;
            
            modal.innerHTML = `
                <div style="background: #262421; border: 3px solid #4ecdc4; border-radius: 20px; padding: 40px; max-width: 600px; width: 90%;">
                    <h2 style="color: #4ecdc4; text-align: center; margin-bottom: 20px;">üì• Load Position</h2>
                    <p style="color: #ccc; margin-bottom: 15px; text-align: center;">Paste RPN (Romgon Position Notation) string:</p>
                    
                    <textarea id="rpn-input" style="
                        width: 100%;
                        height: 120px;
                        background: #1a1a1a;
                        color: #4ecdc4;
                        border: 2px solid #4ecdc4;
                        border-radius: 8px;
                        padding: 10px;
                        font-family: 'Courier New', monospace;
                        font-size: 0.9em;
                        resize: vertical;
                        margin-bottom: 20px;
                    " placeholder="Example: SSSSS/t0t0t0t0t0t0/6/r2R3/6/T0T0T0T0T0T0/sssss w 0 ----"></textarea>
                    
                    <div style="display: flex; gap: 10px;">
                        <button onclick="loadPositionFromInput()" style="
                            flex: 1;
                            background: #4ecdc4;
                            color: white;
                            border: none;
                            padding: 12px;
                            border-radius: 8px;
                            cursor: pointer;
                            font-weight: 600;
                            font-size: 1em;
                        ">‚úÖ Load Position</button>
                        <button onclick="closeLoadPositionModal()" style="
                            flex: 1;
                            background: #555;
                            color: white;
                            border: none;
                            padding: 12px;
                            border-radius: 8px;
                            cursor: pointer;
                            font-weight: 600;
                            font-size: 1em;
                        ">‚ùå Cancel</button>
                    </div>
                    
                    <div style="margin-top: 20px; padding: 15px; background: rgba(78, 205, 196, 0.1); border-radius: 8px; border-left: 4px solid #4ecdc4;">
                        <p style="color: #4ecdc4; margin: 0; font-size: 0.9em; font-weight: 600;">üí° Current Position RPN:</p>
                        <code id="current-rpn-display" style="
                            display: block;
                            margin-top: 8px;
                            color: #fff;
                            font-size: 0.85em;
                            word-break: break-all;
                            background: #1a1a1a;
                            padding: 8px;
                            border-radius: 4px;
                        ">Loading...</code>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Update current RPN display
            setTimeout(() => {
                const display = document.getElementById('current-rpn-display');
                if (display) {
                    display.textContent = exportPositionRPN();
                }
            }, 100);
            
            return modal;
        }

        // Close load position modal
        function closeLoadPositionModal() {
            const modal = document.getElementById('load-position-modal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        // Load position from input
        function loadPositionFromInput() {
            const input = document.getElementById('rpn-input');
            if (!input) return;
            
            const rpnString = input.value.trim();
            if (!rpnString) {
                alert('Please enter an RPN string');
                return;
            }
            
            if (!validateRPN(rpnString)) {
                alert('Invalid RPN format. Please check the notation.');
                return;
            }
            
            if (importPositionRPN(rpnString)) {
                closeLoadPositionModal();
                showNotification('‚úÖ Position loaded successfully!', 'success');
            }
        }

        // Download game as .rmn file
        function downloadGameRMN() {
            const rmn = exportGameRMN();
            const blob = new Blob([rmn], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `romgon_game_${gameMetadata.date}.rmn`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showNotification('‚úÖ Game exported successfully!', 'success');
        }

        // Log current position RPN to console
        function logPositionRPN() {
            const rpn = exportPositionRPN();
            console.log('üìã Current Position RPN:');
            console.log(rpn);
            console.log('\nüéÆ Copy this notation to share or save this position');
        }

        // ============================================
        // DARK MODE TOGGLE
        // ============================================
        
        // Toggle dark/light mode
        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            
            // Update button icon
            const darkModeBtn = document.querySelector('button[title="Toggle Dark/Light Mode"]');
            if (darkModeBtn) {
                if (document.body.classList.contains('dark-mode')) {
                    darkModeBtn.innerHTML = '‚òÄÔ∏è';
                    darkModeBtn.title = 'Switch to Light Mode';
                    // Save preference
                    localStorage.setItem('romgon-theme', 'dark');
                } else {
                    darkModeBtn.innerHTML = 'üåô';
                    darkModeBtn.title = 'Switch to Dark Mode';
                    // Save preference
                    localStorage.setItem('romgon-theme', 'light');
                }
            }
            
            console.log('üé® Theme switched to:', document.body.classList.contains('dark-mode') ? 'Dark Mode' : 'Light Mode');
        }
        
        // Initialize theme on page load
        function initializeTheme() {
            const savedTheme = localStorage.getItem('romgon-theme');
            
            // Default to light mode (if no preference saved)
            if (savedTheme === 'dark') {
                document.body.classList.add('dark-mode');
                const darkModeBtn = document.querySelector('button[title="Toggle Dark/Light Mode"]');
                if (darkModeBtn) {
                    darkModeBtn.innerHTML = '‚òÄÔ∏è';
                    darkModeBtn.title = 'Switch to Light Mode';
                }
            } else if (!savedTheme) {
                // First time user - set light mode as default
                localStorage.setItem('romgon-theme', 'light');
            }
        }
        
        // Call on page load (after DOM is ready)
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeTheme);
        } else {
            initializeTheme();
        }

        // ============================================
        // END OF DARK MODE
        // ============================================
        
        // ============================================
        // WOODEN BOARD THEME TOGGLE
        // ============================================
        
        // Toggle wooden/normal board
        function toggleWoodenTheme() {
            document.body.classList.toggle('wooden-theme');
            const isWooden = document.body.classList.contains('wooden-theme');
            
            // Update button icon
            const woodenBtn = document.querySelector('button[title="Toggle Wooden Board"]');
            if (woodenBtn) {
                woodenBtn.innerHTML = isWooden ? 'üé®' : 'ü™µ';
            }
            
            // Save preference to localStorage
            localStorage.setItem('romgon-board-theme', isWooden ? 'wooden' : 'normal');
            
            console.log('ü™µ Board theme switched to:', isWooden ? 'Wooden Board' : 'Normal Board');
        }
        
        // Initialize wooden theme on page load
        function initializeWoodenTheme() {
            const savedBoardTheme = localStorage.getItem('romgon-board-theme');
            const woodenBtn = document.querySelector('button[title="Toggle Wooden Board"]');
            
            if (savedBoardTheme === 'wooden') {
                document.body.classList.add('wooden-theme');
                if (woodenBtn) woodenBtn.innerHTML = 'üé®';
            } else {
                if (woodenBtn) woodenBtn.innerHTML = 'ü™µ';
            }
        }
        
        // Call on page load (after DOM is ready and button exists)
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => setTimeout(initializeWoodenTheme, 100));
        } else {
            setTimeout(initializeWoodenTheme, 100);
        }
        
        // ============================================
        // END OF WOODEN BOARD THEME
        // ============================================

        // ============================================
        // SPLASH PAGE INITIALIZATION
        // ============================================

        // Initialize splash page on page load
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => setTimeout(initializeSplashPage, 200));
        } else {
            setTimeout(initializeSplashPage, 200);
        }

        // ============================================
        // END OF SPLASH PAGE INITIALIZATION
        // ============================================

        // Global login state and settings
        window.currentUser = null;
        window.gameSettings = window.gameSettings || {};

        // Initialize splash page
        function initializeSplashPage() {
            // Show splash page on load
            showSplashPage();

            // Add event listeners
            const googleBtn = document.getElementById('google-login-btn');
            const guestBtn = document.getElementById('guest-login-btn');

            if (googleBtn) {
                googleBtn.addEventListener('click', handleGoogleLogin);
            }

            if (guestBtn) {
                guestBtn.addEventListener('click', handleGuestLogin);
            }
        }

        // Show splash page
        function showSplashPage() {
            const splashPage = document.getElementById('splash-page');
            const startMenu = document.getElementById('start-menu');

            if (splashPage) splashPage.style.display = 'flex';
            if (startMenu) startMenu.style.display = 'none';
        }

        // Hide splash page and show main menu
        function hideSplashPage() {
            const splashPage = document.getElementById('splash-page');
            const startMenu = document.getElementById('start-menu');

            if (splashPage) splashPage.style.display = 'none';
            if (startMenu) startMenu.style.display = 'flex';
        }

        // ----------------------
        // Google Sign-In helpers
        // ----------------------
        const GOOGLE_CLIENT_ID = '629995302527-jvm799stiufn1ipvp94611518iojqabc.apps.googleusercontent.com';

        function loadGoogleIdentityScript() {
            return new Promise((resolve, reject) => {
                if (window.google && window.google.accounts && window.google.accounts.id) return resolve();
                const s = document.createElement('script');
                s.src = 'https://accounts.google.com/gsi/client';
                s.async = true; s.defer = true;
                s.onload = () => setTimeout(resolve, 50);
                s.onerror = reject;
                document.head.appendChild(s);
            });
        }

        function parseJwt(token) {
            try {
                const base64Url = token.split('.')[1];
                const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
                const jsonPayload = decodeURIComponent(atob(base64).split('').map(function(c) {
                    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
                }).join(''));
                return JSON.parse(jsonPayload);
            } catch (e) {
                console.error('JWT parse error:', e);
                return null;
            }
        }

        function handleGoogleCredentialResponse(response) {
            const payload = parseJwt(response.credential);
            if (!payload) {
                alert('Google sign-in failed to parse credentials.');
                return;
            }
            const user = {
                provider: 'google',
                id: payload.sub,
                name: payload.name || payload.email,
                email: payload.email,
                picture: payload.picture || null,
            };
            // Persist the user and update UI
            try { persistCurrentUser(user); } catch (e) { window.currentUser = user; }
            // Close modal if open
            try { closeAccountModal(); } catch (e) {}
            console.info('‚úÖ Signed in as', user.email);
        }

        async function handleGoogleLogin() {
            try {
                await loadGoogleIdentityScript();
                if (!window.google || !window.google.accounts || !window.google.accounts.id) {
                    alert('Google Identity library failed to load.');
                    return;
                }
                // Initialize the Google Identity Services client
                google.accounts.id.initialize({
                    client_id: GOOGLE_CLIENT_ID,
                    callback: handleGoogleCredentialResponse,
                    auto_select: false,
                });

                // If there's a placeholder button in the modal, render Google's button into it
                const holder = document.getElementById('account-google-btn');
                if (holder) {
                    holder.innerHTML = '';
                    google.accounts.id.renderButton(holder, { theme: 'outline', size: 'large' });
                }

                // Trigger the one-tap prompt (optional).
                // Wrap in try/catch to avoid FedCM/One-tap network/CORS errors causing uncaught exceptions.
                try {
                    google.accounts.id.prompt();
                } catch (promptErr) {
                    console.warn('google.accounts.id.prompt() failed (FedCM/OneTap may be blocked):', promptErr);
                }
            } catch (e) {
                console.error('handleGoogleLogin error', e);
                alert('Failed to load Google sign-in: ' + (e && e.message ? e.message : e));
            }
        }

        // Persist and show current user (used by Google login and guest flow)
        function persistCurrentUser(user) {
            if (!user) return;
            window.currentUser = user;
            try { localStorage.setItem('romgon-user', JSON.stringify(user)); } catch (e) {}
            // Update small badge and user-home UI
            try { showLoggedInUser(user); } catch (e) {}
            try { showUserHome(); } catch (e) {}
        }

        // Profile UI helpers (lightweight, mirrors deploy behavior)
        function showLoggedInUser(user) {
            if (!user) return;
            let badge = document.getElementById('user-profile-badge');
            if (!badge) {
                badge = document.createElement('div');
                badge.id = 'user-profile-badge';
                badge.style.cssText = 'position:fixed; top:12px; right:12px; z-index:20001; display:flex; gap:8px; align-items:center; background:#111; color:#fff; padding:6px 10px; border-radius:18px; box-shadow:0 6px 18px rgba(0,0,0,0.6); cursor:pointer;';
                document.body.appendChild(badge);
                badge.addEventListener('click', (e) => { e.stopPropagation(); showAccountModal(); });
            }
            badge.innerHTML = '';
            if (user.picture) {
                const img = document.createElement('img');
                img.src = user.picture;
                img.style.cssText = 'width:28px; height:28px; border-radius:50%; object-fit:cover;';
                badge.appendChild(img);
            }
            const txt = document.createElement('div');
            txt.style.cssText = 'font-size:13px; color:#fff;';
            txt.textContent = user.name || user.email || 'Player';
            badge.appendChild(txt);
        }

        function removeLoggedInUserUI() {
            const b = document.getElementById('user-profile-badge');
            if (b) b.remove();
        }

        function handleSignOut() {
            window.currentUser = null;
            try { localStorage.removeItem('romgon-user'); } catch (e) {}
            removeLoggedInUserUI();
            try { if (window.google && window.google.accounts && window.google.accounts.id) google.accounts.id.disableAutoSelect(); } catch (e) {}
            // Hide user-home if visible
            try { hideUserHome(); } catch (e) {}
            alert('Signed out');
            try { closeAccountModal(); } catch (e) {}
        }

        // Show / hide the user-first landing page
        function showUserHome() {
            const uh = document.getElementById('user-home');
            if (!uh) return;
            const startMenu = document.getElementById('start-menu');
            const splash = document.getElementById('splash-page');
            if (startMenu) startMenu.style.display = 'none';
            if (splash) splash.style.display = 'none';
            // Populate user info
            const u = window.currentUser || (function(){ try { return JSON.parse(localStorage.getItem('romgon-user')); } catch(e){return null;} })();
            const avatar = document.getElementById('user-home-avatar');
            const nameEl = document.getElementById('user-home-name');
            const emailEl = document.getElementById('user-home-email');
            if (u) {
                if (avatar) {
                    avatar.style.display = 'flex';
                    avatar.style.alignItems = 'center';
                    avatar.style.justifyContent = 'center';
                    if (u.picture) {
                        avatar.style.background = 'transparent';
                        avatar.innerHTML = `<img src="${u.picture}" style="width:100px;height:100px;border-radius:50%;object-fit:cover;"/>`;
                    } else {
                        avatar.style.background = 'linear-gradient(135deg, #4ecdc4, #a55eea)';
                        avatar.innerHTML = '';
                        avatar.textContent = (u.name || 'G').charAt(0).toUpperCase();
                    }
                }
                if (nameEl) nameEl.textContent = u.name || u.email || 'Welcome Player';
                if (emailEl) emailEl.textContent = u.email || (u.type === 'guest' ? 'Guest Session' : 'Not signed in');
            }
            uh.style.display = 'flex';
        }

        function hideUserHome() {
            const uh = document.getElementById('user-home');
            if (!uh) return;
            uh.style.display = 'none';
        }

        // Handle guest login
        function handleGuestLogin() {
            // Create guest user and persist via common helper (will show user-home)
            const guest = { type: 'guest', name: 'Guest Player', id: 'guest_' + Date.now() };
            try { persistCurrentUser(guest); } catch (e) { window.currentUser = guest; localStorage.setItem('romgon-user', JSON.stringify(guest)); hideSplashPage(); }
            console.log('üë§ Logged in as Guest:', guest);
        }

        // Get current user info
        function getCurrentUser() {
            if (!window.currentUser) {
                // Try to load from localStorage
                const savedUser = localStorage.getItem('romgon-user');
                if (savedUser) {
                    window.currentUser = JSON.parse(savedUser);
                }
            }
            return window.currentUser;
        }

        // Check if user is logged in as guest
        function isGuestUser() {
            const user = getCurrentUser();
            return user && user.type === 'guest';
        }

        // Prompt login - open start menu / splash page and focus login area
        function promptLogin() {
            const startMenu = document.getElementById('start-menu');
            const splash = document.getElementById('splash-page');
            // Show start menu (login options) and hide splash if necessary
            if (startMenu) startMenu.style.display = 'flex';
            if (splash) splash.style.display = 'none';
            // Optionally focus the guest login button
            const guestBtn = document.getElementById('guest-login-btn');
            if (guestBtn) {
                guestBtn.focus();
            }
        }

        // Preferred login handler shim: call the in-development handler if present,
        // otherwise fall back to promptLogin(). This lets you wire the new handler
        // later without changing every callsite.
        function preferredLoginHandler() {
            try {
                // If you implement handleLoginFlow or handleGoogleLogin, the shim will prefer them.
                if (typeof handleLoginFlow === 'function') {
                    return handleLoginFlow();
                }
                if (typeof handleGoogleLogin === 'function') {
                    return handleGoogleLogin();
                }
            } catch (e) {
                // swallow and fallback
                console.warn('preferredLoginHandler: preferred handler threw, falling back', e);
            }
            return promptLogin();
        }

        // Show a centered account modal with guest vs user info and login button
        function showAccountModal() {
            // Create or get the modal container
            let modal = document.getElementById('account-modal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'account-modal';
                modal.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,0.7); z-index:20000; cursor:pointer;';
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) modal.style.display = 'none';
                });
                document.body.appendChild(modal);
            }

            // Check if user is already logged in
            const isLoggedIn = !!window.currentUser;

            // Clear modal content
            modal.innerHTML = '';
            modal.style.display = 'flex';

            if (isLoggedIn) {
                // LOGGED-IN VIEW: Show user profile
                const content = document.createElement('div');
                content.style.cssText = 'background:#222;border-radius:12px;padding:20px;max-width:400px;box-shadow:0 10px 30px rgba(0,0,0,0.8);position:relative;';
                
                // Close button
                const closeBtn = document.createElement('button');
                closeBtn.textContent = '‚úï';
                closeBtn.style.cssText = 'position:absolute;top:8px;right:8px;background:none;border:none;color:#888;cursor:pointer;font-size:20px;';
                closeBtn.onclick = () => { modal.style.display = 'none'; };
                content.appendChild(closeBtn);

                // Avatar
                const avatar = document.createElement('div');
                avatar.style.cssText = 'width:80px;height:80px;border-radius:50%;background:#444;display:flex;align-items:center;justify-content:center;margin:10px auto 15px;font-size:32px;font-weight:bold;color:#ccc;';
                if (window.currentUser.picture) {
                    avatar.innerHTML = `<img src="${window.currentUser.picture}" style="width:80px;height:80px;border-radius:50%;object-fit:cover;"/>`;
                } else {
                    avatar.textContent = (window.currentUser.name || 'G').charAt(0).toUpperCase();
                }
                content.appendChild(avatar);

                // Name
                const nameEl = document.createElement('h3');
                nameEl.style.cssText = 'margin:10px 0 5px;text-align:center;color:#fff;font-size:18px;';
                nameEl.textContent = window.currentUser.name || 'Player';
                content.appendChild(nameEl);

                // Email
                const emailEl = document.createElement('p');
                emailEl.style.cssText = 'margin:0 0 15px;text-align:center;color:#aaa;font-size:13px;';
                emailEl.textContent = window.currentUser.email || (window.currentUser.type === 'guest' ? 'Guest Session' : 'No email');
                content.appendChild(emailEl);

                // Sign Out button
                const signOutBtn = document.createElement('button');
                signOutBtn.textContent = 'Sign Out';
                signOutBtn.style.cssText = 'width:100%;padding:10px;background:#d32f2f;color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:bold;';
                signOutBtn.onmouseover = () => { signOutBtn.style.background = '#f44336'; };
                signOutBtn.onmouseout = () => { signOutBtn.style.background = '#d32f2f'; };
                signOutBtn.onclick = handleSignOut;
                content.appendChild(signOutBtn);

                modal.appendChild(content);
            } else {
                // LOGIN VIEW: Show login options
                const content = document.createElement('div');
                content.style.cssText = 'background:#222;border-radius:12px;padding:25px;max-width:420px;box-shadow:0 10px 30px rgba(0,0,0,0.8);position:relative;';
                
                // Close button
                const closeBtn = document.createElement('button');
                closeBtn.textContent = '‚úï';
                closeBtn.style.cssText = 'position:absolute;top:8px;right:8px;background:none;border:none;color:#888;cursor:pointer;font-size:20px;';
                closeBtn.onclick = () => { modal.style.display = 'none'; };
                content.appendChild(closeBtn);

                // Title
                const title = document.createElement('h2');
                title.style.cssText = 'margin:0 0 10px;color:#fff;font-size:22px;';
                title.textContent = 'Join the Game';
                content.appendChild(title);

                // Subtitle
                const subtitle = document.createElement('p');
                subtitle.style.cssText = 'margin:0 0 20px;color:#aaa;font-size:14px;';
                subtitle.textContent = 'Sign in to save your progress and compete on leaderboards.';
                content.appendChild(subtitle);

                // Google Sign-In button placeholder (will be rendered by GSI)
                const googleBtn = document.createElement('div');
                googleBtn.id = 'account-google-btn';
                googleBtn.style.cssText = 'margin-bottom:15px;text-align:center;';
                content.appendChild(googleBtn);

                // Divider
                const divider = document.createElement('p');
                divider.style.cssText = 'text-align:center;color:#666;margin:15px 0;font-size:12px;';
                divider.textContent = 'OR';
                content.appendChild(divider);

                // Guest Login button
                const guestBtn = document.createElement('button');
                guestBtn.textContent = 'Continue as Guest';
                guestBtn.style.cssText = 'width:100%;padding:12px;background:#555;color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:bold;';
                guestBtn.onmouseover = () => { guestBtn.style.background = '#666'; };
                guestBtn.onmouseout = () => { guestBtn.style.background = '#555'; };
                guestBtn.onclick = () => { handleGuestLogin(); modal.style.display = 'none'; };
                content.appendChild(guestBtn);

                modal.appendChild(content);

                // Auto-trigger Google login initialization
                setTimeout(() => {
                    try { handleGoogleLogin(); } catch (e) { console.warn('Google login not ready:', e); }
                }, 100);
            }
        }

        function closeAccountModal() {
            const m = document.getElementById('account-modal');
            if (m) m.style.display = 'none';
        }

        // ============================================
        // END OF SPLASH PAGE LOGIC
        // ============================================

        // ============================================
        // END OF RPN SYSTEM
        // ============================================

    </script>
</body>
</html>
